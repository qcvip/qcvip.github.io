<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>随记</title>
    <url>/2023/12/18/1218/</url>
    <content><![CDATA[<h2 id="随记"><a href="#随记" class="headerlink" title="随记"></a>随记</h2><span id="more"></span>
<hr>
<p>刚刚看了向凹凸的视频，又联想到昨日腌鱼的视频，好像平日再怎么逗的人也会突然有那么几个时刻会突然停下来</p>
<p>会突发奇想留下点什么，我觉得这些时刻是值得记录的，哪怕我是一个不爱记录的人</p>
<p>就像刚刚向凹凸的视频title  “<strong>怕被记住，怕被遗忘</strong>”   </p>
<p>想到自己的一些经历，以及对一些事情的处理方式好像不够“稳妥”，不够“完美”</p>
<p>但回想一下当时的心境，好像也只能那么做，别无他法。</p>
<p>回头看，当然尽是遗憾，但又何尝不是一种成长，正是因为那些事情，才会明白很多道理</p>
<p>只是自己当时太过于冲动</p>
<p>工作后，好像很少有时间闲下来想一想 问一问 </p>
<p>大多数的时间都是匆匆忙忙 过去也就过去了</p>
<p>但其实很多事情，是应该回头想一想 看一看的</p>
<p>当时在学校没觉得，进入社会后才明白 “象牙塔” “乌托邦” 的含义</p>
<p>没有人不向往美好，可是又败给现实</p>
<p>人人都是匆匆忙忙 停不下来 </p>
]]></content>
      <categories>
        <category>问答</category>
      </categories>
      <tags>
        <tag>问答</tag>
        <tag>阅读</tag>
      </tags>
  </entry>
  <entry>
    <title>CSS</title>
    <url>/2022/08/22/CSS/</url>
    <content><![CDATA[<h2 id="CSS篇"><a href="#CSS篇" class="headerlink" title="CSS篇"></a>CSS篇</h2><span id="more"></span>

<p><img  src="/images/image/css.png"  ><span class="image-caption">img</span></p>
<h2 id="一、CSS基础"><a href="#一、CSS基础" class="headerlink" title="一、CSS基础"></a>一、CSS基础</h2><h3 id="1-CSS选择器及其优先级"><a href="#1-CSS选择器及其优先级" class="headerlink" title="1. CSS选择器及其优先级"></a>1. CSS选择器及其优先级</h3><table>
<thead>
<tr>
<th><strong>选择器</strong></th>
<th><strong>格式</strong></th>
<th><strong>优先级权重</strong></th>
</tr>
</thead>
<tbody><tr>
<td>id选择器</td>
<td>#id</td>
<td>100</td>
</tr>
<tr>
<td>类选择器</td>
<td>#classname</td>
<td>10</td>
</tr>
<tr>
<td>属性选择器</td>
<td>a[ref&#x3D;“eee”]</td>
<td>10</td>
</tr>
<tr>
<td>伪类选择器</td>
<td>li:last-child</td>
<td>10</td>
</tr>
<tr>
<td>标签选择器</td>
<td>div</td>
<td>1</td>
</tr>
<tr>
<td>伪元素选择器</td>
<td>li:after</td>
<td>1</td>
</tr>
<tr>
<td>相邻兄弟选择器</td>
<td>h1+p</td>
<td>0</td>
</tr>
<tr>
<td>子选择器</td>
<td>ul&gt;li</td>
<td>0</td>
</tr>
<tr>
<td>后代选择器</td>
<td>li a</td>
<td>0</td>
</tr>
<tr>
<td>通配符选择器</td>
<td>*</td>
<td>0</td>
</tr>
</tbody></table>
<p>对于选择器的<strong>优先级</strong>：</p>
<ul>
<li>标签选择器、伪元素选择器：1</li>
<li>类选择器、伪类选择器、属性选择器：10</li>
<li>id 选择器：100</li>
<li>内联样式：1000</li>
</ul>
<p><strong>注意事项：</strong></p>
<ul>
<li>!important声明的样式的优先级最高；</li>
<li>如果优先级相同，则最后出现的样式生效；</li>
<li>继承得到的样式的优先级最低；</li>
<li>通用选择器（*）、子选择器（&gt;）和相邻同胞选择器（+）并不在这四个等级中，所以它们的权值都为 0 ；</li>
<li>样式表的来源不同时，优先级顺序为：内联样式 &gt; 内部样式 &gt; 外部样式 &gt; 浏览器用户自定义样式 &gt; 浏览器默认样式。</li>
</ul>
<h3 id="2-CSS中可继承与不可继承属性有哪些"><a href="#2-CSS中可继承与不可继承属性有哪些" class="headerlink" title="2. CSS中可继承与不可继承属性有哪些"></a>2. CSS中可继承与不可继承属性有哪些</h3><p><strong>一、无继承性的属性</strong></p>
<ol>
<li><strong>display</strong>：规定元素应该生成的框的类型</li>
<li><strong>文本属性</strong>：</li>
</ol>
<ul>
<li>vertical-align：垂直文本对齐</li>
<li>text-decoration：规定添加到文本的装饰</li>
<li>text-shadow：文本阴影效果</li>
<li>white-space：空白符的处理</li>
<li>unicode-bidi：设置文本的方向</li>
</ul>
<ol>
<li><strong>盒子模型的属性</strong>：width、height、margin、border、padding</li>
<li><strong>背景属性</strong>：background、background-color、background-image、background-repeat、background-position、background-attachment</li>
<li><strong>定位属性</strong>：float、clear、position、top、right、bottom、left、min-width、min-height、max-width、max-height、overflow、clip、z-index</li>
<li><strong>生成内容属性</strong>：content、counter-reset、counter-increment</li>
<li><strong>轮廓样式属性</strong>：outline-style、outline-width、outline-color、outline</li>
<li><strong>页面样式属性</strong>：size、page-break-before、page-break-after</li>
<li><strong>声音样式属性</strong>：pause-before、pause-after、pause、cue-before、cue-after、cue、play-during</li>
</ol>
<p><strong>二、有继承性的属性</strong></p>
<ol>
<li><strong>字体系列属性</strong></li>
</ol>
<ul>
<li>font-family：字体系列</li>
<li>font-weight：字体的粗细</li>
<li>font-size：字体的大小</li>
<li>font-style：字体的风格</li>
</ul>
<ol>
<li><strong>文本系列属性</strong></li>
</ol>
<ul>
<li>text-indent：文本缩进</li>
<li>text-align：文本水平对齐</li>
<li>line-height：行高</li>
<li>word-spacing：单词之间的间距</li>
<li>letter-spacing：中文或者字母之间的间距</li>
<li>text-transform：控制文本大小写（就是uppercase、lowercase、capitalize这三个）</li>
<li>color：文本颜色</li>
</ul>
<ol>
<li><strong>元素可见性</strong></li>
</ol>
<ul>
<li>visibility：控制元素显示隐藏</li>
</ul>
<ol>
<li><strong>列表布局属性</strong></li>
</ol>
<ul>
<li>list-style：列表风格，包括list-style-type、list-style-image等</li>
</ul>
<ol>
<li><strong>光标属性</strong></li>
</ol>
<ul>
<li>cursor：光标显示为何种形态</li>
</ul>
<h3 id="3-display的属性值及其作用"><a href="#3-display的属性值及其作用" class="headerlink" title="3. display的属性值及其作用"></a>3. display的属性值及其作用</h3><table>
<thead>
<tr>
<th><strong>属性值</strong></th>
<th><strong>作用</strong></th>
</tr>
</thead>
<tbody><tr>
<td>none</td>
<td>元素不显示，并且会从文档流中移除。</td>
</tr>
<tr>
<td>block</td>
<td>块类型。默认宽度为父元素宽度，可设置宽高，换行显示。</td>
</tr>
<tr>
<td>inline</td>
<td>行内元素类型。默认宽度为内容宽度，不可设置宽高，同行显示。</td>
</tr>
<tr>
<td>inline-block</td>
<td>默认宽度为内容宽度，可以设置宽高，同行显示。</td>
</tr>
<tr>
<td>list-item</td>
<td>像块类型元素一样显示，并添加样式列表标记。</td>
</tr>
<tr>
<td>table</td>
<td>此元素会作为块级表格来显示。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承display属性的值。</td>
</tr>
</tbody></table>
<h3 id="4-display的block、inline和inline-block的区别"><a href="#4-display的block、inline和inline-block的区别" class="headerlink" title="4. display的block、inline和inline-block的区别"></a>4. display的block、inline和inline-block的区别</h3><p>　（1）<strong>block：</strong>会独占一行，多个元素会另起一行，可以设置width、height、margin和padding属性；</p>
<p>　（2）<strong>inline：</strong>元素不会独占一行，设置width、height属性无效。但可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</p>
<p>　（3）<strong>inline-block：</strong>将对象设置为inline对象，但对象的内容作为block对象呈现，之后的内联对象会被排列在同一行内。</p>
<p>对于行内元素和块级元素，其特点如下：</p>
<p><strong>（1）行内元素</strong></p>
<ul>
<li>设置宽高无效；</li>
<li>可以设置水平方向的margin和padding属性，不能设置垂直方向的padding和margin；</li>
<li>不会自动换行；</li>
</ul>
<p><strong>（2）块级元素</strong></p>
<ul>
<li>可以设置宽高；</li>
<li>设置margin和padding都有效；</li>
<li>可以自动换行；</li>
<li>多个块状，默认排列从上到下。</li>
</ul>
<h3 id="5-隐藏元素的方法有哪些"><a href="#5-隐藏元素的方法有哪些" class="headerlink" title="5. 隐藏元素的方法有哪些"></a>5. 隐藏元素的方法有哪些</h3><ul>
<li><strong>display: none</strong>：渲染树不会包含该渲染对象，因此该元素不会在页面中占据位置，也不会响应绑定的监听事件。</li>
<li><strong>visibility: hidden</strong>：元素在页面中仍占据空间，但是不会响应绑定的监听事件。</li>
<li><strong>opacity: 0</strong>：将元素的透明度设置为 0，以此来实现元素的隐藏。元素在页面中仍然占据空间，并且能够响应元素绑定的监听事件。</li>
<li><strong>position: absolute</strong>：通过使用绝对定位将元素移除可视区域内，以此来实现元素的隐藏。</li>
<li><strong>z-index: 负值</strong>：来使其他元素遮盖住该元素，以此来实现隐藏。</li>
<li><strong>clip&#x2F;clip-path</strong> ：使用元素裁剪的方法来实现元素的隐藏，这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
<li>**transform: scale(0,0)**：将元素缩放为 0，来实现元素的隐藏。这种方法下，元素仍在页面中占据位置，但是不会响应绑定的监听事件。</li>
</ul>
<h3 id="6-link和-import的区别"><a href="#6-link和-import的区别" class="headerlink" title="6. link和@import的区别"></a>6. link和@import的区别</h3><p>两者都是外部引用CSS的方式，它们的区别如下：</p>
<ul>
<li>link是XHTML标签，除了加载CSS外，还可以定义RSS等其他事务；@import属于CSS范畴，只能加载CSS。</li>
<li>link引用CSS时，在页面载入时同时加载；@import需要页面网页完全载入以后加载。</li>
<li>link是XHTML标签，无兼容问题；@import是在CSS2.1提出的，低版本的浏览器不支持。</li>
<li>link支持使用Javascript控制DOM去改变样式；而@import不支持。</li>
</ul>
<h3 id="7-transition和animation的区别"><a href="#7-transition和animation的区别" class="headerlink" title="7. transition和animation的区别"></a>7. transition和animation的区别</h3><ul>
<li><strong>transition是过度属性</strong>，强调过度，它的实现需要触发一个事件（比如鼠标移动上去，焦点，点击等）才执行动画。它类似于flash的补间动画，设置一个开始关键帧，一个结束关键帧。</li>
<li><strong>animation是动画属性</strong>，它的实现不需要触发事件，设定好时间之后可以自己执行，且可以循环一个动画。它也类似于flash的补间动画，但是它可以设置多个关键帧（用@keyframe定义）完成动画。</li>
</ul>
<h3 id="8-display-none与visibility-hidden的区别"><a href="#8-display-none与visibility-hidden的区别" class="headerlink" title="8. display:none与visibility:hidden的区别"></a>8. display:none与visibility:hidden的区别</h3><p>这两个属性都是让元素隐藏，不可见。<strong>两者****区别如下：</strong></p>
<p>（1）<strong>在渲染树中</strong></p>
<ul>
<li><code>display:none</code>会让元素完全从渲染树中消失，渲染时不会占据任何空间；</li>
<li><code>visibility:hidden</code>不会让元素从渲染树中消失，渲染的元素还会占据相应的空间，只是内容不可见。</li>
</ul>
<p>（2）<strong>是否是****继承属性</strong></p>
<ul>
<li><code>display:none</code>是非继承属性，子孙节点会随着父节点从渲染树消失，通过修改子孙节点的属性也无法显示；</li>
<li><code>visibility:hidden</code>是继承属性，子孙节点消失是由于继承了<code>hidden</code>，通过设置<code>visibility:visible</code>可以让子孙节点显示；</li>
</ul>
<p>（3）修改常规文档流中元素的 <code>display</code> 通常会造成文档的重排，但是修改<code>visibility</code>属性只会造成本元素的重绘；</p>
<p>（4）如果使用读屏器，设置为<code>display:none</code>的内容不会被读取，设置为<code>visibility:hidden</code>的内容会被读取。</p>
<h3 id="9-伪元素和伪类的区别和作用？"><a href="#9-伪元素和伪类的区别和作用？" class="headerlink" title="9. 伪元素和伪类的区别和作用？"></a>9. <strong>伪元素和伪类的区别和作用？</strong></h3><ul>
<li>伪元素：在内容元素的前后插入额外的元素或样式，但是这些元素实际上并不在文档中生成。它们只在外部显示可见，但不会在文档的源代码中找到它们，因此，称为“伪”元素。例如：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::before</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;第一章：&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::after</span> &#123;<span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;Hot!&quot;</span>;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-line</span> &#123;<span class="hljs-attribute">background</span>:red;&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">::first-letter</span> &#123;<span class="hljs-attribute">font-size</span>:<span class="hljs-number">30px</span>;&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>伪类：将特殊的效果添加到特定选择器上。它是已有元素上添加类别的，不会产生新的元素。例如：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">a</span><span class="hljs-selector-pseudo">:hover</span> &#123;<span class="hljs-attribute">color</span>: <span class="hljs-number">#FF00FF</span>&#125;<br><span class="hljs-selector-tag">p</span><span class="hljs-selector-pseudo">:first</span>-child &#123;<span class="hljs-attribute">color</span>: red&#125;<br></code></pre></td></tr></table></figure>

<p><strong>总结：</strong>伪类是通过在元素选择器上加⼊伪类改变元素状态，⽽伪元素通过对元素的操作进⾏对元素的改变。 </p>
<h3 id="10-对requestAnimationframe的理解"><a href="#10-对requestAnimationframe的理解" class="headerlink" title="10. 对requestAnimationframe的理解"></a>10. 对requestAnimationframe的理解</h3><p>实现动画效果的方法比较多，Javascript 中可以通过定时器 setTimeout 来实现，CSS3 中可以使用 transition 和 animation 来实现，HTML5 中的 canvas 也可以实现。除此之外，HTML5 提供一个专门用于请求动画的API，那就是 requestAnimationFrame，顾名思义就是<strong>请求动画帧</strong>。</p>
<p>MDN对该方法的描述：</p>
<blockquote>
<p>window.requestAnimationFrame() 告诉浏览器——你希望执行一个动画，并且要求浏览器在下次重绘之前调用指定的回调函数更新动画。该方法需要传入一个回调函数作为参数，该回调函数会在浏览器下一次重绘之前执行。</p>
</blockquote>
<p><strong>语法：</strong> <code>window.requestAnimationFrame(callback);</code>  其中，callback是<strong>下一次重绘之前更新动画帧所调用的函数</strong>(即上面所说的回调函数)。该回调函数会被传入DOMHighResTimeStamp参数，它表示requestAnimationFrame() 开始去执行回调函数的时刻。该方法属于<strong>宏任务</strong>，所以会在执行完微任务之后再去执行。</p>
<p><strong>取消动画：</strong>使用cancelAnimationFrame()来取消执行动画，该方法接收一个参数——requestAnimationFrame默认返回的id，只需要传入这个id就可以取消动画了。</p>
<p><strong>优势：</strong></p>
<ul>
<li><strong>CPU节能</strong>：使用SetTinterval 实现的动画，当页面被隐藏或最小化时，SetTinterval 仍然在后台执行动画任务，由于此时页面处于不可见或不可用状态，刷新动画是没有意义的，完全是浪费CPU资源。而RequestAnimationFrame则完全不同，当页面处理未激活的状态下，该页面的屏幕刷新任务也会被系统暂停，因此跟着系统走的RequestAnimationFrame也会停止渲染，当页面被激活时，动画就从上次停留的地方继续执行，有效节省了CPU开销。</li>
<li><strong>函数节流</strong>：在高频率事件( resize, scroll 等)中，为了防止在一个刷新间隔内发生多次函数执行，RequestAnimationFrame可保证每个刷新间隔内，函数只被执行一次，这样既能保证流畅性，也能更好的节省函数执行的开销，一个刷新间隔内函数执行多次时没有意义的，因为多数显示器每16.7ms刷新一次，多次绘制并不会在屏幕上体现出来。</li>
<li><strong>减少DOM操作</strong>：requestAnimationFrame 会把每一帧中的所有DOM操作集中起来，在一次重绘或回流中就完成，并且重绘或回流的时间间隔紧紧跟随浏览器的刷新频率，一般来说，这个频率为每秒60帧。</li>
</ul>
<p><strong>setTimeout执行动画的缺点</strong>：它通过设定间隔时间来不断改变图像位置，达到动画效果。但是容易出现卡顿、抖动的现象；原因是：</p>
<ul>
<li>settimeout任务被放入异步队列，只有当主线程任务执行完后才会执行队列中的任务，因此实际执行时间总是比设定时间要晚；</li>
<li>settimeout的固定时间间隔不一定与屏幕刷新间隔时间相同，会引起丢帧。</li>
</ul>
<h3 id="11-对盒模型的理解"><a href="#11-对盒模型的理解" class="headerlink" title="11. 对盒模型的理解"></a>11. 对盒模型的理解</h3><p>CSS3中的盒模型有以下两种：标准盒子模型、IE盒子模型</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820746-e10daafa-451a-454e-9705-f8c358769d5b.png#align=left&display=inline&height=366&margin=%5Bobject%20Object%5D&originHeight=455&originWidth=746&size=0&status=done&style=none&width=600"  ><span class="image-caption">image</span></p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603600820555-dc6ed390-d47e-412b-942a-857bbe5f280d.png?x-oss-process=image/resize,w_746#align=left&display=inline&height=368&margin=%5Bobject%20Object%5D&originHeight=462&originWidth=791&size=0&status=done&style=none&width=630"  ><span class="image-caption">img</span></p>
<p>盒模型都是由四个部分组成的，分别是margin、border、padding和content。</p>
<p>标准盒模型和IE盒模型的区别在于设置width和height时，所对应的范围不同：</p>
<ul>
<li>标准盒模型的width和height属性的范围只包含了content，</li>
<li>IE盒模型的width和height属性的范围包含了border、padding和content。</li>
</ul>
<p>可以通过修改元素的box-sizing属性来改变元素的盒模型：</p>
<ul>
<li><code>box-sizeing: content-box</code>表示标准盒模型（默认值）</li>
<li><code>box-sizeing: border-box</code>表示IE盒模型（怪异盒模型）</li>
</ul>
<h3 id="12-为什么有时候⽤translate来改变位置⽽不是定位？"><a href="#12-为什么有时候⽤translate来改变位置⽽不是定位？" class="headerlink" title="12. 为什么有时候⽤translate来改变位置⽽不是定位？"></a>12. 为什么有时候⽤<strong>translate</strong>来改变位置⽽不是定位？</h3><p>translate 是 transform 属性的⼀个值。改变transform或opacity不会触发浏览器重新布局（reflow）或重绘（repaint），只会触发复合（compositions）。⽽改变绝对定位会触发重新布局，进⽽触发重绘和复合。transform使浏览器为元素创建⼀个 GPU 图层，但改变绝对定位会使⽤到 CPU。 因此translate()更⾼效，可以缩短平滑动画的绘制时间。 ⽽translate改变位置时，元素依然会占据其原始空间，绝对定位就不会发⽣这种情况。</p>
<h3 id="13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？"><a href="#13-li-与-li-之间有看不见的空白间隔是什么原因引起的？如何解决？" class="headerlink" title="13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？"></a>13. li 与 li 之间有看不见的空白间隔是什么原因引起的？如何解决？</h3><p>浏览器会把inline内联元素间的空白字符（空格、换行、Tab等）渲染成一个空格。为了美观，通常是一个<code>&lt;li&gt;</code>放在一行，这导致<code>&lt;li&gt;</code>换行后产生换行字符，它变成一个空格，占用了一个字符的宽度。</p>
<p><strong>解决办法：</strong></p>
<p>（1）为<code>&lt;li&gt;</code>设置float:left。不足：有些容器是不能设置浮动，如左右切换的焦点图等。</p>
<p>（2）将所有<code>&lt;li&gt;</code>写在同一行。不足：代码不美观。</p>
<p>（3）将<code>&lt;ul&gt;</code>内的字符尺寸直接设为0，即font-size:0。不足：<code>&lt;ul&gt;</code>中的其他字符尺寸也被设为0，需要额外重新设定其他字符尺寸，且在Safari浏览器依然会出现空白间隔。</p>
<p>（4）消除<code>&lt;ul&gt;</code>的字符间隔letter-spacing:-8px，不足：这也设置了<code>&lt;li&gt;</code>内的字符间隔，因此需要将<code>&lt;li&gt;</code>内的字符间隔设为默认letter-spacing:normal。</p>
<h3 id="14-CSS3中有哪些新特性"><a href="#14-CSS3中有哪些新特性" class="headerlink" title="14. CSS3中有哪些新特性"></a>14. CSS3中有哪些新特性</h3><ul>
<li>新增各种CSS选择器 （: not(.input)：所有 class 不是“input”的节点）</li>
<li>圆角 （border-radius:8px）</li>
<li>多列布局 （multi-column layout）</li>
<li>阴影和反射 （Shadoweflect）</li>
<li>文字特效 （text-shadow）</li>
<li>文字渲染 （Text-decoration）</li>
<li>线性渐变 （gradient）</li>
<li>旋转 （transform）</li>
<li>增加了旋转,缩放,定位,倾斜,动画,多背景</li>
</ul>
<h3 id="15-替换元素的概念及计算规则"><a href="#15-替换元素的概念及计算规则" class="headerlink" title="15. 替换元素的概念及计算规则"></a>15. 替换元素的概念及计算规则</h3><p>通过修改某个属性值呈现的内容就可以被替换的元素就称为“替换元素”。</p>
<p>替换元素除了内容可替换这一特性以外，还有以下特性：</p>
<ul>
<li><strong>内容的外观不受页面上的CSS的影响</strong>：用专业的话讲就是在样式表现在CSS作用域之外。如何更改替换元素本身的外观需要类似appearance属性，或者浏览器自身暴露的一些样式接口。</li>
<li><strong>有自己的尺寸</strong>：在Web中，很多替换元素在没有明确尺寸设定的情况下，其默认的尺寸（不包括边框）是300像素×150像素，如</li>
<li><strong>在很多CSS属性上有自己的一套表现规则</strong>：比较具有代表性的就是vertical-align属性，对于替换元素和非替换元素，vertical-align属性值的解释是不一样的。比方说vertical-align的默认值的baseline，很简单的属性值，基线之意，被定义为字符x的下边缘，而替换元素的基线却被硬生生定义成了元素的下边缘。</li>
<li><strong>所有的替换元素都是内联水平元素</strong>：也就是替换元素和替换元素、替换元素和文字都是可以在一行显示的。但是，替换元素默认的display值却是不一样的，有的是inline，有的是inline-block。</li>
</ul>
<p>替换元素的尺寸从内而外分为三类：</p>
<ul>
<li><strong>固有尺寸：</strong> 指的是替换内容原本的尺寸。例如，图片、视频作为一个独立文件存在的时候，都是有着自己的宽度和高度的。</li>
<li><strong>HTML尺寸：</strong> 只能通过HTML原生属性改变，这些HTML原生属性包括的width和height属性、的size属性。</li>
<li><strong>CSS尺寸：</strong> 特指可以通过CSS的width和height或者max-width&#x2F;min-width和max-height&#x2F;min-height设置的尺寸，对应盒尺寸中的content box。</li>
</ul>
<p>这三层结构的计算规则具体如下：</p>
<p>（1）如果没有CSS尺寸和HTML尺寸，则使用固有尺寸作为最终的宽高。</p>
<p>（2）如果没有CSS尺寸，则使用HTML尺寸作为最终的宽高。</p>
<p>（3）如果有CSS尺寸，则最终尺寸由CSS属性决定。</p>
<p>（4）如果“固有尺寸”含有固有的宽高比例，同时仅设置了宽度或仅设置了高度，则元素依然按照固有的宽高比例显示。</p>
<p>（5）如果上面的条件都不符合，则最终宽度表现为300像素，高度为150像素。</p>
<p>（6）内联替换元素和块级替换元素使用上面同一套尺寸计算规则。</p>
<h3 id="16-常见的图片格式及使用场景"><a href="#16-常见的图片格式及使用场景" class="headerlink" title="16. 常见的图片格式及使用场景"></a>16. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p>
<p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p>
<p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p>
<p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p>
<p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p>
<p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。SVG图片在放大时，不会失真，所以它适合用来绘制Logo、Icon等。</p>
<p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p>
<ul>
<li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li>
<li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li>
<li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>
</ul>
<h3 id="17-对-CSSSprites-的理解"><a href="#17-对-CSSSprites-的理解" class="headerlink" title="17. 对 CSSSprites 的理解"></a>17. 对 CSSSprites 的理解</h3><p>CSSSprites（精灵图），将一个页面涉及到的所有图片都包含到一张大图中去，然后利用CSS的 background-image，background-repeat，background-position属性的组合进行背景定位。</p>
<p><strong>优点：</strong></p>
<ul>
<li>利用<code>CSS Sprites</code>能很好地减少网页的http请求，从而大大提高了页面的性能，这是<code>CSS Sprites</code>最大的优点；</li>
<li><code>CSS Sprites</code>能减少图片的字节，把3张图片合并成1张图片的字节总是小于这3张图片的字节总和。</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>在图片合并时，要把多张图片有序的、合理的合并成一张图片，还要留好足够的空间，防止板块内出现不必要的背景。在宽屏及高分辨率下的自适应页面，如果背景不够宽，很容易出现背景断裂；</li>
<li><code>CSSSprites</code>在开发的时候相对来说有点麻烦，需要借助<code>photoshop</code>或其他工具来对每个背景单元测量其准确的位置。</li>
<li>维护方面：<code>CSS Sprites</code>在维护的时候比较麻烦，页面背景有少许改动时，就要改这张合并的图片，无需改的地方尽量不要动，这样避免改动更多的<code>CSS</code>，如果在原来的地方放不下，又只能（最好）往下加图片，这样图片的字节就增加了，还要改动<code>CSS</code>。</li>
</ul>
<h3 id="18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？"><a href="#18-什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到-3x-2x这种图片？" class="headerlink" title="18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？"></a>18. 什么是物理像素，逻辑像素和像素密度，为什么在移动端开发时需要用到@3x, @2x这种图片？</h3><p>以 iPhone XS 为例，当写 CSS 代码时，针对于单位 px，其宽度为 414px &amp; 896px，也就是说当赋予一个 DIV元素宽度为 414px，这个 DIV 就会填满手机的宽度；</p>
<p>而如果有一把尺子来实际测量这部手机的物理像素，实际为 1242*2688 物理像素；经过计算可知，1242&#x2F;414&#x3D;3，也就是说，在单边上，一个逻辑像素&#x3D;3个物理像素，就说这个屏幕的像素密度为 3，也就是常说的 3 倍屏。</p>
<p>对于图片来说，为了保证其不失真，1 个图片像素至少要对应一个物理像素，假如原始图片是 500300 像素，那么在 3 倍屏上就要放一个 1500900 像素的图片才能保证 1 个物理像素至少对应一个图片像素，才能不失真。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/jpeg/1500604/1605252903834-27a1d90a-7e04-49bc-822a-dadcf974c141.jpeg?x-oss-process=image/resize,w_746#align=left&display=inline&height=1478&margin=%5Bobject%20Object%5D&originHeight=1478&originWidth=1600&size=0&status=done&style=stroke&width=1600"  ><span class="image-caption">img</span></p>
<p>当然，也可以针对所有屏幕，都只提供最高清图片。虽然低密度屏幕用不到那么多图片像素，而且会因为下载多余的像素造成带宽浪费和下载延迟，但从结果上说能保证图片在所有屏幕上都不会失真。</p>
<p>还可以使用 CSS 媒体查询来判断不同的像素密度，从而选择不同的图片:</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">my-image &#123; <span class="hljs-attribute">background</span>: (low.png); &#125;<br><span class="hljs-keyword">@media</span> <span class="hljs-keyword">only</span> screen <span class="hljs-keyword">and</span> (<span class="hljs-attribute">min-device-pixel-ratio</span>: <span class="hljs-number">1.5</span>) &#123;<br>  <span class="hljs-selector-id">#my-image</span> &#123; <span class="hljs-attribute">background</span>: (high.png); &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="19-margin-和-padding-的使用场景"><a href="#19-margin-和-padding-的使用场景" class="headerlink" title="19. margin 和 padding 的使用场景"></a>19. <strong>margin 和 padding 的使用场景</strong></h3><ul>
<li>需要在border外侧添加空白，且空白处不需要背景（色）时，使用 margin；</li>
<li>需要在border内测添加空白，且空白处需要背景（色）时，使用 padding。</li>
</ul>
<h3 id="20-对line-height-的理解及其赋值方式"><a href="#20-对line-height-的理解及其赋值方式" class="headerlink" title="20. 对line-height 的理解及其赋值方式"></a>20. 对<strong>line-height 的理解及其赋值方式</strong></h3><p><strong>（1）line-height的概念：</strong></p>
<ul>
<li>line-height 指一行文本的高度，包含了字间距，实际上是下一行基线到上一行基线距离；</li>
<li>如果一个标签没有定义 height 属性，那么其最终表现的高度由 line-height 决定；</li>
<li>一个容器没有设置高度，那么撑开容器高度的是 line-height，而不是容器内的文本内容；</li>
<li>把 line-height 值设置为 height 一样大小的值可以实现单行文字的垂直居中；</li>
<li>line-height 和 height 都能撑开一个高度；</li>
</ul>
<p><strong>（2）line-height 的赋值方式：</strong></p>
<ul>
<li>带单位：px 是固定值，而 em 会参考父元素 font-size 值计算自身的行高</li>
<li>纯数字：会把比例传递给后代。例如，父级行高为 1.5，子元素字体为 18px，则子元素行高为 1.5 * 18 &#x3D; 27px</li>
<li>百分比：将计算后的值传递给后代</li>
</ul>
<h3 id="21-CSS-优化和提高性能的方法有哪些？"><a href="#21-CSS-优化和提高性能的方法有哪些？" class="headerlink" title="21. CSS 优化和提高性能的方法有哪些？"></a>21. CSS 优化和提高性能的方法有哪些？</h3><p><strong>加载性能：</strong></p>
<p>（1）css压缩：将写好的css进行打包压缩，可以减小文件体积。</p>
<p>（2）css单一样式：当需要下边距和左边距的时候，很多时候会选择使用 margin:top 0 bottom 0；但margin-bottom:bottom;margin-left:left;执行效率会更高。</p>
<p>（3）减少使用@import，建议使用link，因为后者在页面加载时一起加载，前者是等待页面加载完成之后再进行加载。</p>
<p><strong>选择器性能：</strong></p>
<p>（1）关键选择器（key selector）。选择器的最后面的部分为关键选择器（即用来匹配目标元素的部分）。CSS选择符是从右到左进行匹配的。当使用后代选择器的时候，浏览器会遍历所有子元素来确定是否是指定的元素等等；</p>
<p>（2）如果规则拥有ID选择器作为其关键选择器，则不要为规则增加标签。过滤掉无关的规则（这样样式系统就不会浪费时间去匹配它们了）。</p>
<p>（3）避免使用通配规则，如*{}计算次数惊人，只对需要用到的元素进行选择。</p>
<p>（4）尽量少的去对标签进行选择，而是用class。</p>
<p>（5）尽量少的去使用后代选择器，降低选择器的权重值。后代选择器的开销是最高的，尽量将选择器的深度降到最低，最高不要超过三层，更多的使用类来关联每一个标签元素。</p>
<p>（6）了解哪些属性是可以通过继承而来的，然后避免对这些属性重复指定规则。</p>
<p><strong>渲染性能：</strong></p>
<p>（1）慎重使用高性能属性：浮动、定位。</p>
<p>（2）尽量减少页面重排、重绘。</p>
<p>（3）去除空规则：｛｝。空规则的产生原因一般来说是为了预留样式。去除这些空规则无疑能减少css文档体积。</p>
<p>（4）属性值为0时，不加单位。</p>
<p>（5）属性值为浮动小数0.**，可以省略小数点之前的0。</p>
<p>（6）标准化各种浏览器前缀：带浏览器前缀的在前。标准属性在后。</p>
<p>（7）不使用@import前缀，它会影响css的加载速度。</p>
<p>（8）选择器优化嵌套，尽量避免层级过深。</p>
<p>（9）css雪碧图，同一页面相近部分的小图标，方便使用，减少页面的请求次数，但是同时图片本身会变大，使用时，优劣考虑清楚，再使用。</p>
<p>（10）正确使用display的属性，由于display的作用，某些样式组合会无效，徒增样式体积的同时也影响解析性能。</p>
<p>（11）不滥用web字体。对于中文网站来说WebFonts可能很陌生，国外却很流行。web fonts通常体积庞大，而且一些浏览器在下载web fonts时会阻塞页面渲染损伤性能。</p>
<p><strong>可维护性、健壮性：</strong></p>
<p>（1）将具有相同属性的样式抽离出来，整合并通过class在页面中进行使用，提高css的可维护性。</p>
<p>（2）样式与内容分离：将css代码定义到外部css中。</p>
<h3 id="22-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？"><a href="#22-CSS预处理器-x2F-后处理器是什么？为什么要使用它们？" class="headerlink" title="22. CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？"></a>22. CSS预处理器&#x2F;后处理器是什么？为什么要使用它们？</h3><p><strong>预处理器，</strong>如：<code>less</code>，<code>sass</code>，<code>stylus</code>，用来预编译<code>sass</code>或者<code>less</code>，增加了<code>css</code>代码的复用性。层级，<code>mixin</code>， 变量，循环， 函数等对编写以及开发UI组件都极为方便。</p>
<p><strong>后处理器，</strong> 如： <code>postCss</code>，通常是在完成的样式表中根据<code>css</code>规范处理<code>css</code>，让其更加有效。目前最常做的是给<code>css</code>属性添加浏览器私有前缀，实现跨浏览器兼容性的问题。</p>
<p><code>css</code>预处理器为<code>css</code>增加一些编程特性，无需考虑浏览器的兼容问题，可以在<code>CSS</code>中使用变量，简单的逻辑程序，函数等在编程语言中的一些基本的性能，可以让<code>css</code>更加的简洁，增加适应性以及可读性，可维护性等。</p>
<p>其它<code>css</code>预处理器语言：<code>Sass（Scss）</code>, <code>Less</code>, <code>Stylus</code>, <code>Turbine</code>, <code>Swithch css</code>, <code>CSS Cacheer</code>, <code>DT Css</code>。</p>
<p>使用原因：</p>
<ul>
<li>结构清晰， 便于扩展</li>
<li>可以很方便的屏蔽浏览器私有语法的差异</li>
<li>可以轻松实现多重继承</li>
<li>完美的兼容了<code>CSS</code>代码，可以应用到老项目中</li>
</ul>
<h3 id="23-before-和-after-的双冒号和单冒号有什么区别？"><a href="#23-before-和-after-的双冒号和单冒号有什么区别？" class="headerlink" title="23. ::before 和 :after 的双冒号和单冒号有什么区别？"></a>23. ::before 和 :after 的双冒号和单冒号有什么区别？</h3><p>（1）冒号(<code>:</code>)用于<code>CSS3</code>伪类，双冒号(<code>::</code>)用于<code>CSS3</code>伪元素。</p>
<p>（2）<code>::before</code>就是以一个子元素的存在，定义在元素主体内容之前的一个伪元素。并不存在于<code>dom</code>之中，只存在在页面之中。</p>
<p><strong>注意：</strong> <code>:before </code>和 <code>:after</code> 这两个伪元素，是在<code>CSS2.1</code>里新出现的。起初，伪元素的前缀使用的是单冒号语法，但随着<code>Web</code>的进化，在<code>CSS3</code>的规范里，伪元素的语法被修改成使用双冒号，成为<code>::before</code>、<code>::after</code>。</p>
<h3 id="24-display-inline-block-什么时候会显示间隙？"><a href="#24-display-inline-block-什么时候会显示间隙？" class="headerlink" title="24. display:inline-block 什么时候会显示间隙？"></a>24. display:inline-block 什么时候会显示间隙？</h3><ul>
<li>有空格时会有间隙，可以删除空格解决；</li>
<li><code>margin</code>正值时，可以让<code>margin</code>使用负值解决；</li>
<li>使用<code>font-size</code>时，可通过设置<code>font-size:0</code>、<code>letter-spacing</code>、<code>word-spacing</code>解决；</li>
</ul>
<h3 id="25-单行、多行文本溢出隐藏"><a href="#25-单行、多行文本溢出隐藏" class="headerlink" title="25. 单行、多行文本溢出隐藏"></a>25. 单行、多行文本溢出隐藏</h3><ul>
<li>单行文本溢出</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">overflow: hidden;            <span class="hljs-comment">// 溢出隐藏</span><br>text-overflow: ellipsis;      <span class="hljs-comment">// 溢出用省略号显示</span><br>white-space: nowrap;         <span class="hljs-comment">// 规定段落中的文本不进行换行</span><br></code></pre></td></tr></table></figure>

<ul>
<li>多行文本溢出</li>
</ul>
<figure class="highlight arduino"><table><tr><td class="code"><pre><code class="hljs arduino">overflow: hidden;            <span class="hljs-comment">// 溢出隐藏</span><br>text-overflow: ellipsis;     <span class="hljs-comment">// 溢出用省略号显示</span><br>display:-webkit-box;         <span class="hljs-comment">// 作为弹性伸缩盒子模型显示。</span><br>-webkit-box-orient:vertical; <span class="hljs-comment">// 设置伸缩盒子的子元素排列方式：从上到下垂直排列</span><br>-webkit-line-clamp:<span class="hljs-number">3</span>;        <span class="hljs-comment">// 显示的行数</span><br></code></pre></td></tr></table></figure>

<p>注意：由于上面的三个属性都是 CSS3 的属性，没有浏览器可以兼容，所以要在前面加一个<code>-webkit-</code> 来兼容一部分浏览器。</p>
<h3 id="26-Sass、Less-是什么？为什么要使用他们？"><a href="#26-Sass、Less-是什么？为什么要使用他们？" class="headerlink" title="26. Sass、Less 是什么？为什么要使用他们？"></a>26. Sass、Less 是什么？为什么要使用他们？</h3><p>他们都是 CSS 预处理器，是 CSS 上的一种抽象层。他们是一种特殊的语法&#x2F;语言编译成 CSS。 例如 Less 是一种动态样式语言，将 CSS 赋予了动态语言的特性，如变量，继承，运算， 函数，LESS 既可以在客户端上运行 (支持 IE 6+, Webkit, Firefox)，也可以在服务端运行 (借助 Node.js)。 </p>
<p><strong>为什么要使用它们？</strong> </p>
<ul>
<li>结构清晰，便于扩展。 可以方便地屏蔽浏览器私有语法差异。封装对浏览器语法差异的重复处理， 减少无意义的机械劳动。 </li>
<li>可以轻松实现多重继承。 完全兼容 CSS 代码，可以方便地应用到老项目中。LESS 只是在 CSS 语法上做了扩展，所以老的 CSS 代码也可以与 LESS 代码一同编译。</li>
</ul>
<h3 id="27-对媒体查询的理解？"><a href="#27-对媒体查询的理解？" class="headerlink" title="27. 对媒体查询的理解？"></a>27. 对媒体查询的理解？</h3><p>媒体查询由⼀个可选的媒体类型和零个或多个使⽤媒体功能的限制了样式表范围的表达式组成，例如宽度、⾼度和颜⾊。媒体查询，添加⾃CSS3，允许内容的呈现针对⼀个特定范围的输出设备⽽进⾏裁剪，⽽不必改变内容本身，适合web⽹⻚应对不同型号的设备⽽做出对应的响应适配。 </p>
<p>媒体查询包含⼀个可选的媒体类型和满⾜CSS3规范的条件下，包含零个或多个表达式，这些表达式描述了媒体特征，最终会被解析为true或false。如果媒体查询中指定的媒体类型匹配展示⽂档所使⽤的设备类型，并且所有的表达式的值都是true，那么该媒体查询的结果为true。那么媒体查询内的样式将会⽣效。 </p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- link元素中的CSS媒体查询 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">link</span> <span class="hljs-attr">rel</span>=<span class="hljs-string">&quot;stylesheet&quot;</span> <span class="hljs-attr">media</span>=<span class="hljs-string">&quot;(max-width: 800px)&quot;</span> <span class="hljs-attr">href</span>=<span class="hljs-string">&quot;example.css&quot;</span> /&gt;</span> <br><span class="hljs-comment">&lt;!-- 样式表中的CSS媒体查询 --&gt;</span> <br><span class="hljs-tag">&lt;<span class="hljs-name">style</span>&gt;</span><span class="language-css"> </span><br><span class="language-css"><span class="hljs-keyword">@media</span> (<span class="hljs-attribute">max-width</span>: <span class="hljs-number">600px</span>) &#123; </span><br><span class="language-css">  <span class="hljs-selector-class">.facet_sidebar</span> &#123; </span><br><span class="language-css">    <span class="hljs-attribute">display</span>: none; </span><br><span class="language-css">  &#125; </span><br><span class="language-css">&#125;</span><br><span class="language-css"></span><span class="hljs-tag">&lt;/<span class="hljs-name">style</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>简单来说，使用 @media 查询，可以针对不同的媒体类型定义不同的样式。@media 可以针对不同的屏幕尺寸设置不同的样式，特别是需要设置设计响应式的页面，@media 是非常有用的。当重置浏览器大小的过程中，页面也会根据浏览器的宽度和高度重新渲染页面。</p>
<h3 id="28-对-CSS-工程化的理解"><a href="#28-对-CSS-工程化的理解" class="headerlink" title="28. 对 CSS 工程化的理解"></a>28. 对 CSS 工程化的理解</h3><p>CSS 工程化是为了解决以下问题：</p>
<ol>
<li><strong>宏观设计</strong>：CSS 代码如何组织、如何拆分、模块结构怎样设计？</li>
<li><strong>编码优化</strong>：怎样写出更好的 CSS？</li>
<li><strong>构建</strong>：如何处理我的 CSS，才能让它的打包结果最优？</li>
<li><strong>可维护性</strong>：代码写完了，如何最小化它后续的变更成本？如何确保任何一个同事都能轻松接手？</li>
</ol>
<p>以下三个方向都是时下比较流行的、普适性非常好的 CSS 工程化实践：</p>
<ul>
<li>预处理器：Less、 Sass 等；</li>
<li>重要的工程化插件： PostCss；</li>
<li>Webpack loader 等 。</li>
</ul>
<p>基于这三个方向，可以衍生出一些具有典型意义的子问题，这里我们逐个来看：</p>
<p><strong>（1）预处理器：为什么要用预处理器？它的出现是为了解决什么问题？</strong></p>
<p>预处理器，其实就是 CSS 世界的“轮子”。预处理器支持我们写一种类似 CSS、但实际并不是 CSS 的语言，然后把它编译成 CSS 代码：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1615998492170-c294084b-84d5-4537-87bb-b32da4bf0cd6.jpeg"  ><span class="image-caption">image</span></p>
<p>那为什么写 CSS 代码写得好好的，偏偏要转去写“类 CSS”呢？这就和本来用 JS 也可以实现所有功能，但最后却写 React 的 jsx 或者 Vue 的模板语法一样——为了爽！要想知道有了预处理器有多爽，首先要知道的是传统 CSS 有多不爽。随着前端业务复杂度的提高，前端工程中对 CSS 提出了以下的诉求：</p>
<ol>
<li>宏观设计上：我们希望能优化 CSS 文件的目录结构，对现有的 CSS 文件实现复用；</li>
<li>编码优化上：我们希望能写出结构清晰、简明易懂的 CSS，需要它具有一目了然的嵌套层级关系，而不是无差别的一铺到底写法；我们希望它具有变量特征、计算能力、循环能力等等更强的可编程性，这样我们可以少写一些无用的代码；</li>
<li>可维护性上：更强的可编程性意味着更优质的代码结构，实现复用意味着更简单的目录结构和更强的拓展能力，这两点如果能做到，自然会带来更强的可维护性。</li>
</ol>
<p>这三点是传统 CSS 所做不到的，也正是预处理器所解决掉的问题。预处理器普遍会具备这样的特性：</p>
<ul>
<li>嵌套代码的能力，通过嵌套来反映不同 css 属性之间的层级关系 ；</li>
<li>支持定义 css 变量；</li>
<li>提供计算函数；</li>
<li>允许对代码片段进行 extend 和 mixin；</li>
<li>支持循环语句的使用；</li>
<li>支持将 CSS 文件模块化，实现复用。</li>
</ul>
<p><strong>（2）PostCss：PostCss 是如何工作的？我们在什么场景下会使用 PostCss？</strong></p>
<p>PostCss 仍然是一个对 CSS 进行解析和处理的工具，它会对 CSS 做这样的事情：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1615998491947-34e3237c-e54f-4b1a-8aeb-3c38655e1cb0.jpeg?x-oss-process=image/resize,w_1038"  ><span class="image-caption">img</span></p>
<p>它和预处理器的不同就在于，预处理器处理的是 类CSS，而 PostCss 处理的就是 CSS 本身。Babel 可以将高版本的 JS 代码转换为低版本的 JS 代码。PostCss 做的是类似的事情：它可以编译尚未被浏览器广泛支持的先进的 CSS 语法，还可以自动为一些需要额外兼容的语法增加前缀。更强的是，由于 PostCss 有着强大的插件机制，支持各种各样的扩展，极大地强化了 CSS 的能力。</p>
<p>PostCss 在业务中的使用场景非常多：</p>
<ul>
<li>提高 CSS 代码的可读性：PostCss 其实可以做类似预处理器能做的工作；</li>
<li>当我们的 CSS 代码需要适配低版本浏览器时，PostCss 的 <a href="https://github.com/postcss/autoprefixer">Autoprefixer</a> 插件可以帮助我们自动增加浏览器前缀；</li>
<li>允许我们编写面向未来的 CSS：PostCss 能够帮助我们编译 CSS next 代码；</li>
</ul>
<p><strong>（3）Webpack 能处理 CSS 吗？如何实现？</strong></p>
<p>Webpack 能处理 CSS 吗：</p>
<ul>
<li><strong>Webpack 在裸奔的状态下，是不能处理 CSS 的</strong>，Webpack 本身是一个面向 JavaScript 且只能处理 JavaScript 代码的模块化打包工具；</li>
<li>Webpack 在 loader 的辅助下，是可以处理 CSS 的。</li>
</ul>
<p>如何用 Webpack 实现对 CSS 的处理：</p>
<ul>
<li><p>Webpack 中操作 CSS 需要使用的两个关键的 loader：css-loader 和 style-loader</p>
</li>
<li><p>注意，答出“用什么”有时候可能还不够，面试官会怀疑你是不是在背答案，所以你还需要了解每个 loader 都做了什么事情：</p>
</li>
<li><ul>
<li>css-loader：导入 CSS 模块，对 CSS 代码进行编译处理；</li>
<li>style-loader：创建style标签，把 CSS 内容写入标签。</li>
</ul>
</li>
</ul>
<p>在实际使用中，<strong>css-loader 的执行顺序一定要安排在 style-loader 的前面</strong>。因为只有完成了编译过程，才可以对 css 代码进行插入；若提前插入了未编译的代码，那么 webpack 是无法理解这坨东西的，它会无情报错。</p>
<h3 id="29-如何判断元素是否到达可视区域"><a href="#29-如何判断元素是否到达可视区域" class="headerlink" title="29. 如何判断元素是否到达可视区域"></a>29. 如何判断元素是否到达可视区域</h3><p>以图片显示为例：</p>
<ul>
<li><code>window.innerHeight</code> 是浏览器可视区的高度；</li>
<li><code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离；</li>
<li><code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）；</li>
<li>内容达到显示区域的：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image/resize,w_800"  ><span class="image-caption">img</span></p>
<h3 id="30-z-index属性在什么情况下会失效"><a href="#30-z-index属性在什么情况下会失效" class="headerlink" title="30. z-index属性在什么情况下会失效"></a>30. z-index属性在什么情况下会失效</h3><p>通常 z-index 的使用是在有两个重叠的标签，在一定的情况下控制其中一个在另一个的上方或者下方出现。z-index值越大就越是在上层。z-index元素的position属性需要是relative，absolute或是fixed。</p>
<p>z-index属性在下列情况下会失效：</p>
<ul>
<li>父元素position为relative时，子元素的z-index失效。解决：父元素position改为absolute或static；</li>
<li>元素没有设置position属性为非static属性。解决：设置该元素的position属性为relative，absolute或是fixed中的一种；</li>
<li>元素在设置z-index的同时还设置了float浮动。解决：float去除，改为display：inline-block；</li>
</ul>
<h3 id="31-CSS3中的transform有哪些属性"><a href="#31-CSS3中的transform有哪些属性" class="headerlink" title="31. CSS3中的transform有哪些属性"></a>31. CSS3中的transform有哪些属性</h3><h2 id="二、页面布局"><a href="#二、页面布局" class="headerlink" title="二、页面布局"></a>二、页面布局</h2><h3 id="1-常见的CSS布局单位"><a href="#1-常见的CSS布局单位" class="headerlink" title="1. 常见的CSS布局单位"></a>1. 常见的CSS布局单位</h3><p>常用的布局单位包括像素（<code>px</code>），百分比（<code>%</code>），<code>em</code>，<code>rem</code>，<code>vw/vh</code>。</p>
<p><strong>（1）像素</strong>（<code>px</code>）是页面布局的基础，一个像素表示终端（电脑、手机、平板等）屏幕所能显示的最小的区域，像素分为两种类型：CSS像素和物理像素：</p>
<ul>
<li><strong>CSS像素</strong>：为web开发者提供，在CSS中使用的一个抽象单位；</li>
<li><strong>物理像素</strong>：只与设备的硬件密度有关，任何设备的物理像素都是固定的。</li>
</ul>
<p><strong>（2）百分比</strong>（<code>%</code>），当浏览器的宽度或者高度发生变化时，通过百分比单位可以使得浏览器中的组件的宽和高随着浏览器的变化而变化，从而实现响应式的效果。一般认为子元素的百分比相对于直接父元素。</p>
<p><strong>（3）em和rem</strong>相对于px更具灵活性，它们都是相对长度单位，它们之间的区别：<strong>em相对于父元素，rem相对于根元素。</strong></p>
<ul>
<li><strong>em：</strong> 文本相对长度单位。相对于当前对象内文本的字体尺寸。如果当前行内文本的字体尺寸未被人为设置，则相对于浏览器的默认字体尺寸(默认16px)。(相对父元素的字体大小倍数)。</li>
<li><strong>rem：</strong> rem是CSS3新增的一个相对单位，相对于根元素（html元素）的font-size的倍数。<strong>作用</strong>：利用rem可以实现简单的响应式布局，可以利用html元素中字体的大小与屏幕间的比值来设置font-size的值，以此实现当屏幕分辨率变化时让元素也随之变化。</li>
</ul>
<p><strong>（4）vw&#x2F;vh</strong>是与视图窗口有关的单位，vw表示相对于视图窗口的宽度，vh表示相对于视图窗口高度，除了vw和vh外，还有vmin和vmax两个相关的单位。</p>
<ul>
<li>vw：相对于视窗的宽度，视窗宽度是100vw；</li>
<li>vh：相对于视窗的高度，视窗高度是100vh；</li>
<li>vmin：vw和vh中的较小值；</li>
<li>vmax：vw和vh中的较大值；</li>
</ul>
<p><strong>vw&#x2F;vh</strong> 和百分比很类似，两者的区别：</p>
<ul>
<li>百分比（<code>%</code>）：大部分相对于祖先元素，也有相对于自身的情况比如（border-radius、translate等)</li>
<li>vw&#x2F;vm：相对于视窗的尺寸</li>
</ul>
<h3 id="2-px、em、rem的区别及使用场景"><a href="#2-px、em、rem的区别及使用场景" class="headerlink" title="2. px、em、rem的区别及使用场景"></a>2. px、em、rem的区别及使用场景</h3><p><strong>三者的区别：</strong></p>
<ul>
<li>px是固定的像素，一旦设置了就无法因为适应页面大小而改变。</li>
<li>em和rem相对于px更具有灵活性，他们是相对长度单位，其长度不是固定的，更适用于响应式布局。</li>
<li>em是相对于其父元素来设置字体大小，这样就会存在一个问题，进行任何元素设置，都有可能需要知道他父元素的大小。而rem是相对于根元素，这样就意味着，只需要在根元素确定一个参考值。</li>
</ul>
<p><strong>使用场景：</strong></p>
<ul>
<li>对于只需要适配少部分移动设备，且分辨率对页面影响不大的，使用px即可 。</li>
<li>对于需要适配各种移动设备，使用rem，例如需要适配iPhone和iPad等分辨率差别比较挺大的设备。</li>
</ul>
<h3 id="3-两栏布局的实现"><a href="#3-两栏布局的实现" class="headerlink" title="3. 两栏布局的实现"></a>3. 两栏布局的实现</h3><p>一般两栏布局指的是<strong>左边一栏宽度固定，右边一栏宽度自适应</strong>，两栏布局的具体实现：</p>
<ul>
<li>利用浮动，将左边元素宽度设置为200px，并且设置向左浮动。将右边元素的margin-left设置为200px，宽度设置为auto（默认为auto，撑满整个父元素）。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">width</span>: auto;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用浮动，左侧元素设置固定大小，并左浮动，右侧元素设置overflow: hidden; 这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> <span class="hljs-selector-class">.right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用flex布局，将左边元素设置为固定宽度200px，将右边的元素设置为flex:1。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用绝对定位，将父级元素设置为相对定位。左边元素设置为absolute定位，并且宽度设置为200px。将右边元素的margin-left的值设置为200px。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用绝对定位，将父级元素设置为相对定位。左边元素宽度设置为200px，右边元素设置为绝对定位，左边定位为200px，其余方向定位为0。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-三栏布局的实现"><a href="#4-三栏布局的实现" class="headerlink" title="4. 三栏布局的实现"></a>4. 三栏布局的实现</h3><p>三栏布局一般指的是页面中一共有三栏，<strong>左右两栏宽度固定，中间自适应的布局</strong>，三栏布局的具体实现：</p>
<ul>
<li>利用<strong>绝对定位</strong>，左右两栏设置为绝对定位，中间设置对应方向大小的margin的值。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: absolute;<br>  <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用flex布局，左右两栏设置固定大小，中间一栏设置为flex:1。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">display</span>: flex;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">flex</span>: <span class="hljs-number">1</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用浮动，左右两栏设置固定大小，并设置对应方向的浮动。中间一栏设置左右两个方向的margin值，注意这种方式<strong>，中间一栏必须放到最后：</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>圣杯布局，利用浮动和负边距来实现。父级元素设置左右的 padding，三列均设置向左浮动，中间一列放在最前面，宽度设置为父级元素的宽度，因此后面两列都被挤到了下一行，通过设置 margin 负值将其移动到上一行，再利用相对定位，定位到两边。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">padding-right</span>: <span class="hljs-number">200px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: -<span class="hljs-number">100px</span>;<br><br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">position</span>: relative;<br>  <span class="hljs-attribute">left</span>: <span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">float</span>: right;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>双飞翼布局，双飞翼布局相对于圣杯布局来说，左右位置的保留是通过中间列的 margin 值来实现的，而不是通过父元素的 padding 来实现的。本质上来说，也是通过浮动和外边距负值来实现的。</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.outer</span> &#123;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br><br><span class="hljs-selector-class">.left</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">100%</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br><br><span class="hljs-selector-class">.right</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br>  <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">200px</span>;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: gold;<br>&#125;<br><br><span class="hljs-selector-class">.wrapper</span> &#123;<br>  <span class="hljs-attribute">float</span>: left;<br><br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">100%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">background</span>: lightgreen;<br>&#125;<br><br><span class="hljs-selector-class">.center</span> &#123;<br>  <span class="hljs-attribute">margin-left</span>: <span class="hljs-number">100px</span>;<br>  <span class="hljs-attribute">margin-right</span>: <span class="hljs-number">200px</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">100px</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="水平垂直居中的实现"><a href="#水平垂直居中的实现" class="headerlink" title="水平垂直居中的实现"></a>水平垂直居中的实现</h3><ul>
<li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过translate来调整元素的中心点到页面的中心。该方法需要<strong>考虑浏览器兼容问题。</strong></li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">translate</span>(-<span class="hljs-number">50%</span>,-<span class="hljs-number">50%</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用绝对定位，设置四个方向的值都为0，并将margin设置为auto，由于宽高固定，因此对应方向实现平分，可以实现水平和垂直方向上的居中。该方法适用于<strong>盒子有宽高</strong>的情况：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">bottom</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">right</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">margin</span>: auto;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用绝对定位，先将元素的左上角通过top:50%和left:50%定位到页面的中心，然后再通过margin负值来调整元素的中心点到页面的中心。该方法适用于<strong>盒子宽高已知</strong>的情况</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br> <br><span class="hljs-selector-class">.child</span> &#123;<br>    <span class="hljs-attribute">position</span>: absolute;<br>    <span class="hljs-attribute">top</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">left</span>: <span class="hljs-number">50%</span>;<br>    <span class="hljs-attribute">margin-top</span>: -<span class="hljs-number">50px</span>;     <span class="hljs-comment">/* 自身 height 的一半 */</span><br>    <span class="hljs-attribute">margin-left</span>: -<span class="hljs-number">50px</span>;    <span class="hljs-comment">/* 自身 width 的一半 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用flex布局，通过align-items:center和justify-content:center设置容器的垂直和水平方向上为居中对齐，然后它的子元素也可以实现垂直和水平的居中。该方法要<strong>考虑兼容的问题</strong>，该方法在移动端用的较多：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.parent</span> &#123;<br>    <span class="hljs-attribute">display</span>: flex;<br>    <span class="hljs-attribute">justify-content</span>:center;<br>    <span class="hljs-attribute">align-items</span>:center;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-如何根据设计稿进行移动端适配？"><a href="#6-如何根据设计稿进行移动端适配？" class="headerlink" title="6. 如何根据设计稿进行移动端适配？"></a>6. 如何根据设计稿进行移动端适配？</h3><p>移动端适配主要有两个维度：</p>
<ul>
<li><strong>适配不同像素密度，</strong>针对不同的像素密度，使用 CSS 媒体查询，选择不同精度的图片，以保证图片不会失真；</li>
<li><strong>适配不同屏幕大小，</strong>由于不同的屏幕有着不同的逻辑像素大小，所以如果直接使用 px 作为开发单位，会使得开发的页面在某一款手机上可以准确显示，但是在另一款手机上就会失真。为了适配不同屏幕的大小，应按照比例来还原设计稿的内容。</li>
</ul>
<p>为了能让页面的尺寸自适应，可以使用 rem，em，vw，vh 等相对单位。</p>
<h3 id="7-对Flex布局的理解及其使用场景"><a href="#7-对Flex布局的理解及其使用场景" class="headerlink" title="7. 对Flex布局的理解及其使用场景"></a>7. 对Flex布局的理解及其使用场景</h3><p>Flex是FlexibleBox的缩写，意为”弹性布局”，用来为盒状模型提供最大的灵活性。任何一个容器都可以指定为Flex布局。行内元素也可以使用Flex布局。注意，设为Flex布局以后，<strong>子元素的float、clear和vertical-align属性将失效</strong>。采用Flex布局的元素，称为Flex容器（flex container），简称”容器”。它的所有子元素自动成为容器成员，称为Flex项目（flex item），简称”项目”。容器默认存在两根轴：水平的主轴（main axis）和垂直的交叉轴（cross axis），项目默认沿水平主轴排列。</p>
<p>以下6个属性设置在<strong>容器上</strong>：</p>
<ul>
<li>flex-direction属性决定主轴的方向（即项目的排列方向）。</li>
<li>flex-wrap属性定义，如果一条轴线排不下，如何换行。</li>
<li>flex-flow属性是flex-direction属性和flex-wrap属性的简写形式，默认值为row nowrap。</li>
<li>justify-content属性定义了项目在主轴上的对齐方式。</li>
<li>align-items属性定义项目在交叉轴上如何对齐。</li>
<li>align-content属性定义了多根轴线的对齐方式。如果项目只有一根轴线，该属性不起作用。</li>
</ul>
<p>以下6个属性设置在<strong>项目上</strong>：</p>
<ul>
<li>order属性定义项目的排列顺序。数值越小，排列越靠前，默认为0。</li>
<li>flex-grow属性定义项目的放大比例，默认为0，即如果存在剩余空间，也不放大。</li>
<li>flex-shrink属性定义了项目的缩小比例，默认为1，即如果空间不足，该项目将缩小。</li>
<li>flex-basis属性定义了在分配多余空间之前，项目占据的主轴空间。浏览器根据这个属性，计算主轴是否有多余空间。它的默认值为auto，即项目的本来大小。</li>
<li>flex属性是flex-grow，flex-shrink和flex-basis的简写，默认值为0 1 auto。</li>
<li>align-self属性允许单个项目有与其他项目不一样的对齐方式，可覆盖align-items属性。默认值为auto，表示继承父元素的align-items属性，如果没有父元素，则等同于stretch。</li>
</ul>
<p><strong>简单来说：</strong></p>
<p>flex布局是CSS3新增的一种布局方式，可以通过将一个元素的display属性值设置为flex从而使它成为一个flex容器，它的所有子元素都会成为它的项目。一个容器默认有两条轴：一个是水平的主轴，一个是与主轴垂直的交叉轴。可以使用flex-direction来指定主轴的方向。可以使用justify-content来指定元素在主轴上的排列方式，使用align-items来指定元素在交叉轴上的排列方式。还可以使用flex-wrap来规定当一行排列不下时的换行方式。对于容器中的项目，可以使用order属性来指定项目的排列顺序，还可以使用flex-grow来指定当排列空间有剩余的时候，项目的放大比例，还可以使用flex-shrink来指定当排列空间不足时，项目的缩小比例。</p>
<h3 id="8-响应式设计的概念及基本原理"><a href="#8-响应式设计的概念及基本原理" class="headerlink" title="8. 响应式设计的概念及基本原理"></a>8. 响应式设计的概念及基本原理</h3><p>响应式网站设计<code>（Responsive Web design</code>）是一个网站能够兼容多个终端，而不是为每一个终端做一个特定的版本。</p>
<p>关于原理： 基本原理是通过媒体查询<code>（@media）</code>查询检测不同的设备屏幕尺寸做处理。</p>
<p>关于兼容： 页面头部必须有mate声明的<code>viewport</code>。</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;’viewport’&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;”width=device-width,&quot;</span> <span class="hljs-attribute">initial-scale</span>=<span class="hljs-string">&quot;1.&quot;</span> <span class="hljs-attribute">maximum-scale</span>=<span class="hljs-string">&quot;1,user-scalable=no”&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<h2 id="三、定位与浮动"><a href="#三、定位与浮动" class="headerlink" title="三、定位与浮动"></a>三、定位与浮动</h2><h3 id="1-为什么需要清除浮动？清除浮动的方式"><a href="#1-为什么需要清除浮动？清除浮动的方式" class="headerlink" title="1. 为什么需要清除浮动？清除浮动的方式"></a>1. 为什么需要清除浮动？清除浮动的方式</h3><p><strong>浮动的定义：</strong> 非IE浏览器下，容器不设高度且子元素浮动时，容器高度不能被内容撑开。 此时，内容会溢出到容器外面而影响布局。这种现象被称为浮动（溢出）。</p>
<p><strong>浮动的工作原理：</strong></p>
<ul>
<li>浮动元素脱离文档流，不占据空间（引起“高度塌陷”现象）</li>
<li>浮动元素碰到包含它的边框或者其他浮动元素的边框停留</li>
</ul>
<p>浮动元素可以左右移动，直到遇到另一个浮动元素或者遇到它外边缘的包含框。浮动框不属于文档流中的普通流，当元素浮动之后，不会影响块级元素的布局，只会影响内联元素布局。此时文档流中的普通流就会表现得该浮动框不存在一样的布局模式。当包含框的高度小于浮动框的时候，此时就会出现“高度塌陷”。</p>
<p><strong>浮动元素引起的问题？</strong></p>
<ul>
<li>父元素的高度无法被撑开，影响与父元素同级的元素</li>
<li>与浮动元素同级的非浮动元素会跟随其后</li>
<li>若浮动的元素不是第一个元素，则该元素之前的元素也要浮动，否则会影响页面的显示结构</li>
</ul>
<p><strong>清除浮动的方式如下：</strong></p>
<ul>
<li>给父级div定义<code>height</code>属性</li>
<li>最后一个浮动元素之后添加一个空的div标签，并添加<code>clear:both</code>样式</li>
<li>包含浮动元素的父级标签添加<code>overflow:hidden</code>或者<code>overflow:auto</code></li>
<li>使用 :after 伪元素。由于IE6-7不支持 :after，使用 zoom:1 触发 hasLayout**</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clearfix</span><span class="hljs-selector-pseudo">:after</span>&#123;<br>    <span class="hljs-attribute">content</span>: <span class="hljs-string">&quot;\200B&quot;</span>;<br>    <span class="hljs-attribute">display</span>: table; <br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">clear</span>: both;<br>  &#125;<br>  <span class="hljs-selector-class">.clearfix</span>&#123;<br>    *zoom: <span class="hljs-number">1</span>;<br>  &#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-使用-clear-属性清除浮动的原理？"><a href="#2-使用-clear-属性清除浮动的原理？" class="headerlink" title="2. 使用 clear 属性清除浮动的原理？"></a>2. 使用 clear 属性清除浮动的原理？</h3><p>使用clear属性清除浮动，其语法如下：</p>
<figure class="highlight coq"><table><tr><td class="code"><pre><code class="hljs coq"><span class="hljs-built_in">clear</span>:none|<span class="hljs-type">left</span>|<span class="hljs-type">right</span>|<span class="hljs-type">both</span><br></code></pre></td></tr></table></figure>

<p>如果单看字面意思，clear:left 是“清除左浮动”，clear:right 是“清除右浮动”，实际上，这种解释是有问题的，因为浮动一直还在，并没有清除。</p>
<p>官方对clear属性解释：“<strong>元素盒子的边不能和前面的浮动元素相邻</strong>”，对元素设置clear属性是为了避免浮动元素对该元素的影响，而不是清除掉浮动。</p>
<p>还需要注意 clear 属性指的是元素盒子的边不能和前面的浮动元素相邻，注意这里“<strong>前面的</strong>”3个字，也就是clear属性对“后面的”浮动元素是不闻不问的。考虑到float属性要么是left，要么是right，不可能同时存在，同时由于clear属性对“后面的”浮动元素不闻不问，因此，当clear:left有效的时候，clear:right必定无效，也就是此时clear:left等同于设置clear:both；同样地，clear:right如果有效也是等同于设置clear:both。由此可见，clear:left和clear:right这两个声明就没有任何使用的价值，至少在CSS世界中是如此，直接使用clear:both吧。</p>
<p>一般使用伪元素的方式清除浮动：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.clear</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>  <span class="hljs-attribute">content</span>:<span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block; <br>  <span class="hljs-attribute">clear</span>:both;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>clear属性只有块级元素才有效的，而::after等伪元素默认都是内联水平，这就是借助伪元素清除浮动影响时需要设置display属性值的原因。</p>
<h3 id="3-对BFC的理解，如何创建BFC"><a href="#3-对BFC的理解，如何创建BFC" class="headerlink" title="3. 对BFC的理解，如何创建BFC"></a>3. 对BFC的理解，如何创建BFC</h3><p>先来看两个相关的概念：</p>
<ul>
<li>Box: Box 是 CSS 布局的对象和基本单位，⼀个⻚⾯是由很多个 Box 组成的，这个Box就是我们所说的盒模型。 </li>
<li>Formatting context：块级上下⽂格式化，它是⻚⾯中的⼀块渲染区域，并且有⼀套渲染规则，它决定了其⼦元素将如何定位，以及和其他元素的关系和相互作⽤。</li>
</ul>
<p>块格式化上下文（Block Formatting Context，BFC）是Web页面的可视化CSS渲染的一部分，是布局过程中生成块级盒子的区域，也是浮动元素与其他元素的交互限定区域。</p>
<p>通俗来讲：BFC是一个独立的布局环境，可以理解为一个容器，在这个容器中按照一定规则进行物品摆放，并且不会影响其它环境中的物品。如果一个元素符合触发BFC的条件，则BFC中的元素布局不受外部影响。</p>
<p><strong>创建BFC的条件：</strong></p>
<ul>
<li>根元素：body；</li>
<li>元素设置浮动：float 除 none 以外的值；</li>
<li>元素设置绝对定位：position (absolute、fixed)；</li>
<li>display 值为：inline-block、table-cell、table-caption、flex等；</li>
<li>overflow 值为：hidden、auto、scroll；</li>
</ul>
<p><strong>BFC的特点：</strong></p>
<ul>
<li>垂直方向上，自上而下排列，和文档流的排列方式一致。</li>
<li>在BFC中上下相邻的两个容器的margin会重叠</li>
<li>计算BFC的高度时，需要计算浮动元素的高度</li>
<li>BFC区域不会与浮动的容器发生重叠</li>
<li>BFC是独立的容器，容器内部元素不会影响外部元素</li>
<li>每个元素的左margin值和容器的左border相接触</li>
</ul>
<p><strong>BFC的作用：</strong></p>
<ul>
<li><strong>解决margin的重叠问题</strong>：由于BFC是一个独立的区域，内部的元素和外部的元素互不影响，将两个元素变为两个BFC，就解决了margin重叠的问题。</li>
<li><strong>解决高度塌陷的问题</strong>：在对子元素设置浮动后，父元素会发生高度塌陷，也就是父元素的高度变为0。解决这个问题，只需要把父元素变成一个BFC。常用的办法是给父元素设置<code>overflow:hidden</code>。</li>
<li><strong>创建自适应两栏布局</strong>：可以用来创建自适应两栏布局：左边的宽度固定，右边的宽度自适应。</li>
</ul>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">.<span class="hljs-attribute">left</span>&#123;<br>     <span class="hljs-attribute">width</span>: <span class="hljs-number">100px</span>;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">200px</span>;<br>     <span class="hljs-attribute">background</span>: red;<br>     <span class="hljs-attribute">float</span>: left;<br> &#125;<br> .<span class="hljs-attribute">right</span>&#123;<br>     <span class="hljs-attribute">height</span>: <span class="hljs-number">300px</span>;<br>     <span class="hljs-attribute">background</span>: blue;<br>     <span class="hljs-attribute">overflow</span>: hidden;<br> &#125;<br> <br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;left&quot;</span>&gt;&lt;/div&gt;<br>&lt;<span class="hljs-selector-tag">div</span> class=<span class="hljs-string">&quot;right&quot;</span>&gt;&lt;/div&gt;<br></code></pre></td></tr></table></figure>

<p>左侧设置<code>float:left</code>，右侧设置<code>overflow: hidden</code>。这样右边就触发了BFC，BFC的区域不会与浮动元素发生重叠，所以两侧就不会发生重叠，实现了自适应两栏布局。</p>
<h3 id="4-什么是margin重叠问题？如何解决？"><a href="#4-什么是margin重叠问题？如何解决？" class="headerlink" title="4. 什么是margin重叠问题？如何解决？"></a>4. 什么是margin重叠问题？如何解决？</h3><p><strong>问题描述：</strong></p>
<p>两个块级元素的上外边距和下外边距可能会合并（折叠）为一个外边距，其大小会取其中外边距值大的那个，这种行为就是外边距折叠。需要注意的是，<strong>浮动的元素和绝对定位</strong>这种脱离文档流的元素的外边距不会折叠。重叠只会出现在<strong>垂直方向</strong>。</p>
<p><strong>计算原则：</strong></p>
<p>折叠合并后外边距的计算原则如下：</p>
<ul>
<li>如果两者都是正数，那么就去最大者</li>
<li>如果是一正一负，就会正值减去负值的绝对值</li>
<li>两个都是负值时，用0减去两个中绝对值大的那个</li>
</ul>
<p><strong>解决办法：</strong></p>
<p>对于折叠的情况，主要有两种：<strong>兄弟之间重叠</strong>和<strong>父子之间重叠</strong></p>
<p>（1）兄弟之间重叠</p>
<ul>
<li>底部元素变为行内盒子：<code>display: inline-block</code></li>
<li>底部元素设置浮动：<code>float</code></li>
<li>底部元素的position的值为<code>absolute/fixed</code></li>
</ul>
<p>（2）父子之间重叠</p>
<ul>
<li>父元素加入：<code>overflow: hidden</code></li>
<li>父元素添加透明边框：<code>border:1px solid transparent</code></li>
<li>子元素变为行内盒子：<code>display: inline-block</code></li>
<li>子元素加入浮动属性或定位</li>
</ul>
<h3 id="5-元素的层叠顺序"><a href="#5-元素的层叠顺序" class="headerlink" title="5. 元素的层叠顺序"></a>5. 元素的层叠顺序</h3><p>层叠顺序，英文称作 stacking order，表示元素发生层叠时有着特定的垂直显示顺序。下面是盒模型的层叠规则：	</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603553952688-ad155942-9d1d-4e4b-86a7-0f7dca46e6d1.png#align=left&display=inline&height=360&margin=%5Bobject%20Object%5D&originHeight=360&originWidth=600&size=0&status=done&style=shadow&width=600"  ><span class="image-caption">img</span></p>
<p>对于上图，由上到下分别是：</p>
<p>（1）背景和边框：建立当前层叠上下文元素的背景和边框。</p>
<p>（2）负的z-index：当前层叠上下文中，z-index属性值为负的元素。</p>
<p>（3）块级盒：文档流内非行内级非定位后代元素。</p>
<p>（4）浮动盒：非定位浮动元素。</p>
<p>（5）行内盒：文档流内行内级非定位后代元素。</p>
<p>（6）z-index:0：层叠级数为0的定位元素。</p>
<p>（7）正z-index：z-index属性值为正的定位元素。</p>
<p><strong>注意:</strong> 当定位元素z-index:auto，生成盒在当前层叠上下文中的层级为 0，不会建立新的层叠上下文，除非是根元素。</p>
<h3 id="6-position的属性有哪些，区别是什么"><a href="#6-position的属性有哪些，区别是什么" class="headerlink" title="6. position的属性有哪些，区别是什么"></a>6. position的属性有哪些，区别是什么</h3><p>position有以下属性值：</p>
<table>
<thead>
<tr>
<th>属性值</th>
<th>概述</th>
</tr>
</thead>
<tbody><tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于static定位以外的一个父元素进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其原来的位置进行定位。元素的位置通过left、top、right、bottom属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，指定元素相对于屏幕视⼝（viewport）的位置来指定元素位置。元素的位置在屏幕滚动时不会改变，⽐如回到顶部的按钮⼀般都是⽤此定位⽅式。</td>
</tr>
<tr>
<td>static</td>
<td>默认值，没有定位，元素出现在正常的文档流中，会忽略 top, bottom, left, right 或者 z-index 声明，块级元素从上往下纵向排布，⾏级元素从左向右排列。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定从父元素继承position属性的值</td>
</tr>
</tbody></table>
<p>前面三者的定位方式如下：</p>
<ul>
<li><strong>relative：</strong>元素的定位永远是相对于元素自身位置的，和其他元素没关系，也不会影响其他元素。</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694939-58dfe7f7-2fc9-45e5-9961-a953f95496a7.png#align=left&display=inline&height=105&margin=%5Bobject%20Object%5D&originHeight=105&originWidth=448&size=0&status=done&style=stroke&width=447"  ><span class="image-caption">img</span></p>
<p><strong>fixed：</strong>元素的定位是相对于 window （或者 iframe）边界的，和其他元素没有关系。但是它具有破坏性，会导致其他元素位置的变化。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694841-89472ba9-b236-4098-802f-c3c26ff49466.png#align=left&display=inline&height=117&margin=%5Bobject%20Object%5D&originHeight=135&originWidth=516&size=0&status=done&style=stroke&width=446"  ><span class="image-caption">img</span></p>
<p><strong>absolute：</strong>元素的定位相对于前两者要复杂许多。如果为 absolute 设置了 top、left，浏览器会根据什么去确定它的纵向和横向的偏移量呢？答案是浏览器会递归查找该元素的所有父元素，如果找到一个设置了<code>position:relative/absolute/fixed</code>的元素，就以该元素为基准定位，如果没找到，就以浏览器边界定位。如下两个图所示：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694882-589670e0-cd52-41d4-a3ed-4ebbdfc88f32.png#align=left&display=inline&height=142&margin=%5Bobject%20Object%5D&originHeight=183&originWidth=576&size=0&status=done&style=stroke&width=446"  ><span class="image-caption">img</span></p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603554694842-2764d9ed-d5fe-45f4-8ede-34a73d237f94.png#align=left&display=inline&height=118&margin=%5Bobject%20Object%5D&originHeight=137&originWidth=516&size=0&status=done&style=stroke&width=446"  ><span class="image-caption">img</span></p>
<h3 id="7-display、float、position的关系"><a href="#7-display、float、position的关系" class="headerlink" title="7. display、float、position的关系"></a>7. <strong>display、float、position的关系</strong></h3><p>（1）首先判断display属性是否为none，如果为none，则position和float属性的值不影响元素最后的表现。</p>
<p>（2）然后判断position的值是否为absolute或者fixed，如果是，则float属性失效，并且display的值应该被设置为table或者block，具体转换需要看初始转换值。</p>
<p>（3）如果position的值不为absolute或者fixed，则判断float属性的值是否为none，如果不是，则display的值则按上面的规则转换。注意，如果position的值为relative并且float属性的值存在，则relative相对于浮动后的最终位置定位。</p>
<p>（4）如果float的值为none，则判断元素是否为根元素，如果是根元素则display属性按照上面的规则转换，如果不是，则保持指定的display属性值不变。</p>
<p>总的来说，可以把它看作是一个类似优先级的机制，”position:absolute”和”position:fixed”优先级最高，有它存在的时候，浮动不起作用，’display’的值也需要调整；其次，元素的’float’特性的值不是”none”的时候或者它是根元素的时候，调整’display’的值；最后，非根元素，并且非浮动元素，并且非绝对定位的元素，’display’特性值同设置值。</p>
<h3 id="8-absolute与fixed共同点与不同点"><a href="#8-absolute与fixed共同点与不同点" class="headerlink" title="8. absolute与fixed共同点与不同点"></a>8. absolute与fixed共同点与不同点</h3><p><strong>共同点：</strong></p>
<ul>
<li>改变行内元素的呈现方式，将display置为inline-block  </li>
<li>使元素脱离普通文档流，不再占据文档物理空间</li>
<li>覆盖非定位文档元素</li>
</ul>
<p><strong>不同点：</strong></p>
<ul>
<li>abuselute与fixed的根元素不同，abuselute的根元素可以设置，fixed根元素是浏览器。</li>
<li>在有滚动条的页面中，absolute会跟着父元素进行移动，fixed固定在页面的具体位置。</li>
</ul>
<h3 id="9-对-sticky-定位的理解"><a href="#9-对-sticky-定位的理解" class="headerlink" title="9. 对 sticky 定位的理解"></a>9. 对 sticky 定位的理解</h3><p>sticky 英文字面意思是粘贴，所以可以把它称之为粘性定位。语法：<strong>position: sticky;</strong> 基于用户的滚动位置来定位。</p>
<p>粘性定位的元素是依赖于用户的滚动，在 <strong>position:relative</strong> 与 <strong>position:fixed</strong> 定位之间切换。它的行为就像 <strong>position:relative;</strong> 而当页面滚动超出目标区域时，它的表现就像 **position:fixed;**，它会固定在目标位置。元素定位表现为在跨越特定阈值前为相对定位，之后为固定定位。这个特定阈值指的是 top, right, bottom 或 left 之一，换言之，指定 top, right, bottom 或 left 四个阈值其中之一，才可使粘性定位生效。否则其行为与相对定位相同。</p>
<h2 id="四、场景应用"><a href="#四、场景应用" class="headerlink" title="四、场景应用"></a>四、场景应用</h2><h3 id="1-实现一个三角形"><a href="#1-实现一个三角形" class="headerlink" title="1. 实现一个三角形"></a>1. 实现一个三角形</h3><p>CSS绘制三角形主要用到的是border属性，也就是边框。</p>
<p>平时在给盒子设置边框时，往往都设置很窄，就可能误以为边框是由矩形组成的。实际上，border属性是右三角形组成的，下面看一个例子：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid;<br>    <span class="hljs-attribute">border-color</span>: orange blue red green;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>将元素的长宽都设置为0，显示出来的效果是这样的：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245125-d60dca78-0577-4aa1-8809-f1d38594889a.png#align=left&display=inline&height=298&margin=%5Bobject%20Object%5D&originHeight=502&originWidth=1012&size=0&status=done&style=stroke&width=600"  ><span class="image-caption">image</span></p>
<p>所以可以根据border这个特性来绘制三角形：</p>
<p><strong>（1）三角1</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245420-28c28277-5074-4725-9386-ffc955cf950a.png?x-oss-process=image/resize,w_500#align=left&display=inline&height=132&margin=%5Bobject%20Object%5D&originHeight=162&originWidth=738&size=0&status=done&style=stroke&width=600"  ><span class="image-caption">img</span></p>
<p><strong>（2）三角2</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245172-36f955bd-075b-442a-b88b-6c084c66ed25.png?x-oss-process=image/resize,w_500#align=left&display=inline&height=133&margin=%5Bobject%20Object%5D&originHeight=140&originWidth=630&size=0&status=done&style=stroke&width=600"  ><span class="image-caption">img</span></p>
<p><strong>（3）三角3</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-left</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245082-84a06746-dfc7-4782-a0d4-27d521aecac7.png?x-oss-process=image/resize,w_500#align=left&display=inline&height=195&margin=%5Bobject%20Object%5D&originHeight=210&originWidth=646&size=0&status=done&style=stroke&width=600"  ><span class="image-caption">img</span></p>
<p><strong>（4）三角4</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">50px</span> solid red;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">50px</span> solid transparent;<br>    <span class="hljs-attribute">border-bottom</span>: <span class="hljs-number">50px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245064-ecd01197-99fc-476e-897f-a4165b55792a.png?x-oss-process=image/resize,w_500#align=left&display=inline&height=191&margin=%5Bobject%20Object%5D&originHeight=220&originWidth=690&size=0&status=done&style=stroke&width=600"  ><span class="image-caption">img</span></p>
<p><strong>（5）三角5</strong></p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span> &#123;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-top</span>: <span class="hljs-number">100px</span> solid red;<br>    <span class="hljs-attribute">border-right</span>: <span class="hljs-number">100px</span> solid transparent;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636245095-5b40d585-7e68-4bb0-aaef-6c8fce7d36b8.png?x-oss-process=image/resize,w_500#align=left&display=inline&height=177&margin=%5Bobject%20Object%5D&originHeight=218&originWidth=738&size=0&status=done&style=stroke&width=600"  ><span class="image-caption">img</span></p>
<p>还有很多，就不一一实现了，总体的原则就是通过上下左右边框来控制三角形的方向，用边框的宽度比来控制三角形的角度。</p>
<h3 id="2-实现一个扇形"><a href="#2-实现一个扇形" class="headerlink" title="2. 实现一个扇形"></a>2. 实现一个扇形</h3><p>用CSS实现扇形的思路和三角形基本一致，就是多了一个圆角的样式，实现一个90°的扇形：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-tag">div</span>&#123;<br>    <span class="hljs-attribute">border</span>: <span class="hljs-number">100px</span> solid transparent;<br>    <span class="hljs-attribute">width</span>: <span class="hljs-number">0</span>;<br>    heigt: <span class="hljs-number">0</span>;<br>    <span class="hljs-attribute">border-radius</span>: <span class="hljs-number">100px</span>;<br>    <span class="hljs-attribute">border-top-color</span>: red;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603636444767-26da7bbe-5479-44e2-9088-50c9211d6c0d.png?x-oss-process=image/resize,w_500#align=left&display=inline&height=190&margin=%5Bobject%20Object%5D&originHeight=234&originWidth=738&size=0&status=done&style=none&width=600"  ><span class="image-caption">img</span></p>
<h3 id="3-实现一个宽高自适应的正方形"><a href="#3-实现一个宽高自适应的正方形" class="headerlink" title="3. 实现一个宽高自适应的正方形"></a>3. 实现一个宽高自适应的正方形</h3><ul>
<li>利用vw来实现：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">10%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">10vw</span>;<br>  <span class="hljs-attribute">background</span>: tomato;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用元素的margin&#x2F;padding百分比是相对父元素width的性质来实现：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">height</span>: <span class="hljs-number">0</span>;<br>  <span class="hljs-attribute">padding-top</span>: <span class="hljs-number">20%</span>;<br>  <span class="hljs-attribute">background</span>: orange;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>利用子元素的margin-top的值来实现：</li>
</ul>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-class">.square</span> &#123;<br>  <span class="hljs-attribute">width</span>: <span class="hljs-number">30%</span>;<br>  <span class="hljs-attribute">overflow</span>: hidden;<br>  <span class="hljs-attribute">background</span>: yellow;<br>&#125;<br><span class="hljs-selector-class">.square</span><span class="hljs-selector-pseudo">::after</span> &#123;<br>  <span class="hljs-attribute">content</span>: <span class="hljs-string">&#x27;&#x27;</span>;<br>  <span class="hljs-attribute">display</span>: block;<br>  <span class="hljs-attribute">margin-top</span>: <span class="hljs-number">100%</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="4-画一条0-5px的线"><a href="#4-画一条0-5px的线" class="headerlink" title="4. 画一条0.5px的线"></a>4. 画一条0.5px的线</h3><ul>
<li><strong>采用transform: scale()的方式</strong>，该方法用来定义元素的2D 缩放转换：</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">transform</span>: scale(<span class="hljs-number">0</span>.<span class="hljs-number">5</span>,<span class="hljs-number">0</span>.<span class="hljs-number">5</span>);<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>采用meta viewport的方式</strong></li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=0.5, minimum-scale=0.5, maximum-scale=0.5&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<p>这样就能缩放到原来的0.5倍，如果是1px那么就会变成0.5px。viewport只针对于移动端，只在移动端上才能看到效果</p>
<h3 id="5-设置小于12px的字体"><a href="#5-设置小于12px的字体" class="headerlink" title="5. 设置小于12px的字体"></a>5. 设置小于12px的字体</h3><p>在谷歌下css设置字体大小为12px及以下时，显示都是一样大小，都是默认12px。</p>
<p><strong>解决办法：</strong></p>
<ul>
<li>使用Webkit的内核的-webkit-text-size-adjust的私有CSS属性来解决，只要加了-webkit-text-size-adjust:none;字体大小就不受限制了。但是chrome更新到27版本之后就不可以用了。所以高版本chrome谷歌浏览器已经不再支持-webkit-text-size-adjust样式，所以要使用时候慎用。</li>
<li>使用css3的transform缩放属性-webkit-transform:scale(0.5); 注意-webkit-transform:scale(0.75);收缩的是整个元素的大小，这时候，如果是内联元素，必须要将内联元素转换成块元素，可以使用display：block&#x2F;inline-block&#x2F;…；</li>
<li>使用图片：如果是内容固定不变情况下，使用将小于12px文字内容切出做图片，这样不影响兼容也不影响美观。</li>
</ul>
<h3 id="6-如何解决-1px-问题？"><a href="#6-如何解决-1px-问题？" class="headerlink" title="6. 如何解决 1px 问题？"></a>6. 如何解决 1px 问题？</h3><p>1px 问题指的是：在一些 <code>Retina屏幕</code> 的机型上，移动端页面的 1px 会变得很粗，呈现出不止 1px 的效果。原因很简单——CSS 中的 1px 并不能和移动设备上的 1px 划等号。它们之间的比例关系有一个专门的属性来描述：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">window.devicePixelRatio</span> = 设备的物理像素 / CSS像素。<br></code></pre></td></tr></table></figure>

<p>打开 Chrome 浏览器，启动移动端调试模式，在控制台去输出这个 <code>devicePixelRatio</code> 的值。这里选中 iPhone6&#x2F;7&#x2F;8 这系列的机型，输出的结果就是2：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1615998119364-e2b81466-ba5b-4eb8-af5f-61c5621bb0af.jpeg?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image</span></p>
<p>这就意味着设置的 1px CSS 像素，在这个设备上实际会用 2 个物理像素单元来进行渲染，所以实际看到的一定会比 1px 粗一些。</p>
<p><strong>解决****1px 问题的三种思路：</strong></p>
<h4 id="思路一：直接写-0-5px"><a href="#思路一：直接写-0-5px" class="headerlink" title="思路一：直接写 0.5px"></a>思路一：直接写 0.5px</h4><p>如果之前 1px 的样式这样写：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">border</span>:<span class="hljs-number">1</span>px solid #<span class="hljs-number">333</span><br></code></pre></td></tr></table></figure>

<p>可以先在 JS 中拿到 window.devicePixelRatio 的值，然后把这个值通过 JSX 或者模板语法给到 CSS 的 data 里，达到这样的效果（这里用 JSX 语法做示范）：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span> <span class="hljs-attr">data-device</span>=</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">window.devicePixelRatio</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>然后就可以在 CSS 中用属性选择器来命中 devicePixelRatio 为某一值的情况，比如说这里尝试命中 devicePixelRatio 为2的情况：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>  <span class="hljs-attribute">border</span>:<span class="hljs-number">0.5px</span> solid <span class="hljs-number">#333</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>直接把 1px 改成 1&#x2F;devicePixelRatio 后的值，这是目前为止最简单的一种方法。这种方法的缺陷在于兼容性不行，IOS 系统需要8及以上的版本，安卓系统则直接不兼容。</p>
<h4 id="思路二：伪元素先放大后缩小"><a href="#思路二：伪元素先放大后缩小" class="headerlink" title="思路二：伪元素先放大后缩小"></a>思路二：伪元素先放大后缩小</h4><p>这个方法的可行性会更高，兼容性也更好。唯一的缺点是代码会变多。</p>
<p>思路是<strong>先放大、后缩小：<strong><strong>在目标元素的后面追加一个 ::after 伪元素，让这个元素布局为 absolute 之后、整个伸展开铺在目标元素上，然后把它的</strong></strong>宽和高都设置为目标元素的两倍，border值设为 1px。<strong><strong>接着借助 CSS 动画特效中的放缩能力，把整个伪元素缩小为原来的 50%。此时，伪元素的宽高刚好可以和原有的目标元素对齐，而 border 也缩小为了 1px 的二分之一</strong></strong>，间接地实现了 0.5px 的效果。</strong></p>
<p>代码如下：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span> &#123;<br>    <span class="hljs-attribute">position</span>: relative;<br>&#125;<br><span class="hljs-selector-id">#container</span><span class="hljs-selector-attr">[data-device=<span class="hljs-string">&quot;2&quot;</span>]</span><span class="hljs-selector-pseudo">::after</span>&#123;<br>      <span class="hljs-attribute">position</span>:absolute;<br>      <span class="hljs-attribute">top</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">left</span>: <span class="hljs-number">0</span>;<br>      <span class="hljs-attribute">width</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">height</span>: <span class="hljs-number">200%</span>;<br>      <span class="hljs-attribute">content</span>:<span class="hljs-string">&quot;&quot;</span>;<br>      <span class="hljs-attribute">transform</span>: <span class="hljs-built_in">scale</span>(<span class="hljs-number">0.5</span>);<br>      <span class="hljs-attribute">transform-origin</span>: left top;<br>      <span class="hljs-attribute">box-sizing</span>: border-box;<br>      <span class="hljs-attribute">border</span>: <span class="hljs-number">1px</span> solid <span class="hljs-number">#333</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="思路三：viewport-缩放来解决"><a href="#思路三：viewport-缩放来解决" class="headerlink" title="思路三：viewport 缩放来解决"></a>思路三：viewport 缩放来解决</h4><p>这个思路就是对 meta 标签里几个关键属性下手：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;initial-scale=0.5, maximum-scale=0.5, minimum-scale=0.5, user-scalable=no&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>这里针对像素比为2的页面，把整个页面缩放为了原来的1&#x2F;2大小。这样，本来占用2个物理像素的 1px 样式，现在占用的就是标准的一个物理像素。根据像素比的不同，这个缩放比例可以被计算为不同的值，用 js 代码实现如下：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">const scale = <span class="hljs-number">1</span><span class="hljs-operator"> / </span>window.devicePixelRatio;<br><span class="hljs-comment">// 这里 metaEl 指的是 meta 标签对应的 Dom</span><br>metaEl.set<span class="hljs-constructor">Attribute(&#x27;<span class="hljs-params">content</span>&#x27;, `<span class="hljs-params">width</span>=<span class="hljs-params">device</span>-<span class="hljs-params">width</span>,<span class="hljs-params">user</span>-<span class="hljs-params">scalable</span>=<span class="hljs-params">no</span>,<span class="hljs-params">initial</span>-<span class="hljs-params">scale</span>=$&#123;<span class="hljs-params">scale</span>&#125;,<span class="hljs-params">maximum</span>-<span class="hljs-params">scale</span>=$&#123;<span class="hljs-params">scale</span>&#125;,<span class="hljs-params">minimum</span>-<span class="hljs-params">scale</span>=$&#123;<span class="hljs-params">scale</span>&#125;`)</span>;<br></code></pre></td></tr></table></figure>

<p>这样解决了，但这样做的副作用也很大，整个页面被缩放了。这时 1px 已经被处理成物理像素大小，这样的大小在手机上显示边框很合适。但是，一些原本不需要被缩小的内容，比如文字、图片等，也被无差别缩小掉了。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>前端工程化</title>
    <url>/2022/08/22/Engineering%20optimization/</url>
    <content><![CDATA[<h2 id="前端工程化"><a href="#前端工程化" class="headerlink" title="前端工程化"></a>前端工程化</h2><span id="more"></span>


<h2 id="一、Git"><a href="#一、Git" class="headerlink" title="一、Git"></a>一、Git</h2><h3 id="1-git-和-svn-的区别"><a href="#1-git-和-svn-的区别" class="headerlink" title="1. git 和 svn 的区别"></a>1. git 和 svn 的区别</h3><ul>
<li>git 和 svn 最大的区别在于 git 是分布式的，而 svn 是集中式的。因此我们不能再离线的情况下使用 svn。如果服务器出现问题，就没有办法使用 svn 来提交代码。</li>
<li>svn 中的分支是整个版本库的复制的一份完整目录，而 git 的分支是指针指向某次提交，因此 git 的分支创建更加开销更小并且分支上的变化不会影响到其他人。svn 的分支变化会影响到所有的人。</li>
<li>svn 的指令相对于 git 来说要简单一些，比 git 更容易上手。</li>
<li><strong>GIT把内容按元数据方式存储，而SVN是按文件：</strong>因为git目录是处于个人机器上的一个克隆版的版本库，它拥有中心版本库上所有的东西，例如标签，分支，版本记录等。</li>
<li><strong>GIT分支和SVN的分支不同：</strong>svn会发生分支遗漏的情况，而git可以同一个工作目录下快速的在几个分支间切换，很容易发现未被合并的分支，简单而快捷的合并这些文件。</li>
<li><strong>GIT没有一个全局的版本号，而SVN有</strong></li>
<li><strong>GIT的内容完整性要优于SVN：</strong>GIT的内容存储使用的是SHA-1哈希算法。这能确保代码内容的完整性，确保在遇到磁盘故障和网络问题时降低对版本库的破坏</li>
</ul>
<h3 id="2-经常使用的-git-命令？"><a href="#2-经常使用的-git-命令？" class="headerlink" title="2. 经常使用的 git 命令？"></a>2. 经常使用的 git 命令？</h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">git init                     <span class="hljs-regexp">//</span> 新建 git 代码库<br>git add                      <span class="hljs-regexp">//</span> 添加指定文件到暂存区<br>git rm                       <span class="hljs-regexp">//</span> 删除工作区文件，并且将这次删除放入暂存区<br>git commit -m [message]      <span class="hljs-regexp">//</span> 提交暂存区到仓库区<br>git branch                   <span class="hljs-regexp">//</span> 列出所有分支<br>git checkout -b [branch]     <span class="hljs-regexp">//</span> 新建一个分支，并切换到该分支<br>git status                   <span class="hljs-regexp">//</span> 显示有变更文件的状态<br></code></pre></td></tr></table></figure>

<h3 id="3-git-pull-和-git-fetch-的区别"><a href="#3-git-pull-和-git-fetch-的区别" class="headerlink" title="3. git pull 和 git fetch 的区别"></a>3. git pull 和 git fetch 的区别</h3><ul>
<li>git fetch 只是将远程仓库的变化下载下来，并没有和本地分支合并。</li>
<li>git pull 会将远程仓库的变化下载下来，并和当前分支合并。</li>
</ul>
<h3 id="4-git-rebase-和-git-merge-的区别"><a href="#4-git-rebase-和-git-merge-的区别" class="headerlink" title="4. git rebase 和 git merge 的区别"></a>4. git rebase 和 git merge 的区别</h3><p>git merge 和 git rebase 都是用于分支合并，关键<strong>在</strong> <strong>commit 记录的处理上不同</strong>：</p>
<ul>
<li>git merge 会新建一个新的 commit 对象，然后两个分支以前的 commit 记录都指向这个新 commit 记录。这种方法会保留之前每个分支的 commit 历史。</li>
<li>git rebase 会先找到两个分支的第一个共同的 commit 祖先记录，然后将提取当前分支这之后的所有 commit 记录，然后将这个 commit 记录添加到目标分支的最新提交后面。经过这个合并后，两个分支合并后的 commit 记录就变为了线性的记录了。</li>
</ul>
<h2 id="二、Webpack"><a href="#二、Webpack" class="headerlink" title="二、Webpack"></a>二、Webpack</h2><h3 id="1-webpack与grunt、gulp的不同？"><a href="#1-webpack与grunt、gulp的不同？" class="headerlink" title="1. webpack与grunt、gulp的不同？"></a>1. <strong>webpack</strong>与<strong>grunt</strong>、<strong>gulp</strong>的不同？</h3><p><strong>Grunt****、Gulp是基于任务运⾏的⼯具</strong>： 它们会⾃动执⾏指定的任务，就像流⽔线，把资源放上去然后通过不同插件进⾏加⼯，它们包含活跃的社区，丰富的插件，能⽅便的打造各种⼯作流。 </p>
<p><strong>Webpack是基于模块化打包的⼯具:</strong> ⾃动化处理模块，webpack把⼀切当成模块，当 webpack 处理应⽤程序时，它会递归地构建⼀个依赖关系图 (dependency graph)，其中包含应⽤程序需要的每个模块，然后将所有这些模块打包成⼀个或多个 bundle。 </p>
<p>因此这是完全不同的两类⼯具,⽽现在主流的⽅式是⽤npm script代替Grunt、Gulp，npm script同样可以打造任务流。</p>
<h3 id="2-webpack、rollup、parcel优劣？"><a href="#2-webpack、rollup、parcel优劣？" class="headerlink" title="2. webpack、rollup、parcel优劣？"></a>2. <strong>webpack</strong>、<strong>rollup</strong>、<strong>parcel</strong>优劣？</h3><ul>
<li>webpack适⽤于⼤型复杂的前端站点构建: webpack有强⼤的loader和插件⽣态,打包后的⽂件实际上就是⼀个⽴即执⾏函数，这个⽴即执⾏函数接收⼀个参数，这个参数是模块对象，键为各个模块的路径，值为模块内容。⽴即执⾏函数内部则处理模块之间的引⽤，执⾏模块等,这种情况更适合⽂件依赖复杂的应⽤开发。 </li>
<li>rollup适⽤于基础库的打包，如vue、d3等: Rollup 就是将各个模块打包进⼀个⽂件中，并且通过 Tree-shaking 来删除⽆⽤的代码,可以最⼤程度上降低代码体积,但是rollup没有webpack如此多的的如代码分割、按需加载等⾼级功能，其更聚焦于库的打包，因此更适合库的开发。</li>
<li>parcel适⽤于简单的实验性项⽬: 他可以满⾜低⻔槛的快速看到效果,但是⽣态差、报错信息不够全⾯都是他的硬伤，除了⼀些玩具项⽬或者实验项⽬不建议使⽤。</li>
</ul>
<h3 id="3-有哪些常⻅的Loader？"><a href="#3-有哪些常⻅的Loader？" class="headerlink" title="3. 有哪些常⻅的Loader？"></a>3. 有哪些常⻅的<strong>Loader</strong>？</h3><ul>
<li>file-loader：把⽂件输出到⼀个⽂件夹中，在代码中通过相对 URL 去引⽤输出的⽂件 </li>
<li>url-loader：和 file-loader 类似，但是能在⽂件很⼩的情况下以 base64 的⽅式把⽂件内容注⼊到代码中去 </li>
<li>source-map-loader：加载额外的 Source Map ⽂件，以⽅便断点调试 </li>
<li>image-loader：加载并且压缩图⽚⽂件 </li>
<li>babel-loader：把 ES6 转换成 ES5 </li>
<li>css-loader：加载 CSS，⽀持模块化、压缩、⽂件导⼊等特性 </li>
<li>style-loader：把 CSS 代码注⼊到 JavaScript 中，通过 DOM 操作去加载 CSS。 </li>
<li>eslint-loader：通过 ESLint 检查 JavaScript 代码</li>
</ul>
<p><strong>注意：</strong>在Webpack中，loader的执行顺序是<strong>从右向左</strong>执行的。因为webpack选择了<strong>compose这样的函数式编程方式</strong>，这种方式的表达式执行是从右向左的。</p>
<h3 id="4-有哪些常⻅的Plugin？"><a href="#4-有哪些常⻅的Plugin？" class="headerlink" title="4. 有哪些常⻅的Plugin？"></a>4. 有哪些常⻅的<strong>Plugin</strong>？</h3><ul>
<li>define-plugin：定义环境变量 </li>
<li>html-webpack-plugin：简化html⽂件创建 </li>
<li>uglifyjs-webpack-plugin：通过 UglifyES 压缩 ES6 代码 </li>
<li>webpack-parallel-uglify-plugin: 多核压缩，提⾼压缩速度 </li>
<li>webpack-bundle-analyzer: 可视化webpack输出⽂件的体积 </li>
<li>mini-css-extract-plugin: CSS提取到单独的⽂件中，⽀持按需加载</li>
</ul>
<h3 id="5-bundle，chunk，module是什么？"><a href="#5-bundle，chunk，module是什么？" class="headerlink" title="5. bundle，chunk，module是什么？"></a>5. <strong>bundle</strong>，<strong>chunk</strong>，<strong>module</strong>是什么？</h3><ul>
<li>bundle：是由webpack打包出来的⽂件； </li>
<li>chunk：代码块，⼀个chunk由多个模块组合⽽成，⽤于代码的合并和分割；</li>
<li>module：是开发中的单个模块，在webpack的世界，⼀切皆模块，⼀个模块对应⼀个⽂件，webpack会从配置的 entry中递归开始找出所有依赖的模块。</li>
</ul>
<h3 id="6-Loader和Plugin的不同？"><a href="#6-Loader和Plugin的不同？" class="headerlink" title="6. Loader和Plugin的不同？"></a>6. <strong>Loader</strong>和<strong>Plugin</strong>的不同？</h3><p>不同的作⽤: </p>
<ul>
<li><strong>Loader</strong>直译为”加载器”。Webpack将⼀切⽂件视为模块，但是webpack原⽣是只能解析js⽂件，如果想将其他⽂件也打包的话，就会⽤到 loader 。 所以Loader的作⽤是让webpack拥有了加载和解析⾮JavaScript⽂件的能⼒。 </li>
<li><strong>Plugin</strong>直译为”插件”。Plugin可以扩展webpack的功能，让webpack具有更多的灵活性。 在 Webpack 运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</li>
</ul>
<p><strong>不同的⽤法</strong><strong>:</strong> </p>
<ul>
<li><strong>Loader</strong>在 module.rules 中配置，也就是说他作为模块的解析规则⽽存在。 类型为数组，每⼀项都是⼀个 Object ，⾥⾯描述了对于什么类型的⽂件（ test ），使⽤什么加载( loader )和使⽤的参数（ options ） </li>
<li><strong>Plugin</strong>在 plugins 中单独配置。 类型为数组，每⼀项是⼀个 plugin 的实例，参数都通过构造函数传⼊。</li>
</ul>
<h3 id="7-webpack的构建流程"><a href="#7-webpack的构建流程" class="headerlink" title="7. webpack的构建流程**?**"></a>7. <strong>webpack</strong>的构建流程**?**</h3><p>Webpack 的运⾏流程是⼀个串⾏的过程，从启动到结束会依次执⾏以下流程： </p>
<ol>
<li>初始化参数：从配置⽂件和 Shell 语句中读取与合并参数，得出最终的参数； </li>
<li>开始编译：⽤上⼀步得到的参数初始化 Compiler 对象，加载所有配置的插件，执⾏对象的 run ⽅法开始执⾏编译； </li>
<li>确定⼊⼝：根据配置中的 entry 找出所有的⼊⼝⽂件； </li>
<li>编译模块：从⼊⼝⽂件出发，调⽤所有配置的 Loader 对模块进⾏翻译，再找出该模块依赖的模块，再递归本步骤直到所有⼊⼝依赖的⽂件都经过了本步骤的处理； </li>
<li>完成模块编译：在经过第4步使⽤ Loader 翻译完所有模块后，得到了每个模块被翻译后的最终内容以及它们之间的依赖关系； </li>
<li>输出资源：根据⼊⼝和模块之间的依赖关系，组装成⼀个个包含多个模块的 Chunk，再把每个 Chunk 转换成⼀个单独的⽂件加⼊到输出列表，这步是可以修改输出内容的最后机会； </li>
<li>输出完成：在确定好输出内容后，根据配置确定输出的路径和⽂件名，把⽂件内容写⼊到⽂件系统。</li>
</ol>
<p>在以上过程中，Webpack 会在特定的时间点⼴播出特定的事件，插件在监听到感兴趣的事件后会执⾏特定的逻辑，并且插件可以调⽤ Webpack 提供的 API 改变 Webpack 的运⾏结果。 </p>
<h3 id="8-编写loader或plugin的思路？"><a href="#8-编写loader或plugin的思路？" class="headerlink" title="8. 编写loader或plugin的思路？"></a>8. 编写<strong>loader</strong>或<strong>plugin</strong>的思路？</h3><p>Loader像⼀个”翻译官”把读到的源⽂件内容转义成新的⽂件内容，并且每个Loader通过链式操作，将源⽂件⼀步步翻译成想要的样⼦。 </p>
<p>编写Loader时要遵循单⼀原则，每个Loader只做⼀种”转义”⼯作。 每个Loader的拿到的是源⽂件内容（source），可以通过返回值的⽅式将处理后的内容输出，也可以调⽤ this.callback() ⽅法，将内容返回给webpack。 还可以通过this.async() ⽣成⼀个 callback 函数，再⽤这个callback将处理后的内容输出出去。 此外 webpack 还为开发者准备了开发loader的⼯具函数集——loader-utils 。 </p>
<p>相对于Loader⽽⾔，Plugin的编写就灵活了许多。 webpack在运⾏的⽣命周期中会⼴播出许多事件，Plugin 可以监听这些事件，在合适的时机通过 Webpack 提供的 API 改变输出结果。</p>
<h3 id="9-webpack的热更新是如何做到的？说明其原理？"><a href="#9-webpack的热更新是如何做到的？说明其原理？" class="headerlink" title="9. webpack的热更新是如何做到的？说明其原理？"></a>9. <strong>webpack</strong>的热更新是如何做到的？说明其原理？</h3><p>webpack的热更新⼜称热替换（Hot Module Replacement），缩写为HMR。 这个机制可以做到不⽤刷新浏览器⽽将新变更的模块替换掉旧的模块。 </p>
<p>原理： </p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615910527011-339c57ce-22b2-4660-bcb5-93a7c6ec113b.png?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image.png</span></p>
<p>⾸先要知道server端和client端都做了处理⼯作：</p>
<ol>
<li>第⼀步，在 webpack 的 watch 模式下，⽂件系统中某⼀个⽂件发⽣修改，webpack 监听到⽂件变化，根据配置⽂</li>
</ol>
<p>件对模块重新编译打包，并将打包后的代码通过简单的 JavaScript 对象保存在内存中。 </p>
<ol>
<li>第⼆步是 webpack-dev-server 和 webpack 之间的接⼝交互，⽽在这⼀步，主要是 dev-server 的中间件 webpack- dev-middleware 和 webpack 之间的交互，webpack-dev-middleware 调⽤ webpack 暴露的 API对代码变化进⾏监 控，并且告诉 webpack，将代码打包到内存中。 </li>
<li>第三步是 webpack-dev-server 对⽂件变化的⼀个监控，这⼀步不同于第⼀步，并不是监控代码变化重新打包。当我们在配置⽂件中配置了devServer.watchContentBase 为 true 的时候，Server 会监听这些配置⽂件夹中静态⽂件的变化，变化后会通知浏览器端对应⽤进⾏ live reload。注意，这⼉是浏览器刷新，和 HMR 是两个概念。 </li>
<li>第四步也是 webpack-dev-server 代码的⼯作，该步骤主要是通过 sockjs（webpack-dev-server 的依赖）在浏览器端和服务端之间建⽴⼀个 websocket ⻓连接，将 webpack 编译打包的各个阶段的状态信息告知浏览器端，同时也包括第三步中 Server 监听静态⽂件变化的信息。浏览器端根据这些 socket 消息进⾏不同的操作。当然服务端传递的最主要信息还是新模块的 hash 值，后⾯的步骤根据这⼀ hash 值来进⾏模块热替换。 </li>
<li>webpack-dev-server&#x2F;client 端并不能够请求更新的代码，也不会执⾏热更模块操作，⽽把这些⼯作⼜交回给了webpack，webpack&#x2F;hot&#x2F;dev-server 的⼯作就是根据 webpack-dev-server&#x2F;client 传给它的信息以及 dev-server 的配置决定是刷新浏览器呢还是进⾏模块热更新。当然如果仅仅是刷新浏览器，也就没有后⾯那些步骤了。 </li>
<li>HotModuleReplacement.runtime 是客户端 HMR 的中枢，它接收到上⼀步传递给他的新模块的 hash 值，它通过JsonpMainTemplate.runtime 向 server 端发送 Ajax 请求，服务端返回⼀个 json，该 json 包含了所有要更新的模块的 hash 值，获取到更新列表后，该模块再次通过 jsonp 请求，获取到最新的模块代码。这就是上图中 7、8、9 步骤。 </li>
<li>⽽第 10 步是决定 HMR 成功与否的关键步骤，在该步骤中，HotModulePlugin 将会对新旧模块进⾏对⽐，决定是否更新模块，在决定更新模块后，检查模块之间的依赖关系，更新模块的同时更新模块间的依赖引⽤。 </li>
<li>最后⼀步，当 HMR 失败后，回退到 live reload 操作，也就是进⾏浏览器刷新来获取最新打包代码。</li>
</ol>
<h3 id="10-如何⽤webpack来优化前端性能？"><a href="#10-如何⽤webpack来优化前端性能？" class="headerlink" title="10. 如何⽤webpack来优化前端性能？"></a>10. 如何⽤<strong>webpack</strong>来优化前端性能？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。 </p>
<ul>
<li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css </li>
<li><strong>利⽤<strong><strong>CDN</strong></strong>加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径 </li>
<li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li>
<li><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存 </li>
<li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>
</ul>
<h3 id="11-如何提⾼webpack的打包速度"><a href="#11-如何提⾼webpack的打包速度" class="headerlink" title="11. 如何提⾼webpack的打包速度**?**"></a>11. 如何提⾼<strong>webpack</strong>的打包速度**?**</h3><ul>
<li>happypack: 利⽤进程并⾏编译loader,利⽤缓存来使得 rebuild 更快,遗憾的是作者表示已经不会继续开发此项⽬,类似的替代者是thread-loader </li>
<li>外部扩展(externals): 将不怎么需要更新的第三⽅库脱离webpack打包，不被打⼊bundle中，从⽽减少打包时间，⽐如jQuery⽤script标签引⼊ </li>
<li>dll: 采⽤webpack的 DllPlugin 和 DllReferencePlugin 引⼊dll，让⼀些基本不会改动的代码先打包成静态资源，避免反复编译浪费时间 </li>
<li>利⽤缓存: webpack.cache 、babel-loader.cacheDirectory、 HappyPack.cache 都可以利⽤缓存提⾼rebuild效率缩⼩⽂件搜索范围: ⽐如babel-loader插件,如果你的⽂件仅存在于src中,那么可以 include: path.resolve(__dirname,’src’) ,当然绝⼤多数情况下这种操作的提升有限，除⾮不⼩⼼build了node_modules⽂件</li>
</ul>
<h3 id="12-如何提⾼webpack的构建速度？"><a href="#12-如何提⾼webpack的构建速度？" class="headerlink" title="12. 如何提⾼webpack的构建速度？"></a>12. 如何提⾼<strong>webpack</strong>的构建速度？</h3><ol>
<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码 </li>
<li>通过 externals 配置来提取常⽤库 </li>
<li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 </li>
<li>使⽤ Happypack 实现多线程加速编译 </li>
<li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度 </li>
<li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li>
</ol>
<h3 id="13-怎么配置单⻚应⽤？怎么配置多⻚应⽤？"><a href="#13-怎么配置单⻚应⽤？怎么配置多⻚应⽤？" class="headerlink" title="13. 怎么配置单⻚应⽤？怎么配置多⻚应⽤？"></a>13. 怎么配置单⻚应⽤？怎么配置多⻚应⽤？</h3><p>单⻚应⽤可以理解为webpack的标准模式，直接在 entry 中指定单⻚应⽤的⼊⼝即可，这⾥不再赘述多⻚应⽤的话，可以使⽤webpack的 AutoWebPlugin 来完成简单⾃动化的构建，但是前提是项⽬的⽬录结构必须遵守他预设的规范。 多⻚应⽤中要注意的是： </p>
<ul>
<li>每个⻚⾯都有公共的代码，可以将这些代码抽离出来，避免重复的加载。⽐如，每个⻚⾯都引⽤了同⼀套css样式表</li>
<li>随着业务的不断扩展，⻚⾯可能会不断的追加，所以⼀定要让⼊⼝的配置⾜够灵活，避免每次添加新⻚⾯还需要修改构建配置</li>
</ul>
<h2 id="三、其他"><a href="#三、其他" class="headerlink" title="三、其他"></a>三、其他</h2><h3 id="1-Babel的原理是什么"><a href="#1-Babel的原理是什么" class="headerlink" title="1. Babel的原理是什么**?**"></a><strong>1. Babel</strong>的原理是什么**?**</h3><p>babel 的转译过程也分为三个阶段，这三步具体是： </p>
<ul>
<li><strong>解析 Parse</strong>: 将代码解析⽣成抽象语法树（AST），即词法分析与语法分析的过程；</li>
<li><strong>转换 Transform</strong>: 对于 AST 进⾏变换⼀系列的操作，babel 接受得到 AST 并通过 babel-traverse 对其进⾏遍历，在此过程中进⾏添加、更新及移除等操作；</li>
<li><strong>⽣成 Generate</strong>: 将变换后的 AST 再转换为 JS 代码, 使⽤到的模块是 babel-generator。</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615908675152-69682ae3-d0b3-4552-a32e-39c2022b1db0.png?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image.png</span></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>HTML</title>
    <url>/2022/08/22/HTML/</url>
    <content><![CDATA[<h2 id="HTML篇"><a href="#HTML篇" class="headerlink" title="HTML篇"></a>HTML篇</h2><span id="more"></span>

<p><img  src="/images/image/html.png"  ><span class="image-caption">HTML面试题.png</span></p>
<h3 id="1-src和href的区别"><a href="#1-src和href的区别" class="headerlink" title="1. src和href的区别"></a>1. src和href的区别</h3><p>src和href都是<strong>用来引用外部的资源</strong>，它们的区别如下：</p>
<ul>
<li><strong>src：</strong>表示对资源的引用，它指向的内容会嵌入到当前标签所在的位置。src会将其指向的资源下载并应⽤到⽂档内，如请求js脚本。当浏览器解析到该元素时，会暂停其他资源的下载和处理，直到将该资源加载、编译、执⾏完毕，所以⼀般js脚本会放在页面底部。</li>
<li><strong>href：</strong>表示超文本引用，它指向一些网络资源，建立和当前元素或本文档的链接关系。当浏览器识别到它他指向的⽂件时，就会并⾏下载资源，不会停⽌对当前⽂档的处理。 常用在a、link等标签上。</li>
</ul>
<h3 id="2-对HTML语义化的理解"><a href="#2-对HTML语义化的理解" class="headerlink" title="2. 对HTML语义化的理解"></a>2. 对HTML语义化的理解</h3><p><strong>语义化是指****根据内容的结构化（内容语义化），选择合适的标签（代码语义化）</strong>。通俗来讲就是用正确的标签做正确的事情。</p>
<p>语义化的优点如下：</p>
<ul>
<li>对机器友好，带有语义的文字表现力丰富，更适合搜索引擎的爬虫爬取有效信息，有利于SEO。除此之外，语义类还支持读屏软件，根据文章可以自动生成目录；</li>
<li>对开发者友好，使用语义类标签增强了可读性，结构更加清晰，开发者能清晰的看出网页的结构，便于团队的开发与维护。</li>
</ul>
<p> 常见的语义化标签：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&lt;<span class="hljs-selector-tag">header</span>&gt;&lt;/<span class="hljs-selector-tag">header</span>&gt;  头部<br><br>&lt;<span class="hljs-selector-tag">nav</span>&gt;&lt;/<span class="hljs-selector-tag">nav</span>&gt;  导航栏<br><br>&lt;<span class="hljs-selector-tag">section</span>&gt;&lt;/<span class="hljs-selector-tag">section</span>&gt;  区块（有语义化的<span class="hljs-selector-tag">div</span>）<br><br>&lt;<span class="hljs-selector-tag">main</span>&gt;&lt;/<span class="hljs-selector-tag">main</span>&gt;  主要区域<br><br>&lt;<span class="hljs-selector-tag">article</span>&gt;&lt;/<span class="hljs-selector-tag">article</span>&gt;  主要内容<br><br>&lt;<span class="hljs-selector-tag">aside</span>&gt;&lt;/<span class="hljs-selector-tag">aside</span>&gt;  侧边栏<br><br>&lt;<span class="hljs-selector-tag">footer</span>&gt;&lt;/<span class="hljs-selector-tag">footer</span>&gt;  底部<br></code></pre></td></tr></table></figure>

<h3 id="3-DOCTYPE-⽂档类型-的作⽤"><a href="#3-DOCTYPE-⽂档类型-的作⽤" class="headerlink" title="3. DOCTYPE(⽂档类型) 的作⽤"></a>3. DOCTYPE(⽂档类型) 的作⽤</h3><p>DOCTYPE是HTML5中一种标准通用标记语言的文档类型声明，它的目的是<strong>告诉浏览器（解析器）应该以什么样（html或xhtml）的文档类型定义****来解析文档</strong>，不同的渲染模式会影响浏览器对 CSS 代码甚⾄ JavaScript 脚本的解析。它必须声明在HTML⽂档的第⼀⾏。</p>
<p>浏览器渲染页面的两种模式（可通过document.compatMode获取，比如，语雀官网的文档类型是<strong>CSS1Compat</strong>）：</p>
<ul>
<li><strong>CSS1Compat：标准模式（Strick mode）</strong>，默认模式，浏览器使用W3C的标准解析渲染页面。在标准模式中，浏览器以其支持的最高标准呈现页面。</li>
<li>**BackCompat：怪异模式(混杂模式)(Quick mode)**，浏览器使用自己的怪异模式解析渲染页面。在怪异模式中，页面以一种比较宽松的向后兼容的方式显示。</li>
</ul>
<h3 id="4-script标签中defer和async的区别"><a href="#4-script标签中defer和async的区别" class="headerlink" title="4. script标签中defer和async的区别"></a>4. script标签中defer和async的区别</h3><p>如果没有defer或async属性，浏览器会立即加载并执行相应的脚本。它不会等待后续加载的文档元素，读取到就会开始加载和执行，这样就阻塞了后续文档的加载。</p>
<p>下图可以直观的看出三者之间的区别:</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603547262709-5029c4e4-42f5-4fd4-bcbb-c0e0e3a40f5a.png"  ><span class="image-caption">image.png</span></p>
<p>其中蓝色代表js脚本网络加载时间，红色代表js脚本执行时间，绿色代表html解析。</p>
<p><strong>defer 和 async属性都是去异步加载外部的JS脚本文件，它们都不会阻塞页面的解析</strong>，其区别如下：</p>
<ul>
<li><strong>执行顺序：</strong>多个带async属性的标签，不能保证加载的顺序；多个带defer属性的标签，按照加载顺序执行；</li>
<li><strong>脚本是否并行执行：</strong>async属性，表示<strong>后续文档的加载和执行与js脚本的加载和执行是并行进行的</strong>，即异步执行；defer属性，加载后续文档的过程和js脚本的加载(此时仅加载不执行)是并行进行的(异步)，js脚本需要等到文档所有元素解析完成之后才执行，DOMContentLoaded事件触发执行之前。</li>
</ul>
<h3 id="5-常⽤的meta标签有哪些"><a href="#5-常⽤的meta标签有哪些" class="headerlink" title="5. 常⽤的meta标签有哪些"></a>5. 常⽤的meta标签有哪些</h3><p><code>meta</code> 标签由 <code>name</code> 和 <code>content</code> 属性定义，<strong>用来描述网页文档的属性</strong>，比如网页的作者，网页描述，关键词等，除了HTTP标准固定了一些<code>name</code>作为大家使用的共识，开发者还可以自定义name。</p>
<p>常用的meta标签：</p>
<p>（1）<code>charset</code>，用来描述HTML文档的编码类型：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;meta charset<span class="hljs-operator">=</span><span class="hljs-string">&quot;UTF-8&quot;</span> &gt;<br></code></pre></td></tr></table></figure>

<p>（2） <code>keywords</code>，页面关键词：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;meta name<span class="hljs-operator">=</span><span class="hljs-string">&quot;keywords&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;关键词&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<p>（3）<code>description</code>，页面描述：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;meta name<span class="hljs-operator">=</span><span class="hljs-string">&quot;description&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;页面描述内容&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<p>（4）<code>refresh</code>，页面重定向和刷新：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;meta http-equiv<span class="hljs-operator">=</span><span class="hljs-string">&quot;refresh&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;0;url=&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<p>（5）<code>viewport</code>，适配移动端，可以控制视口的大小和比例：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;meta <span class="hljs-attribute">name</span>=<span class="hljs-string">&quot;viewport&quot;</span> <span class="hljs-attribute">content</span>=<span class="hljs-string">&quot;width=device-width, initial-scale=1, maximum-scale=1&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>width viewport</code> ：宽度(数值&#x2F;device-width)</li>
<li><code>height viewport</code> ：高度(数值&#x2F;device-height)</li>
<li><code>initial-scale</code> ：初始缩放比例</li>
<li><code>maximum-scale</code> ：最大缩放比例</li>
<li><code>minimum-scale</code> ：最小缩放比例</li>
<li><code>user-scalable</code> ：是否允许用户缩放(yes&#x2F;no）</li>
</ul>
<p>（6）搜索引擎索引方式：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;meta name<span class="hljs-operator">=</span><span class="hljs-string">&quot;robots&quot;</span> content<span class="hljs-operator">=</span><span class="hljs-string">&quot;index,follow&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<p>其中，<code>content</code> 参数有以下几种：</p>
<ul>
<li><code>all</code>：文件将被检索，且页面上的链接可以被查询；</li>
<li><code>none</code>：文件将不被检索，且页面上的链接不可以被查询；</li>
<li><code>index</code>：文件将被检索；</li>
<li><code>follow</code>：页面上的链接可以被查询；</li>
<li><code>noindex</code>：文件将不被检索；</li>
<li><code>nofollow</code>：页面上的链接不可以被查询。</li>
</ul>
<h3 id="6-HTML5有哪些更新"><a href="#6-HTML5有哪些更新" class="headerlink" title="6. HTML5有哪些更新"></a>6. HTML5有哪些更新</h3><h4 id="1-语义化标签"><a href="#1-语义化标签" class="headerlink" title="1. 语义化标签"></a>1. 语义化标签</h4><ul>
<li>header：定义文档的页眉（头部）；</li>
<li>nav：定义导航链接的部分；</li>
<li>footer：定义文档或节的页脚（底部）；</li>
<li>article：定义文章内容；</li>
<li>section：定义文档中的节（section、区段）；</li>
<li>aside：定义其所处内容之外的内容（侧边）；</li>
</ul>
<h4 id="2-媒体标签"><a href="#2-媒体标签" class="headerlink" title="2. 媒体标签"></a>2. 媒体标签</h4><p>（1） audio：音频</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;audio <span class="hljs-attribute">src</span>=<span class="hljs-string">&#x27;&#x27;</span> controls autoplay <span class="hljs-attribute">loop</span>=<span class="hljs-string">&#x27;true&#x27;</span>&gt;&lt;/audio&gt;<br></code></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>controls 控制面板</li>
<li>autoplay 自动播放</li>
<li>loop&#x3D;‘true’ 循环播放</li>
</ul>
<p>（2）video视频</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">video</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&#x27;&#x27;</span> <span class="hljs-attr">poster</span>=<span class="hljs-string">&#x27;imgs/aa.jpg&#x27;</span> <span class="hljs-attr">controls</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">video</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>属性：</p>
<ul>
<li>poster：指定视频还没有完全下载完毕，或者用户还没有点击播放前显示的封面。默认显示当前视频文件的第一针画面，当然通过poster也可以自己指定。</li>
<li>controls 控制面板</li>
<li>width</li>
<li>height</li>
</ul>
<p>（3）source标签</p>
<p>因为浏览器对视频格式支持程度不一样，为了能够兼容不同的浏览器，可以通过source来指定视频源。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">&lt;video&gt;<br>    &lt;<span class="hljs-built_in">source</span> src=<span class="hljs-string">&#x27;aa.flv&#x27;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;video/flv&#x27;</span>&gt;&lt;/source&gt;<br>    &lt;<span class="hljs-built_in">source</span> src=<span class="hljs-string">&#x27;aa.mp4&#x27;</span> <span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;video/mp4&#x27;</span>&gt;&lt;/source&gt;<br>&lt;/video&gt;<br></code></pre></td></tr></table></figure>

<h4 id="3-表单"><a href="#3-表单" class="headerlink" title="3. 表单"></a>3. 表单</h4><p><strong>表单类型：</strong></p>
<ul>
<li>email ：能够验证当前输入的邮箱地址是否合法</li>
<li>url ： 验证URL</li>
<li>number ： 只能输入数字，其他输入不了，而且自带上下增大减小箭头，max属性可以设置为最大值，min可以设置为最小值，value为默认值。</li>
<li>search ： 输入框后面会给提供一个小叉，可以删除输入的内容，更加人性化。</li>
<li>range ： 可以提供给一个范围，其中可以设置max和min以及value，其中value属性可以设置为默认值</li>
<li>color ： 提供了一个颜色拾取器</li>
<li>time ： 时分秒</li>
<li>data ： 日期选择年月日</li>
<li>datatime ： 时间和日期(目前只有Safari支持)</li>
<li>datatime-local ：日期时间控件</li>
<li>week ：周控件</li>
<li>month：月控件</li>
</ul>
<p><strong>表单属性：</strong></p>
<ul>
<li><p>placeholder ：提示信息</p>
</li>
<li><p>autofocus ：自动获取焦点</p>
</li>
<li><p>autocomplete&#x3D;“on” 或者 autocomplete&#x3D;“off” 使用这个属性需要有两个前提：</p>
</li>
<li><ul>
<li>表单必须提交过</li>
<li>必须有name属性。</li>
</ul>
</li>
<li><p>required：要求输入框不能为空，必须有值才能够提交。</p>
</li>
<li><p>pattern&#x3D;” “ 里面写入想要的正则模式，例如手机号patte&#x3D;”^(+86)?\d{10}$”</p>
</li>
<li><p>multiple：可以选择多个文件或者多个邮箱</p>
</li>
<li><p>form&#x3D;” form表单的ID”</p>
</li>
</ul>
<p><strong>表单事件：</strong></p>
<ul>
<li>oninput 每当input里的输入框内容发生变化都会触发此事件。</li>
<li>oninvalid 当验证不通过时触发此事件。</li>
</ul>
<h4 id="4-进度条、度量器"><a href="#4-进度条、度量器" class="headerlink" title="4. 进度条、度量器"></a>4. 进度条、度量器</h4><ul>
<li><p>progress标签：用来表示任务的进度（IE、Safari不支持），max用来表示任务的进度，value表示已完成多少</p>
</li>
<li><p>meter属性：用来显示剩余容量或剩余库存（IE、Safari不支持）</p>
</li>
<li><ul>
<li>high&#x2F;low：规定被视作高&#x2F;低的范围</li>
<li>max&#x2F;min：规定最大&#x2F;小值</li>
<li>value：规定当前度量值</li>
</ul>
</li>
</ul>
<p>设置规则：min &lt; low &lt; high &lt; max</p>
<h4 id="5-DOM查询操作"><a href="#5-DOM查询操作" class="headerlink" title="5.DOM查询操作"></a>5.DOM查询操作</h4><ul>
<li>document.querySelector()</li>
<li>document.querySelectorAll()</li>
</ul>
<p>它们选择的对象可以是标签，可以是类(需要加点)，可以是ID(需要加#)</p>
<h4 id="6-Web存储"><a href="#6-Web存储" class="headerlink" title="6. Web存储"></a>6. Web存储</h4><p>HTML5 提供了两种在客户端存储数据的新方法：</p>
<ul>
<li>localStorage - 没有时间限制的数据存储</li>
<li>sessionStorage - 针对一个 session 的数据存储</li>
</ul>
<h4 id="7-其他"><a href="#7-其他" class="headerlink" title="7. 其他"></a>7. 其他</h4><ul>
<li>拖放：拖放是一种常见的特性，即抓取对象以后拖到另一个位置。设置元素可拖放：</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;img draggable<span class="hljs-operator">=</span><span class="hljs-string">&quot;true&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>画布（canvas ）： canvas 元素使用 JavaScript 在网页上绘制图像。画布是一个矩形区域，可以控制其每一像素。canvas 拥有多种绘制路径、矩形、圆形、字符以及添加图像的方法。</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;canvas <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;myCanvas&quot;</span> <span class="hljs-attribute">width</span>=<span class="hljs-string">&quot;200&quot;</span> <span class="hljs-attribute">height</span>=<span class="hljs-string">&quot;100&quot;</span>&gt;&lt;/canvas&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>SVG：SVG 指可伸缩矢量图形，用于定义用于网络的基于矢量的图形，使用 XML 格式定义图形，图像在放大或改变尺寸的情况下其图形质量不会有损失，它是万维网联盟的标准</li>
<li>地理定位：Geolocation（地理定位）用于定位用户的位置。‘</li>
</ul>
<p><strong>总结：</strong></p>
<p>（1）新增语义化标签：nav、header、footer、aside、section、article</p>
<p>（2）音频、视频标签：audio、video</p>
<p>（3）数据存储：localStorage、sessionStorage</p>
<p>（4）canvas（画布）、Geolocation（地理定位）、websocket（通信协议）</p>
<p>（5）input标签新增属性：placeholder、autocomplete、autofocus、required</p>
<p>（6）history API：go、forward、back、pushstate</p>
<p><strong>移除的元素有：</strong></p>
<ul>
<li>纯表现的元素：basefont，big，center，font, s，strike，tt，u;</li>
<li>对可用性产生负面影响的元素：frame，frameset，noframes；</li>
</ul>
<h3 id="7-img的srcset属性的作⽤？"><a href="#7-img的srcset属性的作⽤？" class="headerlink" title="7. img的srcset属性的作⽤？"></a>7. img的srcset属性的作⽤？</h3><p>响应式页面中经常用到根据屏幕密度设置不同的图片。这时就用到了 img 标签的srcset属性。srcset属性用于设置不同屏幕密度下，img 会自动加载不同的图片。用法如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;image-128.png&quot;</span> srcset<span class="hljs-operator">=</span><span class="hljs-string">&quot;image-256.png 2x&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<p>使用上面的代码，就能实现在屏幕密度为1x的情况下加载image-128.png, 屏幕密度为2x时加载image-256.png。</p>
<p>按照上面的实现，不同的屏幕密度都要设置图片地址，目前的屏幕密度有1x,2x,3x,4x四种，如果每一个图片都设置4张图片，加载就会很慢。所以就有了新的srcset标准。代码如下：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">&lt;img src<span class="hljs-operator">=</span><span class="hljs-string">&quot;image-128.png&quot;</span><br>     srcset<span class="hljs-operator">=</span><span class="hljs-string">&quot;image-128.png 128w, image-256.png 256w, image-512.png 512w&quot;</span><br>     sizes<span class="hljs-operator">=</span><span class="hljs-string">&quot;(max-width: 360px) 340px, 128px&quot;</span> /&gt;<br></code></pre></td></tr></table></figure>

<p>其中srcset指定图片的地址和对应的图片质量。sizes用来设置图片的尺寸零界点。对于 srcset 中的 w 单位，可以理解成图片质量。如果可视区域小于这个质量的值，就可以使用。浏览器会自动选择一个最小的可用图片。</p>
<p>sizes语法如下：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">sizes=<span class="hljs-string">&quot;<span class="hljs-subst">[media query]</span> <span class="hljs-subst">[length]</span>, <span class="hljs-subst">[media query]</span> <span class="hljs-subst">[length]</span> ... &quot;</span><br></code></pre></td></tr></table></figure>

<p>sizes就是指默认显示128px, 如果视区宽度大于360px, 则显示340px。</p>
<h3 id="8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？"><a href="#8-行内元素有哪些？块级元素有哪些？-空-void-元素有那些？" class="headerlink" title="8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？"></a>8.  行内元素有哪些？块级元素有哪些？ 空(void)元素有那些？</h3><ul>
<li>行内元素有：<code>a b span img input select strong</code>；</li>
<li>块级元素有：<code>div ul ol li dl dt dd h1 h2 h3 h4 h5 h6 p</code>；</li>
</ul>
<p>空元素，即没有内容的HTML元素。空元素是在开始标签中关闭的，也就是空元素没有闭合标签：</p>
<ul>
<li>常见的有：<code>&lt;br&gt;</code>、<code>&lt;hr&gt;</code>、<code>&lt;img&gt;</code>、<code>&lt;input&gt;</code>、<code>&lt;link&gt;</code>、<code>&lt;meta&gt;</code>；</li>
<li>鲜见的有：<code>&lt;area&gt;</code>、<code>&lt;base&gt;</code>、<code>&lt;col&gt;</code>、<code>&lt;colgroup&gt;</code>、<code>&lt;command&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;keygen&gt;</code>、<code>&lt;param&gt;</code>、<code>&lt;source&gt;</code>、<code>&lt;track&gt;</code>、<code>&lt;wbr&gt;</code>。</li>
</ul>
<h3 id="9-说一下-web-worker"><a href="#9-说一下-web-worker" class="headerlink" title="9. 说一下 web worker"></a>9. 说一下 web worker</h3><p>在 HTML 页面中，如果在执行脚本时，页面的状态是不可响应的，直到脚本执行完成后，页面才变成可响应。web worker 是运行在后台的 js，独立于其他脚本，不会影响页面的性能。 并且通过 postMessage 将结果回传到主线程。这样在进行复杂操作的时候，就不会阻塞主线程了。 </p>
<p>如何创建 web worker： </p>
<ol>
<li>检测浏览器对于 web worker 的支持性 </li>
<li>创建 web worker 文件（js，回传函数等） </li>
<li>创建 web worker 对象</li>
</ol>
<h3 id="10-HTML5的离线储存怎么使用，它的工作原理是什么"><a href="#10-HTML5的离线储存怎么使用，它的工作原理是什么" class="headerlink" title="10. HTML5的离线储存怎么使用，它的工作原理是什么"></a>10. HTML5的离线储存怎么使用，它的工作原理是什么</h3><p>离线存储指的是：在用户没有与因特网连接时，可以正常访问站点或应用，在用户与因特网连接时，更新用户机器上的缓存文件。</p>
<p><strong>原理：</strong>HTML5的离线存储是基于一个新建的 <code>.appcache</code> 文件的缓存机制(不是存储技术)，通过这个文件上的解析清单离线存储资源，这些资源就会像cookie一样被存储了下来。之后当网络在处于离线状态下时，浏览器会通过被离线存储的数据进行页面展示</p>
<p><strong>使用方法：</strong></p>
<p>（1）创建一个和 html 同名的 manifest 文件，然后在页面头部加入 manifest 属性：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;html <span class="hljs-attribute">lang</span>=<span class="hljs-string">&quot;en&quot;</span> <span class="hljs-attribute">manifest</span>=<span class="hljs-string">&quot;index.manifest&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>（2）在 <code>cache.manifest</code> 文件中编写需要离线存储的资源：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">CACHE MANIFEST<br>    <span class="hljs-comment">#v0.11</span><br>    CACHE:<br>    js/app.js<br>    css/style.css<br>    NETWORK:<br>    resourse/logo.png<br>    FALLBACK:<br>    / /offline.html<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>CACHE</strong>: 表示需要离线存储的资源列表，由于包含 manifest 文件的页面将被自动离线存储，所以不需要把页面自身也列出来。</li>
<li><strong>NETWORK</strong>: 表示在它下面列出来的资源只有在在线的情况下才能访问，他们不会被离线存储，所以在离线情况下无法使用这些资源。不过，如果在 CACHE 和 NETWORK 中有一个相同的资源，那么这个资源还是会被离线存储，也就是说 CACHE 的优先级更高。</li>
<li><strong>FALLBACK</strong>: 表示如果访问第一个资源失败，那么就使用第二个资源来替换他，比如上面这个文件表示的就是如果访问根目录下任何一个资源失败了，那么就去访问 offline.html 。</li>
</ul>
<p>（3）在离线状态时，操作 <code>window.applicationCache</code> 进行离线缓存的操作。</p>
<p><strong>如何更新缓存：</strong></p>
<p> （1）更新 manifest 文件</p>
<p> （2）通过 javascript 操作</p>
<p> （3）清除浏览器缓存</p>
<p><strong>注意事项：</strong></p>
<p> （1）浏览器对缓存数据的容量限制可能不太一样（某些浏览器设置的限制是每个站点 5MB）。</p>
<p> （2）如果 manifest 文件，或者内部列举的某一个文件不能正常下载，整个更新过程都将失败，浏览器继续全部使用老的缓存。</p>
<p> （3）引用 manifest 的 html 必须与 manifest 文件同源，在同一个域下。</p>
<p> （4）FALLBACK 中的资源必须和 manifest 文件同源。</p>
<p> （5）当一个资源被缓存后，该浏览器直接请求这个绝对路径也会访问缓存中的资源。</p>
<p> （6）站点中的其他页面即使没有设置 manifest 属性，请求的资源如果在缓存中也从缓存中访问。</p>
<p> （7）当 manifest 文件发生改变时，资源请求本身也会触发更新。</p>
<h3 id="11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？"><a href="#11-浏览器是如何对-HTML5-的离线储存资源进行管理和加载？" class="headerlink" title="11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？"></a>11. 浏览器是如何对 HTML5 的离线储存资源进行管理和加载？</h3><ul>
<li><strong>在线的情况下</strong>，浏览器发现 html 头部有 manifest 属性，它会请求 manifest 文件，如果是第一次访问页面 ，那么浏览器就会根据 manifest 文件的内容下载相应的资源并且进行离线存储。如果已经访问过页面并且资源已经进行离线存储了，那么浏览器就会使用离线的资源加载页面，然后浏览器会对比新的 manifest 文件与旧的 manifest 文件，如果文件没有发生改变，就不做任何操作，如果文件改变了，就会重新下载文件中的资源并进行离线存储。</li>
<li><strong>离线的情况下</strong>，浏览器会直接使用离线存储的资源。</li>
</ul>
<h3 id="12-title与h1的区别、b与strong的区别、i与em的区别？"><a href="#12-title与h1的区别、b与strong的区别、i与em的区别？" class="headerlink" title="12. title与h1的区别、b与strong的区别、i与em的区别？"></a>12. title与h1的区别、b与strong的区别、i与em的区别？</h3><ul>
<li>strong标签有语义，是起到加重语气的效果，而b标签是没有的，b标签只是一个简单加粗标签。b标签之间的字符都设为粗体，strong标签加强字符的语气都是通过粗体来实现的，而搜索引擎更侧重strong标签。</li>
<li>title属性没有明确意义只表示是个标题，H1则表示层次明确的标题，对页面信息的抓取有很大的影响</li>
<li><strong>i内容展示为斜体，em表示强调的文本</strong></li>
</ul>
<h3 id="13-iframe-有那些优点和缺点？"><a href="#13-iframe-有那些优点和缺点？" class="headerlink" title="13. iframe 有那些优点和缺点？"></a>13. <strong>iframe 有那些优点和缺点？</strong></h3><p>iframe 元素会创建包含另外一个文档的内联框架（即行内框架）。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用来加载速度较慢的内容（如广告）</li>
<li>可以使脚本可以并行下载</li>
<li>可以实现跨子域通信</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>iframe 会阻塞主页面的 onload 事件</li>
<li>无法被一些搜索引擎索识别</li>
<li>会产生很多页面，不容易管理</li>
</ul>
<h3 id="14-label-的作用是什么？如何使用？"><a href="#14-label-的作用是什么？如何使用？" class="headerlink" title="14. label 的作用是什么？如何使用？"></a>14. label 的作用是什么？如何使用？</h3><p>label标签来定义表单控件的关系：当用户选择label标签时，浏览器会自动将焦点转到和label标签相关的表单控件上。</p>
<ul>
<li>使用方法1：</li>
</ul>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;label <span class="hljs-attribute">for</span>=<span class="hljs-string">&quot;mobile&quot;</span>&gt;Number:&lt;/label&gt;<br>&lt;input <span class="hljs-attribute">type</span>=<span class="hljs-string">&quot;text&quot;</span> <span class="hljs-attribute">id</span>=<span class="hljs-string">&quot;mobile&quot;</span>/&gt;<br></code></pre></td></tr></table></figure>

<ul>
<li>使用方法2：</li>
</ul>
<figure class="highlight stata"><table><tr><td class="code"><pre><code class="hljs stata">&lt;<span class="hljs-keyword">label</span>&gt;Date:&lt;<span class="hljs-keyword">input</span> <span class="hljs-keyword">type</span>=<span class="hljs-string">&quot;text&quot;</span>/&gt;&lt;/<span class="hljs-keyword">label</span>&gt;<br></code></pre></td></tr></table></figure>

<h3 id="15-Canvas和SVG的区别"><a href="#15-Canvas和SVG的区别" class="headerlink" title="15. Canvas和SVG的区别"></a>15. Canvas和SVG的区别</h3><p><strong>（1）SVG：</strong></p>
<p>SVG可缩放矢量图形（Scalable Vector Graphics）是基于可扩展标记语言XML描述的2D图形的语言，SVG基于XML就意味着SVG DOM中的每个元素都是可用的，可以为某个元素附加Javascript事件处理器。在 SVG 中，每个被绘制的图形均被视为对象。如果 SVG 对象的属性发生变化，那么浏览器能够自动重现图形。</p>
<p>其特点如下：</p>
<ul>
<li>不依赖分辨率</li>
<li>支持事件处理器</li>
<li>最适合带有大型渲染区域的应用程序（比如谷歌地图）</li>
<li>复杂度高会减慢渲染速度（任何过度使用 DOM 的应用都不快）</li>
<li>不适合游戏应用</li>
</ul>
<p><strong>（2）Canvas：</strong></p>
<p>Canvas是画布，通过Javascript来绘制2D图形，是逐像素进行渲染的。其位置发生改变，就会重新进行绘制。</p>
<p>其特点如下：</p>
<ul>
<li>依赖分辨率</li>
<li>不支持事件处理器</li>
<li>弱的文本渲染能力</li>
<li>能够以 .png 或 .jpg 格式保存结果图像</li>
<li>最适合图像密集型的游戏，其中的许多对象会被频繁重绘</li>
</ul>
<p>注：矢量图，也称为面向对象的图像或绘图图像，在数学上定义为一系列由线连接的点。矢量文件中的图形元素称为对象。每个对象都是一个自成一体的实体，它具有颜色、形状、轮廓、大小和屏幕位置等属性。</p>
<h3 id="16-head-标签有什么作用，其中什么标签必不可少？"><a href="#16-head-标签有什么作用，其中什么标签必不可少？" class="headerlink" title="16. head 标签有什么作用，其中什么标签必不可少？"></a>16. head 标签有什么作用，其中什么标签必不可少？</h3><head> 标签用于定义文档的头部，它是所有头部元素的容器。<head> 中的元素可以引用脚本、指示浏览器在哪里找到样式表、提供元信息等。



<p>文档的头部描述了文档的各种属性和信息，包括文档的标题、在 Web 中的位置以及和其他文档的关系等。绝大多数文档头部包含的数据都不会真正作为内容显示给读者。</p>
<p>下面这些标签可用在 head 部分：<base>, <link>, <meta>, <script>, <style>, <title>。 </p>
<p>其中 <title> 定义文档的标题，它是 head 部分中唯一必需的元素。</p>
<h3 id="17-文档声明（Doctype）和有何作用-严格模式与混杂模式如何区分？它们有何意义"><a href="#17-文档声明（Doctype）和有何作用-严格模式与混杂模式如何区分？它们有何意义" class="headerlink" title="17. 文档声明（Doctype）和有何作用? 严格模式与混杂模式如何区分？它们有何意义?"></a>17. 文档声明（Doctype）和<!Doctype html>有何作用? 严格模式与混杂模式如何区分？它们有何意义?</h3><p><strong>文档声明的作用：</strong>文档声明是为了告诉浏览器，当前<code>HTML</code>文档使用什么版本的<code>HTML</code>来写的，这样浏览器才能按照声明的版本来正确的解析。</p>
<p><strong><!Doctype html>的作用：</strong><code>&lt;!doctype html&gt;</code> 的作用就是让浏览器进入标准模式，使用最新的 <code>HTML5</code> 标准来解析渲染页面；如果不写，浏览器就会进入混杂模式，我们需要避免此类情况发生。</p>
<p><strong>严格模式与混杂模式的区分：</strong></p>
<ul>
<li><strong>严格模式</strong>： 又称为标准模式，指浏览器按照<code>W3C</code>标准解析代码；</li>
<li><strong>混杂模式</strong>： 又称怪异模式、兼容模式，是指浏览器用自己的方式解析代码。混杂模式通常模拟老式浏览器的行为，以防止老站点无法工作；</li>
</ul>
<p><strong>区分</strong>：网页中的<code>DTD</code>，直接影响到使用的是严格模式还是浏览模式，可以说<code>DTD</code>的使用与这两种方式的区别息息相关。</p>
<ul>
<li>如果文档包含严格的<code>DOCTYPE</code> ，那么它一般以严格模式呈现（<strong>严格 DTD ——严格模式</strong>）；</li>
<li>包含过渡 <code>DTD</code> 和 <code>URI</code> 的 <code>DOCTYPE</code> ，也以严格模式呈现，但有过渡 <code>DTD</code> 而没有 <code>URI</code> （统一资源标识符，就是声明最后的地址）会导致页面以混杂模式呈现（<strong>有 URI 的过渡 DTD ——严格模式；没有 URI 的过渡 DTD ——混杂模式</strong>）；</li>
<li><code>DOCTYPE</code> 不存在或形式不正确会导致文档以混杂模式呈现（<strong>DTD不存在或者格式不正确——混杂模式</strong>）；</li>
<li><code>HTML5</code> 没有 <code>DTD</code> ，因此也就没有严格模式与混杂模式的区别，<code>HTML5</code> 有相对宽松的 法，实现时，已经尽可能大的实现了向后兼容(<strong>HTML5 没有严格和混杂之分</strong>)。</li>
</ul>
<p>总之，<strong>严格模式让各个浏览器统一执行一套规范兼容模式保证了旧网站的正常运行。</strong></p>
<h3 id="18-浏览器乱码的原因是什么？如何解决？"><a href="#18-浏览器乱码的原因是什么？如何解决？" class="headerlink" title="18. 浏览器乱码的原因是什么？如何解决？"></a>18. 浏览器乱码的原因是什么？如何解决？</h3><p><strong>产生乱码的原因：</strong></p>
<ul>
<li>网页源代码是<code>gbk</code>的编码，而内容中的中文字是<code>utf-8</code>编码的，这样浏览器打开即会出现<code>html</code>乱码，反之也会出现乱码；</li>
<li><code>html</code>网页编码是<code>gbk</code>，而程序从数据库中调出呈现是<code>utf-8</code>编码的内容也会造成编码乱码；</li>
<li>浏览器不能自动检测网页编码，造成网页乱码。</li>
</ul>
<p><strong>解决办法：</strong></p>
<ul>
<li>使用软件编辑HTML网页内容；</li>
<li>如果网页设置编码是<code>gbk</code>，而数据库储存数据编码格式是<code>UTF-8</code>，此时需要程序查询数据库数据显示数据前进程序转码；</li>
<li>如果浏览器浏览时候出现网页乱码，在浏览器中找到转换编码的菜单进行转换。</li>
</ul>
<h3 id="19-渐进增强和优雅降级之间的区别"><a href="#19-渐进增强和优雅降级之间的区别" class="headerlink" title="19. 渐进增强和优雅降级之间的区别"></a>19. 渐进增强和优雅降级之间的区别</h3><p><strong>（1）渐进增强（progressive enhancement）</strong>：主要是针对低版本的浏览器进行页面重构，保证基本的功能情况下，再针对高级浏览器进行效果、交互等方面的改进和追加功能，以达到更好的用户体验。</p>
<p><strong>（2）优雅降级 graceful degradation</strong>： 一开始就构建完整的功能，然后再针对低版本的浏览器进行兼容。</p>
<p><strong>两者区别：</strong></p>
<ul>
<li>优雅降级是从复杂的现状开始的，并试图减少用户体验的供给；而渐进增强是从一个非常基础的，能够起作用的版本开始的，并在此基础上不断扩充，以适应未来环境的需要；</li>
<li>降级（功能衰竭）意味着往回看，而渐进增强则意味着往前看，同时保证其根基处于安全地带。</li>
</ul>
<p>“优雅降级”观点认为应该针对那些最高级、最完善的浏览器来设计网站。而将那些被认为“过时”或有功能缺失的浏览器下的测试工作安排在开发周期的最后阶段，并把测试对象限定为主流浏览器（如 IE、Mozilla 等）的前一个版本。 在这种设计范例下，旧版的浏览器被认为仅能提供“简陋却无妨 (poor, but passable)” 的浏览体验。可以做一些小的调整来适应某个特定的浏览器。但由于它们并非我们所关注的焦点，因此除了修复较大的错误之外，其它的差异将被直接忽略。 </p>
<p>“渐进增强”观点则认为应关注于内容本身。内容是建立网站的诱因，有的网站展示它，有的则收集它，有的寻求，有的操作，还有的网站甚至会包含以上的种种，但相同点是它们全都涉及到内容。这使得“渐进增强”成为一种更为合理的设计范例。这也是它立即被 Yahoo 所采纳并用以构建其“分级式浏览器支持 (Graded Browser Support)”策略的原因所在。 </p>
<h3 id="20-说一下-HTML5-drag-API"><a href="#20-说一下-HTML5-drag-API" class="headerlink" title="20. 说一下 HTML5 drag API"></a>20. 说一下 HTML5 drag API</h3><ul>
<li>dragstart：事件主体是被拖放元素，在开始拖放被拖放元素时触发。 </li>
<li>darg：事件主体是被拖放元素，在正在拖放被拖放元素时触发。 </li>
<li>dragenter：事件主体是目标元素，在被拖放元素进入某元素时触发。 </li>
<li>dragover：事件主体是目标元素，在被拖放在某元素内移动时触发。 </li>
<li>dragleave：事件主体是目标元素，在被拖放元素移出目标元素是触发。 </li>
<li>drop：事件主体是目标元素，在目标元素完全接受被拖放元素时触发。 </li>
<li>dragend：事件主体是被拖放元素，在整个拖放操作结束时触发。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器原理</title>
    <url>/2022/08/22/Browser%20Principle/</url>
    <content><![CDATA[<h2 id="浏览器原理"><a href="#浏览器原理" class="headerlink" title="浏览器原理"></a>浏览器原理</h2><span id="more"></span>

<p><img  src="/images/image/browser.png"  ><span class="image-caption">浏览器原理面试题.png</span></p>
<h2 id="一、浏览器安全"><a href="#一、浏览器安全" class="headerlink" title="一、浏览器安全"></a>一、浏览器安全</h2><h3 id="1-什么是-XSS-攻击？"><a href="#1-什么是-XSS-攻击？" class="headerlink" title="1.  什么是 XSS 攻击？"></a>1.  什么是 XSS 攻击？</h3><h4 id="（1）概念"><a href="#（1）概念" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>XSS 攻击指的是跨站脚本攻击，是一种代码注入攻击。攻击者通过在网站注入恶意脚本，使之在用户的浏览器上运行，从而盗取用户的信息如 cookie 等。</p>
<p>XSS 的本质是因为网站没有对恶意代码进行过滤，与正常的代码混合在一起了，浏览器没有办法分辨哪些脚本是可信的，从而导致了恶意代码的执行。</p>
<p>攻击者可以通过这种攻击方式可以进行以下操作：</p>
<ul>
<li>获取页面的数据，如DOM、cookie、localStorage；</li>
<li>DOS攻击，发送合理请求，占用服务器资源，从而使用户无法访问服务器；</li>
<li>破坏页面结构；</li>
<li>流量劫持（将链接指向某网站）；</li>
</ul>
<h4 id="（2）攻击类型"><a href="#（2）攻击类型" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>XSS 可以分为存储型、反射型和 DOM 型：</p>
<ul>
<li>存储型指的是恶意脚本会存储在目标服务器上，当浏览器请求数据时，脚本从服务器传回并执行。</li>
<li>反射型指的是攻击者诱导用户访问一个带有恶意代码的 URL 后，服务器端接收数据后处理，然后把带有恶意代码的数据发送到浏览器端，浏览器端解析这段带有 XSS 代码的数据后当做脚本执行，最终完成 XSS 攻击。 </li>
<li>DOM 型指的通过修改页面的 DOM 节点形成的 XSS。</li>
</ul>
<p><strong>1）存储型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong> </p>
<ol>
<li>攻击者将恶意代码提交到⽬标⽹站的数据库中。 </li>
<li>⽤户打开⽬标⽹站时，⽹站服务端将恶意代码从数据库取出，拼接在 HTML 中返回给浏览器。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>这种攻击常⻅于带有⽤户保存数据的⽹站功能，如论坛发帖、商品评论、⽤户私信等。</p>
<p><strong>2）反射型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong> </p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li>
<li>⽤户打开带有恶意代码的 URL 时，⽹站服务端将恶意代码从 URL 中取出，拼接在 HTML 中返回给浏览器。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，混在其中的恶意代码也被执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>反射型 XSS 跟存储型 XSS 的区别是：存储型 XSS 的恶意代码存在数据库⾥，反射型 XSS 的恶意代码存在 URL ⾥。 </p>
<p>反射型 XSS 漏洞常⻅于通过 URL 传递参数的功能，如⽹站搜索、跳转等。 由于需要⽤户主动打开恶意的 URL 才能⽣效，攻击者往往会结合多种⼿段诱导⽤户点击。  </p>
<p><strong>3）DOM</strong> <strong>型</strong> <strong>XSS</strong> <strong>的攻击步骤：</strong> </p>
<ol>
<li>攻击者构造出特殊的 URL，其中包含恶意代码。 </li>
<li>⽤户打开带有恶意代码的 URL。 </li>
<li>⽤户浏览器接收到响应后解析执⾏，前端 JavaScript 取出 URL 中的恶意代码并执⾏。 </li>
<li>恶意代码窃取⽤户数据并发送到攻击者的⽹站，或者冒充⽤户的⾏为，调⽤⽬标⽹站接⼝执⾏攻击者指定的操作。</li>
</ol>
<p>DOM 型 XSS 跟前两种 XSS 的区别：DOM 型 XSS 攻击中，取出和执⾏恶意代码由浏览器端完成，属于前端JavaScript ⾃身的安全漏洞，⽽其他两种 XSS 都属于服务端的安全漏洞。 </p>
<h3 id="2-如何防御-XSS-攻击？"><a href="#2-如何防御-XSS-攻击？" class="headerlink" title="2. 如何防御 XSS 攻击？"></a>2. 如何防御 XSS 攻击？</h3><p>可以看到XSS危害如此之大， 那么在开发网站时就要做好防御措施，具体措施如下：</p>
<ul>
<li>可以从浏览器的执行来进行预防，一种是使用纯前端的方式，不用服务器端拼接后返回（不使用服务端渲染）。另一种是对需要插入到 HTML 中的代码做好充分的转义。对于 DOM 型的攻击，主要是前端脚本的不可靠而造成的，对于数据获取渲染和字符串拼接的时候应该对可能出现的恶意代码情况进行判断。</li>
<li>使用 CSP ，CSP 的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行，从而防止恶意代码的注入攻击。</li>
</ul>
<blockquote>
<ol>
<li>CSP 指的是内容安全策略，它的本质是建立一个白名单，告诉浏览器哪些外部资源可以加载和执行。我们只需要配置规则，如何拦截由浏览器自己来实现。</li>
<li>通常有两种方式来开启 CSP，一种是设置 HTTP 首部中的 Content-Security-Policy，一种是设置 meta 标签的方式 <meta http-equiv="Content-Security-Policy"></li>
</ol>
</blockquote>
<ul>
<li>对一些敏感信息进行保护，比如 cookie 使用 http-only，使得脚本无法获取。也可以使用验证码，避免脚本伪装成用户执行一些操作。</li>
</ul>
<h3 id="3-什么是-CSRF-攻击？"><a href="#3-什么是-CSRF-攻击？" class="headerlink" title="3. 什么是 CSRF 攻击？"></a>3. 什么是 CSRF 攻击？</h3><h4 id="（1）概念-1"><a href="#（1）概念-1" class="headerlink" title="（1）概念"></a>（1）概念</h4><p>CSRF 攻击指的是<strong>跨站请求伪造攻击</strong>，攻击者诱导用户进入一个第三方网站，然后该网站向被攻击网站发送跨站请求。如果用户在被攻击网站中保存了登录状态，那么攻击者就可以利用这个登录状态，绕过后台的用户验证，冒充用户向服务器执行一些操作。</p>
<p>CSRF 攻击的<strong>本质是****利用 cookie 会在同源请求中携带发送给服务器的特点，以此来实现用户的冒充。</strong></p>
<h4 id="（2）攻击类型-1"><a href="#（2）攻击类型-1" class="headerlink" title="（2）攻击类型"></a>（2）攻击类型</h4><p>常见的 CSRF 攻击有三种：</p>
<ul>
<li>GET 类型的 CSRF 攻击，比如在网站中的一个 img 标签里构建一个请求，当用户打开这个网站的时候就会自动发起提交。</li>
<li>POST 类型的 CSRF 攻击，比如构建一个表单，然后隐藏它，当用户进入页面时，自动提交这个表单。</li>
<li>链接类型的 CSRF 攻击，比如在 a 标签的 href 属性里构建一个请求，然后诱导用户去点击。</li>
</ul>
<h3 id="4-如何防御-CSRF-攻击？"><a href="#4-如何防御-CSRF-攻击？" class="headerlink" title="4. 如何防御 CSRF 攻击？"></a>4. 如何防御 CSRF 攻击？</h3><p><strong>CSRF 攻击可以使用以下方法来防护：</strong></p>
<ul>
<li><strong>进行同源检测</strong>，服务器根据 http 请求头中 origin 或者 referer 信息来判断请求是否为允许访问的站点，从而对请求进行过滤。当 origin 或者 referer 信息都不存在的时候，直接阻止请求。这种方式的缺点是有些情况下 referer 可以被伪造，同时还会把搜索引擎的链接也给屏蔽了。所以一般网站会允许搜索引擎的页面请求，但是相应的页面请求这种请求方式也可能被攻击者给利用。（Referer 字段会告诉服务器该网页是从哪个页面链接过来的）</li>
<li><strong>使用 CSRF Token 进行验证</strong>，服务器向用户返回一个随机数 Token ，当网站再次发起请求时，在请求参数中加入服务器端返回的 token ，然后服务器对这个 token 进行验证。这种方法解决了使用 cookie 单一验证方式时，可能会被冒用的问题，但是这种方法存在一个缺点就是，我们需要给网站中的所有请求都添加上这个 token，操作比较繁琐。还有一个问题是一般不会只有一台网站服务器，如果请求经过负载平衡转移到了其他的服务器，但是这个服务器的 session 中没有保留这个 token 的话，就没有办法验证了。这种情况可以通过改变 token 的构建方式来解决。</li>
<li><strong>对</strong> <strong>Cookie 进行****双重验证</strong>，服务器在用户访问网站页面时，向请求域名注入一个Cookie，内容为随机字符串，然后当用户再次向服务器发送请求的时候，从 cookie 中取出这个字符串，添加到 URL 参数中，然后服务器通过对 cookie 中的数据和参数中的数据进行比较，来进行验证。使用这种方式是利用了攻击者只能利用 cookie，但是不能访问获取 cookie 的特点。并且这种方法比 CSRF Token 的方法更加方便，并且不涉及到分布式访问的问题。这种方法的缺点是如果网站存在 XSS 漏洞的，那么这种方式会失效。同时这种方式不能做到子域名的隔离。</li>
<li><strong>在设置 cookie 属性的时候设置 Samesite ，限制 cookie 不能作为被第三方使用</strong>，从而可以避免被攻击者利用。Samesite 一共有两种模式，一种是严格模式，在严格模式下 cookie 在任何情况下都不可能作为第三方 Cookie 使用，在宽松模式下，cookie 可以被请求是 GET 请求，且会发生页面跳转的请求所使用。</li>
</ul>
<h3 id="5-什么是中间人攻击？如何防范中间人攻击？"><a href="#5-什么是中间人攻击？如何防范中间人攻击？" class="headerlink" title="5. 什么是中间人攻击？如何防范中间人攻击？"></a>5. 什么是中间人攻击？如何防范中间人攻击？</h3><p>中间⼈ (Man-in-the-middle attack, MITM) 是指攻击者与通讯的两端分别创建独⽴的联系, 并交换其所收到的数据, 使通讯的两端认为他们正在通过⼀个私密的连接与对⽅直接对话, 但事实上整个会话都被攻击者完全控制。在中间⼈攻击中，攻击者可以拦截通讯双⽅的通话并插⼊新的内容。</p>
<p>攻击过程如下: </p>
<ul>
<li>客户端发送请求到服务端，请求被中间⼈截获 </li>
<li>服务器向客户端发送公钥 </li>
<li>中间⼈截获公钥，保留在⾃⼰⼿上。然后⾃⼰⽣成⼀个<strong>伪造的</strong>公钥，发给客户端 </li>
<li>客户端收到伪造的公钥后，⽣成加密hash值发给服务器 </li>
<li>中间⼈获得加密hash值，⽤⾃⼰的私钥解密获得真秘钥,同时⽣成假的加密hash值，发给服务器 </li>
<li>服务器⽤私钥解密获得假密钥,然后加密数据传输给客户端</li>
</ul>
<h3 id="6-有哪些可能引起前端安全的问题"><a href="#6-有哪些可能引起前端安全的问题" class="headerlink" title="6. 有哪些可能引起前端安全的问题**?**"></a>6. 有哪些可能引起前端安全的问题**?**</h3><ul>
<li>跨站脚本 (Cross-Site Scripting, XSS): ⼀种代码注⼊⽅式, 为了与 CSS 区分所以被称作 XSS。早期常⻅于⽹络论坛, 起因是⽹站没有对⽤户的输⼊进⾏严格的限制, 使得攻击者可以将脚本上传到帖⼦让其他⼈浏览到有恶意脚本的⻚⾯, 其注⼊⽅式很简单包括但不限于 JavaScript &#x2F; CSS &#x2F; Flash 等； </li>
<li>iframe的滥⽤: iframe中的内容是由第三⽅来提供的，默认情况下他们不受控制，他们可以在iframe中运⾏JavaScirpt脚本、Flash插件、弹出对话框等等，这可能会破坏前端⽤户体验；</li>
<li>跨站点请求伪造（Cross-Site Request Forgeries，CSRF）: 指攻击者通过设置好的陷阱，强制对已完成认证的⽤户进⾏⾮预期的个⼈信息或设定信息等某些状态更新，属于被动攻击 </li>
<li>恶意第三⽅库: ⽆论是后端服务器应⽤还是前端应⽤开发，绝⼤多数时候都是在借助开发框架和各种类库进⾏快速开发，⼀旦第三⽅库被植⼊恶意代码很容易引起安全问题。</li>
</ul>
<h3 id="7-网络劫持有哪几种，如何防范？"><a href="#7-网络劫持有哪几种，如何防范？" class="headerlink" title="7. 网络劫持有哪几种，如何防范？"></a>7. 网络劫持有哪几种，如何防范？</h3><p>⽹络劫持分为两种: </p>
<p>（1）<strong>DNS****劫持</strong>: (输⼊京东被强制跳转到淘宝这就属于dns劫持) </p>
<ul>
<li>DNS强制解析: 通过修改运营商的本地DNS记录，来引导⽤户流量到缓存服务器</li>
<li>302跳转的⽅式: 通过监控⽹络出⼝的流量，分析判断哪些内容是可以进⾏劫持处理的,再对劫持的内存发起302跳转的回复，引导⽤户获取内容</li>
</ul>
<p>（2）<strong>HTTP****劫持</strong>: (访问⾕歌但是⼀直有贪玩蓝⽉的⼴告),由于http明⽂传输,运营商会修改你的http响应内容(即加⼴告) </p>
<p>DNS劫持由于涉嫌违法，已经被监管起来，现在很少会有DNS劫持，⽽http劫持依然⾮常盛⾏，最有效的办法就是全站HTTPS，将HTTP加密，这使得运营商⽆法获取明⽂，就⽆法劫持你的响应内容。 </p>
<h2 id="二、进程与线程"><a href="#二、进程与线程" class="headerlink" title="二、进程与线程"></a>二、进程与线程</h2><h3 id="1-进程与线程的概念"><a href="#1-进程与线程的概念" class="headerlink" title="1. 进程与线程的概念"></a>1. 进程与线程的概念</h3><p>从本质上说，进程和线程都是 CPU 工作时间片的一个描述：</p>
<ul>
<li>进程描述了 CPU 在运行指令及加载和保存上下文所需的时间，放在应用上来说就代表了一个程序。</li>
<li>线程是进程中的更小单位，描述了执行一段指令所需的时间。</li>
</ul>
<p><strong>进程是资源分配的最小单位，线程是CPU调度的最小单位。</strong></p>
<p>一个进程就是一个程序的运行实例。详细解释就是，启动一个程序的时候，操作系统会为该程序创建一块内存，用来存放代码、运行中的数据和一个执行任务的主线程，我们把这样的一个运行环境叫<strong>进程</strong>。<strong>进程是运行在虚拟内存上的，虚拟内存是用来解决用户对硬件资源的无限需求和有限的硬件资源之间的矛盾的。从操作系统角度来看，虚拟内存即交换文件；从处理器角度看，虚拟内存即虚拟地址空间。</strong></p>
<p>如果程序很多时，内存可能会不够，操作系统为每个进程提供一套独立的虚拟地址空间，从而使得同一块物理内存在不同的进程中可以对应到不同或相同的虚拟地址，变相的增加了程序可以使用的内存。</p>
<p>进程和线程之间的关系有以下四个特点：</p>
<p><strong>（1）进程中的任意一线程执行出错，都会导致整个进程的崩溃。</strong></p>
<p><strong>（2）线程之间共享进程中的数据。</strong></p>
<p><strong>（3）当一个进程关闭之后，操作系统会回收进程所占用的内存，</strong>当一个进程退出时，操作系统会回收该进程所申请的所有资源；即使其中任意线程因为操作不当导致内存泄漏，当进程退出时，这些内存也会被正确回收。</p>
<p><strong>（4）进程之间的内容相互隔离。</strong>进程隔离就是为了使操作系统中的进程互不干扰，每一个进程只能访问自己占有的数据，也就避免出现进程 A 写入数据到进程 B 的情况。正是因为进程之间的数据是严格隔离的，所以一个进程如果崩溃了，或者挂起了，是不会影响到其他进程的。如果进程之间需要进行数据的通信，这时候，就需要使用用于进程间通信的机制了。</p>
<p><strong>Chrome浏览器的架构图</strong>：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603803289911-191cabf3-e7e2-4354-a83d-858668cc116f.png"  ><span class="image-caption">image</span></p>
<p>从图中可以看出，最新的 Chrome 浏览器包括：</p>
<ul>
<li>1 个浏览器主进程</li>
<li>1 个 GPU 进程</li>
<li>1 个网络进程</li>
<li>多个渲染进程</li>
<li>多个插件进程</li>
</ul>
<p>这些进程的功能：</p>
<ul>
<li><strong>浏览器进程</strong>：主要负责界面显示、用户交互、子进程管理，同时提供存储等功能。</li>
<li><strong>渲染进程</strong>：核心任务是将 HTML、CSS 和 JavaScript 转换为用户可以与之交互的网页，排版引擎 Blink 和 JavaScript 引擎 V8 都是运行在该进程中，默认情况下，Chrome 会为每个 Tab 标签创建一个渲染进程。出于安全考虑，渲染进程都是运行在沙箱模式下。</li>
<li><strong>GPU 进程</strong>：其实， GPU 的使用初衷是为了实现 3D CSS 的效果，只是随后网页、Chrome 的 UI 界面都选择采用 GPU 来绘制，这使得 GPU 成为浏览器普遍的需求。最后，Chrome 在其多进程架构上也引入了 GPU 进程。</li>
<li><strong>网络进程</strong>：主要负责页面的网络资源加载，之前是作为一个模块运行在浏览器进程里面的，直至最近才独立出来，成为一个单独的进程。</li>
<li><strong>插件进程</strong>：主要是负责插件的运行，因插件易崩溃，所以需要通过插件进程来隔离，以保证插件进程崩溃不会对浏览器和页面造成影响。</li>
</ul>
<p>所以，<strong>打开一个网页，最少需要四个进程</strong>：1 个网络进程、1 个浏览器进程、1 个 GPU 进程以及 1 个渲染进程。如果打开的页面有运行插件的话，还需要再加上 1 个插件进程。</p>
<p>虽然多进程模型提升了浏览器的稳定性、流畅性和安全性，但同样不可避免地带来了一些问题：</p>
<ul>
<li><strong>更高的资源占用</strong>：因为每个进程都会包含公共基础结构的副本（如 JavaScript 运行环境），这就意味着浏览器会消耗更多的内存资源。</li>
<li><strong>更复杂的体系架构</strong>：浏览器各模块之间耦合性高、扩展性差等问题，会导致现在的架构已经很难适应新的需求了。</li>
</ul>
<h3 id="2-进程和线程的区别"><a href="#2-进程和线程的区别" class="headerlink" title="2. 进程和线程的区别"></a>2. 进程和线程的区别</h3><ul>
<li>进程可以看做独立应用，线程不能</li>
<li>资源：进程是cpu资源分配的最小单位（是能拥有资源和独立运行的最小单位）；线程是cpu调度的最小单位（线程是建立在进程的基础上的一次程序运行单位，一个进程中可以有多个线程）。</li>
<li>通信方面：线程间可以通过直接共享同一进程中的资源，而进程通信需要借助 进程间通信。</li>
<li>调度：进程切换比线程切换的开销要大。线程是CPU调度的基本单位，线程的切换不会引起进程切换，但某个进程中的线程切换到另一个进程中的线程时，会引起进程切换。</li>
<li>系统开销：由于创建或撤销进程时，系统都要为之分配或回收资源，如内存、I&#x2F;O 等，其开销远大于创建或撤销线程时的开销。同理，在进行进程切换时，涉及当前执行进程 CPU 环境还有各种各样状态的保存及新调度进程状态的设置，而线程切换时只需保存和设置少量寄存器内容，开销较小。</li>
</ul>
<h3 id="3-浏览器渲染进程的线程有哪些"><a href="#3-浏览器渲染进程的线程有哪些" class="headerlink" title="3. 浏览器渲染进程的线程有哪些"></a>3. 浏览器渲染进程的线程有哪些</h3><p>浏览器的渲染进程的线程总共有五种：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603803289922-6462f252-aa33-4cf6-b541-d8bc2e285125.png"  ><span class="image-caption">image</span></p>
<p><strong>（1）GUI渲染线程</strong></p>
<p>负责渲染浏览器页面，解析HTML、CSS，构建DOM树、构建CSSOM树、构建渲染树和绘制页面；当界面需要<strong>重绘</strong>或由于某种操作引发<strong>回流</strong>时，该线程就会执行。</p>
<p>注意：GUI渲染线程和JS引擎线程是互斥的，当JS引擎执行时GUI线程会被挂起，GUI更新会被保存在一个队列中等到JS引擎空闲时立即被执行。</p>
<p><strong>（2）JS引擎线程</strong></p>
<p>JS引擎线程也称为JS内核，负责处理Javascript脚本程序，解析Javascript脚本，运行代码；JS引擎线程一直等待着任务队列中任务的到来，然后加以处理，一个Tab页中无论什么时候都只有一个JS引擎线程在运行JS程序；</p>
<p>注意：GUI渲染线程与JS引擎线程的互斥关系，所以如果JS执行的时间过长，会造成页面的渲染不连贯，导致页面渲染加载阻塞。</p>
<p><strong>（3）时间触发线程</strong></p>
<p><strong>时间触发线程</strong>属于浏览器而不是JS引擎，用来控制事件循环；当JS引擎执行代码块如setTimeOut时（也可是来自浏览器内核的其他线程,如鼠标点击、AJAX异步请求等），会将对应任务添加到事件触发线程中；当对应的事件符合触发条件被触发时，该线程会把事件添加到待处理队列的队尾，等待JS引擎的处理；</p>
<p>注意：由于JS的单线程关系，所以这些待处理队列中的事件都得排队等待JS引擎处理（当JS引擎空闲时才会去执行）；</p>
<p><strong>（4）定时器触发进程</strong></p>
<p><strong>定时器触发进程</strong>即setInterval与setTimeout所在线程；浏览器定时计数器并不是由JS引擎计数的，因为JS引擎是单线程的，如果处于阻塞线程状态就会影响记计时的准确性；因此使用单独线程来计时并触发定时器，计时完毕后，添加到事件队列中，等待JS引擎空闲后执行，所以定时器中的任务在设定的时间点不一定能够准时执行，定时器只是在指定时间点将任务添加到事件队列中；</p>
<p>注意：W3C在HTML标准中规定，定时器的定时时间不能小于4ms，如果是小于4ms，则默认为4ms。</p>
<p><strong>（5）异步http请求线程</strong></p>
<ul>
<li>XMLHttpRequest连接后通过浏览器新开一个线程请求；</li>
<li>检测到状态变更时，如果设置有回调函数，异步线程就产生状态变更事件，将回调函数放入事件队列中，等待JS引擎空闲后执行；</li>
</ul>
<h3 id="4-进程之前的通信方式"><a href="#4-进程之前的通信方式" class="headerlink" title="4. 进程之前的通信方式"></a>4. 进程之前的通信方式</h3><p><strong>（1）管道通信</strong></p>
<p>管道是一种最基本的进程间通信机制。<strong>管道就是操作系统在内核中开辟的一段缓冲区，进程1可以将需要交互的数据拷贝到这段缓冲区，进程2就可以读取了。</strong></p>
<p>管道的特点：</p>
<ul>
<li>只能单向通信</li>
<li>只能血缘关系的进程进行通信</li>
<li>依赖于文件系统</li>
<li>生命周期随进程</li>
<li>面向字节流的服务</li>
<li>管道内部提供了同步机制</li>
</ul>
<p><strong>（2）消息队列通信</strong></p>
<p>消息队列就是一个消息的列表。用户可以在消息队列中添加消息、读取消息等。消息队列提供了一种从一个进程向另一个进程发送一个数据块的方法。 每个数据块都被认为含有一个类型，接收进程可以独立地接收含有不同类型的数据结构。可以通过发送消息来避免命名管道的同步和阻塞问题。但是消息队列与命名管道一样，每个数据块都有一个最大长度的限制。</p>
<p>使用消息队列进行进程间通信，可能会收到数据块最大长度的限制约束等，这也是这种通信方式的缺点。如果频繁的发生进程间的通信行为，那么进程需要频繁地读取队列中的数据到内存，相当于间接地从一个进程拷贝到另一个进程，这需要花费时间。</p>
<p><strong>（3）信号量通信</strong></p>
<p>共享内存最大的问题就是多进程竞争内存的问题，就像类似于线程安全问题。我们可以使用信号量来解决这个问题。信号量的本质就是一个计数器，用来实现进程之间的互斥与同步。例如信号量的初始值是 1，然后 a 进程来访问内存1的时候，我们就把信号量的值设为 0，然后进程b 也要来访问内存1的时候，看到信号量的值为 0 就知道已经有进程在访问内存1了，这个时候进程 b 就会访问不了内存1。所以说，信号量也是进程之间的一种通信方式。</p>
<p><strong>（4）信号通信</strong></p>
<p>信号（Signals ）是Unix系统中使用的最古老的进程间通信的方法之一。操作系统通过信号来通知进程系统中发生了某种预先规定好的事件（一组事件中的一个），它也是用户进程之间通信和同步的一种原始机制。</p>
<p><strong>（5）共享内存通信</strong></p>
<p>共享内存就是映射一段能被其他进程所访问的内存，这段共享内存由一个进程创建，但多个进程都可以访问（使多个进程可以访问同一块内存空间）。共享内存是最快的 IPC 方式，它是针对其他进程间通信方式运行效率低而专门设计的。它往往与其他通信机制，如信号量，配合使用，来实现进程间的同步和通信。</p>
<p><strong>（6）套接字通信</strong></p>
<p>上面我们说的共享内存、管道、信号量、消息队列，他们都是多个进程在一台主机之间的通信，那两个相隔几千里的进程能够进行通信吗？答是必须的，这个时候 Socket 这家伙就派上用场了，例如我们平时通过浏览器发起一个 http 请求，然后服务器给你返回对应的数据，这种就是采用 Socket 的通信方式了。</p>
<h3 id="5-僵尸进程和孤儿进程是什么？"><a href="#5-僵尸进程和孤儿进程是什么？" class="headerlink" title="5. 僵尸进程和孤儿进程是什么？"></a>5. 僵尸进程和孤儿进程是什么？</h3><ul>
<li><strong>孤儿进程</strong>：父进程退出了，而它的一个或多个进程还在运行，那这些子进程都会成为孤儿进程。孤儿进程将被init进程(进程号为1)所收养，并由init进程对它们完成状态收集工作。</li>
<li><strong>僵尸进程</strong>：子进程比父进程先结束，而父进程又没有释放子进程占用的资源，那么子进程的进程描述符仍然保存在系统中，这种进程称之为僵死进程。</li>
</ul>
<h3 id="6-死锁产生的原因？-如果解决死锁的问题？"><a href="#6-死锁产生的原因？-如果解决死锁的问题？" class="headerlink" title="6. 死锁产生的原因？ 如果解决死锁的问题？"></a>6. 死锁产生的原因？ 如果解决死锁的问题？</h3><p>所谓死锁，是指多个进程在运行过程中因争夺资源而造成的一种僵局，当进程处于这种僵持状态时，若无外力作用，它们都将无法再向前推进。</p>
<p>系统中的资源可以分为两类：</p>
<ul>
<li>可剥夺资源，是指某进程在获得这类资源后，该资源可以再被其他进程或系统剥夺，CPU和主存均属于可剥夺性资源；</li>
<li>不可剥夺资源，当系统把这类资源分配给某进程后，再不能强行收回，只能在进程用完后自行释放，如磁带机、打印机等。</li>
</ul>
<p><strong>产生死锁的原因：</strong></p>
<p><strong>（1）竞争资源</strong></p>
<ul>
<li>产生死锁中的竞争资源之一指的是<strong>竞争不可剥夺资源</strong>（例如：系统中只有一台打印机，可供进程P1使用，假定P1已占用了打印机，若P2继续要求打印机打印将阻塞）</li>
<li>产生死锁中的竞争资源另外一种资源指的是<strong>竞争临时资源</strong>（临时资源包括硬件中断、信号、消息、缓冲区内的消息等），通常消息通信顺序进行不当，则会产生死锁</li>
</ul>
<p><strong>（2）进程间推进顺序非法</strong></p>
<p>若P1保持了资源R1，P2保持了资源R2，系统处于不安全状态，因为这两个进程再向前推进，便可能发生死锁。例如，当P1运行到P1：Request（R2）时，将因R2已被P2占用而阻塞；当P2运行到P2：Request（R1）时，也将因R1已被P1占用而阻塞，于是发生进程死锁</p>
<p><strong>产生死锁的必要条件：</strong></p>
<ul>
<li>互斥条件：进程要求对所分配的资源进行排它性控制，即在一段时间内某资源仅为一进程所占用。</li>
<li>请求和保持条件：当进程因请求资源而阻塞时，对已获得的资源保持不放。</li>
<li>不剥夺条件：进程已获得的资源在未使用完之前，不能剥夺，只能在使用完时由自己释放。</li>
<li>环路等待条件：在发生死锁时，必然存在一个进程——资源的环形链。</li>
</ul>
<p><strong>预防死锁的方法：</strong></p>
<ul>
<li>资源一次性分配：一次性分配所有资源，这样就不会再有请求了（破坏请求条件）</li>
<li>只要有一个资源得不到分配，也不给这个进程分配其他的资源（破坏请保持条件）</li>
<li>可剥夺资源：即当某进程获得了部分资源，但得不到其它资源，则释放已占有的资源（破坏不可剥夺条件）</li>
<li>资源有序分配法：系统给每类资源赋予一个编号，每一个进程按编号递增的顺序请求资源，释放则相反（破坏环路等待条件）</li>
</ul>
<h3 id="7-如何实现浏览器内多个标签页之间的通信"><a href="#7-如何实现浏览器内多个标签页之间的通信" class="headerlink" title="7. 如何实现浏览器内多个标签页之间的通信?"></a>7. 如何实现浏览器内多个标签页之间的通信?</h3><p>实现多个标签页之间的通信，本质上都是通过中介者模式来实现的。因为标签页之间没有办法直接通信，因此我们可以找一个中介者，让标签页和中介者进行通信，然后让这个中介者来进行消息的转发。通信方法如下：</p>
<ul>
<li><strong>使用 websocket 协议</strong>，因为 websocket 协议可以实现服务器推送，所以服务器就可以用来当做这个中介者。标签页通过向服务器发送数据，然后由服务器向其他标签页推送转发。</li>
<li><strong>使用 ShareWorker 的方式</strong>，shareWorker 会在页面存在的生命周期内创建一个唯一的线程，并且开启多个页面也只会使用同一个线程。这个时候共享线程就可以充当中介者的角色。标签页间通过共享一个线程，然后通过这个共享的线程来实现数据的交换。</li>
<li><strong>使****用 localStorage 的方式</strong>，我们可以在一个标签页对 localStorage 的变化事件进行监听，然后当另一个标签页修改数据的时候，我们就可以通过这个监听事件来获取到数据。这个时候 localStorage 对象就是充当的中介者的角色。</li>
<li><strong>使用 postMessage 方法</strong>，如果我们能够获得对应标签页的引用，就可以使用postMessage 方法，进行通信。</li>
</ul>
<h3 id="8-对Service-Worker的理解"><a href="#8-对Service-Worker的理解" class="headerlink" title="8. 对Service Worker的理解"></a>8. 对Service Worker的理解</h3><p>Service Worker 是运行在浏览器背后的<strong>独立线程</strong>，一般可以用来实现缓存功能。使用 Service Worker的话，传输协议必须为 <strong>HTTPS</strong>。因为 Service Worker 中涉及到请求拦截，所以必须使用 HTTPS 协议来保障安全。</p>
<p>Service Worker 实现缓存功能一般分为三个步骤：首先需要先注册 Service Worker，然后监听到 <code>install</code> 事件以后就可以缓存需要的文件，那么在下次用户访问的时候就可以通过拦截请求的方式查询是否存在缓存，存在缓存的话就可以直接读取缓存文件，否则就去请求数据。以下是这个步骤的实现：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">if</span> (navigator.serviceWorker) &#123;<br>  navigator<span class="hljs-selector-class">.serviceWorker</span><br>    <span class="hljs-selector-class">.register</span>(<span class="hljs-string">&#x27;sw.js&#x27;</span>)<br>    <span class="hljs-selector-class">.then</span>(<span class="hljs-built_in">function</span>(registration) &#123;<br>      console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;service worker 注册成功&#x27;</span>)<br>    &#125;)<br>    <span class="hljs-selector-class">.catch</span>(<span class="hljs-built_in">function</span>(err) &#123;<br>      console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;servcie worker 注册失败&#x27;</span>)<br>    &#125;)<br>&#125;<br><span class="hljs-comment">// sw.js</span><br><span class="hljs-comment">// 监听 `install` 事件，回调中缓存所需文件</span><br>self<span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;install&#x27;</span>, e =&gt; &#123;<br>  e<span class="hljs-selector-class">.waitUntil</span>(<br>    caches<span class="hljs-selector-class">.open</span>(<span class="hljs-string">&#x27;my-cache&#x27;</span>)<span class="hljs-selector-class">.then</span>(<span class="hljs-built_in">function</span>(cache) &#123;<br>      return cache<span class="hljs-selector-class">.addAll</span>(<span class="hljs-selector-attr">[<span class="hljs-string">&#x27;./index.html&#x27;</span>, <span class="hljs-string">&#x27;./index.js&#x27;</span>]</span>)<br>    &#125;)<br>  )<br>&#125;)<br><span class="hljs-comment">// 拦截所有请求事件</span><br><span class="hljs-comment">// 如果缓存中已经有请求的数据就直接用缓存，否则去请求数据</span><br>self<span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;fetch&#x27;</span>, e =&gt; &#123;<br>  e<span class="hljs-selector-class">.respondWith</span>(<br>    caches<span class="hljs-selector-class">.match</span>(e.request)<span class="hljs-selector-class">.then</span>(<span class="hljs-built_in">function</span>(response) &#123;<br>      <span class="hljs-keyword">if</span> (response) &#123;<br>        return response<br>      &#125;<br>      console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;fetch source&#x27;</span>)<br>    &#125;)<br>  )<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>打开页面，可以在开发者工具中的 <code>Application</code> 看到 Service Worker 已经启动了：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615478097248-5e3c9a93-5683-41de-8787-e87705d31fe1.png?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image</span></p>
<p>在 Cache 中也可以发现所需的文件已被缓存：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615477994804-e7eaa2c7-91bf-406d-b024-5add76d37d5e.png"  ><span class="image-caption">image</span></p>
<h2 id="三、浏览器缓存"><a href="#三、浏览器缓存" class="headerlink" title="三、浏览器缓存"></a>三、浏览器缓存</h2><h3 id="1-对浏览器的缓存机制的理解"><a href="#1-对浏览器的缓存机制的理解" class="headerlink" title="1. 对浏览器的缓存机制的理解"></a>1. 对浏览器的缓存机制的理解</h3><p><strong>浏览器缓存的全过程：</strong></p>
<ul>
<li>浏览器第一次加载资源，服务器返回 200，浏览器从服务器下载资源文件，并缓存资源文件与 response header，以供下次加载时对比使用；</li>
<li>下一次加载资源时，由于强制缓存优先级较高，先比较当前时间与上一次返回 200 时的时间差，如果没有超过 cache-control 设置的 max-age，则没有过期，并命中强缓存，直接从本地读取资源。如果浏览器不支持HTTP1.1，则使用 expires 头判断是否过期；</li>
<li>如果资源已过期，则表明强制缓存没有被命中，则开始协商缓存，向服务器发送带有 If-None-Match 和 If-Modified-Since 的请求；</li>
<li>服务器收到请求后，优先根据 Etag 的值判断被请求的文件有没有做修改，Etag 值一致则没有修改，命中协商缓存，返回 304；如果不一致则有改动，直接返回新的资源文件带上新的 Etag 值并返回 200；</li>
<li>如果服务器收到的请求没有 Etag 值，则将 If-Modified-Since 和被请求文件的最后修改时间做比对，一致则命中协商缓存，返回 304；不一致则返回新的 last-modified 和文件并返回 200；</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1618399660902-60a33dae-cedc-4bd0-9a5b-160c5da3f516.png"  ><span class="image-caption">业务流程图1.png</span></p>
<p>很多网站的资源后面都加了版本号，这样做的目的是：每次升级了 JS 或 CSS 文件后，为了防止浏览器进行缓存，强制改变版本号，客户端浏览器就会重新下载新的 JS 或 CSS 文件 ，以保证用户能够及时获得网站的最新更新。</p>
<h3 id="2-浏览器资源缓存的位置有哪些？"><a href="#2-浏览器资源缓存的位置有哪些？" class="headerlink" title="2. 浏览器资源缓存的位置有哪些？"></a>2. 浏览器资源缓存的位置有哪些？</h3><p>资源缓存的位置一共有 3 种，按优先级从高到低分别是：</p>
<ol>
<li><strong>Service Worker：</strong>Service Worker 运行在 JavaScript 主线程之外，虽然由于脱离了浏览器窗体无法直接访问 DOM，但是它可以完成离线缓存、消息推送、网络代理等功能。它可以让我们<strong>自由控制</strong>缓存哪些文件、如何匹配缓存、如何读取缓存，并且<strong>缓存是持续性的</strong>。当 Service Worker 没有命中缓存的时候，需要去调用 <code>fetch</code> 函数获取  数据。也就是说，如果没有在 Service Worker 命中缓存，会根据缓存查找优先级去查找数据。<strong>但是不管是从 Memory Cache 中还是从网络请求中获取的数据，浏览器都会显示是从 Service Worker 中获取的内容。</strong></li>
<li><strong>Memory Cache：</strong>Memory Cache 就是内存缓存，它的效率最快，<strong>但是内存缓存虽然读取高效，可是缓存持续性很短，会随着进程的释放而释放。</strong>一旦我们关闭 Tab 页面，内存中的缓存也就被释放了。</li>
<li><strong>Disk Cache：</strong>Disk Cache 也就是存储在硬盘中的缓存，读取速度慢点，但是什么都能存储到磁盘中，比之 Memory Cache <strong>胜在容量和存储时效性上。</strong>在所有浏览器缓存中，Disk Cache 覆盖面基本是最大的。它会根据 HTTP Herder 中的字段判断哪些资源需要缓存，哪些资源可以不请求直接使用，哪些资源已经过期需要重新请求。<strong>并且即使在跨站点的情况下，相同地址的资源一旦被硬盘缓存下来，就不会再次去请求数据。</strong></li>
</ol>
<p><strong>Disk Cache：</strong>Push Cache 是 HTTP&#x2F;2 中的内容，当以上三种缓存都没有命中时，它才会被使用。<strong>并且缓存时间也很短暂，只在会话（Session）中存在，一旦会话结束就被释放。</strong>其具有以下特点：</p>
<ul>
<li>所有的资源都能被推送，但是 Edge 和 Safari 浏览器兼容性不怎么好</li>
<li>可以推送 <code>no-cache</code> 和 <code>no-store</code> 的资源</li>
<li>一旦连接被关闭，Push Cache 就被释放</li>
<li>多个页面可以使用相同的 HTTP&#x2F;2 连接，也就是说能使用同样的缓存</li>
<li>Push Cache 中的缓存只能被使用一次</li>
<li>浏览器可以拒绝接受已经存在的资源推送</li>
<li>可以给其他域名推送资源</li>
</ul>
<h3 id="3-协商缓存和强缓存的区别"><a href="#3-协商缓存和强缓存的区别" class="headerlink" title="3. 协商缓存和强缓存的区别"></a>3. 协商缓存和强缓存的区别</h3><h4 id="（1）强缓存"><a href="#（1）强缓存" class="headerlink" title="（1）强缓存"></a>（1）强缓存</h4><p>使用强缓存策略时，如果缓存资源有效，则直接使用缓存资源，不必再向服务器发起请求。</p>
<p>强缓存策略可以通过两种方式来设置，分别是 http 头信息中的 Expires 属性和 Cache-Control 属性。</p>
<p>（1）服务器通过在响应头中添加 Expires 属性，来指定资源的过期时间。在过期时间以内，该资源可以被缓存使用，不必再向服务器发送请求。这个时间是一个绝对时间，它是服务器的时间，因此可能存在这样的问题，就是客户端的时间和服务器端的时间不一致，或者用户可以对客户端时间进行修改的情况，这样就可能会影响缓存命中的结果。</p>
<p>（2）Expires 是 http1.0 中的方式，因为它的一些缺点，在 HTTP 1.1 中提出了一个新的头部属性就是 Cache-Control 属性，它提供了对资源的缓存的更精确的控制。它有很多不同的值，</p>
<p><code>Cache-Control</code>可设置的字段：</p>
<ul>
<li><code>public</code>：设置了该字段值的资源表示可以被任何对象（包括：发送请求的客户端、代理服务器等等）缓存。这个字段值不常用，一般还是使用max-age&#x3D;来精确控制；</li>
<li><code>private</code>：设置了该字段值的资源只能被用户浏览器缓存，不允许任何代理服务器缓存。在实际开发当中，对于一些含有用户信息的HTML，通常都要设置这个字段值，避免代理服务器(CDN)缓存；</li>
<li><code>no-cache</code>：设置了该字段需要先和服务端确认返回的资源是否发生了变化，如果资源未发生变化，则直接使用缓存好的资源；</li>
<li><code>no-store</code>：设置了该字段表示禁止任何缓存，每次都会向服务端发起新的请求，拉取最新的资源；</li>
<li><code>max-age=</code>：设置缓存的最大有效期，单位为秒；</li>
<li><code>s-maxage=</code>：优先级高于max-age&#x3D;，仅适用于共享缓存(CDN)，优先级高于max-age或者Expires头；</li>
<li><code>max-stale[=]</code>：设置了该字段表明客户端愿意接收已经过期的资源，但是不能超过给定的时间限制。</li>
</ul>
<p>一般来说只需要设置其中一种方式就可以实现强缓存策略，当两种方式一起使用时，Cache-Control 的优先级要高于 Expires。</p>
<p><strong>no-cache和no-store很容易混淆：</strong></p>
<ul>
<li>no-cache 是指先要和服务器确认是否有资源更新，在进行判断。也就是说没有强缓存，但是会有协商缓存；</li>
<li>no-store 是指不使用任何缓存，每次请求都直接从服务器获取资源。</li>
</ul>
<h4 id="（2）协商缓存"><a href="#（2）协商缓存" class="headerlink" title="（2）协商缓存"></a>（2）协商缓存</h4><p>如果命中强制缓存，我们无需发起新的请求，直接使用缓存内容，如果没有命中强制缓存，如果设置了协商缓存，这个时候协商缓存就会发挥作用了。</p>
<p>上面已经说到了，命中协商缓存的条件有两个：</p>
<ul>
<li><code>max-age=xxx</code> 过期了</li>
<li>值为<code>no-store</code></li>
</ul>
<p>使用协商缓存策略时，会先向服务器发送一个请求，如果资源没有发生修改，则返回一个 304 状态，让浏览器使用本地的缓存副本。如果资源发生了修改，则返回修改后的资源。</p>
<p>协商缓存也可以通过两种方式来设置，分别是 http 头信息中的 <strong>Etag</strong> 和 <strong>Last-Modified</strong> 属性。</p>
<p>（1）服务器通过在响应头中添加 Last-Modified 属性来指出资源最后一次修改的时间，当浏览器下一次发起请求时，会在请求头中添加一个 If-Modified-Since 的属性，属性值为上一次资源返回时的 Last-Modified 的值。当请求发送到服务器后服务器会通过这个属性来和资源的最后一次的修改时间来进行比较，以此来判断资源是否做了修改。如果资源没有修改，那么返回 304 状态，让客户端使用本地的缓存。如果资源已经被修改了，则返回修改后的资源。使用这种方法有一个缺点，就是 Last-Modified 标注的最后修改时间只能精确到秒级，如果某些文件在1秒钟以内，被修改多次的话，那么文件已将改变了但是 Last-Modified 却没有改变，这样会造成缓存命中的不准确。</p>
<p>（2）因为 Last-Modified 的这种可能发生的不准确性，http 中提供了另外一种方式，那就是 Etag 属性。服务器在返回资源的时候，在头信息中添加了 Etag 属性，这个属性是资源生成的唯一标识符，当资源发生改变的时候，这个值也会发生改变。在下一次资源请求时，浏览器会在请求头中添加一个 If-None-Match 属性，这个属性的值就是上次返回的资源的 Etag 的值。服务接收到请求后会根据这个值来和资源当前的 Etag 的值来进行比较，以此来判断资源是否发生改变，是否需要返回资源。通过这种方式，比 Last-Modified 的方式更加精确。</p>
<p>当 Last-Modified 和 Etag 属性同时出现的时候，Etag 的优先级更高。使用协商缓存的时候，服务器需要考虑负载平衡的问题，因此多个服务器上资源的 Last-Modified 应该保持一致，因为每个服务器上 Etag 的值都不一样，因此在考虑负载平衡时，最好不要设置 Etag 属性。</p>
<p><strong>总结：</strong></p>
<p>强缓存策略和协商缓存策略在缓存命中时都会直接使用本地的缓存副本，区别只在于协商缓存会向服务器发送一次请求。它们缓存不命中时，都会向服务器发送请求来获取资源。在实际的缓存机制中，强缓存策略和协商缓存策略是一起合作使用的。浏览器首先会根据请求的信息判断，强缓存是否命中，如果命中则直接使用资源。如果不命中则根据头信息向服务器发起请求，使用协商缓存，如果协商缓存命中的话，则服务器不返回资源，浏览器直接使用本地资源的副本，如果协商缓存不命中，则浏览器返回最新的资源给浏览器。</p>
<h3 id="4-为什么需要浏览器缓存？"><a href="#4-为什么需要浏览器缓存？" class="headerlink" title="4. 为什么需要浏览器缓存？"></a>4. 为什么需要浏览器缓存？</h3><p>对于浏览器的缓存，主要针对的是前端的静态资源，最好的效果就是，在发起请求之后，拉取相应的静态资源，并保存在本地。如果服务器的静态资源没有更新，那么在下次请求的时候，就直接从本地读取即可，如果服务器的静态资源已经更新，那么我们再次请求的时候，就到服务器拉取新的资源，并保存在本地。这样就大大的减少了请求的次数，提高了网站的性能。这就要用到浏览器的缓存策略了。</p>
<p>所谓的<strong>浏览器缓存</strong>指的是浏览器将用户请求过的静态资源，存储到电脑本地磁盘中，当浏览器再次访问时，就可以直接从本地加载，不需要再去服务端请求了。</p>
<p>使用浏览器缓存，有以下优点：</p>
<ul>
<li>减少了服务器的负担，提高了网站的性能</li>
<li>加快了客户端网页的加载速度</li>
<li>减少了多余网络数据传输</li>
</ul>
<h3 id="5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？"><a href="#5-点击刷新按钮或者按-F5、按-Ctrl-F5-（强制刷新）、地址栏回车有什么区别？" class="headerlink" title="5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？"></a>5. 点击刷新按钮或者按 F5、按 Ctrl+F5 （强制刷新）、地址栏回车有什么区别？</h3><ul>
<li><strong>点击刷新按钮或者按 F5：</strong>浏览器直接对本地的缓存文件过期，但是会带上If-Modifed-Since，If-None-Match，这就意味着服务器会对文件检查新鲜度，返回结果可能是 304，也有可能是 200。</li>
<li><strong>用户按 Ctrl+F5（强制刷新）：</strong>浏览器不仅会对本地文件过期，而且不会带上 If-Modifed-Since，If-None-Match，相当于之前从来没有请求过，返回结果是 200。</li>
<li>地址栏回车： 浏览器发起请求，按照正常流程，本地检查是否过期，然后服务器检查新鲜度，最后返回内容。</li>
</ul>
<h2 id="四、浏览器组成"><a href="#四、浏览器组成" class="headerlink" title="四、浏览器组成"></a>四、浏览器组成</h2><h3 id="1-对浏览器的理解"><a href="#1-对浏览器的理解" class="headerlink" title="1. 对浏览器的理解"></a>1. 对浏览器的理解</h3><p>浏览器的主要功能是将用户选择的 web 资源呈现出来，它需要从服务器请求资源，并将其显示在浏览器窗口中，资源的格式通常是 HTML，也包括 PDF、image 及其他格式。用户用 URI（Uniform Resource Identifier 统一资源标识符）来指定所请求资源的位置。</p>
<p>HTML 和 CSS 规范中规定了浏览器解释 html 文档的方式，由 W3C 组织对这些规范进行维护，W3C 是负责制定 web 标准的组织。但是浏览器厂商纷纷开发自己的扩展，对规范的遵循并不完善，这为 web 开发者带来了严重的兼容性问题。</p>
<p>浏览器可以分为两部分，shell 和 内核。其中 shell 的种类相对比较多，内核则比较少。也有一些浏览器并不区分外壳和内核。从 Mozilla 将 Gecko 独立出来后，才有了外壳和内核的明确划分。</p>
<ul>
<li>shell 是指浏览器的外壳：例如菜单，工具栏等。主要是提供给用户界面操作，参数设置等等。它是调用内核来实现各种功能的。</li>
<li>内核是浏览器的核心。内核是基于标记语言显示内容的程序或模块。</li>
</ul>
<h3 id="2-对浏览器内核的理解"><a href="#2-对浏览器内核的理解" class="headerlink" title="2. 对浏览器内核的理解"></a>2. 对浏览器内核的理解</h3><p>浏览器内核主要分成两部分：</p>
<ul>
<li>渲染引擎的职责就是渲染，即在浏览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示 html、xml 文档及图片，它也可以借助插件显示其他类型数据，例如使用 PDF 阅读器插件，可以显示 PDF 格式。</li>
<li>JS 引擎：解析和执行 javascript 来实现网页的动态效果。</li>
</ul>
<p>最开始渲染引擎和 JS 引擎并没有区分的很明确，后来 JS 引擎越来越独立，内核就倾向于只指渲染引擎。</p>
<h3 id="3-常见的浏览器内核比较"><a href="#3-常见的浏览器内核比较" class="headerlink" title="3. 常见的浏览器内核比较"></a>3. 常见的浏览器内核比较</h3><ul>
<li><strong>Trident：</strong>这种浏览器内核是 IE 浏览器用的内核，因为在早期 IE 占有大量的市场份额，所以这种内核比较流行，以前有很多网页也是根据这个内核的标准来编写的，但是实际上这个内核对真正的网页标准支持不是很好。但是由于 IE 的高市场占有率，微软也很长时间没有更新 Trident 内核，就导致了 Trident 内核和 W3C 标准脱节。还有就是 Trident 内核的大量 Bug 等安全问题没有得到解决，加上一些专家学者公开自己认为 IE 浏览器不安全的观点，使很多用户开始转向其他浏览器。</li>
<li><strong>Gecko：</strong>这是 Firefox 和 Flock 所采用的内核，这个内核的优点就是功能强大、丰富，可以支持很多复杂网页效果和浏览器扩展接口，但是代价是也显而易见就是要消耗很多的资源，比如内存。</li>
<li><strong>Presto：</strong>Opera 曾经采用的就是 Presto 内核，Presto 内核被称为公认的浏览网页速度最快的内核，这得益于它在开发时的天生优势，在处理 JS 脚本等脚本语言时，会比其他的内核快3倍左右，缺点就是为了达到很快的速度而丢掉了一部分网页兼容性。</li>
<li><strong>Webkit：</strong>Webkit 是 Safari 采用的内核，它的优点就是网页浏览速度较快，虽然不及 Presto 但是也胜于 Gecko 和 Trident，缺点是对于网页代码的容错性不高，也就是说对网页代码的兼容性较低，会使一些编写不标准的网页无法正确显示。WebKit 前身是 KDE 小组的 KHTML 引擎，可以说 WebKit 是 KHTML 的一个开源的分支。</li>
<li><strong>Blink：</strong>谷歌在 Chromium Blog 上发表博客，称将与苹果的开源浏览器核心 Webkit 分道扬镳，在 Chromium 项目中研发 Blink 渲染引擎（即浏览器核心），内置于 Chrome 浏览器之中。其实 Blink 引擎就是 Webkit 的一个分支，就像 webkit 是KHTML 的分支一样。Blink 引擎现在是谷歌公司与 Opera Software 共同研发，上面提到过的，Opera 弃用了自己的 Presto 内核，加入 Google 阵营，跟随谷歌一起研发 Blink。</li>
</ul>
<h3 id="4-常见浏览器所用内核"><a href="#4-常见浏览器所用内核" class="headerlink" title="4. 常见浏览器所用内核"></a>4. 常见浏览器所用内核</h3><p>  （1） IE 浏览器内核：Trident 内核，也是俗称的 IE 内核；</p>
<p> （2） Chrome 浏览器内核：统称为 Chromium 内核或 Chrome 内核，以前是 Webkit 内核，现在是 Blink内核；</p>
<p> （3） Firefox 浏览器内核：Gecko 内核，俗称 Firefox 内核；</p>
<p> （4） Safari 浏览器内核：Webkit 内核；</p>
<p> （5） Opera 浏览器内核：最初是自己的 Presto 内核，后来加入谷歌大军，从 Webkit 又到了 Blink 内核；</p>
<p> （6） 360浏览器、猎豹浏览器内核：IE + Chrome 双内核；</p>
<p> （7） 搜狗、遨游、QQ 浏览器内核：Trident（兼容模式）+ Webkit（高速模式）；</p>
<p> （8） 百度浏览器、世界之窗内核：IE 内核；</p>
<p> （9） 2345浏览器内核：好像以前是 IE 内核，现在也是 IE + Chrome 双内核了；</p>
<p> （10）UC 浏览器内核：这个众口不一，UC 说是他们自己研发的 U3 内核，但好像还是基于 Webkit 和 Trident ，还有说是基于火狐内核。</p>
<h3 id="5-浏览器的主要组成部分"><a href="#5-浏览器的主要组成部分" class="headerlink" title="5. 浏览器的主要组成部分"></a>5. 浏览器的主要组成部分</h3><ul>
<li><strong>⽤户界⾯</strong> - 包括地址栏、前进&#x2F;后退按钮、书签菜单等。除了浏览器主窗⼝显示的您请求的⻚⾯外，其他显示的各个部分都属于⽤户界⾯。 </li>
<li><strong>浏览器引擎</strong> - 在⽤户界⾯和呈现引擎之间传送指令。 </li>
<li><strong>呈现引擎</strong> - 负责显示请求的内容。如果请求的内容是 HTML，它就负责解析 HTML 和 CSS 内容，并将解析后的内容显示在屏幕上。 </li>
<li><strong>⽹络</strong> - ⽤于⽹络调⽤，⽐如 HTTP 请求。其接⼝与平台⽆关，并为所有平台提供底层实现。 </li>
<li><strong>⽤户界⾯后端</strong> - ⽤于绘制基本的窗⼝⼩部件，⽐如组合框和窗⼝。其公开了与平台⽆关的通⽤接⼝，⽽在底层使⽤操作系统的⽤户界⾯⽅法。 </li>
<li><strong>JavaScript</strong> <strong>解释器</strong>。⽤于解析和执⾏ JavaScript 代码。 </li>
<li><strong>数据存储</strong> - 这是持久层。浏览器需要在硬盘上保存各种数据，例如 Cookie。新的 HTML 规范 (HTML5) 定义了“⽹络数据库”，这是⼀个完整（但是轻便）的浏览器内数据库。</li>
</ul>
<p>值得注意的是，和⼤多数浏览器不同，Chrome 浏览器的每个标签⻚都分别对应⼀个呈现引擎实例。每个标签⻚都是⼀个独⽴的进程。</p>
<h2 id="五、浏览器渲染原理"><a href="#五、浏览器渲染原理" class="headerlink" title="五、浏览器渲染原理"></a>五、浏览器渲染原理</h2><h3 id="1-浏览器的渲染过程"><a href="#1-浏览器的渲染过程" class="headerlink" title="1. 浏览器的渲染过程"></a>1. 浏览器的渲染过程</h3><p>浏览器渲染主要有以下步骤：</p>
<ul>
<li>首先解析收到的文档，根据文档定义构建一棵 DOM 树，DOM 树是由 DOM 元素及属性节点组成的。</li>
<li>然后对 CSS 进行解析，生成 CSSOM 规则树。</li>
<li>根据 DOM 树和 CSSOM 规则树构建渲染树。渲染树的节点被称为渲染对象，渲染对象是一个包含有颜色和大小等属性的矩形，渲染对象和 DOM 元素相对应，但这种对应关系不是一对一的，不可见的 DOM 元素不会被插入渲染树。还有一些 DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。</li>
<li>当渲染对象被创建并添加到树中，它们并没有位置和大小，所以当浏览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段浏览器要做的事情是要弄清楚各个节点在页面中的确切位置和大小。通常这一行为也被称为“自动重排”。</li>
<li>布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的 paint 方法将它们的内容显示在屏幕上，绘制使用 UI 基础组件。</li>
</ul>
<p>大致过程如图所示：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603797939165-3bf54e28-5469-4093-a0e1-e0569cec1305.png"  ><span class="image-caption">image</span></p>
<p><strong>注意：</strong>这个过程是逐步完成的，为了更好的用户体验，渲染引擎将会尽可能早的将内容呈现到屏幕上，并不会等到所有的html 都解析完成之后再去构建和布局 render 树。它是解析完一部分内容就显示一部分内容，同时，可能还在通过网络下载其余内容。</p>
<h3 id="2-浏览器渲染优化"><a href="#2-浏览器渲染优化" class="headerlink" title="2. 浏览器渲染优化"></a>2. 浏览器渲染优化</h3><p><strong>（1）针对JavaScript：</strong>JavaScript既会阻塞HTML的解析，也会阻塞CSS的解析。因此我们可以对JavaScript的加载方式进行改变，来进行优化：</p>
<p>（1）尽量将JavaScript文件放在body的最后</p>
<p>（2） body中间尽量不要写<code>&lt;script&gt;</code>标签</p>
<p>（3）<code>&lt;script&gt;</code>标签的引入资源方式有三种，有一种就是我们常用的直接引入，还有两种就是使用 async 属性和 defer 属性来异步引入，两者都是去异步加载外部的JS文件，不会阻塞DOM的解析（尽量使用异步加载）。三者的区别如下：</p>
<ul>
<li><strong>script</strong> 立即停止页面渲染去加载资源文件，当资源加载完毕后立即执行js代码，js代码执行完毕后继续渲染页面；</li>
<li><strong>async</strong> 是在下载完成之后，立即异步加载，加载好后立即执行，多个带async属性的标签，不能保证加载的顺序；</li>
<li><strong>defer</strong> 是在下载完成之后，立即异步加载。加载好后，如果 DOM 树还没构建好，则先等 DOM 树解析好再执行；如果DOM树已经准备好，则立即执行。多个带defer属性的标签，按照顺序执行。</li>
</ul>
<p><strong>（2）针对CSS：</strong>使用CSS有三种方式：使用<strong>link、@import、内联样式</strong>，其中link和@import都是导入外部样式。它们之间的区别：</p>
<ul>
<li><strong>link</strong>：浏览器会派发一个新等线程(HTTP线程)去加载资源文件，与此同时GUI渲染线程会继续向下渲染代码</li>
<li><strong>@import</strong>：GUI渲染线程会暂时停止渲染，去服务器加载资源文件，资源文件没有返回之前不会继续渲染(阻碍浏览器渲染)</li>
<li><strong>style</strong>：GUI直接渲染</li>
</ul>
<p>外部样式如果长时间没有加载完毕，浏览器为了用户体验，会使用浏览器会默认样式，确保首次渲染的速度。所以CSS一般写在headr中，让浏览器尽快发送请求去获取css样式。</p>
<p>所以，在开发过程中，导入外部样式使用link，而不用@import。如果css少，尽可能采用内嵌样式，直接写在style标签中。</p>
<p><strong>（3）针对DOM树、CSSOM树：</strong></p>
<p>可以通过以下几种方式来减少渲染的时间：</p>
<ul>
<li>HTML文件的代码层级尽量不要太深</li>
<li>使用语义化的标签，来避免不标准语义化的特殊处理</li>
<li>减少CSSD代码的层级，因为选择器是从左向右进行解析的</li>
</ul>
<p><strong>（4）减少回流与重绘：</strong></p>
<ul>
<li>操作DOM时，尽量在低层级的DOM节点进行操作</li>
<li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li>
<li>使用CSS的表达式</li>
<li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li>
<li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>
<li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-渲染过程中遇到-JS-文件如何处理？"><a href="#3-渲染过程中遇到-JS-文件如何处理？" class="headerlink" title="3. 渲染过程中遇到 JS 文件如何处理？"></a>3. 渲染过程中遇到 JS 文件如何处理？</h3><p>JavaScript 的加载、解析与执行会阻塞文档的解析，也就是说，在构建 DOM 时，HTML 解析器若遇到了 JavaScript，那么它会暂停文档的解析，将控制权移交给 JavaScript 引擎，等 JavaScript 引擎运行完毕，浏览器再从中断的地方恢复继续解析文档。也就是说，如果想要首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。</p>
<h3 id="4-什么是文档的预解析？"><a href="#4-什么是文档的预解析？" class="headerlink" title="4. 什么是文档的预解析？"></a>4. 什么是文档的预解析？</h3><p>Webkit 和 Firefox 都做了这个优化，当执行 JavaScript 脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载从而使整体速度更快。需要注意的是，预解析并不改变 DOM 树，它将这个工作留给主解析过程，自己只解析外部资源的引用，比如外部脚本、样式表及图片。</p>
<h3 id="5-CSS-如何阻塞文档解析？"><a href="#5-CSS-如何阻塞文档解析？" class="headerlink" title="5. CSS 如何阻塞文档解析？"></a>5. CSS 如何阻塞文档解析？</h3><p>理论上，既然样式表不改变 DOM 树，也就没有必要停下文档的解析等待它们。然而，存在一个问题，JavaScript 脚本执行时可能在文档的解析过程中请求样式信息，如果样式还没有加载和解析，脚本将得到错误的值，显然这将会导致很多问题。所以如果浏览器尚未完成 CSSOM 的下载和构建，而我们却想在此时运行脚本，那么浏览器将延迟 JavaScript 脚本执行和文档的解析，直至其完成 CSSOM 的下载和构建。也就是说，在这种情况下，浏览器会先下载和构建 CSSOM，然后再执行 JavaScript，最后再继续文档的解析。</p>
<h3 id="6-如何优化关键渲染路径？"><a href="#6-如何优化关键渲染路径？" class="headerlink" title="6. 如何优化关键渲染路径？"></a>6. 如何优化关键渲染路径？</h3><p>为尽快完成首次渲染，我们需要最大限度减小以下三种可变因素：</p>
<p> （1）关键资源的数量。</p>
<p> （2）关键路径长度。</p>
<p> （3）关键字节的数量。</p>
<p>关键资源是可能阻止网页首次渲染的资源。这些资源越少，浏览器的工作量就越小，对 CPU 以及其他资源的占用也就越少。同样，关键路径长度受所有关键资源与其字节大小之间依赖关系图的影响：某些资源只能在上一资源处理完毕之后才能开始下载，并且资源越大，下载所需的往返次数就越多。最后，浏览器需要下载的关键字节越少，处理内容并让其出现在屏幕上的速度就越快。要减少字节数，我们可以减少资源数（将它们删除或设为非关键资源），此外还要压缩和优化各项资源，确保最大限度减小传送大小。</p>
<p>优化关键渲染路径的常规步骤如下：</p>
<p> （1）对关键路径进行分析和特性描述：资源数、字节数、长度。</p>
<p> （2）最大限度减少关键资源的数量：删除它们，延迟它们的下载，将它们标记为异步等。</p>
<p> （3）优化关键字节数以缩短下载时间（往返次数）。</p>
<p> （4）优化其余关键资源的加载顺序：您需要尽早下载所有关键资产，以缩短关键路径长度</p>
<h3 id="7-什么情况会阻塞渲染？"><a href="#7-什么情况会阻塞渲染？" class="headerlink" title="7. 什么情况会阻塞渲染？"></a>7. 什么情况会阻塞渲染？</h3><p>首先渲染的前提是生成渲染树，所以 HTML 和 CSS 肯定会阻塞渲染。如果你想渲染的越快，你越应该降低一开始需要渲染的文件大小，并且扁平层级，优化选择器。然后当浏览器在解析到 script 标签时，会暂停构建 DOM，完成后才会从暂停的地方重新开始。也就是说，如果你想首屏渲染的越快，就越不应该在首屏就加载 JS 文件，这也是都建议将 script 标签放在 body 标签底部的原因。</p>
<p>当然在当下，并不是说 script 标签必须放在底部，因为你可以给 script 标签添加 defer 或者 async 属性。当 script 标签加上 defer 属性以后，表示该 JS 文件会并行下载，但是会放到 HTML 解析完成后顺序执行，所以对于这种情况你可以把 script 标签放在任意位置。对于没有任何依赖的 JS 文件可以加上 async 属性，表示 JS 文件下载和解析不会阻塞渲染。</p>
<h2 id="六、浏览器本地存储"><a href="#六、浏览器本地存储" class="headerlink" title="六、浏览器本地存储"></a>六、浏览器本地存储</h2><h3 id="1-浏览器本地存储方式及使用场景"><a href="#1-浏览器本地存储方式及使用场景" class="headerlink" title="1. 浏览器本地存储方式及使用场景"></a>1. 浏览器本地存储方式及使用场景</h3><h4 id="（1）Cookie"><a href="#（1）Cookie" class="headerlink" title="（1）Cookie"></a>（1）Cookie</h4><p>Cookie是最早被提出来的本地存储方式，在此之前，服务端是无法判断网络中的两个请求是否是同一用户发起的，为解决这个问题，Cookie就出现了。Cookie的大小只有4kb，它是一种纯文本文件，每次发起HTTP请求都会携带Cookie。</p>
<p><strong>Cookie的特性：</strong></p>
<ul>
<li>Cookie一旦创建成功，名称就无法修改</li>
<li>Cookie是无法跨域名的，也就是说a域名和b域名下的cookie是无法共享的，这也是由Cookie的隐私安全性决定的，这样就能够阻止非法获取其他网站的Cookie</li>
<li>每个域名下Cookie的数量不能超过20个，每个Cookie的大小不能超过4kb</li>
<li>有安全问题，如果Cookie被拦截了，那就可获得session的所有信息，即使加密也于事无补，无需知道cookie的意义，只要转发cookie就能达到目的</li>
<li>Cookie在请求一个新的页面的时候都会被发送过去</li>
</ul>
<p>如果需要域名之间跨域共享Cookie，有两种方法：</p>
<ol>
<li>使用Nginx反向代理</li>
<li>在一个站点登陆之后，往其他网站写Cookie。服务端的Session存储到一个节点，Cookie存储sessionId</li>
</ol>
<p><strong>Cookie的使用场景：</strong></p>
<ul>
<li>最常见的使用场景就是Cookie和session结合使用，我们将sessionId存储到Cookie中，每次发请求都会携带这个sessionId，这样服务端就知道是谁发起的请求，从而响应相应的信息。</li>
<li>可以用来统计页面的点击次数</li>
</ul>
<h4 id="（2）LocalStorage"><a href="#（2）LocalStorage" class="headerlink" title="（2）LocalStorage"></a>（2）LocalStorage</h4><p>LocalStorage是HTML5新引入的特性，由于有的时候我们存储的信息较大，Cookie就不能满足我们的需求，这时候LocalStorage就派上用场了。</p>
<p><strong>LocalStorage的优点：</strong></p>
<ul>
<li>在大小方面，LocalStorage的大小一般为5MB，可以储存更多的信息</li>
<li>LocalStorage是持久储存，并不会随着页面的关闭而消失，除非主动清理，不然会永久存在</li>
<li>仅储存在本地，不像Cookie那样每次HTTP请求都会被携带</li>
</ul>
<p><strong>LocalStorage的缺点：</strong></p>
<ul>
<li>存在浏览器兼容问题，IE8以下版本的浏览器不支持</li>
<li>如果浏览器设置为隐私模式，那我们将无法读取到LocalStorage</li>
<li>LocalStorage受到同源策略的限制，即端口、协议、主机地址有任何一个不相同，都不会访问</li>
</ul>
<p><strong>LocalStorage的****常用API：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 保存数据到 localStorage</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">setItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-comment">// 从 localStorage 获取数据</span><br><span class="hljs-keyword">let</span> data = <span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">getItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 从 localStorage 删除保存的数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">removeItem</span>(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-comment">// 从 localStorage 删除所有保存的数据</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">clear</span>();<br><br><span class="hljs-comment">// 获取某个索引的Key</span><br><span class="hljs-variable language_">localStorage</span>.<span class="hljs-title function_">key</span>(index)<br></code></pre></td></tr></table></figure>

<p><strong>LocalStorage的****使用场景：</strong></p>
<ul>
<li>有些网站有换肤的功能，这时候就可以将换肤的信息存储在本地的LocalStorage中，当需要换肤的时候，直接操作LocalStorage即可</li>
<li>在网站中的用户浏览信息也会存储在LocalStorage中，还有网站的一些不常变动的个人信息等也可以存储在本地的LocalStorage中</li>
</ul>
<h4 id="（3）SessionStorage"><a href="#（3）SessionStorage" class="headerlink" title="（3）SessionStorage"></a>（3）SessionStorage</h4><p>SessionStorage和LocalStorage都是在HTML5才提出来的存储方案，SessionStorage 主要用于临时保存同一窗口(或标签页)的数据，刷新页面时不会删除，关闭窗口或标签页之后将会删除这些数据。</p>
<p><strong>SessionStorage****与LocalStorage对比：</strong></p>
<ul>
<li>SessionStorage和LocalStorage都在<strong>本地进行数据存储</strong>；</li>
<li>SessionStorage也有同源策略的限制，但是SessionStorage有一条更加严格的限制，SessionStorage<strong>只有在同一浏览器的同一窗口下才能够共享</strong>；</li>
<li>LocalStorage和SessionStorage<strong>都不能被爬虫爬取</strong>；</li>
</ul>
<p><strong>SessionStorage的****常用API：</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 保存数据到 sessionStorage<br>sessionStorage.setItem(<span class="hljs-string">&#x27;key&#x27;</span>, <span class="hljs-string">&#x27;value&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 从 sessionStorage 获取数据<br>let data = sessionStorage.getItem(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 从 sessionStorage 删除保存的数据<br>sessionStorage.removeItem(<span class="hljs-string">&#x27;key&#x27;</span>);<br><br><span class="hljs-regexp">//</span> 从 sessionStorage 删除所有保存的数据<br>sessionStorage.clear();<br><br><span class="hljs-regexp">//</span> 获取某个索引的Key<br>sessionStorage.key(index)<br></code></pre></td></tr></table></figure>

<p><strong>SessionStorage的****使用场景</strong></p>
<ul>
<li>由于SessionStorage具有时效性，所以可以用来存储一些网站的游客登录的信息，还有临时的浏览记录的信息。当关闭网站之后，这些信息也就随之消除了。</li>
</ul>
<h3 id="2-Cookie有哪些字段，作用分别是什么"><a href="#2-Cookie有哪些字段，作用分别是什么" class="headerlink" title="2. Cookie有哪些字段，作用分别是什么"></a>2. Cookie有哪些字段，作用分别是什么</h3><p><strong>Cookie由以下字段组成：</strong></p>
<ul>
<li><strong>Name</strong>：cookie的名称</li>
<li><strong>Value</strong>：cookie的值，对于认证cookie，value值包括web服务器所提供的访问令牌；</li>
<li><strong>Size</strong>： cookie的大小</li>
<li><strong>Path</strong>：可以访问此cookie的页面路径。 比如domain是abc.com，path是<code>/test</code>，那么只有<code>/test</code>路径下的页面可以读取此cookie。</li>
<li><strong>Secure</strong>： 指定是否使用HTTPS安全协议发送Cookie。使用HTTPS安全协议，可以保护Cookie在浏览器和Web服务器间的传输过程中不被窃取和篡改。该方法也可用于Web站点的身份鉴别，即在HTTPS的连接建立阶段，浏览器会检查Web网站的SSL证书的有效性。但是基于兼容性的原因（比如有些网站使用自签署的证书）在检测到SSL证书无效时，浏览器并不会立即终止用户的连接请求，而是显示安全风险信息，用户仍可以选择继续访问该站点。</li>
<li><strong>Domain</strong>：可以访问该cookie的域名，Cookie 机制并未遵循严格的同源策略，允许一个子域可以设置或获取其父域的 Cookie。当需要实现单点登录方案时，Cookie 的上述特性非常有用，然而也增加了 Cookie受攻击的危险，比如攻击者可以借此发动会话定置攻击。因而，浏览器禁止在 Domain 属性中设置.org、.com 等通用顶级域名、以及在国家及地区顶级域下注册的二级域名，以减小攻击发生的范围。</li>
<li><strong>HTTP</strong>： 该字段包含<code>HTTPOnly</code> 属性 ，该属性用来设置cookie能否通过脚本来访问，默认为空，即可以通过脚本访问。在客户端是不能通过js代码去设置一个httpOnly类型的cookie的，这种类型的cookie只能通过服务端来设置。该属性用于防止客户端脚本通过<code>document.cookie</code>属性访问Cookie，有助于保护Cookie不被跨站脚本攻击窃取或篡改。但是，HTTPOnly的应用仍存在局限性，一些浏览器可以阻止客户端脚本对Cookie的读操作，但允许写操作；此外大多数浏览器仍允许通过XMLHTTP对象读取HTTP响应中的Set-Cookie头。</li>
<li><strong>Expires&#x2F;Max-size</strong> ： 此cookie的超时时间。若设置其值为一个时间，那么当到达此时间后，此cookie失效。不设置的话默认值是Session，意思是cookie会和session一起失效。当浏览器关闭(不是浏览器标签页，而是整个浏览器) 后，此cookie失效。</li>
</ul>
<p><strong>总结：</strong></p>
<p>服务器端可以使用 Set-Cookie 的响应头部来配置 cookie 信息。一条cookie 包括了5个属性值 expires、domain、path、secure、HttpOnly。其中 expires 指定了 cookie 失效的时间，domain 是域名、path是路径，domain 和 path 一起限制了 cookie 能够被哪些 url 访问。secure 规定了 cookie 只能在确保安全的情况下传输，HttpOnly 规定了这个 cookie 只能被服务器访问，不能使用 js 脚本访问。</p>
<h3 id="3-Cookie、LocalStorage、SessionStorage区别"><a href="#3-Cookie、LocalStorage、SessionStorage区别" class="headerlink" title="3. Cookie、LocalStorage、SessionStorage区别"></a>3. Cookie、LocalStorage、SessionStorage区别</h3><p>浏览器端常用的存储技术是 cookie 、localStorage 和 sessionStorage。</p>
<ul>
<li><strong>cookie：</strong>其实最开始是服务器端用于记录用户状态的一种方式，由服务器设置，在客户端存储，然后每次发起同源请求时，发送给服务器端。cookie 最多能存储 4 k 数据，它的生存时间由 expires 属性指定，并且 cookie 只能被同源的页面访问共享。</li>
<li><strong>sessionStorage：</strong>html5 提供的一种浏览器本地存储的方法，它借鉴了服务器端 session 的概念，代表的是一次会话中所保存的数据。它一般能够存储 5M 或者更大的数据，它在当前窗口关闭后就失效了，并且 sessionStorage 只能被同一个窗口的同源页面所访问共享。</li>
<li><strong>localStorage：</strong>html5 提供的一种浏览器本地存储的方法，它一般也能够存储 5M 或者更大的数据。它和 sessionStorage 不同的是，除非手动删除它，否则它不会失效，并且 localStorage 也只能被同源页面所访问共享。</li>
</ul>
<p>上面几种方式都是存储少量数据的时候的存储方式，当需要在本地存储大量数据的时候，我们可以使用浏览器的 indexDB 这是浏览器提供的一种本地的数据库存储机制。它不是关系型数据库，它内部采用对象仓库的形式存储数据，它更接近 NoSQL 数据库。</p>
<h3 id="4-前端储存的⽅式有哪些？"><a href="#4-前端储存的⽅式有哪些？" class="headerlink" title="4. 前端储存的⽅式有哪些？"></a>4. 前端储存的⽅式有哪些？</h3><ul>
<li>cookies： 在HTML5标准前本地储存的主要⽅式，优点是兼容性好，请求头⾃带cookie⽅便，缺点是⼤⼩只有4k，⾃动请求头加⼊cookie浪费流量，每个domain限制20个cookie，使⽤起来麻烦，需要⾃⾏封装；</li>
<li>localStorage：HTML5加⼊的以键值对(Key-Value)为标准的⽅式，优点是操作⽅便，永久性储存（除⾮⼿动删除），⼤⼩为5M，兼容IE8+ ；</li>
<li>sessionStorage：与localStorage基本类似，区别是sessionStorage当⻚⾯关闭后会被清理，⽽且与cookie、localStorage不同，他不能在所有同源窗⼝中共享，是会话级别的储存⽅式； </li>
<li>Web SQL：2010年被W3C废弃的本地数据库数据存储⽅案，但是主流浏览器（⽕狐除外）都已经有了相关的实现，web sql类似于SQLite，是真正意义上的关系型数据库，⽤sql进⾏操作，当我们⽤JavaScript时要进⾏转换，较为繁琐； </li>
<li>IndexedDB： 是被正式纳⼊HTML5标准的数据库储存⽅案，它是NoSQL数据库，⽤键值对进⾏储存，可以进⾏快速读取操作，⾮常适合web场景，同时⽤JavaScript进⾏操作会⾮常便。</li>
</ul>
<h3 id="5-IndexedDB有哪些特点？"><a href="#5-IndexedDB有哪些特点？" class="headerlink" title="5. IndexedDB有哪些特点？"></a>5. IndexedDB有哪些特点？</h3><p>IndexedDB 具有以下特点：</p>
<ul>
<li><strong>键值对储存</strong>：IndexedDB 内部采用对象仓库（object store）存放数据。所有类型的数据都可以直接存入，包括 JavaScript 对象。对象仓库中，数据以”键值对”的形式保存，每一个数据记录都有对应的主键，主键是独一无二的，不能有重复，否则会抛出一个错误。</li>
<li><strong>异步</strong>：IndexedDB 操作时不会锁死浏览器，用户依然可以进行其他操作，这与 LocalStorage 形成对比，后者的操作是同步的。异步设计是为了防止大量数据的读写，拖慢网页的表现。</li>
<li><strong>支持事务</strong>：IndexedDB 支持事务（transaction），这意味着一系列操作步骤之中，只要有一步失败，整个事务就都取消，数据库回滚到事务发生之前的状态，不存在只改写一部分数据的情况。</li>
<li><strong>同源限制：</strong>IndexedDB 受到同源限制，每一个数据库对应创建它的域名。网页只能访问自身域名下的数据库，而不能访问跨域的数据库。</li>
<li><strong>储存空间大</strong>：IndexedDB 的储存空间比 LocalStorage 大得多，一般来说不少于 250MB，甚至没有上限。</li>
<li><strong>支持二进制储存</strong>：IndexedDB 不仅可以储存字符串，还可以储存二进制数据（ArrayBuffer 对象和 Blob 对象）。</li>
</ul>
<h2 id="七、浏览器同源策略"><a href="#七、浏览器同源策略" class="headerlink" title="七、浏览器同源策略"></a>七、浏览器同源策略</h2><h3 id="1-什么是同源策略"><a href="#1-什么是同源策略" class="headerlink" title="1. 什么是同源策略"></a>1. 什么是同源策略</h3><p>跨域问题其实就是浏览器的同源策略造成的。</p>
<blockquote>
<p>同源策略限制了从同一个源加载的文档或脚本如何与另一个源的资源进行交互。这是浏览器的一个用于隔离潜在恶意文件的重要的安全机制。同源指的是：<strong>协议</strong>、<strong>端口号</strong>、<strong>域名</strong>必须一致。</p>
</blockquote>
<p>下表给出了与 URL <a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a> 的源进行对比的示例:</p>
<table>
<thead>
<tr>
<th>URL</th>
<th>是否跨域</th>
<th>原因</th>
</tr>
</thead>
<tbody><tr>
<td><a href="http://store.company.com/dir/page.html">http://store.company.com/dir/page.html</a></td>
<td>同源</td>
<td>完全相同</td>
</tr>
<tr>
<td><a href="http://store.company.com/dir/inner/another.html">http://store.company.com/dir/inner/another.html</a></td>
<td>同源</td>
<td>只有路径不同</td>
</tr>
<tr>
<td><a href="https://store.company.com/secure.html">https://store.company.com/secure.html</a></td>
<td>跨域</td>
<td>协议不同</td>
</tr>
<tr>
<td><a href="http://store.company.com:81/dir/etc.html">http://store.company.com:81/dir/etc.html</a></td>
<td>跨域</td>
<td>端口不同 ( http:&#x2F;&#x2F; 默认端口是80)</td>
</tr>
<tr>
<td><a href="http://news.company.com/dir/other.html">http://news.company.com/dir/other.html</a></td>
<td>跨域</td>
<td>主机不同</td>
</tr>
</tbody></table>
<p><strong>同源策略：protocol（协议）、domain（域名）、port（端口）三者必须一致。</strong></p>
<p><strong>同源政策主要限制了三个方面：</strong></p>
<ul>
<li>当前域下的 js 脚本不能够访问其他域下的 cookie、localStorage 和 indexDB。</li>
<li>当前域下的 js 脚本不能够操作访问操作其他域下的 DOM。</li>
<li>当前域下 ajax 无法发送跨域请求。</li>
</ul>
<p>同源政策的目的主要是为了保证用户的信息安全，它只是对 js 脚本的一种限制，并不是对浏览器的限制，对于一般的 img、或者script 脚本请求都不会有跨域的限制，这是因为这些操作都不会通过响应结果来进行可能出现安全问题的操作。</p>
<h3 id="2-如何解决跨越问题"><a href="#2-如何解决跨越问题" class="headerlink" title="2. 如何解决跨越问题"></a>2. 如何解决跨越问题</h3><h4 id="（1）CORS"><a href="#（1）CORS" class="headerlink" title="（1）CORS"></a>（1）CORS</h4><p>下面是MDN对于CORS的定义：</p>
<blockquote>
<p>跨域资源共享(CORS) 是一种机制，它使用额外的 HTTP 头来告诉浏览器  让运行在一个 origin (domain)上的Web应用被准许访问来自不同源服务器上的指定的资源。当一个资源从与该资源本身所在的服务器不同的域、协议或端口请求一个资源时，资源会发起一个跨域HTTP 请求。</p>
</blockquote>
<p>CORS需要浏览器和服务器同时支持，整个CORS过程都是浏览器完成的，无需用户参与。因此实现<strong>CORS的关键就是服务器，只要服务器实现了CORS请求</strong>，就可以跨源通信了。</p>
<p>浏览器将CORS分为<strong>简单请求</strong>和<strong>非简单请求</strong>：</p>
<p>简单请求不会触发CORS预检请求。若该请求满足以下两个条件，就可以看作是简单请求：</p>
<p><strong>1）请求方法是以下三种方法之一：</strong></p>
<ul>
<li>HEAD</li>
<li>GET</li>
<li>POST</li>
</ul>
<p><strong>2）HTTP的头信息不超出以下几种字段：</strong></p>
<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Last-Event-ID</li>
<li>Content-Type：只限于三个值application&#x2F;x-www-form-urlencoded、multipart&#x2F;form-data、text&#x2F;plain</li>
</ul>
<p>若不满足以上条件，就属于非简单请求了。</p>
<p><strong>（1）简单请求过程：</strong></p>
<p>对于简单请求，浏览器会直接发出CORS请求，它会在请求的头信息中增加一个Orign字段，该字段用来说明本次请求来自哪个源（协议+端口+域名），服务器会根据这个值来决定是否同意这次请求。如果Orign指定的域名在许可范围之内，服务器返回的响应就会多出以下信息头：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">Access-Control-Allow-Origin: http:<span class="hljs-regexp">//</span>api.bob.com  <span class="hljs-regexp">//</span> 和Orign一直<br>Access-Control-Allow-Credentials: true   <span class="hljs-regexp">//</span> 表示是否允许发送Cookie<br>Access-Control-Expose-Headers: FooBar   <span class="hljs-regexp">//</span> 指定返回其他字段的值<br>Content-Type: text<span class="hljs-regexp">/html; charset=utf-8   /</span><span class="hljs-regexp">/ 表示文档类型</span><br></code></pre></td></tr></table></figure>

<p>如果Orign指定的域名不在许可范围之内，服务器会返回一个正常的HTTP回应，浏览器发现没有上面的Access-Control-Allow-Origin头部信息，就知道出错了。这个错误无法通过状态码识别，因为返回的状态码可能是200。</p>
<p><strong>在简单请求中，在服务器内，至少需要设置字段：</strong><code>**Access-Control-Allow-Origin**</code></p>
<p><strong>（2）非简单请求过程</strong></p>
<p>非简单请求是对服务器有特殊要求的请求，比如请求方法为DELETE或者PUT等。非简单请求的CORS请求会在正式通信之前进行一次HTTP查询请求，<strong>称为预检请求</strong>。</p>
<p>浏览器会询问服务器，当前所在的网页是否在服务器允许访问的范围内，以及可以使用哪些HTTP请求方式和头信息字段，只有得到肯定的回复，才会进行正式的HTTP请求，否则就会报错。</p>
<p>预检请求使用的<strong>请求方法是OPTIONS</strong>，表示这个请求是来询问的。他的头信息中的关键字段是Orign，表示请求来自哪个源。除此之外，头信息中还包括两个字段：</p>
<ul>
<li><strong>Access-Control-Request-Method</strong>：该字段是必须的，用来列出浏览器的CORS请求会用到哪些HTTP方法。</li>
<li><strong>Access-Control-Request-Headers</strong>： 该字段是一个逗号分隔的字符串，指定浏览器CORS请求会额外发送的头信息字段。</li>
</ul>
<p>服务器在收到浏览器的预检请求之后，会根据头信息的三个字段来进行判断，如果返回的头信息在中有Access-Control-Allow-Origin这个字段就是允许跨域请求，如果没有，就是不同意这个预检请求，就会报错。</p>
<p>服务器回应的CORS的字段如下：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">Access-Control-Allow-Origin: http:<span class="hljs-regexp">//</span>api.bob.com  <span class="hljs-regexp">//</span> 允许跨域的源地址<br>Access-Control-Allow-Methods: GET, POST, PUT <span class="hljs-regexp">//</span> 服务器支持的所有跨域请求的方法<br>Access-Control-Allow-Headers: X-Custom-Header  <span class="hljs-regexp">//</span> 服务器支持的所有头信息字段<br>Access-Control-Allow-Credentials: true   <span class="hljs-regexp">//</span> 表示是否允许发送Cookie<br>Access-Control-Max-Age: <span class="hljs-number">1728000</span>  <span class="hljs-regexp">//</span> 用来指定本次预检请求的有效期，单位为秒<br></code></pre></td></tr></table></figure>

<p>只要服务器通过了预检请求，在以后每次的CORS请求都会自带一个Origin头信息字段。服务器的回应，也都会有一个Access-Control-Allow-Origin头信息字段。</p>
<p><strong>在非简单请求中，至少需要设置以下字段：</strong></p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><code class="hljs scheme"><span class="hljs-symbol">&#x27;Access-Control-Allow-Origin</span>&#x27;  <br><span class="hljs-symbol">&#x27;Access-Control-Allow-Methods</span>&#x27;<br><span class="hljs-symbol">&#x27;Access-Control-Allow-Headers</span>&#x27;<br></code></pre></td></tr></table></figure>

<h5 id="减少OPTIONS请求次数："><a href="#减少OPTIONS请求次数：" class="headerlink" title="减少OPTIONS请求次数："></a>减少OPTIONS请求次数：</h5><p>OPTIONS请求次数过多就会损耗页面加载的性能，降低用户体验度。所以尽量要减少OPTIONS请求次数，可以后端在请求的返回头部添加：Access-Control-Max-Age：number。它表示预检请求的返回结果可以被缓存多久，单位是秒。该字段只对完全一样的URL的缓存设置生效，所以设置了缓存时间，在这个时间范围内，再次发送请求就不需要进行预检请求了。</p>
<h5 id=""><a href="#" class="headerlink" title=""></a></h5><h5 id="CORS中Cookie相关问题："><a href="#CORS中Cookie相关问题：" class="headerlink" title="CORS中Cookie相关问题："></a>CORS中Cookie相关问题：</h5><p>在CORS请求中，如果想要传递Cookie，就要满足以下三个条件：</p>
<ul>
<li><strong>在请求中设置</strong> <code>**withCredentials**</code></li>
</ul>
<p>默认情况下在跨域请求，浏览器是不带 cookie 的。但是我们可以通过设置 withCredentials 来进行传递 cookie.</p>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-comment">// 原生 xml 的设置方式</span><br><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-type">XMLHttpRequest</span>();<br>xhr.withCredentials = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// axios 设置方式</span><br>axios.defaults.withCredentials = <span class="hljs-literal">true</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>Access-Control-Allow-Credentials 设置为 true</strong></li>
<li><strong>Access-Control-Allow-Origin 设置为非</strong> <code>*****</code></li>
</ul>
<h4 id="（2）JSONP"><a href="#（2）JSONP" class="headerlink" title="（2）JSONP"></a>（2）JSONP</h4><p><strong>jsonp</strong>的原理就是利用<code>&lt;script&gt;</code>标签没有跨域限制，通过<code>&lt;script&gt;</code>标签src属性，发送带有callback参数的GET请求，服务端将接口返回数据拼凑到callback函数中，返回给浏览器，浏览器解析执行，从而前端拿到callback函数返回的数据。</p>
<p>1）原生JS实现：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> script = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">createElement</span>(<span class="hljs-string">&#x27;script&#x27;</span>);</span><br><span class="language-javascript">    script.<span class="hljs-property">type</span> = <span class="hljs-string">&#x27;text/javascript&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 传参一个回调函数名给后端，方便后端返回时执行这个在前端定义的回调函数</span></span><br><span class="language-javascript">    script.<span class="hljs-property">src</span> = <span class="hljs-string">&#x27;http://www.domain2.com:8080/login?user=admin&amp;callback=handleCallback&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">head</span>.<span class="hljs-title function_">appendChild</span>(script);</span><br><span class="language-javascript">    <span class="hljs-comment">// 回调执行函数</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">handleCallback</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(res));</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"> </span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>服务端返回如下（返回时即执行全局函数）：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">handleCallback</span><span class="hljs-params">(&#123;<span class="hljs-string">&quot;success&quot;</span>: true, <span class="hljs-string">&quot;user&quot;</span>: <span class="hljs-string">&quot;admin&quot;</span>&#125;)</span></span><br></code></pre></td></tr></table></figure>

<p>2）Vue axios实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span> = axios;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">$http</span>.<span class="hljs-title function_">jsonp</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080/login&#x27;</span>, &#123;<br>    <span class="hljs-attr">params</span>: &#123;&#125;,<br>    <span class="hljs-attr">jsonp</span>: <span class="hljs-string">&#x27;handleCallback&#x27;</span><br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res); <br>&#125;)<br></code></pre></td></tr></table></figure>

<p>后端node.js代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> querystring = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;querystring&#x27;</span>);<br><span class="hljs-keyword">var</span> http = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> server = http.<span class="hljs-title function_">createServer</span>();<br>server.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;request&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    <span class="hljs-keyword">var</span> params = querystring.<span class="hljs-title function_">parse</span>(req.<span class="hljs-property">url</span>.<span class="hljs-title function_">split</span>(<span class="hljs-string">&#x27;?&#x27;</span>)[<span class="hljs-number">1</span>]);<br>    <span class="hljs-keyword">var</span> fn = params.<span class="hljs-property">callback</span>;<br>    <span class="hljs-comment">// jsonp返回设置</span><br>    res.<span class="hljs-title function_">writeHead</span>(<span class="hljs-number">200</span>, &#123; <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;text/javascript&#x27;</span> &#125;);<br>    res.<span class="hljs-title function_">write</span>(fn + <span class="hljs-string">&#x27;(&#x27;</span> + <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(params) + <span class="hljs-string">&#x27;)&#x27;</span>);<br>    res.<span class="hljs-title function_">end</span>();<br>&#125;);<br>server.<span class="hljs-title function_">listen</span>(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>JSONP的缺点：</strong></p>
<ul>
<li>具有局限性， 仅支持get方法</li>
<li>不安全，可能会遭受XSS攻击</li>
</ul>
<h4 id="（3）postMessage-跨域"><a href="#（3）postMessage-跨域" class="headerlink" title="（3）postMessage 跨域"></a>（3）postMessage 跨域</h4><p>postMessage是HTML5 XMLHttpRequest Level 2中的API，且是为数不多可以跨域操作的window属性之一，它可用于解决以下方面的问题：</p>
<ul>
<li>页面和其打开的新窗口的数据传递</li>
<li>多窗口之间消息传递</li>
<li>页面与嵌套的iframe消息传递</li>
<li>上面三个场景的跨域数据传递</li>
</ul>
<p>用法：postMessage(data,origin)方法接受两个参数：</p>
<ul>
<li><strong>data</strong>： html5规范支持任意基本类型或可复制的对象，但部分浏览器只支持字符串，所以传参时最好用JSON.stringify()序列化。</li>
<li><strong>origin</strong>： 协议+主机+端口号，也可以设置为”*”，表示可以传递给任意窗口，如果要指定和当前窗口同源的话设置为”&#x2F;“。</li>
</ul>
<p>1）a.html：(domain1.com&#x2F;a.html)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript">       </span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    iframe.<span class="hljs-property">onload</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> data = &#123;</span><br><span class="language-javascript">            <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;aym&#x27;</span></span><br><span class="language-javascript">        &#125;;</span><br><span class="language-javascript">        <span class="hljs-comment">// 向domain2传送跨域数据</span></span><br><span class="language-javascript">        iframe.<span class="hljs-property">contentWindow</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain2.com&#x27;</span>);</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript">    <span class="hljs-comment">// 接受domain2返回数据</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain2 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2）b.html：(domain2.com&#x2F;b.html)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 接收domain1的数据</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (data) &#123;</span><br><span class="language-javascript">            data.<span class="hljs-property">number</span> = <span class="hljs-number">16</span>;</span><br><span class="language-javascript">            <span class="hljs-comment">// 处理后再发回domain1</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 接收domain1的数据</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from domain1 ---&gt; &#x27;</span> + e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> data = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(e.<span class="hljs-property">data</span>);</span><br><span class="language-javascript">        <span class="hljs-keyword">if</span> (data) &#123;</span><br><span class="language-javascript">            data.<span class="hljs-property">number</span> = <span class="hljs-number">16</span>;</span><br><span class="language-javascript">            <span class="hljs-comment">// 处理后再发回domain1</span></span><br><span class="language-javascript">            <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">postMessage</span>(<span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data), <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;, <span class="hljs-literal">false</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="（4）nginx代理跨域"><a href="#（4）nginx代理跨域" class="headerlink" title="（4）nginx代理跨域"></a>（4）nginx代理跨域</h4><p>nginx代理跨域，实质和CORS跨域原理一样，通过配置文件设置请求响应头Access-Control-Allow-Origin…等字段。</p>
<p>1）nginx配置解决iconfont跨域</p>
<p>浏览器跨域访问js、css、img等常规静态资源被同源策略许可，但iconfont字体文件(eot|otf|ttf|woff|svg)例外，此时可在nginx的静态资源服务器中加入以下配置。</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-keyword">location</span> <span class="hljs-title">/ &#123;</span><br><span class="hljs-title">  add_header</span> Access-Control-Allow-Origin *;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）nginx反向代理接口跨域</p>
<p>跨域问题：同源策略仅是针对浏览器的安全策略。服务器端调用HTTP接口只是使用HTTP协议，不需要同源策略，也就不存在跨域问题。</p>
<p>实现思路：通过Nginx配置一个代理服务器域名与domain1相同，端口不同）做跳板机，反向代理访问domain2接口，并且可以顺便修改cookie中domain信息，方便当前域cookie写入，实现跨域访问。</p>
<p>nginx具体配置：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-comment">#proxy服务器</span><br><span class="hljs-section">server</span> &#123;<br>    <span class="hljs-attribute">listen</span>       <span class="hljs-number">81</span>;<br>    <span class="hljs-attribute">server_name</span>  www.domain1.com;<br>    <span class="hljs-section">location</span> / &#123;<br>        <span class="hljs-attribute">proxy_pass</span>   http://www.domain2.com:8080;  <span class="hljs-comment">#反向代理</span><br>        <span class="hljs-attribute">proxy_cookie_domain</span> www.domain2.com www.domain1.com; <span class="hljs-comment">#修改cookie里域名</span><br>        <span class="hljs-attribute">index</span>  index.html index.htm;<br>        <span class="hljs-comment"># 当用webpack-dev-server等中间件代理接口访问nignx时，此时无浏览器参与，故没有同源限制，下面的跨域配置可不启用</span><br>        <span class="hljs-attribute">add_header</span> Access-Control-Allow-Origin http://www.domain1.com;  <span class="hljs-comment">#当前端只跨域不带cookie时，可为*</span><br>        <span class="hljs-attribute">add_header</span> Access-Control-Allow-Credentials <span class="hljs-literal">true</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（5）nodejs-中间件代理跨域"><a href="#（5）nodejs-中间件代理跨域" class="headerlink" title="（5）nodejs 中间件代理跨域"></a>（5）nodejs 中间件代理跨域</h4><p>node中间件实现跨域代理，原理大致与nginx相同，都是通过启一个代理服务器，实现数据的转发，也可以通过设置cookieDomainRewrite参数修改响应头中cookie中域名，实现当前域的cookie写入，方便接口登录认证。</p>
<p><strong>1）非vue框架的跨域</strong></p>
<p>使用node + express + http-proxy-middleware搭建一个proxy服务器。</p>
<ul>
<li>前端代码：</li>
</ul>
<figure class="highlight haxe"><table><tr><td class="code"><pre><code class="hljs haxe"><span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-type">XMLHttpRequest</span>();<br><span class="hljs-comment">// 前端开关：浏览器是否读写cookie</span><br>xhr.withCredentials = <span class="hljs-literal">true</span>;<br><span class="hljs-comment">// 访问http-proxy-middleware代理服务器</span><br>xhr.open(<span class="hljs-string">&#x27;get&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com:3000/login?user=admin&#x27;</span>, <span class="hljs-literal">true</span>);<br>xhr.send();<br></code></pre></td></tr></table></figure>

<ul>
<li>中间件服务器代码：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> express = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;express&#x27;</span>);<br><span class="hljs-keyword">var</span> proxy = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;http-proxy-middleware&#x27;</span>);<br><span class="hljs-keyword">var</span> app = <span class="hljs-title function_">express</span>();<br>app.<span class="hljs-title function_">use</span>(<span class="hljs-string">&#x27;/&#x27;</span>, <span class="hljs-title function_">proxy</span>(&#123;<br>    <span class="hljs-comment">// 代理跨域目标接口</span><br>    <span class="hljs-attr">target</span>: <span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>,<br>    <span class="hljs-attr">changeOrigin</span>: <span class="hljs-literal">true</span>,<br>    <span class="hljs-comment">// 修改响应头信息，实现跨域并允许带cookie</span><br>    <span class="hljs-attr">onProxyRes</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">proxyRes, req, res</span>) &#123;<br>        res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Origin&#x27;</span>, <span class="hljs-string">&#x27;http://www.domain1.com&#x27;</span>);<br>        res.<span class="hljs-title function_">header</span>(<span class="hljs-string">&#x27;Access-Control-Allow-Credentials&#x27;</span>, <span class="hljs-string">&#x27;true&#x27;</span>);<br>    &#125;,<br>    <span class="hljs-comment">// 修改响应信息中的cookie域名</span><br>    <span class="hljs-attr">cookieDomainRewrite</span>: <span class="hljs-string">&#x27;www.domain1.com&#x27;</span>  <span class="hljs-comment">// 可以为false，表示不修改</span><br>&#125;));<br>app.<span class="hljs-title function_">listen</span>(<span class="hljs-number">3000</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Proxy server is listen at port 3000...&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p><strong>2）vue框架的跨域</strong></p>
<p>node + vue + webpack + webpack-dev-server搭建的项目，跨域请求接口，直接修改webpack.config.js配置。开发环境下，vue渲染服务和接口代理服务都是webpack-dev-server同一个，所以页面与代理接口之间不再跨域。</p>
<p>webpack.config.js部分配置：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">module.exports</span> <span class="hljs-string">=</span> &#123;<br>    <span class="hljs-attr">entry:</span> &#123;&#125;,<br>    <span class="hljs-attr">module:</span> &#123;&#125;,<br>    <span class="hljs-string">...</span><br>    <span class="hljs-attr">devServer:</span> &#123;<br>        <span class="hljs-attr">historyApiFallback:</span> <span class="hljs-literal">true</span>,<br>        <span class="hljs-attr">proxy:</span> [&#123;<br>            <span class="hljs-attr">context:</span> <span class="hljs-string">&#x27;/login&#x27;</span>,<br>            <span class="hljs-attr">target:</span> <span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>,  <span class="hljs-string">//</span> <span class="hljs-string">代理跨域目标接口</span><br>            <span class="hljs-attr">changeOrigin:</span> <span class="hljs-literal">true</span>,<br>            <span class="hljs-attr">secure:</span> <span class="hljs-literal">false</span>,  <span class="hljs-string">//</span> <span class="hljs-string">当代理某些https服务报错时用</span><br>            <span class="hljs-attr">cookieDomainRewrite:</span> <span class="hljs-string">&#x27;www.domain1.com&#x27;</span>  <span class="hljs-string">//</span> <span class="hljs-string">可以为false，表示不修改</span><br>        &#125;],<br>        <span class="hljs-attr">noInfo:</span> <span class="hljs-literal">true</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（6）document-domain-iframe跨域"><a href="#（6）document-domain-iframe跨域" class="headerlink" title="（6）document.domain + iframe跨域"></a>（6）document.domain + iframe跨域</h4><p>此方案仅限主域相同，子域不同的跨域应用场景。实现原理：两个页面都通过js强制设置document.domain为基础主域，就实现了同域。</p>
<p>1）父窗口：(domain.com&#x2F;a.html)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://child.domain.com/b.html&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;domain.com&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> user = <span class="hljs-string">&#x27;admin&#x27;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>1）子窗口：(child.domain.com&#x2F;a.html)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">document</span>.<span class="hljs-property">domain</span> = <span class="hljs-string">&#x27;domain.com&#x27;</span>;</span><br><span class="language-javascript">    <span class="hljs-comment">// 获取父窗口中变量</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;get js data from parent ---&gt; &#x27;</span> + <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">user</span>);</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="（7）location-hash-iframe跨域"><a href="#（7）location-hash-iframe跨域" class="headerlink" title="（7）location.hash + iframe跨域"></a>（7）location.hash + iframe跨域</h4><p>实现原理：a欲与b跨域相互通信，通过中间页c来实现。 三个页面，不同域之间利用iframe的location.hash传值，相同域之间直接js访问来通信。</p>
<p>具体实现：A域：a.html -&gt; B域：b.html -&gt; A域：c.html，a与b不同域只能通过hash值单向通信，b与c也不同域也只能单向通信，但c与a同域，所以c可通过parent.parent访问a页面所有对象。</p>
<p>1）a.html：(domain1.com&#x2F;a.html)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain2.com/b.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 向b.html传hash值</span></span><br><span class="language-javascript">    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        iframe.<span class="hljs-property">src</span> = iframe.<span class="hljs-property">src</span> + <span class="hljs-string">&#x27;#user=admin&#x27;</span>;</span><br><span class="language-javascript">    &#125;, <span class="hljs-number">1000</span>);</span><br><span class="language-javascript">    </span><br><span class="language-javascript">    <span class="hljs-comment">// 开放给同域c.html的回调方法</span></span><br><span class="language-javascript">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">onCallback</span>(<span class="hljs-params">res</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">alert</span>(<span class="hljs-string">&#x27;data from c.html ---&gt; &#x27;</span> + res);</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2）b.html：(.domain2.com&#x2F;b.html)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">iframe</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;iframe&quot;</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;http://www.domain1.com/c.html&quot;</span> <span class="hljs-attr">style</span>=<span class="hljs-string">&quot;display:none;&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">iframe</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-keyword">var</span> iframe = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;iframe&#x27;</span>);</span><br><span class="language-javascript">    <span class="hljs-comment">// 监听a.html传来的hash值，再传给c.html</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        iframe.<span class="hljs-property">src</span> = iframe.<span class="hljs-property">src</span> + location.<span class="hljs-property">hash</span>;</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>3）c.html：(<a href="https://link.zhihu.com/?target=http://www.domain1.com/c.html">http://www.domain1.com/c.html</a>)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-comment">// 监听b.html传来的hash值</span></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">onhashchange</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-comment">// 再通过操作同域a.html的js回调，将结果传回</span></span><br><span class="language-javascript">        <span class="hljs-variable language_">window</span>.<span class="hljs-property">parent</span>.<span class="hljs-property">parent</span>.<span class="hljs-title function_">onCallback</span>(<span class="hljs-string">&#x27;hello: &#x27;</span> + location.<span class="hljs-property">hash</span>.<span class="hljs-title function_">replace</span>(<span class="hljs-string">&#x27;#user=&#x27;</span>, <span class="hljs-string">&#x27;&#x27;</span>));</span><br><span class="language-javascript">    &#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h4 id="（8）window-name-iframe跨域"><a href="#（8）window-name-iframe跨域" class="headerlink" title="（8）window.name + iframe跨域"></a>（8）window.name + iframe跨域</h4><p>window.name属性的独特之处：name值在不同的页面（甚至不同域名）加载后依旧存在，并且可以支持非常长的 name 值（2MB）。</p>
<p>1）a.html：(domain1.com&#x2F;a.html)</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">var</span> proxy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">url, callback</span>) </span>&#123;<br>    <span class="hljs-keyword">var</span> state = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">var</span> iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">&#x27;iframe&#x27;</span>);<br>    <span class="hljs-comment">// 加载跨域页面</span><br>    iframe.src = <span class="hljs-built_in">url</span>;<br>    <span class="hljs-comment">// onload事件会触发2次，第1次加载跨域页，并留存数据于window.name</span><br>    iframe.onload = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>&#123;<br>        <span class="hljs-keyword">if</span> (state === <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-comment">// 第2次onload(同域proxy页)成功后，读取同域window.name中数据</span><br>            callback(iframe.contentWindow.name);<br>            destoryFrame();<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (state === <span class="hljs-number">0</span>) &#123;<br>            <span class="hljs-comment">// 第1次onload(跨域页)成功后，切换到同域代理页面</span><br>            iframe.contentWindow.location = <span class="hljs-string">&#x27;http://www.domain1.com/proxy.html&#x27;</span>;<br>            state = <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;;<br>    <span class="hljs-built_in">document</span>.body.appendChild(iframe);<br>    <span class="hljs-comment">// 获取数据以后销毁这个iframe，释放内存；这也保证了安全（不被其他域frame js访问）</span><br>    <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">destoryFrame</span>(<span class="hljs-params"></span>) </span>&#123;<br>        iframe.contentWindow.document.write(<span class="hljs-string">&#x27;&#x27;</span>);<br>        iframe.contentWindow.close();<br>        <span class="hljs-built_in">document</span>.body.removeChild(iframe);<br>    &#125;<br>&#125;;<br><span class="hljs-comment">// 请求跨域b页面数据</span><br>proxy(<span class="hljs-string">&#x27;http://www.domain2.com/b.html&#x27;</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">data</span>)</span>&#123;<br>    alert(data);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>2）proxy.html：(domain1.com&#x2F;proxy.html)</p>
<p>中间代理页，与a.html同域，内容为空即可。</p>
<p>3）b.html：(domain2.com&#x2F;b.html)</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">    <span class="hljs-variable language_">window</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;This is domain2 data!&#x27;</span>;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>通过iframe的src属性由外域转向本地域，跨域数据即由iframe的window.name从外域传递到本地域。这个就巧妙地绕过了浏览器的跨域访问限制，但同时它又是安全操作。</p>
<h4 id="（9）WebSocket协议跨域"><a href="#（9）WebSocket协议跨域" class="headerlink" title="（9）WebSocket协议跨域"></a>（9）WebSocket协议跨域</h4><p>WebSocket protocol是HTML5一种新的协议。它实现了浏览器与服务器全双工通信，同时允许跨域通讯，是server push技术的一种很好的实现。</p>
<p>原生WebSocket API使用起来不太方便，我们使用Socket.io，它很好地封装了webSocket接口，提供了更简单、灵活的接口，也对不支持webSocket的浏览器提供了向下兼容。</p>
<p>1）前端代码：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>user input：<span class="hljs-tag">&lt;<span class="hljs-name">input</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;text&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;https://cdn.bootcss.com/socket.io/2.2.0/socket.io.js&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> socket = <span class="hljs-title function_">io</span>(<span class="hljs-string">&#x27;http://www.domain2.com:8080&#x27;</span>);</span><br><span class="language-javascript"><span class="hljs-comment">// 连接成功处理</span></span><br><span class="language-javascript">socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;connect&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    <span class="hljs-comment">// 监听服务端消息</span></span><br><span class="language-javascript">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;data from server: ---&gt; &#x27;</span> + msg); </span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">    <span class="hljs-comment">// 监听服务端关闭</span></span><br><span class="language-javascript">    socket.<span class="hljs-title function_">on</span>(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123; </span><br><span class="language-javascript">        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;Server socket has closed.&#x27;</span>); </span><br><span class="language-javascript">    &#125;);</span><br><span class="language-javascript">&#125;);</span><br><span class="language-javascript"><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementsByTagName</span>(<span class="hljs-string">&#x27;input&#x27;</span>)[<span class="hljs-number">0</span>].<span class="hljs-property">onblur</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">    socket.<span class="hljs-title function_">send</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>2）Nodejs socket后台：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> http = require(<span class="hljs-string">&#x27;http&#x27;</span>);<br><span class="hljs-keyword">var</span> socket = require(<span class="hljs-string">&#x27;socket.io&#x27;</span>);<br><span class="hljs-comment">// 启http服务</span><br><span class="hljs-keyword">var</span> server = http.createServer(<span class="hljs-keyword">function</span>(<span class="hljs-params">req, res</span>) &#123;<br>    res.writeHead(<span class="hljs-number">200</span>, &#123;<br>        <span class="hljs-string">&#x27;Content-type&#x27;</span>: <span class="hljs-string">&#x27;text/html&#x27;</span><br>    &#125;);<br>    res.end();<br>&#125;);<br>server.listen(<span class="hljs-string">&#x27;8080&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Server is running at port 8080...&#x27;</span>);<br><span class="hljs-comment">// 监听socket连接</span><br>socket.listen(server).on(<span class="hljs-string">&#x27;connection&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">client</span>) &#123;<br>    <span class="hljs-comment">// 接收信息</span><br>    client.on(<span class="hljs-string">&#x27;message&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>) &#123;<br>        client.send(<span class="hljs-string">&#x27;hello：&#x27;</span> + msg);<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;data from client: ---&gt; &#x27;</span> + msg);<br>    &#125;);<br>    <span class="hljs-comment">// 断开处理</span><br>    client.on(<span class="hljs-string">&#x27;disconnect&#x27;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Client socket has closed.&#x27;</span>); <br>    &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<h3 id="3-正向代理和反向代理的区别"><a href="#3-正向代理和反向代理的区别" class="headerlink" title="3. 正向代理和反向代理的区别"></a>3. 正向代理和反向代理的区别</h3><ul>
<li><strong>正向代理：</strong></li>
</ul>
<p>客户端想获得一个服务器的数据，但是因为种种原因无法直接获取。于是客户端设置了一个代理服务器，并且指定目标服务器，之后代理服务器向目标服务器转交请求并将获得的内容发送给客户端。这样本质上起到了对真实服务器隐藏真实客户端的目的。实现正向代理需要修改客户端，比如修改浏览器配置。</p>
<ul>
<li><strong>反向代理：</strong></li>
</ul>
<p>服务器为了能够将工作负载分不到多个服务器来提高网站性能 (负载均衡)等目的，当其受到请求后，会首先根据转发规则来确定请求应该被转发到哪个服务器上，然后将请求转发到对应的真实服务器上。这样本质上起到了对客户端隐藏真实服务器的作用。</p>
<p>一般使用反向代理后，需要通过修改 DNS 让域名解析到代理服务器 IP，这时浏览器无法察觉到真正服务器的存在，当然也就不需要修改配置了。</p>
<p>两者区别如图示：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/jpeg/1500604/1605256274960-50bd9e69-dde9-4782-b2c0-6afc8188fca2.jpeg"  ><span class="image-caption">image</span></p>
<p>正向代理和反向代理的结构是一样的，都是 client-proxy-server 的结构，它们主要的区别就在于中间这个 proxy 是哪一方设置的。在正向代理中，proxy 是 client 设置的，用来隐藏 client；而在反向代理中，proxy 是 server 设置的，用来隐藏 server。</p>
<h3 id="4-Nginx的概念及其工作原理"><a href="#4-Nginx的概念及其工作原理" class="headerlink" title="4. Nginx的概念及其工作原理"></a>4. Nginx的概念及其工作原理</h3><p>Nginx 是一款轻量级的 Web 服务器，也可以用于反向代理、负载平衡和 HTTP 缓存等。Nginx 使用异步事件驱动的方法来处理请求，是一款面向性能设计的 HTTP 服务器。</p>
<p>传统的 Web 服务器如 Apache 是 process-based 模型的，而 Nginx 是基于event-driven模型的。正是这个主要的区别带给了 Nginx 在性能上的优势。</p>
<p>Nginx 架构的最顶层是一个 master process，这个 master process 用于产生其他的 worker process，这一点和Apache 非常像，但是 Nginx 的 worker process 可以同时处理大量的HTTP请求，而每个 Apache process 只能处理一个。</p>
<h2 id="八、浏览器事件机制"><a href="#八、浏览器事件机制" class="headerlink" title="八、浏览器事件机制"></a>八、浏览器事件机制</h2><h3 id="1-事件是什么？事件模型？"><a href="#1-事件是什么？事件模型？" class="headerlink" title="1. 事件是什么？事件模型？"></a>1. 事件是什么？事件模型？</h3><p>事件是用户操作网页时发生的交互动作，比如 click&#x2F;move， 事件除了用户触发的动作外，还可以是文档加载，窗口滚动和大小调整。事件被封装成一个 event 对象，包含了该事件发生时的所有相关信息（ event 的属性）以及可以对事件进行的操作（ event 的方法）。</p>
<p>事件是用户操作网页时发生的交互动作或者网页本身的一些操作，现代浏览器一共有三种事件模型：</p>
<ul>
<li><strong>DOM0 级事件模型</strong>，这种模型不会传播，所以没有事件流的概念，但是现在有的浏览器支持以冒泡的方式实现，它可以在网页中直接定义监听函数，也可以通过 js 属性来指定监听函数。所有浏览器都兼容这种方式。直接在dom对象上注册事件名称，就是DOM0写法。</li>
<li><strong>IE 事件模型</strong>，在该事件模型中，一次事件共有两个过程，事件处理阶段和事件冒泡阶段。事件处理阶段会首先执行目标元素绑定的监听事件。然后是事件冒泡阶段，冒泡指的是事件从目标元素冒泡到 document，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。这种模型通过attachEvent 来添加监听函数，可以添加多个监听函数，会按顺序依次执行。</li>
<li><strong>DOM2 级事件模型</strong>，在该事件模型中，一次事件共有三个过程，第一个过程是事件捕获阶段。捕获指的是事件从 document 一直向下传播到目标元素，依次检查经过的节点是否绑定了事件监听函数，如果有则执行。后面两个阶段和 IE 事件模型的两个阶段相同。这种事件模型，事件绑定的函数是addEventListener，其中第三个参数可以指定事件是否在捕获阶段执行。</li>
</ul>
<h3 id="2-如何阻止事件冒泡"><a href="#2-如何阻止事件冒泡" class="headerlink" title="2. 如何阻止事件冒泡"></a>2. 如何阻止事件冒泡</h3><ul>
<li>普通浏览器使用：event.stopPropagation() </li>
<li>IE浏览器使用：event.cancelBubble &#x3D; true;</li>
</ul>
<h3 id="3-对事件委托的理解"><a href="#3-对事件委托的理解" class="headerlink" title="3. 对事件委托的理解"></a>3. 对事件委托的理解</h3><h4 id="（1）事件委托的概念"><a href="#（1）事件委托的概念" class="headerlink" title="（1）事件委托的概念"></a>（1）事件委托的概念</h4><p>事件委托本质上是利用了<strong>浏览器事件冒泡</strong>的机制。因为事件在冒泡过程中会上传到父节点，父节点可以通过事件对象获取到目标节点，因此可以把子节点的监听函数定义在父节点上，由父节点的监听函数统一处理多个子元素的事件，这种方式称为事件委托（事件代理）。</p>
<p>使用事件委托可以不必要为每一个子元素都绑定一个监听事件，这样减少了内存上的消耗。并且使用事件代理还可以实现事件的动态绑定，比如说新增了一个子节点，并不需要单独地为它添加一个监听事件，它绑定的事件会交给父元素中的监听函数来处理。</p>
<h4 id="（2）事件委托的特点"><a href="#（2）事件委托的特点" class="headerlink" title="（2）事件委托的特点"></a>（2）事件委托的特点</h4><ul>
<li><strong>减少内存消耗</strong></li>
</ul>
<p>如果有一个列表，列表之中有大量的列表项，需要在点击列表项的时候响应一个事件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;list&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item 3<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br>  ......<br>  <span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>item n<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>如果给每个列表项一一都绑定一个函数，那对于内存消耗是非常大的，效率上需要消耗很多性能。因此，比较好的方法就是把这个点击事件绑定到他的父层，也就是 ul 上，然后在执行事件时再去匹配判断目标元素，所以事件委托可以减少大量的内存消耗，节约效率。</p>
<ul>
<li><strong>动态绑定事件</strong></li>
</ul>
<p>给上述的例子中每个列表项都绑定事件，在很多时候，需要通过 AJAX 或者用户操作动态的增加或者去除列表项元素，那么在每一次改变的时候都需要重新给新增的元素绑定事件，给即将删去的元素解绑事件；如果用了事件委托就没有这种麻烦了，因为事件是绑定在父层的，和目标元素的增减是没有关系的，执行到目标元素是在真正响应执行事件函数的过程中去匹配的，所以使用事件在动态绑定事件的情况下是可以减少很多重复工作的。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 来实现把 #list 下的 li 元素的事件代理委托到它的父层元素也就是 #list 上：</span><br><span class="hljs-comment">// 给父层元素绑定事件</span><br><span class="hljs-variable language_">document</span>.<span class="hljs-title function_">getElementById</span>(<span class="hljs-string">&#x27;list&#x27;</span>).<span class="hljs-title function_">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, <span class="hljs-keyword">function</span> (<span class="hljs-params">e</span>) &#123;<br>  <span class="hljs-comment">// 兼容性处理</span><br>  <span class="hljs-keyword">var</span> event = e || <span class="hljs-variable language_">window</span>.<span class="hljs-property">event</span>;<br>  <span class="hljs-keyword">var</span> target = event.<span class="hljs-property">target</span> || event.<span class="hljs-property">srcElement</span>;<br>  <span class="hljs-comment">// 判断是否匹配目标元素</span><br>  <span class="hljs-keyword">if</span> (target.<span class="hljs-property">nodeName</span>.<span class="hljs-property">toLocaleLowerCase</span> === <span class="hljs-string">&#x27;li&#x27;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;the content is: &#x27;</span>, target.<span class="hljs-property">innerHTML</span>);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>在上述代码中， target 元素则是在 #list 元素之下具体被点击的元素，然后通过判断 target 的一些属性（比如：nodeName，id 等等）可以更精确地匹配到某一类 #list li 元素之上；</p>
<h4 id="（3）局限性"><a href="#（3）局限性" class="headerlink" title="（3）局限性"></a>（3）局限性</h4><p>当然，事件委托也是有局限的。比如 focus、blur 之类的事件没有事件冒泡机制，所以无法实现事件委托；mousemove、mouseout 这样的事件，虽然有事件冒泡，但是只能不断通过位置去计算定位，对性能消耗高，因此也是不适合于事件委托的。</p>
<p>当然事件委托不是只有优点，它也是有<strong>缺点</strong>的，事件委托会影响页面性能，主要影响因素有：</p>
<ul>
<li>元素中，绑定事件委托的次数；</li>
<li>点击的最底层元素，到绑定事件元素之间的<code>DOM</code>层数；</li>
</ul>
<p>在必须使用事件委托的地方，可以进行如下的处理：</p>
<ul>
<li>只在必须的地方，使用事件委托，比如：<code>ajax</code>的局部刷新区域</li>
<li>尽量的减少绑定的层级，不在<code>body</code>元素上，进行绑定</li>
<li>减少绑定的次数，如果可以，那么把多个事件的绑定，合并到一次事件委托中去，由这个事件委托的回调，来进行分发。</li>
</ul>
<h3 id="4-事件委托的使用场景"><a href="#4-事件委托的使用场景" class="headerlink" title="4. 事件委托的使用场景"></a>4. 事件委托的使用场景</h3><p>场景：给页面的所有的a标签添加click事件，代码如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">document.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">if</span> (e.target.nodeName == <span class="hljs-string">&quot;A&quot;</span>)<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<p>但是这些a标签可能包含一些像span、img等元素，如果点击到了这些a标签中的元素，就不会触发click事件，因为事件绑定上在a标签元素上，而触发这些内部的元素时，e.target指向的是触发click事件的元素（span、img等其他元素）。</p>
<p>这种情况下就可以使用事件委托来处理，将事件绑定在a标签的内部元素上，当点击它的时候，就会逐级向上查找，知道找到a标签为止，代码如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">document.addEventListener(<span class="hljs-string">&quot;click&quot;</span>, <span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) &#123;<br>    <span class="hljs-keyword">var</span> node = e.target;<br>    <span class="hljs-keyword">while</span> (node.parentNode.nodeName != <span class="hljs-string">&quot;BODY&quot;</span>) &#123;<br>        <span class="hljs-keyword">if</span> (node.nodeName == <span class="hljs-string">&quot;A&quot;</span>) &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;a&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br>        node = node.parentNode;<br>    &#125;<br>&#125;, <span class="hljs-literal">false</span>);<br></code></pre></td></tr></table></figure>

<h3 id="5-同步和异步的区别"><a href="#5-同步和异步的区别" class="headerlink" title="5. 同步和异步的区别"></a>5. 同步和异步的区别</h3><ul>
<li><strong>同步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，那么这个进程会一直等待下去，直到消息返回为止再继续向下执行。</li>
<li><strong>异步</strong>指的是当一个进程在执行某个请求时，如果这个请求需要等待一段时间才能返回，这个时候进程会继续往下执行，不会阻塞等待消息的返回，当消息返回时系统再通知进程进行处理。</li>
</ul>
<h3 id="6-对事件循环的理解"><a href="#6-对事件循环的理解" class="headerlink" title="6. 对事件循环的理解"></a>6. 对事件循环的理解</h3><p>因为 js 是单线程运行的，在代码执行时，通过将不同函数的执行上下文压入执行栈中来保证代码的有序执行。在执行同步代码时，如果遇到异步事件，js 引擎并不会一直等待其返回结果，而是会将这个事件挂起，继续执行执行栈中的其他任务。当异步事件执行完毕后，再将异步事件对应的回调加入到一个任务队列中等待执行。任务队列可以分为宏任务队列和微任务队列，当当前执行栈中的事件执行完毕后，js 引擎首先会判断微任务队列中是否有任务可以执行，如果有就将微任务队首的事件压入栈中执行。当微任务队列中的任务都执行完成后再去执行宏任务队列中的任务。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476500217-472563e1-de67-403f-baa7-0fd574d0e618.png?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image</span></p>
<p>Event Loop 执行顺序如下所示：</p>
<ul>
<li>首先执行同步代码，这属于宏任务</li>
<li>当执行完所有同步代码后，执行栈为空，查询是否有异步代码需要执行</li>
<li>执行所有微任务</li>
<li>当执行完所有微任务后，如有必要会渲染页面</li>
<li>然后开始下一轮 Event Loop，执行宏任务中的异步代码</li>
</ul>
<h3 id="7-宏任务和微任务分别有哪些"><a href="#7-宏任务和微任务分别有哪些" class="headerlink" title="7. 宏任务和微任务分别有哪些"></a>7. 宏任务和微任务分别有哪些</h3><ul>
<li>微任务包括： promise 的回调、node 中的 process.nextTick 、对 Dom 变化监听的 MutationObserver。</li>
<li>宏任务包括： script 脚本的执行、setTimeout ，setInterval ，setImmediate 一类的定时事件，还有如 I&#x2F;O 操作、UI 渲染等。</li>
</ul>
<h3 id="8-什么是执行栈"><a href="#8-什么是执行栈" class="headerlink" title="8. 什么是执行栈"></a>8. 什么是执行栈</h3><p>可以把执行栈认为是一个存储函数调用的<strong>栈结构</strong>，遵循先进后出的原则。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/gif/1500604/1615476375478-4f0a93a1-de5e-4536-9bbe-4e69c1f91773.gif"  ><span class="image-caption">image</span></p>
<p>当开始执行 JS 代码时，根据先进后出的原则，后执行的函数会先弹出栈，可以看到，<code>foo</code> 函数后执行，当执行完毕后就从栈中弹出了。</p>
<p>平时在开发中，可以在报错中找到执行栈的痕迹：</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">foo</span>() &#123;<br>  throw new <span class="hljs-built_in">Error</span>(&#x27;error&#x27;)<br>&#125;<br>function <span class="hljs-built_in">bar</span>() &#123;<br>  <span class="hljs-built_in">foo</span>()<br>&#125;<br><span class="hljs-built_in">bar</span>()<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476375462-269c6a54-a21d-460c-aa82-a713ef9a2999.png"  ><span class="image-caption">img</span></p>
<p>可以看到报错在 <code>foo</code> 函数，<code>foo</code> 函数又是在 <code>bar</code> 函数中调用的。当使用递归时，因为栈可存放的函数是有<strong>限制</strong>的，一旦存放了过多的函数且没有得到释放的话，就会出现爆栈的问题</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">bar</span>() &#123;<br>  <span class="hljs-built_in">bar</span>()<br>&#125;<br><span class="hljs-built_in">bar</span>()<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476375388-2867ba62-cf27-4740-91fd-485f0ae12986.png"  ><span class="image-caption">img</span></p>
<h3 id="9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？"><a href="#9-Node-中的-Event-Loop-和浏览器中的有什么区别？process-nextTick-执行顺序？" class="headerlink" title="9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？"></a>9. Node 中的 Event Loop 和浏览器中的有什么区别？process.nextTick 执行顺序？</h3><p>Node 中的 Event Loop 和浏览器中的是完全不相同的东西。</p>
<p>Node 的 Event Loop 分为 6 个阶段，它们会按照<strong>顺序</strong>反复运行。每当进入某一个阶段的时候，都会从对应的回调队列中取出函数去执行。当队列为空或者执行的回调函数数量到达系统设定的阈值，就会进入下一阶段。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476641904-a9763034-9114-4a7c-aa50-1bdb612f2f5e.png"  ><span class="image-caption">image</span></p>
<p>（1）<strong>Timers（计时器阶段）</strong>：初次进入事件循环，会从计时器阶段开始。此阶段会判断是否存在过期的计时器回调（包含 setTimeout 和 setInterval），如果存在则会执行所有过期的计时器回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Pending callbacks 阶段。</p>
<p>（2）<strong>Pending callbacks</strong>：执行推迟到下一个循环迭代的I &#x2F; O回调（系统调用相关的回调）。</p>
<p>（3）<strong>Idle&#x2F;Prepare</strong>：仅供内部使用。</p>
<p>（4）<strong>Poll（轮询阶段）</strong>：</p>
<ul>
<li>当回调队列不为空时：会执行回调，若回调中触发了相应的微任务，这里的微任务执行时机和其他地方有所不同，不会等到所有回调执行完毕后才执行，而是针对每一个回调执行完毕后，就执行相应微任务。执行完所有的回调后，变为下面的情况。</li>
<li>当回调队列为空时（没有回调或所有回调执行完毕）：但如果存在有计时器（setTimeout、setInterval和setImmediate）没有执行，会结束轮询阶段，进入 Check 阶段。否则会阻塞并等待任何正在执行的I&#x2F;O操作完成，并马上执行相应的回调，直到所有回调执行完毕。</li>
</ul>
<p>（5）<strong>Check（查询阶段）</strong>：会检查是否存在 setImmediate 相关的回调，如果存在则执行所有回调，执行完毕后，如果回调中触发了相应的微任务，会接着执行所有微任务，执行完微任务后再进入 Close callbacks 阶段。</p>
<p>（6）<strong>Close callbacks</strong>：执行一些关闭回调，比如socket.on(‘close’, …)等。</p>
<p>下面来看一个例子，首先在有些情况下，定时器的执行顺序其实是<strong>随机</strong>的</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setTimeout&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br>setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;setImmediate&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>对于以上代码来说，<code>setTimeout</code> 可能执行在前，也可能执行在后</p>
<ul>
<li>首先 <code>setTimeout(fn, 0) === setTimeout(fn, 1)</code>，这是由源码决定的</li>
<li>进入事件循环也是需要成本的，如果在准备时候花费了大于 1ms 的时间，那么在 timer 阶段就会直接执行 <code>setTimeout</code> 回调</li>
<li>那么如果准备时间花费小于 1ms，那么就是 <code>setImmediate</code> 回调先执行了</li>
</ul>
<p>当然在某些情况下，他们的执行顺序一定是固定的，比如以下代码：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const fs = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;fs&#x27;</span>)<br>fs.readFile(__filename, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;timeout&#x27;</span>);<br>    &#125;, <span class="hljs-number">0</span>)<br>    setImmediate(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        console.log(<span class="hljs-string">&#x27;immediate&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>在上述代码中，<code>setImmediate</code> 永远<strong>先执行</strong>。因为两个代码写在 IO 回调中，IO 回调是在 poll 阶段执行，当回调执行完毕后队列为空，发现存在 <code>setImmediate</code> 回调，所以就直接跳转到 check 阶段去执行回调了。</p>
<p>上面都是 macrotask 的执行情况，对于 microtask 来说，它会在以上每个阶段完成前<strong>清空</strong> microtask 队列，下图中的 Tick 就代表了 microtask</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615476641927-75409d91-38a1-4797-aa75-cb02dd95d732.png"  ><span class="image-caption">image</span></p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer21&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br>Promise.resolve().then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>对于以上代码来说，其实和浏览器中的输出是一样的，microtask 永远执行在 macrotask 前面。</p>
<p>最后来看 Node 中的 <code>process.nextTick</code>，这个函数其实是独立于 Event Loop 之外的，它有一个自己的队列，当每个阶段完成后，如果存在 nextTick 队列，就会<strong>清空队列中的所有回调函数</strong>，并且优先于其他 microtask 执行。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br> Promise.resolve().then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br> &#125;)<br>&#125;, <span class="hljs-number">0</span>)<br>process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br> process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>   process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>     process.nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;nextTick&#x27;</span>)<br>     &#125;)<br>   &#125;)<br> &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>对于以上代码，永远都是先把 nextTick 全部打印出来。</p>
<h3 id="10-事件触发的过程是怎样的"><a href="#10-事件触发的过程是怎样的" class="headerlink" title="10. 事件触发的过程是怎样的"></a>10. 事件触发的过程是怎样的</h3><p>事件触发有三个阶段：</p>
<ul>
<li><code>window</code> 往事件触发处传播，遇到注册的捕获事件会触发</li>
<li>传播到事件触发处时触发注册的事件</li>
<li>从事件触发处往 <code>window</code> 传播，遇到注册的冒泡事件会触发</li>
</ul>
<p>事件触发一般来说会按照上面的顺序进行，但是也有特例，<strong>如果给一个</strong> <code>**body**</code> <strong>中的子节点同时注册冒泡和捕获事件，事件触发会按照注册的顺序执行。</strong></p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 以下会先打印冒泡然后是捕获</span><br>node.addEventListener(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  event =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;冒泡&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>)<br>node.addEventListener(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  event =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;捕获 &#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure>

<p>通常使用 <code>addEventListener</code> 注册事件，该函数的第三个参数可以是布尔值，也可以是对象。对于布尔值 <code>useCapture</code> 参数来说，该参数默认值为 <code>false</code> ，<code>useCapture</code> 决定了注册的事件是捕获事件还是冒泡事件。对于对象参数来说，可以使用以下几个属性：</p>
<ul>
<li><code>capture</code>：布尔值，和 <code>useCapture</code> 作用一样</li>
<li><code>once</code>：布尔值，值为 <code>true</code> 表示该回调只会调用一次，调用后会移除监听</li>
<li><code>passive</code>：布尔值，表示永远不会调用 <code>preventDefault</code></li>
</ul>
<p>一般来说，如果只希望事件只触发在目标上，这时候可以使用 <code>stopPropagation</code> 来阻止事件的进一步传播。通常认为 <code>stopPropagation</code> 是用来阻止事件冒泡的，其实该函数也可以阻止捕获事件。</p>
<p><code>stopImmediatePropagation</code> 同样也能实现阻止事件，但是还能阻止该事件目标执行别的注册事件。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">node.addEventListener(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  event =&gt; &#123;<br>    event.stopImmediatePropagation()<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;冒泡&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">false</span><br>)<br><span class="hljs-comment">// 点击 node 只会执行上面的函数，该函数不会执行</span><br>node.addEventListener(<br>  <span class="hljs-string">&#x27;click&#x27;</span>,<br>  event =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;捕获 &#x27;</span>)<br>  &#125;,<br>  <span class="hljs-literal">true</span><br>)<br></code></pre></td></tr></table></figure>

<h2 id="九、浏览器垃圾回收机制"><a href="#九、浏览器垃圾回收机制" class="headerlink" title="九、浏览器垃圾回收机制"></a>九、浏览器垃圾回收机制</h2><h3 id="1-V8的垃圾回收机制是怎样的"><a href="#1-V8的垃圾回收机制是怎样的" class="headerlink" title="1. V8的垃圾回收机制是怎样的"></a>1. V8的垃圾回收机制是怎样的</h3><p>V8 实现了准确式 GC，GC 算法采用了分代式垃圾回收机制。因此，V8 将内存（堆）分为新生代和老生代两部分。</p>
<p><strong>（1）新生代算法</strong></p>
<p>新生代中的对象一般存活时间较短，使用 Scavenge GC 算法。</p>
<p>在新生代空间中，内存空间分为两部分，分别为 From 空间和 To 空间。在这两个空间中，必定有一个空间是使用的，另一个空间是空闲的。新分配的对象会被放入 From 空间中，当 From 空间被占满时，新生代 GC 就会启动了。算法会检查 From 空间中存活的对象并复制到 To 空间中，如果有失活的对象就会销毁。当复制完成后将 From 空间和 To 空间互换，这样 GC 就结束了。</p>
<p><strong>（2）老生代算法</strong></p>
<p>老生代中的对象一般存活时间较长且数量也多，使用了两个算法，分别是标记清除算法和标记压缩算法。</p>
<p>先来说下什么情况下对象会出现在老生代空间中：</p>
<ul>
<li>新生代中的对象是否已经经历过一次 Scavenge 算法，如果经历过的话，会将对象从新生代空间移到老生代空间中。</li>
<li>To 空间的对象占比大小超过 25 %。在这种情况下，为了不影响到内存分配，会将对象从新生代空间移到老生代空间中。</li>
</ul>
<p>老生代中的空间很复杂，有如下几个空间</p>
<figure class="highlight thrift"><table><tr><td class="code"><pre><code class="hljs thrift"><span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">AllocationSpace</span> </span>&#123;<br>  <span class="hljs-comment">// TODO(v8:7464): Actually map this space&#x27;s memory as read-only.</span><br>  RO_SPACE,    <span class="hljs-comment">// 不变的对象空间</span><br>  NEW_SPACE,   <span class="hljs-comment">// 新生代用于 GC 复制算法的空间</span><br>  OLD_SPACE,   <span class="hljs-comment">// 老生代常驻对象空间</span><br>  CODE_SPACE,  <span class="hljs-comment">// 老生代代码对象空间</span><br>  MAP_SPACE,   <span class="hljs-comment">// 老生代 map 对象</span><br>  LO_SPACE,    <span class="hljs-comment">// 老生代大空间对象</span><br>  NEW_LO_SPACE,  <span class="hljs-comment">// 新生代大空间对象</span><br>  FIRST_SPACE = RO_SPACE,<br>  LAST_SPACE = NEW_LO_SPACE,<br>  FIRST_GROWABLE_PAGED_SPACE = OLD_SPACE,<br>  LAST_GROWABLE_PAGED_SPACE = MAP_SPACE<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>在老生代中，以下情况会先启动标记清除算法：</p>
<ul>
<li>某一个空间没有分块的时候</li>
<li>空间中被对象超过一定限制</li>
<li>空间不能保证新生代中的对象移动到老生代中</li>
</ul>
<p>在这个阶段中，会遍历堆中所有的对象，然后标记活的对象，在标记完成后，销毁所有没有被标记的对象。在标记大型对内存时，可能需要几百毫秒才能完成一次标记。这就会导致一些性能上的问题。为了解决这个问题，2011 年，V8 从 stop-the-world 标记切换到增量标志。在增量标记期间，GC 将标记工作分解为更小的模块，可以让 JS 应用逻辑在模块间隙执行一会，从而不至于让应用出现停顿情况。但在 2018 年，GC 技术又有了一个重大突破，这项技术名为并发标记。该技术可以让 GC 扫描和标记对象时，同时允许 JS 运行。</p>
<p>清除对象后会造成堆内存出现碎片的情况，当碎片超过一定限制后会启动压缩算法。在压缩过程中，将活的对象向一端移动，直到所有对象都移动完成然后清理掉不需要的内存。</p>
<h3 id="2-哪些操作会造成内存泄漏？"><a href="#2-哪些操作会造成内存泄漏？" class="headerlink" title="2. 哪些操作会造成内存泄漏？"></a>2. 哪些操作会造成内存泄漏？</h3><ul>
<li>第一种情况是由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li>第二种情况是设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li>第三种情况是获取一个 DOM 元素的引用，而后面这个元素被删除，由于我们一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li>第四种情况是不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>力扣题目</title>
    <url>/2022/08/22/LeetCode/</url>
    <content><![CDATA[<h2 id="力扣题目"><a href="#力扣题目" class="headerlink" title="力扣题目"></a>力扣题目</h2><span id="more"></span>

<table>
<thead>
<tr>
<th><strong>序号</strong></th>
<th><strong>题号</strong></th>
<th><strong>题目</strong></th>
<th><strong>难度</strong></th>
<th><strong>频度</strong></th>
<th><strong>题解</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1</td>
<td>206</td>
<td><a href="https://leetcode-cn.com/problems/reverse-linked-list">反转链表</a></td>
<td>容易</td>
<td>96</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106676536">题解</a></td>
</tr>
<tr>
<td>2</td>
<td>215</td>
<td><a href="https://leetcode-cn.com/problems/kth-largest-element-in-an-array">数组中的第K个最大元素</a></td>
<td>中等</td>
<td>85</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108436611">题解</a></td>
</tr>
<tr>
<td>3</td>
<td>3</td>
<td><a href="https://leetcode-cn.com/problems/longest-substring-without-repeating-characters">无重复字符的最长子串</a></td>
<td>中等</td>
<td>71</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/107877584">题解</a></td>
</tr>
<tr>
<td>4</td>
<td>25</td>
<td><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group">K 个一组翻转链表</a></td>
<td>困难</td>
<td>58</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108231000">题解</a></td>
</tr>
<tr>
<td>5</td>
<td>146</td>
<td><a href="https://leetcode-cn.com/problems/lru-cache">LRU缓存机制</a></td>
<td>中等</td>
<td>56</td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>15</td>
<td><a href="https://leetcode-cn.com/problems/3sum">三数之和</a></td>
<td>中等</td>
<td>52</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106596357">题解</a></td>
</tr>
<tr>
<td>7</td>
<td>121</td>
<td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock">买卖股票的最佳时机</a></td>
<td>容易</td>
<td>46</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106699551">题解</a></td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td><a href="https://leetcode-cn.com/problems/two-sum">两数之和</a></td>
<td>容易</td>
<td>44</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106595078">题解</a></td>
</tr>
<tr>
<td>9</td>
<td>142</td>
<td><a href="https://leetcode-cn.com/problems/linked-list-cycle-ii">环形链表 II</a></td>
<td>中等</td>
<td>40</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106699636">题解</a></td>
</tr>
<tr>
<td>10</td>
<td>94</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-inorder-traversal">二叉树的中序遍历</a></td>
<td>中等</td>
<td>34</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/105973380">题解</a></td>
</tr>
<tr>
<td>11</td>
<td>102</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal">二叉树的层序遍历</a></td>
<td>中等</td>
<td>34</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106008688">题解</a></td>
</tr>
<tr>
<td>12</td>
<td>236</td>
<td><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-tree">二叉树的最近公共祖先</a></td>
<td>中等</td>
<td>31</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112131073">题解</a></td>
</tr>
<tr>
<td>13</td>
<td>103</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-zigzag-level-order-traversal">二叉树的锯齿形层次遍历</a></td>
<td>中等</td>
<td>30</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108178427">题解</a></td>
</tr>
<tr>
<td>14</td>
<td>199</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-right-side-view">二叉树的右视图</a></td>
<td>中等</td>
<td>28</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108448678">题解</a></td>
</tr>
<tr>
<td>15</td>
<td>415</td>
<td><a href="https://leetcode-cn.com/problems/add-strings">字符串相加</a></td>
<td>容易</td>
<td>27</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112131112">题解</a></td>
</tr>
<tr>
<td>16</td>
<td>160</td>
<td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists">相交链表</a></td>
<td>容易</td>
<td>26</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108067127">题解</a></td>
</tr>
<tr>
<td>17</td>
<td>21</td>
<td><a href="https://leetcode-cn.com/problems/merge-two-sorted-lists">合并两个有序链表</a></td>
<td>容易</td>
<td>26</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106650834">题解</a></td>
</tr>
<tr>
<td>18</td>
<td>200</td>
<td><a href="https://leetcode-cn.com/problems/number-of-islands">岛屿数量</a></td>
<td>中等</td>
<td>25</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/107501754">题解</a></td>
</tr>
<tr>
<td>19</td>
<td>20</td>
<td><a href="https://leetcode-cn.com/problems/valid-parentheses">有效的括号</a></td>
<td>容易</td>
<td>25</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106726181">题解</a></td>
</tr>
<tr>
<td>20</td>
<td>53</td>
<td><a href="https://leetcode-cn.com/problems/maximum-subarray">最大子序和</a></td>
<td>容易</td>
<td>25</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112131118">题解</a></td>
</tr>
<tr>
<td>21</td>
<td>92</td>
<td><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii">反转链表 II</a></td>
<td>中等</td>
<td>24</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106677585">题解</a></td>
</tr>
<tr>
<td>22</td>
<td>141</td>
<td><a href="https://leetcode-cn.com/problems/linked-list-cycle">环形链表</a></td>
<td>容易</td>
<td>23</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106699551">题解</a></td>
</tr>
<tr>
<td>23</td>
<td>543</td>
<td><a href="https://leetcode-cn.com/problems/diameter-of-binary-tree">二叉树的直径</a></td>
<td>容易</td>
<td>23</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112134776">题解</a></td>
</tr>
<tr>
<td>24</td>
<td>104</td>
<td><a href="https://leetcode-cn.com/problems/maximum-depth-of-binary-tree">二叉树的最大深度</a></td>
<td>容易</td>
<td>22</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106009246">题解</a></td>
</tr>
<tr>
<td>25</td>
<td>69</td>
<td><a href="https://leetcode-cn.com/problems/sqrtx">x 的平方根</a></td>
<td>容易</td>
<td>21</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108656803">题解</a></td>
</tr>
<tr>
<td>26</td>
<td>88</td>
<td><a href="https://leetcode-cn.com/problems/merge-sorted-array">合并两个有序数组</a></td>
<td>容易</td>
<td>21</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106595622">题解</a></td>
</tr>
<tr>
<td>27</td>
<td>110</td>
<td><a href="https://leetcode-cn.com/problems/balanced-binary-tree">平衡二叉树</a></td>
<td>容易</td>
<td>21</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/107151605">题解</a></td>
</tr>
<tr>
<td>28</td>
<td>54</td>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix">螺旋矩阵</a></td>
<td>中等</td>
<td>20</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112137715">题解</a></td>
</tr>
<tr>
<td>29</td>
<td>113</td>
<td><a href="https://leetcode-cn.com/problems/path-sum-ii">路径总和 II</a></td>
<td>中等</td>
<td>20</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108458113">题解</a></td>
</tr>
<tr>
<td>30</td>
<td>98</td>
<td><a href="https://leetcode-cn.com/problems/validate-binary-search-tree">验证二叉搜索树</a></td>
<td>中等</td>
<td>20</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106980295">题解</a></td>
</tr>
<tr>
<td>31</td>
<td>42</td>
<td><a href="https://leetcode-cn.com/problems/trapping-rain-water">接雨水</a></td>
<td>困难</td>
<td>20</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112254417">题解</a></td>
</tr>
<tr>
<td>32</td>
<td>124</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-maximum-path-sum">二叉树中的最大路径和</a></td>
<td>困难</td>
<td>20</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112255014">题解</a></td>
</tr>
<tr>
<td>33</td>
<td>105</td>
<td><a href="https://leetcode-cn.com/problems/construct-binary-tree-from-preorder-and-inorder-traversal">从前序与中序遍历序列构造二叉树</a></td>
<td>中等</td>
<td>19</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108176121">题解</a></td>
</tr>
<tr>
<td>34</td>
<td>151</td>
<td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string">翻转字符串里的单词</a></td>
<td>中等</td>
<td>18</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112210308">题解</a></td>
</tr>
<tr>
<td>35</td>
<td>234</td>
<td><a href="https://leetcode-cn.com/problems/palindrome-linked-list">回文链表</a></td>
<td>容易</td>
<td>18</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108040927">题解</a></td>
</tr>
<tr>
<td>36</td>
<td>33</td>
<td><a href="https://leetcode-cn.com/problems/search-in-rotated-sorted-array">搜索旋转排序数组</a></td>
<td>中等</td>
<td>18</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108452058">题解</a></td>
</tr>
<tr>
<td>37</td>
<td>48</td>
<td><a href="https://leetcode-cn.com/problems/rotate-image">旋转图像</a></td>
<td>中等</td>
<td>17</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112446655">题解</a></td>
</tr>
<tr>
<td>38</td>
<td>剑指 Offer 22</td>
<td><a href="https://leetcode-cn.com/problems/lian-biao-zhong-dao-shu-di-kge-jie-dian-lcof">链表中倒数第k个节点</a></td>
<td>容易</td>
<td>16</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113804214">题解</a></td>
</tr>
<tr>
<td>39</td>
<td>5</td>
<td><a href="https://leetcode-cn.com/problems/longest-palindromic-substring">最长回文子串</a></td>
<td>中等</td>
<td>16</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106775026">题解</a></td>
</tr>
<tr>
<td>40</td>
<td>144</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-preorder-traversal">二叉树的前序遍历</a></td>
<td>中等</td>
<td>16</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/105970362">题解</a></td>
</tr>
<tr>
<td>41</td>
<td>232</td>
<td><a href="https://leetcode-cn.com/problems/implement-queue-using-stacks">用栈实现队列</a></td>
<td>容易</td>
<td>16</td>
<td></td>
</tr>
<tr>
<td>42</td>
<td>240</td>
<td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix-ii">搜索二维矩阵 II</a></td>
<td>中等</td>
<td>15</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113804527">题解</a></td>
</tr>
<tr>
<td>43</td>
<td>23</td>
<td><a href="https://leetcode-cn.com/problems/merge-k-sorted-lists">合并K个排序链表</a></td>
<td>困难</td>
<td>15</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108446322">题解</a></td>
</tr>
<tr>
<td>44</td>
<td>56</td>
<td><a href="https://leetcode-cn.com/problems/merge-intervals">合并区间</a></td>
<td>中等</td>
<td>15</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108446322">题解</a></td>
</tr>
<tr>
<td>45</td>
<td>101</td>
<td><a href="https://leetcode-cn.com/problems/symmetric-tree">对称二叉树</a></td>
<td>容易</td>
<td>15</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108091477">题解</a></td>
</tr>
<tr>
<td>46</td>
<td>2</td>
<td><a href="https://leetcode-cn.com/problems/add-two-numbers">两数相加</a></td>
<td>中等</td>
<td>15</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/107872193">题解</a></td>
</tr>
<tr>
<td>47</td>
<td>剑指 Offer 09</td>
<td><a href="https://leetcode-cn.com/problems/yong-liang-ge-zhan-shi-xian-dui-lie-lcof">用两个栈实现队列</a></td>
<td>容易</td>
<td>15</td>
<td></td>
</tr>
<tr>
<td>48</td>
<td>155</td>
<td><a href="https://leetcode-cn.com/problems/min-stack">最小栈</a></td>
<td>容易</td>
<td>14</td>
<td></td>
</tr>
<tr>
<td>49</td>
<td>300</td>
<td><a href="https://leetcode-cn.com/problems/longest-increasing-subsequence">最长上升子序列</a></td>
<td>中等</td>
<td>14</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113804861">题解</a></td>
</tr>
<tr>
<td>50</td>
<td>128</td>
<td><a href="https://leetcode-cn.com/problems/longest-consecutive-sequence">最长连续序列</a></td>
<td>困难</td>
<td>13</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113962133">题解</a></td>
</tr>
<tr>
<td>51</td>
<td>46</td>
<td><a href="https://leetcode-cn.com/problems/permutations">全排列</a></td>
<td>中等</td>
<td>13</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108549192">题解</a></td>
</tr>
<tr>
<td>52</td>
<td>70</td>
<td><a href="https://leetcode-cn.com/problems/climbing-stairs">爬楼梯</a></td>
<td>容易</td>
<td>13</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113873250">题解</a></td>
</tr>
<tr>
<td>53</td>
<td>62</td>
<td><a href="https://leetcode-cn.com/problems/unique-paths">不同路径</a></td>
<td>中等</td>
<td>13</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113873798">题解</a></td>
</tr>
<tr>
<td>54</td>
<td>剑指 Offer 21</td>
<td><a href="https://leetcode-cn.com/problems/diao-zheng-shu-zu-shun-xu-shi-qi-shu-wei-yu-ou-shu-qian-mian-lcof">调整数组顺序使奇数位于偶数前面</a></td>
<td>容易</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/114108941">题解</a></td>
</tr>
<tr>
<td>55</td>
<td>93</td>
<td><a href="https://leetcode-cn.com/problems/restore-ip-addresses">复原IP地址</a></td>
<td>中等</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113965009">题解</a></td>
</tr>
<tr>
<td>56</td>
<td>83</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list">删除排序链表中的重复元素</a></td>
<td>容易</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106650954">题解</a></td>
</tr>
<tr>
<td>57</td>
<td>148</td>
<td><a href="https://leetcode-cn.com/problems/sort-list">排序链表</a></td>
<td>中等</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108044466">题解</a></td>
</tr>
<tr>
<td>58</td>
<td>169</td>
<td><a href="https://leetcode-cn.com/problems/majority-element">多数元素</a></td>
<td>容易</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108230508">题解</a></td>
</tr>
<tr>
<td>59</td>
<td>958</td>
<td><a href="https://leetcode-cn.com/problems/check-completeness-of-a-binary-tree">二叉树的完全性检验</a></td>
<td>中等</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113964032">题解</a></td>
</tr>
<tr>
<td>60</td>
<td>41</td>
<td><a href="https://leetcode-cn.com/problems/first-missing-positive">缺失的第一个正数</a></td>
<td>困难</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/114178789">题解</a></td>
</tr>
<tr>
<td>61</td>
<td>4</td>
<td><a href="https://leetcode-cn.com/problems/median-of-two-sorted-arrays">寻找两个正序数组的中位数</a></td>
<td>困难</td>
<td>12</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/114179481">题解</a></td>
</tr>
<tr>
<td>62</td>
<td>72</td>
<td><a href="https://leetcode-cn.com/problems/edit-distance">编辑距离</a></td>
<td>困难</td>
<td>11</td>
<td></td>
</tr>
<tr>
<td>63</td>
<td>209</td>
<td><a href="https://leetcode-cn.com/problems/minimum-size-subarray-sum">长度最小的子数组</a></td>
<td>中等</td>
<td>11</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108457712">题解</a></td>
</tr>
<tr>
<td>64</td>
<td>143</td>
<td><a href="https://leetcode-cn.com/problems/reorder-list">重排链表</a></td>
<td>中等</td>
<td>11</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108468070">题解</a></td>
</tr>
<tr>
<td>65</td>
<td>328</td>
<td><a href="https://leetcode-cn.com/problems/odd-even-linked-list">奇偶链表</a></td>
<td>中等</td>
<td>11</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108067365">题解</a></td>
</tr>
<tr>
<td>66</td>
<td>19</td>
<td><a href="https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list">删除链表的倒数第N个节点</a></td>
<td>中等</td>
<td>10</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/106673376">题解</a></td>
</tr>
<tr>
<td>67</td>
<td>1143</td>
<td><a href="https://leetcode-cn.com/problems/longest-common-subsequence">最长公共子序列</a></td>
<td>中等</td>
<td>10</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/114185057">题解</a></td>
</tr>
<tr>
<td>68</td>
<td>468</td>
<td><a href="https://leetcode-cn.com/problems/validate-ip-address">验证IP地址</a></td>
<td>中等</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>69</td>
<td>34</td>
<td><a href="https://leetcode-cn.com/problems/find-first-and-last-position-of-element-in-sorted-array">在排序数组中查找元素的第一个和最后一个位置</a></td>
<td>中等</td>
<td>10</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108551378">题解</a></td>
</tr>
<tr>
<td>70</td>
<td>162</td>
<td><a href="https://leetcode-cn.com/problems/find-peak-element">寻找峰值</a></td>
<td>中等</td>
<td>10</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/114187295">题解</a></td>
</tr>
<tr>
<td>71</td>
<td>剑指 Offer 36</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-yu-shuang-xiang-lian-biao-lcof">二叉搜索树与双向链表</a></td>
<td>中等</td>
<td>10</td>
<td></td>
</tr>
<tr>
<td>72</td>
<td>322</td>
<td><a href="https://leetcode-cn.com/problems/coin-change">零钱兑换</a></td>
<td>中等</td>
<td>9</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/114189426">题解</a></td>
</tr>
<tr>
<td>73</td>
<td>394</td>
<td><a href="https://leetcode-cn.com/problems/decode-string">字符串解码</a></td>
<td>中等</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>74</td>
<td>22</td>
<td><a href="https://leetcode-cn.com/problems/generate-parentheses">括号生成</a></td>
<td>中等</td>
<td>9</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/108305376">题解</a></td>
</tr>
<tr>
<td>75</td>
<td>662</td>
<td><a href="https://leetcode-cn.com/problems/maximum-width-of-binary-tree">二叉树最大宽度</a></td>
<td>中等</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>76</td>
<td>24</td>
<td><a href="https://leetcode-cn.com/problems/swap-nodes-in-pairs">两两交换链表中的节点</a></td>
<td>中等</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>77</td>
<td>226</td>
<td><a href="https://leetcode-cn.com/problems/invert-binary-tree">翻转二叉树</a></td>
<td>容易</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>78</td>
<td>704</td>
<td><a href="https://leetcode-cn.com/problems/binary-search">二分查找</a></td>
<td>容易</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>79</td>
<td>剑指 Offer 24</td>
<td><a href="https://leetcode-cn.com/problems/fan-zhuan-lian-biao-lcof">反转链表</a></td>
<td>容易</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>80</td>
<td>122</td>
<td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-ii">买卖股票的最佳时机 II</a></td>
<td>容易</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>81</td>
<td>145</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-postorder-traversal">二叉树的后序遍历</a></td>
<td>困难</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>82</td>
<td>189</td>
<td><a href="https://leetcode-cn.com/problems/rotate-array">旋转数组</a></td>
<td>容易</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>83</td>
<td>剑指 Offer 10 - II</td>
<td><a href="https://leetcode-cn.com/problems/qing-wa-tiao-tai-jie-wen-ti-lcof">青蛙跳台阶问题</a></td>
<td>容易</td>
<td>9</td>
<td></td>
</tr>
<tr>
<td>84</td>
<td>86</td>
<td><a href="https://leetcode-cn.com/problems/partition-list">分隔链表</a></td>
<td>中等</td>
<td>8</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112130920">题解</a></td>
</tr>
<tr>
<td>85</td>
<td>114</td>
<td><a href="https://leetcode-cn.com/problems/flatten-binary-tree-to-linked-list">二叉树展开为链表</a></td>
<td>中等</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>86</td>
<td>198</td>
<td><a href="https://leetcode-cn.com/problems/house-robber">打家劫舍</a></td>
<td>容易</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>87</td>
<td>165</td>
<td><a href="https://leetcode-cn.com/problems/compare-version-numbers">比较版本号</a></td>
<td>中等</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>88</td>
<td>32</td>
<td><a href="https://leetcode-cn.com/problems/longest-valid-parentheses">最长有效括号</a></td>
<td>困难</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>89</td>
<td>31</td>
<td><a href="https://leetcode-cn.com/problems/next-permutation">下一个排列</a></td>
<td>中等</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>90</td>
<td>560</td>
<td><a href="https://leetcode-cn.com/problems/subarray-sum-equals-k">和为K的子数组</a></td>
<td>中等</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>91</td>
<td>239</td>
<td><a href="https://leetcode-cn.com/problems/sliding-window-maximum">滑动窗口最大值</a></td>
<td>困难</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>92</td>
<td>112</td>
<td><a href="https://leetcode-cn.com/problems/path-sum">路径总和</a></td>
<td>容易</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>93</td>
<td>78</td>
<td><a href="https://leetcode-cn.com/problems/subsets">子集</a></td>
<td>中等</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>94</td>
<td>136</td>
<td><a href="https://leetcode-cn.com/problems/single-number">只出现一次的数字</a></td>
<td>容易</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>95</td>
<td>344</td>
<td><a href="https://leetcode-cn.com/problems/reverse-string">反转字符串</a></td>
<td>容易</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>96</td>
<td>剑指 Offer 52</td>
<td><a href="https://leetcode-cn.com/problems/liang-ge-lian-biao-de-di-yi-ge-gong-gong-jie-dian-lcof">两个链表的第一个公共节点</a></td>
<td>容易</td>
<td>8</td>
<td></td>
</tr>
<tr>
<td>97</td>
<td>224</td>
<td><a href="https://leetcode-cn.com/problems/basic-calculator">基本计算器</a></td>
<td>困难</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>98</td>
<td>76</td>
<td><a href="https://leetcode-cn.com/problems/minimum-window-substring">最小覆盖子串</a></td>
<td>困难</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>99</td>
<td>82</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-list-ii">删除排序链表中的重复元素 II</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>100</td>
<td>剑指 Offer 51</td>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-de-ni-xu-dui-lcof">数组中的逆序对</a></td>
<td>困难</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>101</td>
<td>349</td>
<td><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays">两个数组的交集</a></td>
<td>容易</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>102</td>
<td>287</td>
<td><a href="https://leetcode-cn.com/problems/find-the-duplicate-number">寻找重复数</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>103</td>
<td>718</td>
<td><a href="https://leetcode-cn.com/problems/maximum-length-of-repeated-subarray">最长重复子数组</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>104</td>
<td>64</td>
<td><a href="https://leetcode-cn.com/problems/minimum-path-sum">最小路径和</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>105</td>
<td>79</td>
<td><a href="https://leetcode-cn.com/problems/word-search">单词搜索</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>106</td>
<td>739</td>
<td><a href="https://leetcode-cn.com/problems/daily-temperatures">每日温度</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>107</td>
<td>470</td>
<td><a href="https://leetcode-cn.com/problems/implement-rand10-using-rand7">用 Rand7() 实现 Rand10()</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>108</td>
<td>518</td>
<td><a href="https://leetcode-cn.com/problems/coin-change-2">零钱兑换 II</a></td>
<td>中等</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>109</td>
<td>剑指 Offer 54</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-di-kda-jie-dian-lcof">二叉搜索树的第k大节点</a></td>
<td>容易</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>110</td>
<td>剑指 Offer 42</td>
<td><a href="https://leetcode-cn.com/problems/lian-xu-zi-shu-zu-de-zui-da-he-lcof">连续子数组的最大和</a></td>
<td>容易</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>111</td>
<td>剑指 Offer 27</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-shu-de-jing-xiang-lcof">二叉树的镜像</a></td>
<td>容易</td>
<td>7</td>
<td></td>
</tr>
<tr>
<td>112</td>
<td>91</td>
<td><a href="https://leetcode-cn.com/problems/decode-ways">解码方法</a></td>
<td>中等</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>113</td>
<td>129</td>
<td><a href="https://leetcode-cn.com/problems/sum-root-to-leaf-numbers">求根到叶子节点数字之和</a></td>
<td>中等</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>114</td>
<td>297</td>
<td><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-binary-tree">二叉树的序列化与反序列化</a></td>
<td>困难</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>115</td>
<td>460</td>
<td><a href="https://leetcode-cn.com/problems/lfu-cache">LFU缓存</a></td>
<td>困难</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>116</td>
<td>242</td>
<td><a href="https://leetcode-cn.com/problems/valid-anagram">有效的字母异位词</a></td>
<td>容易</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>117</td>
<td>179</td>
<td><a href="https://leetcode-cn.com/problems/largest-number">最大数</a></td>
<td>中等</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>118</td>
<td>剑指 Offer 48</td>
<td><a href="https://leetcode-cn.com/problems/zui-chang-bu-han-zhong-fu-zi-fu-de-zi-zi-fu-chuan-lcof">最长不含重复字符的子字符串</a></td>
<td>中等</td>
<td>6</td>
<td></td>
</tr>
<tr>
<td>119</td>
<td>509</td>
<td><a href="https://leetcode-cn.com/problems/fibonacci-number">斐波那契数</a></td>
<td>容易</td>
<td>6</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112209242">题解</a></td>
</tr>
<tr>
<td>120</td>
<td>443</td>
<td><a href="https://leetcode-cn.com/problems/string-compression">压缩字符串</a></td>
<td>容易</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>121</td>
<td>138</td>
<td><a href="https://leetcode-cn.com/problems/copy-list-with-random-pointer">复制带随机指针的链表</a></td>
<td>中等</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>122</td>
<td>450</td>
<td><a href="https://leetcode-cn.com/problems/delete-node-in-a-bst">删除二叉搜索树中的节点</a></td>
<td>中等</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>123</td>
<td>补充题1</td>
<td><a href="https://zhuanlan.zhihu.com/p/311113031">排序奇升偶降链表</a></td>
<td>中等</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>124</td>
<td>59</td>
<td><a href="https://leetcode-cn.com/problems/spiral-matrix-ii">螺旋矩阵 II</a></td>
<td>中等</td>
<td>5</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/112141555">题解</a></td>
</tr>
<tr>
<td>125</td>
<td>268</td>
<td><a href="https://leetcode-cn.com/problems/missing-number">缺失数字</a></td>
<td>容易</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>126</td>
<td>剑指 Offer 61</td>
<td><a href="https://leetcode-cn.com/problems/bu-ke-pai-zhong-de-shun-zi-lcof">扑克牌中的顺子</a></td>
<td>容易</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>127</td>
<td>39</td>
<td><a href="https://leetcode-cn.com/problems/combination-sum">组合总和</a></td>
<td>中等</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>128</td>
<td>剑指 Offer 25</td>
<td><a href="https://leetcode-cn.com/problems/he-bing-liang-ge-pai-xu-de-lian-biao-lcof">合并两个排序的链表</a></td>
<td>容易</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>129</td>
<td>670</td>
<td><a href="https://leetcode-cn.com/problems/maximum-swap">最大交换</a></td>
<td>中等</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>130</td>
<td>557</td>
<td><a href="https://leetcode-cn.com/problems/reverse-words-in-a-string-iii">反转字符串中的单词 III</a></td>
<td>容易</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>131</td>
<td>7</td>
<td><a href="https://leetcode-cn.com/problems/reverse-integer">整数反转</a></td>
<td>容易</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>132</td>
<td>221</td>
<td><a href="https://leetcode-cn.com/problems/maximal-square">最大正方形</a></td>
<td>中等</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>133</td>
<td>283</td>
<td><a href="https://leetcode-cn.com/problems/move-zeroes">移动零</a></td>
<td>容易</td>
<td>5</td>
<td></td>
</tr>
<tr>
<td>134</td>
<td>207</td>
<td><a href="https://leetcode-cn.com/problems/course-schedule">课程表</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>135</td>
<td>123</td>
<td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iii">买卖股票的最佳时机 III</a></td>
<td>困难</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>136</td>
<td>剑指 Offer 04</td>
<td><a href="https://leetcode-cn.com/problems/er-wei-shu-zu-zhong-de-cha-zhao-lcof">二维数组中的查找</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>137</td>
<td>384</td>
<td><a href="https://leetcode-cn.com/problems/shuffle-an-array">打乱数组</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>138</td>
<td>528</td>
<td><a href="https://leetcode-cn.com/problems/random-pick-with-weight">按权重随机选择</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>139</td>
<td>230</td>
<td><a href="https://leetcode-cn.com/problems/kth-smallest-element-in-a-bst">二叉搜索树中第K小的元素</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>140</td>
<td>210</td>
<td><a href="https://leetcode-cn.com/problems/course-schedule-ii">课程表 II</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>141</td>
<td>剑指 Offer 45</td>
<td><a href="https://leetcode-cn.com/problems/ba-shu-zu-pai-cheng-zui-xiao-de-shu-lcof">把数组排成最小的数</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>142</td>
<td>补充题2</td>
<td><a href="https://zhuanlan.zhihu.com/p/338806463">圆环回原点问题</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>143</td>
<td>862</td>
<td><a href="https://leetcode-cn.com/problems/shortest-subarray-with-sum-at-least-k">和至少为 K 的最短子数组</a></td>
<td>困难</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>144</td>
<td>26</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicates-from-sorted-array">删除排序数组中的重复项</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>145</td>
<td>329</td>
<td><a href="https://leetcode-cn.com/problems/longest-increasing-path-in-a-matrix">矩阵中的最长递增路径</a></td>
<td>困难</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>146</td>
<td>1047</td>
<td><a href="https://leetcode-cn.com/problems/remove-all-adjacent-duplicates-in-string">删除字符串中的所有相邻重复项</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>147</td>
<td>986</td>
<td><a href="https://leetcode-cn.com/problems/interval-list-intersections">区间列表的交集</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>148</td>
<td>71</td>
<td><a href="https://leetcode-cn.com/problems/simplify-path">简化路径</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>149</td>
<td>55</td>
<td><a href="https://leetcode-cn.com/problems/jump-game">跳跃游戏</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>150</td>
<td>剑指 Offer 18</td>
<td><a href="https://leetcode-cn.com/problems/shan-chu-lian-biao-de-jie-dian-lcof">删除链表的节点</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>151</td>
<td>498</td>
<td><a href="https://leetcode-cn.com/problems/diagonal-traverse">对角线遍历</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>152</td>
<td>225</td>
<td><a href="https://leetcode-cn.com/problems/implement-stack-using-queues">用队列实现栈</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>153</td>
<td>445</td>
<td><a href="https://leetcode-cn.com/problems/add-two-numbers-ii">两数相加 II</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>154</td>
<td>306</td>
<td><a href="https://leetcode-cn.com/problems/additive-number">累加数</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>155</td>
<td>44</td>
<td><a href="https://leetcode-cn.com/problems/wildcard-matching">通配符匹配</a></td>
<td>困难</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>156</td>
<td>208</td>
<td><a href="https://leetcode-cn.com/problems/implement-trie-prefix-tree">实现 Trie (前缀树)</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>157</td>
<td>43</td>
<td><a href="https://leetcode-cn.com/problems/multiply-strings">字符串相乘</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>158</td>
<td>572</td>
<td><a href="https://leetcode-cn.com/problems/subtree-of-another-tree">另一个树的子树</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>159</td>
<td>876</td>
<td><a href="https://leetcode-cn.com/problems/middle-of-the-linked-list">链表的中间结点</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>160</td>
<td>剑指 Offer 32 - III</td>
<td><a href="https://leetcode-cn.com/problems/cong-shang-dao-xia-da-yin-er-cha-shu-iii-lcof">从上到下打印二叉树 III</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>161</td>
<td>426</td>
<td><a href="https://leetcode-cn.com/problems/convert-binary-search-tree-to-sorted-doubly-linked-list">将二叉搜索树转化为排序的双向链表</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>162</td>
<td>剑指 Offer 39</td>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-chu-xian-ci-shu-chao-guo-yi-ban-de-shu-zi-lcof">数组中出现次数超过一半的数字</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>163</td>
<td>222</td>
<td><a href="https://leetcode-cn.com/problems/count-complete-tree-nodes">完全二叉树的节点个数</a></td>
<td>中等</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>164</td>
<td>108</td>
<td><a href="https://leetcode-cn.com/problems/convert-sorted-array-to-binary-search-tree">将有序数组转换为二叉搜索树</a></td>
<td>容易</td>
<td>4</td>
<td></td>
</tr>
<tr>
<td>165</td>
<td>257</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-paths">二叉树的所有路径</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>166</td>
<td>剑指 Offer 34</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-shu-zhong-he-wei-mou-yi-zhi-de-lu-jing-lcof">二叉树中和为某一值的路径</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>167</td>
<td>50</td>
<td><a href="https://leetcode-cn.com/problems/powx-n">Pow(x, n)</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>168</td>
<td>459</td>
<td><a href="https://leetcode-cn.com/problems/repeated-substring-pattern">重复的子字符串</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>169</td>
<td>37</td>
<td><a href="https://leetcode-cn.com/problems/sudoku-solver">解数独</a></td>
<td>困难</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>170</td>
<td>97</td>
<td><a href="https://leetcode-cn.com/problems/interleaving-string">交错字符串</a></td>
<td>困难</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>171</td>
<td>120</td>
<td><a href="https://leetcode-cn.com/problems/triangle">三角形最小路径和</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>172</td>
<td>1095</td>
<td><a href="https://leetcode-cn.com/problems/find-in-mountain-array">山脉数组中查找目标值</a></td>
<td>困难</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>173</td>
<td>154</td>
<td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array-ii">寻找旋转排序数组中的最小值 II</a></td>
<td>困难</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>174</td>
<td>315</td>
<td><a href="https://leetcode-cn.com/problems/count-of-smaller-numbers-after-self">计算右侧小于当前元素的个数</a></td>
<td>困难</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>175</td>
<td>14</td>
<td><a href="https://leetcode-cn.com/problems/longest-common-prefix">最长公共前缀</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>176</td>
<td>264</td>
<td><a href="https://leetcode-cn.com/problems/ugly-number-ii">丑数 II</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>177</td>
<td>125</td>
<td><a href="https://leetcode-cn.com/problems/valid-palindrome">验证回文串</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>178</td>
<td>340</td>
<td><a href="https://leetcode-cn.com/problems/longest-substring-with-at-most-k-distinct-characters">至多包含 K 个不同字符的最长子串</a></td>
<td>困难</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>179</td>
<td>191</td>
<td><a href="https://leetcode-cn.com/problems/number-of-1-bits">位1的个数</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>180</td>
<td>49</td>
<td><a href="https://leetcode-cn.com/problems/group-anagrams">字母异位词分组</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>181</td>
<td>402</td>
<td><a href="https://leetcode-cn.com/problems/remove-k-digits">移掉K位数字</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>182</td>
<td>814</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-pruning">二叉树剪枝</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>183</td>
<td>530</td>
<td><a href="https://leetcode-cn.com/problems/minimum-absolute-difference-in-bst">二叉搜索树的最小绝对差</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>184</td>
<td>701</td>
<td><a href="https://leetcode-cn.com/problems/insert-into-a-binary-search-tree">二叉搜索树中的插入操作</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>185</td>
<td>695</td>
<td><a href="https://leetcode-cn.com/problems/max-area-of-island">岛屿的最大面积</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>186</td>
<td>99</td>
<td><a href="https://leetcode-cn.com/problems/recover-binary-search-tree">恢复二叉搜索树</a></td>
<td>困难</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>187</td>
<td>152</td>
<td><a href="https://leetcode-cn.com/problems/maximum-product-subarray">乘积最大子数组</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>188</td>
<td>503</td>
<td><a href="https://leetcode-cn.com/problems/next-greater-element-ii">下一个更大元素 II</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>189</td>
<td>剑指 Offer 53 - II</td>
<td><a href="https://leetcode-cn.com/problems/que-shi-de-shu-zi-lcof">0～n-1中缺失的数字</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>190</td>
<td>40</td>
<td><a href="https://leetcode-cn.com/problems/combination-sum-ii">组合总和 II</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>191</td>
<td>16</td>
<td><a href="https://leetcode-cn.com/problems/3sum-closest">最接近的三数之和</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>192</td>
<td>449</td>
<td><a href="https://leetcode-cn.com/problems/serialize-and-deserialize-bst">序列化和反序列化二叉搜索树</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>193</td>
<td>139</td>
<td><a href="https://leetcode-cn.com/problems/word-break">单词拆分</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>194</td>
<td>9</td>
<td><a href="https://leetcode-cn.com/problems/palindrome-number">回文数</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>195</td>
<td>剑指 Offer 11</td>
<td><a href="https://leetcode-cn.com/problems/xuan-zhuan-shu-zu-de-zui-xiao-shu-zi-lcof">旋转数组的最小数字</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>196</td>
<td>100</td>
<td><a href="https://leetcode-cn.com/problems/same-tree">相同的树</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>197</td>
<td>剑指 Offer 29</td>
<td><a href="https://leetcode-cn.com/problems/shun-shi-zhen-da-yin-ju-zhen-lcof">顺时针打印矩阵</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>198</td>
<td>剑指 Offer 10 - I</td>
<td><a href="https://leetcode-cn.com/problems/fei-bo-na-qi-shu-lie-lcof">斐波那契数列</a></td>
<td>容易</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>199</td>
<td>47</td>
<td><a href="https://leetcode-cn.com/problems/permutations-ii">全排列 II</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>200</td>
<td>74</td>
<td><a href="https://leetcode-cn.com/problems/search-a-2d-matrix">搜索二维矩阵</a></td>
<td>中等</td>
<td>3</td>
<td></td>
</tr>
<tr>
<td>201</td>
<td>295</td>
<td><a href="https://leetcode-cn.com/problems/find-median-from-data-stream">数据流的中位数</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>202</td>
<td>404</td>
<td><a href="https://leetcode-cn.com/problems/sum-of-left-leaves">左叶子之和</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>203</td>
<td>362</td>
<td><a href="https://leetcode-cn.com/problems/design-hit-counter">敲击计数器</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>204</td>
<td>63</td>
<td><a href="https://leetcode-cn.com/problems/unique-paths-ii">不同路径 II</a></td>
<td>中等</td>
<td>2</td>
<td><a href="https://cuggz.blog.csdn.net/article/details/113874084">题解</a></td>
</tr>
<tr>
<td>205</td>
<td>668</td>
<td><a href="https://leetcode-cn.com/problems/kth-smallest-number-in-multiplication-table">乘法表中第k小的数</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>206</td>
<td>692</td>
<td><a href="https://leetcode-cn.com/problems/top-k-frequent-words">前K个高频单词</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>207</td>
<td>617</td>
<td><a href="https://leetcode-cn.com/problems/merge-two-binary-trees">合并二叉树</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>208</td>
<td>119</td>
<td><a href="https://leetcode-cn.com/problems/pascals-triangle-ii">杨辉三角 II</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>209</td>
<td>863</td>
<td><a href="https://leetcode-cn.com/problems/all-nodes-distance-k-in-binary-tree">二叉树中所有距离为 K 的结点</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>210</td>
<td>面试题 03.05</td>
<td><a href="https://leetcode-cn.com/problems/sort-of-stacks-lcci">栈排序</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>211</td>
<td>67</td>
<td><a href="https://leetcode-cn.com/problems/add-binary">二进制求和</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>212</td>
<td>680</td>
<td><a href="https://leetcode-cn.com/problems/valid-palindrome-ii">验证回文字符串 Ⅱ</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>213</td>
<td>1363</td>
<td><a href="https://leetcode-cn.com/problems/largest-multiple-of-three">形成三的最大倍数</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>214</td>
<td>438</td>
<td><a href="https://leetcode-cn.com/problems/find-all-anagrams-in-a-string">找到字符串中所有字母异位词</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>215</td>
<td>147</td>
<td><a href="https://leetcode-cn.com/problems/insertion-sort-list">对链表进行插入排序</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>216</td>
<td>188</td>
<td><a href="https://leetcode-cn.com/problems/best-time-to-buy-and-sell-stock-iv">买卖股票的最佳时机 IV</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>217</td>
<td>321</td>
<td><a href="https://leetcode-cn.com/problems/create-maximum-number">拼接最大数</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>218</td>
<td>785</td>
<td><a href="https://leetcode-cn.com/problems/is-graph-bipartite">判断二分图</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>219</td>
<td>722</td>
<td><a href="https://leetcode-cn.com/problems/remove-comments">删除注释</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>220</td>
<td>109</td>
<td><a href="https://leetcode-cn.com/problems/convert-sorted-list-to-binary-search-tree">有序链表转换二叉搜索树</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>221</td>
<td>694</td>
<td><a href="https://leetcode-cn.com/problems/number-of-distinct-islands">不同岛屿的数量</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>222</td>
<td>238</td>
<td><a href="https://leetcode-cn.com/problems/product-of-array-except-self">除自身以外数组的乘积</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>223</td>
<td>85</td>
<td><a href="https://leetcode-cn.com/problems/maximal-rectangle">最大矩形</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>224</td>
<td>60</td>
<td><a href="https://leetcode-cn.com/problems/permutation-sequence">第k个排列</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>225</td>
<td>134</td>
<td><a href="https://leetcode-cn.com/problems/gas-station">加油站</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>226</td>
<td>204</td>
<td><a href="https://leetcode-cn.com/problems/count-primes">计数质数</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>227</td>
<td>剑指 Offer 19</td>
<td><a href="https://leetcode-cn.com/problems/zheng-ze-biao-da-shi-pi-pei-lcof">正则表达式匹配</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>228</td>
<td>386</td>
<td><a href="https://leetcode-cn.com/problems/lexicographical-numbers">字典序排数</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>229</td>
<td>1026</td>
<td><a href="https://leetcode-cn.com/problems/maximum-difference-between-node-and-ancestor">节点与其祖先之间的最大差值</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>230</td>
<td>135</td>
<td><a href="https://leetcode-cn.com/problems/candy">分发糖果</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>231</td>
<td>437</td>
<td><a href="https://leetcode-cn.com/problems/path-sum-iii">路径总和 III</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>232</td>
<td>398</td>
<td><a href="https://leetcode-cn.com/problems/random-pick-index">随机数索引</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>233</td>
<td>516</td>
<td><a href="https://leetcode-cn.com/problems/longest-palindromic-subsequence">最长回文子序列</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>234</td>
<td>173</td>
<td><a href="https://leetcode-cn.com/problems/binary-search-tree-iterator">二叉搜索树迭代器</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>235</td>
<td>45</td>
<td><a href="https://leetcode-cn.com/problems/jump-game-ii">跳跃游戏 II</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>236</td>
<td>164</td>
<td><a href="https://leetcode-cn.com/problems/maximum-gap">最大间距</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>237</td>
<td>130</td>
<td><a href="https://leetcode-cn.com/problems/surrounded-regions">被围绕的区域</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>238</td>
<td>剑指 Offer 58 - I</td>
<td><a href="https://leetcode-cn.com/problems/fan-zhuan-dan-ci-shun-xu-lcof">翻转单词顺序</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>239</td>
<td>416</td>
<td><a href="https://leetcode-cn.com/problems/partition-equal-subset-sum">分割等和子集</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>240</td>
<td>540</td>
<td><a href="https://leetcode-cn.com/problems/single-element-in-a-sorted-array">有序数组中的单一元素</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>241</td>
<td>235</td>
<td><a href="https://leetcode-cn.com/problems/lowest-common-ancestor-of-a-binary-search-tree">二叉搜索树的最近公共祖先</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>242</td>
<td>剑指 Offer 46</td>
<td><a href="https://leetcode-cn.com/problems/ba-shu-zi-fan-yi-cheng-zi-fu-chuan-lcof">把数字翻译成字符串</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>243</td>
<td>347</td>
<td><a href="https://leetcode-cn.com/problems/top-k-frequent-elements">前 K 个高频元素</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>244</td>
<td>387</td>
<td><a href="https://leetcode-cn.com/problems/first-unique-character-in-a-string">字符串中的第一个唯一字符</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>245</td>
<td>977</td>
<td><a href="https://leetcode-cn.com/problems/squares-of-a-sorted-array">有序数组的平方</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>246</td>
<td>767</td>
<td><a href="https://leetcode-cn.com/problems/reorganize-string">重构字符串</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>247</td>
<td>887</td>
<td><a href="https://leetcode-cn.com/problems/super-egg-drop">鸡蛋掉落</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>248</td>
<td>剑指 Offer 40</td>
<td><a href="https://leetcode-cn.com/problems/zui-xiao-de-kge-shu-lcof">最小的k个数</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>249</td>
<td>111</td>
<td><a href="https://leetcode-cn.com/problems/minimum-depth-of-binary-tree">二叉树的最小深度</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>250</td>
<td>153</td>
<td><a href="https://leetcode-cn.com/problems/find-minimum-in-rotated-sorted-array">寻找旋转排序数组中的最小值</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>251</td>
<td>168</td>
<td><a href="https://leetcode-cn.com/problems/excel-sheet-column-title">Excel表列名称</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>252</td>
<td>61</td>
<td><a href="https://leetcode-cn.com/problems/rotate-list">旋转链表</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>253</td>
<td>1156</td>
<td><a href="https://leetcode-cn.com/problems/swap-for-longest-repeated-character-substring">单字符重复子串的最大长度</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>254</td>
<td>628</td>
<td><a href="https://leetcode-cn.com/problems/maximum-product-of-three-numbers">三个数的最大乘积</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>255</td>
<td>674</td>
<td><a href="https://leetcode-cn.com/problems/longest-continuous-increasing-subsequence">最长连续递增序列</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>256</td>
<td>1254</td>
<td><a href="https://leetcode-cn.com/problems/number-of-closed-islands">统计封闭岛屿的数目</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>257</td>
<td>剑指 Offer 12</td>
<td><a href="https://leetcode-cn.com/problems/ju-zhen-zhong-de-lu-jing-lcof">矩阵中的路径</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>258</td>
<td>8</td>
<td><a href="https://leetcode-cn.com/problems/string-to-integer-atoi">字符串转换整数 (atoi)</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>259</td>
<td>350</td>
<td><a href="https://leetcode-cn.com/problems/intersection-of-two-arrays-ii">两个数组的交集 II</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>260</td>
<td>剑指 Offer 33</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-sou-suo-shu-de-hou-xu-bian-li-xu-lie-lcof">二叉搜索树的后序遍历序列</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>261</td>
<td>1201</td>
<td><a href="https://leetcode-cn.com/problems/ugly-number-iii">丑数 III</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>262</td>
<td>190</td>
<td><a href="https://leetcode-cn.com/problems/reverse-bits">颠倒二进制位</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>263</td>
<td>137</td>
<td><a href="https://leetcode-cn.com/problems/single-number-ii">只出现一次的数字 II</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>264</td>
<td>150</td>
<td><a href="https://leetcode-cn.com/problems/evaluate-reverse-polish-notation">逆波兰表达式求值</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>265</td>
<td>1312</td>
<td><a href="https://leetcode-cn.com/problems/minimum-insertion-steps-to-make-a-string-palindrome">让字符串成为回文串的最少插入次数</a></td>
<td>困难</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>266</td>
<td>剑指 Offer 55 - I</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-shu-de-shen-du-lcof">二叉树的深度</a></td>
<td>容易</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>267</td>
<td>89</td>
<td><a href="https://leetcode-cn.com/problems/gray-code">格雷编码</a></td>
<td>中等</td>
<td>2</td>
<td></td>
</tr>
<tr>
<td>268</td>
<td>407</td>
<td><a href="https://leetcode-cn.com/problems/trapping-rain-water-ii">接雨水 II</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>269</td>
<td>334</td>
<td><a href="https://leetcode-cn.com/problems/increasing-triplet-subsequence">递增的三元子序列</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>270</td>
<td>面试题 01.06</td>
<td><a href="https://leetcode-cn.com/problems/compress-string-lcci">字符串压缩</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>271</td>
<td>877</td>
<td><a href="https://leetcode-cn.com/problems/stone-game">石子游戏</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>272</td>
<td>569</td>
<td><a href="https://leetcode-cn.com/problems/median-employee-salary">员工薪水中位数</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>273</td>
<td>848</td>
<td><a href="https://leetcode-cn.com/problems/shifting-letters">字母移位</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>274</td>
<td>713</td>
<td><a href="https://leetcode-cn.com/problems/subarray-product-less-than-k">乘积小于K的子数组</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>275</td>
<td>75</td>
<td><a href="https://leetcode-cn.com/problems/sort-colors">颜色分类</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>276</td>
<td>77</td>
<td><a href="https://leetcode-cn.com/problems/combinations">组合</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>277</td>
<td>984</td>
<td><a href="https://leetcode-cn.com/problems/string-without-aaa-or-bbb">不含 AAA 或 BBB 的字符串</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>278</td>
<td>1498</td>
<td><a href="https://leetcode-cn.com/problems/number-of-subsequences-that-satisfy-the-given-sum-condition">满足条件的子序列数目</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>279</td>
<td>376</td>
<td><a href="https://leetcode-cn.com/problems/wiggle-subsequence">摆动序列</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>280</td>
<td>213</td>
<td><a href="https://leetcode-cn.com/problems/house-robber-ii">打家劫舍 II</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>281</td>
<td>剑指 Offer 28</td>
<td><a href="https://leetcode-cn.com/problems/dui-cheng-de-er-cha-shu-lcof">对称的二叉树</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>282</td>
<td>525</td>
<td><a href="https://leetcode-cn.com/problems/contiguous-array">连续数组</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>283</td>
<td>1314</td>
<td><a href="https://leetcode-cn.com/problems/matrix-block-sum">矩阵区域和</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>284</td>
<td>440</td>
<td><a href="https://leetcode-cn.com/problems/k-th-smallest-in-lexicographical-order">字典序的第K小数字</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>285</td>
<td>1155</td>
<td><a href="https://leetcode-cn.com/problems/number-of-dice-rolls-with-target-sum">掷骰子的N种方法</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>286</td>
<td>260</td>
<td><a href="https://leetcode-cn.com/problems/single-number-iii">只出现一次的数字 III</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>287</td>
<td>剑指 Offer 59 - II</td>
<td><a href="https://leetcode-cn.com/problems/dui-lie-de-zui-da-zhi-lcof">队列的最大值</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>288</td>
<td>面试题 02.01</td>
<td><a href="https://leetcode-cn.com/problems/remove-duplicate-node-lcci">移除重复节点</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>289</td>
<td>剑指 Offer 58 - II</td>
<td><a href="https://leetcode-cn.com/problems/zuo-xuan-zhuan-zi-fu-chuan-lcof">左旋转字符串</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>290</td>
<td>895</td>
<td><a href="https://leetcode-cn.com/problems/maximum-frequency-stack">最大频率栈</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>291</td>
<td>17</td>
<td><a href="https://leetcode-cn.com/problems/letter-combinations-of-a-phone-number">电话号码的字母组合</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>292</td>
<td>325</td>
<td><a href="https://leetcode-cn.com/problems/maximum-size-subarray-sum-equals-k">和等于 k 的最长子数组长度</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>293</td>
<td>面试题 17.14</td>
<td><a href="https://leetcode-cn.com/problems/smallest-k-lcci">最小K个数</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>294</td>
<td>343</td>
<td><a href="https://leetcode-cn.com/problems/integer-break">整数拆分</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>295</td>
<td>202</td>
<td><a href="https://leetcode-cn.com/problems/happy-number">快乐数</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>296</td>
<td>1233</td>
<td><a href="https://leetcode-cn.com/problems/remove-sub-folders-from-the-filesystem">删除子文件夹</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>297</td>
<td>435</td>
<td><a href="https://leetcode-cn.com/problems/non-overlapping-intervals">无重叠区间</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>298</td>
<td>951</td>
<td><a href="https://leetcode-cn.com/problems/flip-equivalent-binary-trees">翻转等价二叉树</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>299</td>
<td>107</td>
<td><a href="https://leetcode-cn.com/problems/binary-tree-level-order-traversal-ii">二叉树的层次遍历 II</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>300</td>
<td>865</td>
<td><a href="https://leetcode-cn.com/problems/smallest-subtree-with-all-the-deepest-nodes">具有所有最深结点的最小子树</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>301</td>
<td>1139</td>
<td><a href="https://leetcode-cn.com/problems/largest-1-bordered-square">最大的以 1 为边界的正方形</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>302</td>
<td>400</td>
<td><a href="https://leetcode-cn.com/problems/nth-digit">第N个数字</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>303</td>
<td>1235</td>
<td><a href="https://leetcode-cn.com/problems/maximum-profit-in-job-scheduling">规划兼职工作</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>304</td>
<td>369</td>
<td><a href="https://leetcode-cn.com/problems/plus-one-linked-list">给单链表加一</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>305</td>
<td>52</td>
<td><a href="https://leetcode-cn.com/problems/n-queens-ii">N皇后 II</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>306</td>
<td>305</td>
<td><a href="https://leetcode-cn.com/problems/number-of-islands-ii">岛屿数量 II</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>307</td>
<td>409</td>
<td><a href="https://leetcode-cn.com/problems/longest-palindrome">最长回文串</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>308</td>
<td>面试题 02.07</td>
<td><a href="https://leetcode-cn.com/problems/intersection-of-two-linked-lists-lcci">链表相交</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>309</td>
<td>172</td>
<td><a href="https://leetcode-cn.com/problems/factorial-trailing-zeroes">阶乘后的零</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>310</td>
<td>912</td>
<td><a href="https://leetcode-cn.com/problems/sort-an-array">排序数组</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>311</td>
<td>637</td>
<td><a href="https://leetcode-cn.com/problems/average-of-levels-in-binary-tree">二叉树的层平均值</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>312</td>
<td>424</td>
<td><a href="https://leetcode-cn.com/problems/longest-repeating-character-replacement">替换后的最长重复字符</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>313</td>
<td>582</td>
<td><a href="https://leetcode-cn.com/problems/kill-process">杀死进程</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>314</td>
<td>622</td>
<td><a href="https://leetcode-cn.com/problems/design-circular-queue">设计循环队列</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>315</td>
<td>73</td>
<td><a href="https://leetcode-cn.com/problems/set-matrix-zeroes">矩阵置零</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>316</td>
<td>688</td>
<td><a href="https://leetcode-cn.com/problems/knight-probability-in-chessboard">“马”在棋盘上的概率</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>317</td>
<td>773</td>
<td><a href="https://leetcode-cn.com/problems/sliding-puzzle">滑动谜题</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>318</td>
<td>827</td>
<td><a href="https://leetcode-cn.com/problems/making-a-large-island">最大人工岛</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>319</td>
<td>673</td>
<td><a href="https://leetcode-cn.com/problems/number-of-longest-increasing-subsequence">最长递增子序列的个数</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>320</td>
<td>915</td>
<td><a href="https://leetcode-cn.com/problems/partition-array-into-disjoint-intervals">分割数组</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>321</td>
<td>1339</td>
<td><a href="https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree">分裂二叉树的最大乘积</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>322</td>
<td>剑指 Offer 13</td>
<td><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">机器人的运动范围</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>323</td>
<td>227</td>
<td><a href="https://leetcode-cn.com/problems/basic-calculator-ii">基本计算器 II</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>324</td>
<td>277</td>
<td><a href="https://leetcode-cn.com/problems/find-the-celebrity">搜寻名人</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>325</td>
<td>807</td>
<td><a href="https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline">保持城市天际线</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>326</td>
<td>6</td>
<td><a href="https://leetcode-cn.com/problems/zigzag-conversion">Z 字形变换</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>327</td>
<td>456</td>
<td><a href="https://leetcode-cn.com/problems/132-pattern">132模式</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>328</td>
<td>559</td>
<td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree">N叉树的最大深度</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>329</td>
<td>217</td>
<td><a href="https://leetcode-cn.com/problems/contains-duplicate">存在重复元素</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>330</td>
<td>剑指 Offer 56 - II</td>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof">数组中数字出现的次数 II</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>331</td>
<td>剑指 Offer 68 - II</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof">二叉树的最近公共祖先</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>332</td>
<td>410</td>
<td><a href="https://leetcode-cn.com/problems/split-array-largest-sum">分割数组的最大值</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>333</td>
<td>面试题 08.12</td>
<td><a href="https://leetcode-cn.com/problems/eight-queens-lcci">八皇后</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>334</td>
<td>剑指 Offer 59 - I</td>
<td><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">滑动窗口的最大值</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>335</td>
<td>剑指 Offer 14 - I</td>
<td><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">剪绳子</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>336</td>
<td>421</td>
<td><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array">数组中两个数的最大异或值</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>337</td>
<td>255</td>
<td><a href="https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree">验证前序遍历序列二叉搜索树</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>338</td>
<td>1245</td>
<td><a href="https://leetcode-cn.com/problems/tree-diameter">树的直径</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>339</td>
<td>剑指 Offer 67</td>
<td><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">把字符串转换成整数</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>340</td>
<td>剑指 Offer 38</td>
<td><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">字符串的排列</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>341</td>
<td>1339</td>
<td><a href="https://leetcode-cn.com/problems/maximum-product-of-splitted-binary-tree">分裂二叉树的最大乘积</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>342</td>
<td>剑指 Offer 13</td>
<td><a href="https://leetcode-cn.com/problems/ji-qi-ren-de-yun-dong-fan-wei-lcof">机器人的运动范围</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>343</td>
<td>227</td>
<td><a href="https://leetcode-cn.com/problems/basic-calculator-ii">基本计算器 II</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>344</td>
<td>277</td>
<td><a href="https://leetcode-cn.com/problems/find-the-celebrity">搜寻名人</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>345</td>
<td>807</td>
<td><a href="https://leetcode-cn.com/problems/max-increase-to-keep-city-skyline">保持城市天际线</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>346</td>
<td>6</td>
<td><a href="https://leetcode-cn.com/problems/zigzag-conversion">Z 字形变换</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>347</td>
<td>456</td>
<td><a href="https://leetcode-cn.com/problems/132-pattern">132模式</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>348</td>
<td>559</td>
<td><a href="https://leetcode-cn.com/problems/maximum-depth-of-n-ary-tree">N叉树的最大深度</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>349</td>
<td>217</td>
<td><a href="https://leetcode-cn.com/problems/contains-duplicate">存在重复元素</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>350</td>
<td>剑指 Offer 56 - II</td>
<td><a href="https://leetcode-cn.com/problems/shu-zu-zhong-shu-zi-chu-xian-de-ci-shu-ii-lcof">数组中数字出现的次数 II</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>351</td>
<td>剑指 Offer 68 - II</td>
<td><a href="https://leetcode-cn.com/problems/er-cha-shu-de-zui-jin-gong-gong-zu-xian-lcof">二叉树的最近公共祖先</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>352</td>
<td>410</td>
<td><a href="https://leetcode-cn.com/problems/split-array-largest-sum">分割数组的最大值</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>353</td>
<td>面试题 08.12</td>
<td><a href="https://leetcode-cn.com/problems/eight-queens-lcci">八皇后</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>354</td>
<td>剑指 Offer 59 - I</td>
<td><a href="https://leetcode-cn.com/problems/hua-dong-chuang-kou-de-zui-da-zhi-lcof">滑动窗口的最大值</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>355</td>
<td>剑指 Offer 14 - I</td>
<td><a href="https://leetcode-cn.com/problems/jian-sheng-zi-lcof">剪绳子</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>356</td>
<td>421</td>
<td><a href="https://leetcode-cn.com/problems/maximum-xor-of-two-numbers-in-an-array">数组中两个数的最大异或值</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>357</td>
<td>255</td>
<td><a href="https://leetcode-cn.com/problems/verify-preorder-sequence-in-binary-search-tree">验证前序遍历序列二叉搜索树</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>358</td>
<td>1245</td>
<td><a href="https://leetcode-cn.com/problems/tree-diameter">树的直径</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>359</td>
<td>剑指 Offer 38</td>
<td><a href="https://leetcode-cn.com/problems/zi-fu-chuan-de-pai-lie-lcof">字符串的排列</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>360</td>
<td>剑指 Offer 67</td>
<td><a href="https://leetcode-cn.com/problems/ba-zi-fu-chuan-zhuan-huan-cheng-zheng-shu-lcof">把字符串转换成整数</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>361</td>
<td>51</td>
<td><a href="https://leetcode-cn.com/problems/n-queens">N皇后</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>362</td>
<td>994</td>
<td><a href="https://leetcode-cn.com/problems/rotting-oranges">腐烂的橘子</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>363</td>
<td>剑指 Offer 41</td>
<td><a href="https://leetcode-cn.com/problems/shu-ju-liu-zhong-de-zhong-wei-shu-lcof">数据流中的中位数</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>364</td>
<td>剑指 Offer 55 - II</td>
<td><a href="https://leetcode-cn.com/problems/ping-heng-er-cha-shu-lcof">平衡二叉树</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>365</td>
<td>140</td>
<td><a href="https://leetcode-cn.com/problems/word-break-ii">单词拆分 II</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>366</td>
<td>405</td>
<td><a href="https://leetcode-cn.com/problems/convert-a-number-to-hexadecimal">数字转换为十六进制数</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>367</td>
<td>480</td>
<td><a href="https://leetcode-cn.com/problems/sliding-window-median">滑动窗口中位数</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>368</td>
<td>515</td>
<td><a href="https://leetcode-cn.com/problems/find-largest-value-in-each-tree-row">在每个树行中找最大值</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>369</td>
<td>636</td>
<td><a href="https://leetcode-cn.com/problems/exclusive-time-of-functions">函数的独占时间</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>370</td>
<td>1299</td>
<td><a href="https://leetcode-cn.com/problems/replace-elements-with-greatest-element-on-right-side">将每个元素替换为右侧最大元素</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>371</td>
<td>11</td>
<td><a href="https://leetcode-cn.com/problems/container-with-most-water">盛最多水的容器</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>372</td>
<td>220</td>
<td><a href="https://leetcode-cn.com/problems/contains-duplicate-iii">存在重复元素 III</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>373</td>
<td>1464</td>
<td><a href="https://leetcode-cn.com/problems/maximum-product-of-two-elements-in-an-array">数组中两元素的最大乘积</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>374</td>
<td>剑指 Offer 43</td>
<td><a href="https://leetcode-cn.com/problems/1nzheng-shu-zhong-1chu-xian-de-ci-shu-lcof">1～n整数中1出现的次数</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>375</td>
<td>剑指 Offer 64</td>
<td><a href="https://leetcode-cn.com/problems/qiu-12n-lcof">求1+2+…+n</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>376</td>
<td>84</td>
<td><a href="https://leetcode-cn.com/problems/largest-rectangle-in-histogram">柱状图中最大的矩形</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>377</td>
<td>867</td>
<td><a href="https://leetcode-cn.com/problems/transpose-matrix">转置矩阵</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>378</td>
<td>547</td>
<td><a href="https://leetcode-cn.com/problems/friend-circles">朋友圈</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>379</td>
<td>907</td>
<td><a href="https://leetcode-cn.com/problems/sum-of-subarray-minimums">子数组的最小值之和</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>380</td>
<td>1013</td>
<td><a href="https://leetcode-cn.com/problems/partition-array-into-three-parts-with-equal-sum">将数组分成和相等的三个部分</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>381</td>
<td>10</td>
<td><a href="https://leetcode-cn.com/problems/regular-expression-matching">正则表达式匹配</a></td>
<td>困难</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>382</td>
<td>973</td>
<td><a href="https://leetcode-cn.com/problems/k-closest-points-to-origin">最接近原点的 K 个点</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>383</td>
<td>剑指 Offer 26</td>
<td><a href="https://leetcode-cn.com/problems/shu-de-zi-jie-gou-lcof">树的子结构</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>384</td>
<td>171</td>
<td><a href="https://leetcode-cn.com/problems/excel-sheet-column-number">Excel表列序号</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>385</td>
<td>1375</td>
<td><a href="https://leetcode-cn.com/problems/bulb-switcher-iii">灯泡开关 III</a></td>
<td>中等</td>
<td>1</td>
<td></td>
</tr>
<tr>
<td>386</td>
<td>700</td>
<td><a href="https://leetcode-cn.com/problems/search-in-a-binary-search-tree">二叉搜索树中的搜索</a></td>
<td>容易</td>
<td>1</td>
<td></td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue项目优化</title>
    <url>/2022/08/22/Vue%20project%20optimization/</url>
    <content><![CDATA[<h2 id="Vue项目优化"><a href="#Vue项目优化" class="headerlink" title="Vue项目优化"></a>Vue项目优化</h2><span id="more"></span>

<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>Vue 框架通过数据双向绑定和虚拟 DOM 技术，帮我们处理了前端开发中最脏最累的 DOM 操作部分， 我们不再需要去考虑如何操作 DOM 以及如何最高效地操作 DOM；但 Vue 项目中仍然存在项目首屏优化、Webpack 编译配置优化等问题，所以我们仍然需要去关注 Vue 项目性能方面的优化，使项目具有更高效的性能、更好的用户体验。本文是作者通过实际项目的优化实践进行总结而来，希望读者读完本文，有一定的启发思考，从而对自己的项目进行优化起到帮助。本文内容分为以下三部分组成：</p>
<p>Vue 代码层面的优化；</p>
<p>webpack 配置层面的优化；</p>
<p>基础的 Web 技术层面的优化。</p>
<h2 id="一、代码层面的优化"><a href="#一、代码层面的优化" class="headerlink" title="一、代码层面的优化"></a>一、代码层面的优化</h2><p><strong>1.1、v-if 和 v-show 区分使用场景</strong></p>
<p>v-if 是 真正 的条件渲染，因为它会确保在切换过程中条件块内的事件监听器和子组件适当地被销毁和重建；也是惰性的：如果在初始渲染时条件为假，则什么也不做——直到条件第一次变为真时，才会开始渲染条件块。</p>
<p>v-show 就简单得多， 不管初始条件是什么，元素总是会被渲染，并且只是简单地基于 CSS 的 display 属性进行切换。</p>
<p>所以，v-if 适用于在运行时很少改变条件，不需要频繁切换条件的场景；v-show 则适用于需要非常频繁切换条件的场景。</p>
<p><strong>1.2、computed 和 watch  区分使用场景</strong></p>
<p>computed： 是计算属性，依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed  的值；</p>
<p>watch： 更多的是「观察」的作用，类似于某些数据的监听回调 ，每当监听的数据变化时都会执行回调进行后续操作；</p>
<p>运用场景：</p>
<p>当我们需要进行数值计算，并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时，都要重新计算；</p>
<p>当我们需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许我们执行异步操作 ( 访问一个 API )，限制我们执行该操作的频率，并在我们得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</p>
<p><strong>1.3、v-for 遍历必须为 item 添加 key，且避免同时使用 v-if</strong></p>
<p>（1）v-for 遍历必须为 item 添加 key</p>
<p>在列表数据进行遍历渲染时，需要为每一项 item 设置唯一 key 值，方便 Vue.js 内部机制精准找到该条列表数据。当 state 更新时，新的状态值和旧的状态值对比，较快地定位到 diff 。</p>
<p>（2）v-for 遍历避免同时使用 v-if</p>
<p>v-for 比 v-if 优先级高，如果每一次都需要遍历整个数组，将会影响速度，尤其是当之需要渲染很小一部分的时候，必要情况下应该替换成 computed 属性。</p>
<p>推荐：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">&lt;ul&gt;<br>  <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;user in activeUsers&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="language-xml">    &#123;&#123; user.name &#125;&#125;</span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br>&lt;/ul&gt;<br><span class="hljs-attr">computed</span>: &#123;<br>  <span class="hljs-attr">activeUsers</span>: <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">users</span>.<span class="hljs-title function_">filter</span>(<span class="hljs-keyword">function</span> (<span class="hljs-params">user</span>) &#123;<br>   <span class="hljs-keyword">return</span> user.<span class="hljs-property">isActive</span><br>    &#125;)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>不推荐：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">li</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;user in users&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;user.isActive&quot;</span></span></span><br><span class="hljs-tag"><span class="language-xml">    <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;user.id&quot;</span>&gt;</span></span><br><span class="language-xml">    </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">user.name</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br></code></pre></td></tr></table></figure>
<p><strong>1.4、长列表性能优化</strong></p>
<p>Vue 会通过 Object.defineProperty 对数据进行劫持，来实现视图响应数据的变化，然而有些时候我们的组件就是纯粹的数据展示，不会有任何改变，我们就不需要 Vue 来劫持我们的数据，在大量数据展示的情况下，这能够很明显的减少组件初始化的时间，那如何禁止 Vue 劫持我们的数据呢？可以通过 Object.freeze 方法来冻结一个对象，一旦被冻结的对象就再也不能被修改了。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">export <span class="hljs-keyword">default</span> &#123;<br>  data: () =&gt; (&#123;<br>    users: &#123;&#125;<br>  &#125;),<br>  async created() &#123;<br>    const users = await axios.<span class="hljs-keyword">get</span>(&quot;/api/users&quot;);<br>    this.users = <span class="hljs-keyword">Object</span>.<span class="hljs-keyword">freeze</span>(users);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>
<p><strong>1.5、事件的销毁</strong></p>
<p>Vue 组件销毁时，会自动清理它与其它实例的连接，解绑它的全部指令及事件监听器，但是仅限于组件本身的事件。如果在 js 内</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">created</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">addEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, this<span class="hljs-selector-class">.click</span>, false)<br>&#125;,<br><span class="hljs-function"><span class="hljs-title">beforeDestroy</span><span class="hljs-params">()</span></span> &#123;<br>  <span class="hljs-built_in">removeEventListener</span>(<span class="hljs-string">&#x27;click&#x27;</span>, this<span class="hljs-selector-class">.click</span>, false)<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>1.6、图片资源懒加载</strong></p>
<p>对于图片过多的页面，为了加速页面加载速度，所以很多时候我们需要将页面内未出现在可视区域内的图片先不做加载， 等到滚动到可视区域后再去加载。这样对于页面加载性能上会有很大的提升，也提高了用户体验。我们在项目中使用 Vue 的 vue-lazyload 插件：</p>
<p>（1）安装插件</p>
<figure class="highlight q"><table><tr><td class="code"><pre><code class="hljs q">npm install vue-lazyload --<span class="hljs-built_in">save</span>-<span class="hljs-built_in">dev</span><br></code></pre></td></tr></table></figure>
<p>（2）在入口文件 man.js 中引入并使用</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> VueLazyload <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue-lazyload&#x27;</span><br></code></pre></td></tr></table></figure>
<p>然后再 vue 中直接使用</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">Vue.<span class="hljs-keyword">use</span>(VueLazyload)<br></code></pre></td></tr></table></figure>
<p>或者添加自定义选项</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">Vue.use(VueLazyload, &#123;<br>preLoad: 1.3,<br><span class="hljs-keyword">error: </span>&#x27;dist/error.png&#x27;,<br>loading: &#x27;dist/loading.gif&#x27;,<br>attempt: 1<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>（3）在 vue 文件中将 img 标签的 src 属性直接改为 v-lazy ，从而将图片显示方式更改为懒加载显示：</p>
<img v-lazy="/static/img/1.png">
以上为 vue-lazyload 插件的简单使用，如果要看插件的更多参数选项，可以查看 vue-lazyload 的 github 地址。

<p><strong>1.7、路由懒加载</strong><br>Vue  是单页面应用，可能会有很多的路由引入 ，这样使用 webpcak 打包后的文件很大，当进入首页时，加载的资源过多，页面会出现白屏的情况，不利于用户体验。如果我们能把不同路由对应的组件分割成不同的代码块，然后当路由被访问的时候才加载对应的组件，这样就更加高效了。这样会大大提高首屏显示的速度，但是可能其他的页面的速度就会降下来。</p>
<p>路由懒加载：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const Foo = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;./Foo.vue&#x27;</span>)<br>const router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123; path: <span class="hljs-string">&#x27;/foo&#x27;</span>, component: Foo &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure>
<p><strong>1.8、第三方插件的按需引入</strong></p>
<p>我们在项目中经常会需要引入第三方插件，如果我们直接引入整个插件，会导致项目的体积太大，我们可以借助 babel-plugin-component ，然后可以只引入需要的组件，以达到减小项目体积的目的。以下为项目中引入 element-ui 组件库为例：</p>
<p>（1）首先，安装 babel-plugin-component ：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">npm <span class="hljs-keyword">install </span><span class="hljs-keyword">babel-plugin-component </span>-D<br></code></pre></td></tr></table></figure>
<p>（2）然后，将 .babelrc 修改为：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">&#123;<br>  <span class="hljs-string">&quot;presets&quot;</span>: [[<span class="hljs-string">&quot;es2015&quot;</span>, &#123; <span class="hljs-string">&quot;modules&quot;</span>: false &#125;]],<br>  <span class="hljs-string">&quot;plugins&quot;</span>: [<br>    [<br>      <span class="hljs-string">&quot;component&quot;</span>,<br>      &#123;<br>        <span class="hljs-string">&quot;libraryName&quot;</span>: <span class="hljs-string">&quot;element-ui&quot;</span>,<br>        <span class="hljs-string">&quot;styleLibraryName&quot;</span>: <span class="hljs-string">&quot;theme-chalk&quot;</span><br>      &#125;<br>    ]<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>（3）在 main.js 中引入部分组件：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">import</span> Vue <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span>;<br><span class="hljs-keyword">import</span> &#123; Button, <span class="hljs-keyword">Select</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;element-ui&#x27;</span>;<br><br> Vue.use(Button)<br> Vue.use(<span class="hljs-keyword">Select</span>)<br></code></pre></td></tr></table></figure>
<p><strong>1.9、优化无限列表性能</strong></p>
<p>如果你的应用存在非常长或者无限滚动的列表，那么需要采用 窗口化 的技术来优化性能，只需要渲染少部分区域的内容，减少重新渲染组件和创建 dom 节点的时间。你可以参考以下开源项目 vue-virtual-scroll-list 和 vue-virtual-scroller  来优化这种无限列表的场景的。</p>
<p><strong>1.10、服务端渲染 SSR or 预渲染</strong></p>
<p>服务端渲染是指 Vue 在客户端将标签渲染成的整个 html 片段的工作在服务端完成，服务端形成的 html 片段直接返回给客户端这个过程就叫做服务端渲染。</p>
<p>（1）服务端渲染的优点：</p>
<p>更好的 SEO：因为 SPA 页面的内容是通过 Ajax 获取，而搜索引擎爬取工具并不会等待 Ajax 异步完成后再抓取页面内容，所以在 SPA 中是抓取不到页面通过 Ajax 获取到的内容；而 SSR 是直接由服务端返回已经渲染好的页面（数据已经包含在页面中），所以搜索引擎爬取工具可以抓取渲染好的页面；</p>
<p>更快的内容到达时间（首屏加载更快）：SPA 会等待所有 Vue 编译后的 js 文件都下载完成后，才开始进行页面的渲染，文件下载等需要一定的时间等，所以首屏渲染需要一定的时间；SSR 直接由服务端渲染好页面直接返回显示，无需等待下载 js 文件及再去渲染等，所以 SSR 有更快的内容到达时间；</p>
<p>（2）服务端渲染的缺点：</p>
<p>更多的开发条件限制：例如服务端渲染只支持 beforCreate 和 created 两个钩子函数，这会导致一些外部扩展库需要特殊处理，才能在服务端渲染应用程序中运行；并且与可以部署在任何静态文件服务器上的完全静态单页面应用程序 SPA 不同，服务端渲染应用程序，需要处于 Node.js server 运行环境；</p>
<p>更多的服务器负载：在 Node.js 中渲染完整的应用程序，显然会比仅仅提供静态文件的 server 更加大量占用CPU 资源，因此如果你预料在高流量环境下使用，请准备相应的服务器负载，并明智地采用缓存策略。</p>
<p>如果你的项目的 SEO 和 首屏渲染是评价项目的关键指标，那么你的项目就需要服务端渲染来帮助你实现最佳的初始加载性能和 SEO，具体的 Vue SSR 如何实现，可以参考作者的另一篇文章《Vue SSR 踩坑之旅》。如果你的 Vue 项目只需改善少数营销页面（例如  &#x2F;， &#x2F;about， &#x2F;contact 等）的 SEO，那么你可能需要预渲染，在构建时 (build time) 简单地生成针对特定路由的静态 HTML 文件。优点是设置预渲染更简单，并可以将你的前端作为一个完全静态的站点，具体你可以使用 prerender-spa-plugin 就可以轻松地添加预渲染 。</p>
<h2 id="二、Webpack-层面的优化"><a href="#二、Webpack-层面的优化" class="headerlink" title="二、Webpack 层面的优化"></a>二、Webpack 层面的优化</h2><p><strong>2.1、Webpack 对图片进行压缩</strong></p>
<p>在 vue 项目中除了可以在 webpack.base.conf.js 中 url-loader 中设置 limit 大小来对图片处理，对小于 limit 的图片转化为 base64 格式，其余的不做操作。所以对有些较大的图片资源，在请求资源的时候，加载会很慢，我们可以用 image-webpack-loader来压缩图片：</p>
<p>（1）首先，安装 image-webpack-loader  ：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">npm install <span class="hljs-built_in">image</span>-webpack-loader --<span class="hljs-built_in">save</span>-dev<br></code></pre></td></tr></table></figure>
<p>（2）然后，在 webpack.base.conf.js  中进行配置：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">&#123;<br>  test: /\.(png|jpe?g|gif|svg)(\?.*)?$/,<br>  use:[<br>    &#123;<br>    loader: <span class="hljs-string">&#x27;url-loader&#x27;</span>,<br>    options: &#123;<br>      limit: <span class="hljs-number">10000</span>,<br>      name: utils.<span class="hljs-built_in">assetsPath</span>(<span class="hljs-string">&#x27;img/[name].[hash:7].[ext]&#x27;</span>)<br>      &#125;<br>    &#125;,<br>    &#123;<br>      loader: <span class="hljs-string">&#x27;image-webpack-loader&#x27;</span>,<br>      options: &#123;<br>        bypassOnDebug: true,<br>      &#125;<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>
<p>2.2、减少 ES6 转为 ES5 的冗余代码<br>Babel 插件会在将 ES6 代码转换成 ES5 代码时会注入一些辅助函数，例如下面的 ES6 代码：</p>
<figure class="highlight scala"><table><tr><td class="code"><pre><code class="hljs scala"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloWebpack</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Component</span></span>&#123;...&#125;<br></code></pre></td></tr></table></figure>
<p>这段代码再被转换成能正常运行的 ES5 代码时需要以下两个辅助函数：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">babel-runtime<span class="hljs-regexp">/helpers/</span>createClass  <span class="hljs-regexp">//</span> 用于实现 class 语法<br>babel-runtime<span class="hljs-regexp">/helpers/i</span>nherits  <span class="hljs-regexp">//</span> 用于实现 extends 语法<br></code></pre></td></tr></table></figure>
<p>在默认情况下， Babel 会在每个输出文件中内嵌这些依赖的辅助函数代码，如果多个源代码文件都依赖这些辅助函数，那么这些辅助函数的代码将会出现很多次，造成代码冗余。为了不让这些辅助函数的代码重复出现，可以在依赖它们时通过 require(‘babel-runtime&#x2F;helpers&#x2F;createClass’) 的方式导入，这样就能做到只让它们出现一次。babel-plugin-transform-runtime 插件就是用来实现这个作用的，将相关辅助函数进行替换成导入语句，从而减小 babel 编译出来的代码的文件大小。</p>
<p>（1）首先，安装 babel-plugin-transform-runtime ：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css">npm install babel-plugin-<span class="hljs-attribute">transform</span>-runtime <span class="hljs-attr">--save-dev</span><br></code></pre></td></tr></table></figure>
<p>（2）然后，修改 .babelrc  配置文件为：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog"><span class="hljs-string">&quot;plugins&quot;</span>: [<br>    <span class="hljs-string">&quot;transform-runtime&quot;</span><br>]<br></code></pre></td></tr></table></figure>
<p>如果要看插件的更多详细内容，可以查看babel-plugin-transform-runtime 的 详细介绍。</p>
<p><strong>2.3、提取公共代码</strong></p>
<p>如果项目中没有去将每个页面的第三方库和公共模块提取出来，则项目会存在以下问题：</p>
<p>相同的资源被重复加载，浪费用户的流量和服务器的成本。</p>
<p>每个页面需要加载的资源太大，导致网页首屏加载缓慢，影响用户体验。</p>
<p>所以我们需要将多个页面的公共代码抽离成单独的文件，来优化以上问题 。Webpack 内置了专门用于提取多个Chunk 中的公共部分的插件 CommonsChunkPlugin，我们在项目中 CommonsChunkPlugin 的配置如下：</p>
<p>&#x2F;&#x2F; 所有在 package.json 里面依赖的包，都会被打包进 vendor.js 这个文件中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;vendor&#x27;</span>,<br>  <span class="hljs-attr">minChunks</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"><span class="hljs-variable language_">module</span>, count</span>) &#123;<br>    <span class="hljs-keyword">return</span> (<br>      <span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span> &amp;&amp;<br>      <span class="hljs-regexp">/\.js$/</span>.<span class="hljs-title function_">test</span>(<span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span>) &amp;&amp;<br>      <span class="hljs-variable language_">module</span>.<span class="hljs-property">resource</span>.<span class="hljs-title function_">indexOf</span>(<br>        path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;../node_modules&#x27;</span>)<br>      ) === <span class="hljs-number">0</span><br>    );<br>  &#125;<br>&#125;),<br><span class="hljs-comment">// 抽取出代码模块的映射关系</span><br><span class="hljs-keyword">new</span> webpack.<span class="hljs-property">optimize</span>.<span class="hljs-title class_">CommonsChunkPlugin</span>(&#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;manifest&#x27;</span>,<br>  <span class="hljs-attr">chunks</span>: [<span class="hljs-string">&#x27;vendor&#x27;</span>]<br>&#125;)<br></code></pre></td></tr></table></figure>
<p>如果要看插件的更多详细内容，可以查看 CommonsChunkPlugin 的 详细介绍。</p>
<p><strong>2.4、模板预编译</strong></p>
<p>当使用 DOM 内模板或 JavaScript 内的字符串模板时，模板会在运行时被编译为渲染函数。通常情况下这个过程已经足够快了，但对性能敏感的应用还是最好避免这种用法。</p>
<p>预编译模板最简单的方式就是使用单文件组件——相关的构建设置会自动把预编译处理好，所以构建好的代码已经包含了编译出来的渲染函数而不是原始的模板字符串。</p>
<p>如果你使用 webpack，并且喜欢分离 JavaScript 和模板文件，你可以使用 vue-template-loader，它也可以在构建过程中把模板文件转换成为 JavaScript 渲染函数。</p>
<p><strong>2.5、提取组件的 CSS</strong></p>
<p>当使用单文件组件时，组件内的 CSS 会以 style 标签的方式通过 JavaScript 动态注入。这有一些小小的运行时开销，如果你使用服务端渲染，这会导致一段 “无样式内容闪烁 (fouc) ” 。将所有组件的 CSS 提取到同一个文件可以避免这个问题，也会让 CSS 更好地进行压缩和缓存。</p>
<p>查阅这个构建工具各自的文档来了解更多：</p>
<p>webpack + vue-loader ( vue-cli 的 webpack 模板已经预先配置好)</p>
<p>Browserify + vueify</p>
<p>Rollup + rollup-plugin-vue</p>
<p><strong>2.6、优化 SourceMap</strong></p>
<p>我们在项目进行打包后，会将开发中的多个文件代码打包到一个文件中，并且经过压缩、去掉多余的空格、babel编译化后，最终将编译得到的代码会用于线上环境，那么这样处理后的代码和源代码会有很大的差别，当有 bug的时候，我们只能定位到压缩处理后的代码位置，无法定位到开发环境中的代码，对于开发来说不好调式定位问题，因此 sourceMap 出现了，它就是为了解决不好调式代码问题的。</p>
<p>SourceMap 的可选值如下（+ 号越多，代表速度越快，- 号越多，代表速度越慢, o 代表中等速度 ）</p>
<p>开发环境推荐：cheap-module-eval-source-map</p>
<p>生产环境推荐：cheap-module-source-map</p>
<p>原因如下：</p>
<p>cheap：源代码中的列信息是没有任何作用，因此我们打包后的文件不希望包含列相关信息，只有行信息能建立打包前后的依赖关系。因此不管是开发环境或生产环境，我们都希望添加 cheap 的基本类型来忽略打包前后的列信息；</p>
<p>module ：不管是开发环境还是正式环境，我们都希望能定位到bug的源代码具体的位置，比如说某个 Vue 文件报错了，我们希望能定位到具体的 Vue 文件，因此我们也需要 module 配置；</p>
<p>soure-map ：source-map 会为每一个打包后的模块生成独立的 soucemap 文件 ，因此我们需要增加source-map 属性；</p>
<p>eval-source-map：eval 打包代码的速度非常快，因为它不生成 map 文件，但是可以对 eval 组合使用 eval-source-map 使用会将 map 文件以 DataURL 的形式存在打包后的 js 文件中。在正式环境中不要使用 eval-source-map, 因为它会增加文件的大小，但是在开发环境中，可以试用下，因为他们打包的速度很快。</p>
<p><strong>2.7、构建结果输出分析</strong></p>
<p>Webpack 输出的代码可读性非常差而且文件非常大，让我们非常头疼。为了更简单、直观地分析输出结果，社区中出现了许多可视化分析工具。这些工具以图形的方式将结果更直观地展示出来，让我们快速了解问题所在。接下来讲解我们在 Vue 项目中用到的分析工具：webpack-bundle-analyzer 。</p>
<p>我们在项目中 webpack.prod.conf.js 进行配置：</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">if (<span class="hljs-built_in">config</span>.<span class="hljs-keyword">build.bundleAnalyzerReport) </span>&#123;<br>  var <span class="hljs-keyword">BundleAnalyzerPlugin </span>=   require(<span class="hljs-string">&#x27;webpack-bundle-analyzer&#x27;</span>).<span class="hljs-keyword">BundleAnalyzerPlugin;</span><br><span class="hljs-keyword"></span>  webpackConfig.plugins.push(new <span class="hljs-keyword">BundleAnalyzerPlugin());</span><br><span class="hljs-keyword"></span>&#125;<br></code></pre></td></tr></table></figure>
<p>执行  $ npm run build –report  后生成分析报告如下：</p>
<p><strong>2.8、Vue 项目的编译优化</strong></p>
<p>如果你的 Vue 项目使用 Webpack 编译，需要你喝一杯咖啡的时间，那么也许你需要对项目的 Webpack 配置进行优化，提高 Webpack 的构建效率。具体如何进行 Vue 项目的 Webpack 构建优化，可以参考作者的另一篇文章《 Vue 项目 Webpack 优化实践》</p>
<h2 id="三、基础的-Web-技术优化"><a href="#三、基础的-Web-技术优化" class="headerlink" title="三、基础的 Web 技术优化"></a>三、基础的 Web 技术优化</h2><p><strong>3.1、开启 gzip 压缩</strong></p>
<p>gzip 是 GNUzip 的缩写，最早用于 UNIX 系统的文件压缩。HTTP 协议上的 gzip 编码是一种用来改进 web 应用程序性能的技术，web 服务器和客户端（浏览器）必须共同支持 gzip。目前主流的浏览器，Chrome，firefox，IE等都支持该协议。常见的服务器如 Apache，Nginx，IIS 同样支持，gzip 压缩效率非常高，通常可以达到 70% 的压缩率，也就是说，如果你的网页有 30K，压缩之后就变成了 9K 左右</p>
<p>以下我们以服务端使用我们熟悉的 express 为例，开启 gzip 非常简单，相关步骤如下：</p>
<p>安装：</p>
<p>npm install compression –save<br>添加代码逻辑：</p>
<figure class="highlight isbl"><table><tr><td class="code"><pre><code class="hljs isbl"><span class="hljs-variable">var</span> <span class="hljs-variable">compression</span> = <span class="hljs-function"><span class="hljs-title">require</span>(<span class="hljs-string">&#x27;compression&#x27;</span>);</span><br><span class="hljs-function"><span class="hljs-variable">var</span> <span class="hljs-variable">app</span> = <span class="hljs-title">express</span>();</span><br><span class="hljs-function"><span class="hljs-variable">app.use</span>(<span class="hljs-title">compression</span>())</span><br></code></pre></td></tr></table></figure>
<p>重启服务，观察网络面板里面的 response header，如果看到如下红圈里的字段则表明 gzip 开启成功 ：</p>
<p><strong>3.2、浏览器缓存</strong></p>
<p>为了提高用户加载页面的速度，对静态资源进行缓存是非常必要的，根据是否需要重新向服务器发起请求来分类，将 HTTP 缓存规则分为两大类（强制缓存，对比缓存），如果对缓存机制还不是了解很清楚的，可以参考作者写的关于 HTTP 缓存的文章《深入理解HTTP缓存机制及原理》，这里不再赘述。</p>
<p><strong>3.3、CDN 的使用</strong></p>
<p>浏览器从服务器上下载 CSS、js 和图片等文件时都要和服务器连接，而大部分服务器的带宽有限，如果超过限制，网页就半天反应不过来。而 CDN 可以通过不同的域名来加载文件，从而使下载文件的并发连接数大大增加，且CDN 具有更好的可用性，更低的网络延迟和丢包率 。</p>
<p><strong>3.4、使用 Chrome Performance 查找性能瓶颈</strong></p>
<p>Chrome 的 Performance 面板可以录制一段时间内的 js 执行细节及时间。使用 Chrome 开发者工具分析页面性能的步骤如下。</p>
<p>打开 Chrome 开发者工具，切换到 Performance 面板</p>
<p>点击 Record 开始录制</p>
<p>刷新页面或展开某个节点</p>
<p>点击 Stop 停止录制</p>
<p>#原文地址：<a href="https://blog.csdn.net/qq_37939251/article/details/100031285">https://blog.csdn.net/qq_37939251/article/details/100031285</a></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>javaScript</title>
    <url>/2022/08/22/JavaScript/</url>
    <content><![CDATA[<h2 id="javaScript"><a href="#javaScript" class="headerlink" title="javaScript"></a>javaScript</h2><span id="more"></span>

<p><img  src="/images/image/js.png"  ><span class="image-caption">JavaScript面试题.png</span></p>
<h2 id="一、数据类型"><a href="#一、数据类型" class="headerlink" title="一、数据类型"></a>一、数据类型</h2><h3 id="1-JavaScript有哪些数据类型，它们的区别？"><a href="#1-JavaScript有哪些数据类型，它们的区别？" class="headerlink" title="1. JavaScript有哪些数据类型，它们的区别？"></a>1. JavaScript有哪些数据类型，它们的区别？</h3><p>JavaScript共有八种数据类型，分别是 Undefined、Null、Boolean、Number、String、Object、Symbol、BigInt。</p>
<p>其中 Symbol 和 BigInt 是ES6 中新增的数据类型：</p>
<ul>
<li>Symbol 代表创建后独一无二且不可变的数据类型，它主要是为了解决可能出现的全局变量冲突的问题。</li>
<li>BigInt 是一种数字类型的数据，它可以表示任意精度格式的整数，使用 BigInt 可以安全地存储和操作大整数，即使这个数已经超出了 Number 能够表示的安全整数范围。</li>
</ul>
<p>这些数据可以分为原始数据类型和引用数据类型：</p>
<ul>
<li>栈：原始数据类型（Undefined、Null、Boolean、Number、String）</li>
<li>堆：引用数据类型（对象、数组和函数）</li>
</ul>
<p>两种类型的区别在于<strong>存储位置的不同：</strong></p>
<ul>
<li>原始数据类型直接存储在栈（stack）中的简单数据段，占据空间小、大小固定，属于被频繁使用数据，所以放入栈中存储；</li>
<li>引用数据类型存储在堆（heap）中的对象，占据空间大、大小不固定。如果存储在栈中，将会影响程序运行的性能；引用数据类型在栈中存储了指针，该指针指向堆中该实体的起始地址。当解释器寻找引用值时，会首先检索其在栈中的地址，取得地址后从堆中获得实体。</li>
</ul>
<p>堆和栈的概念存在于数据结构和操作系统内存中，在数据结构中：</p>
<ul>
<li>在数据结构中，栈中数据的存取方式为先进后出。</li>
<li>堆是一个优先队列，是按优先级来进行排序的，优先级可以按照大小来规定。</li>
</ul>
<p>在操作系统中，内存被分为栈区和堆区：</p>
<ul>
<li>栈区内存由编译器自动分配释放，存放函数的参数值，局部变量的值等。其操作方式类似于数据结构中的栈。 </li>
<li>堆区内存一般由开发着分配释放，若开发者不释放，程序结束时可能由垃圾回收机制回收。</li>
</ul>
<h3 id="2-数据类型检测的方式有哪些"><a href="#2-数据类型检测的方式有哪些" class="headerlink" title="2. 数据类型检测的方式有哪些"></a>2. 数据类型检测的方式有哪些</h3><p><strong>（1）typeof</strong></p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-number">2</span>);               <span class="hljs-comment">// number</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">true</span>);            <span class="hljs-comment">// boolean</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-string">&#x27;str&#x27;</span>);           <span class="hljs-comment">// string</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> []);              <span class="hljs-comment">// object    </span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;);    <span class="hljs-comment">// function</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> &#123;&#125;);              <span class="hljs-comment">// object</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">undefined</span>);       <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">typeof</span> <span class="hljs-literal">null</span>);            <span class="hljs-comment">// object</span><br></code></pre></td></tr></table></figure>

<p>其中数组、对象、null都会被判断为object，其他判断都正确。</p>
<p><strong>（2）instanceof</strong></p>
<p><code>instanceof</code>可以正确判断对象的类型，<strong>其内部运行机制是****判断在其原型链中能否找到该类型的原型</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">2</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Number</span>);                    <span class="hljs-comment">// false</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-literal">true</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Boolean</span>);                <span class="hljs-comment">// false </span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;str&#x27;</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">String</span>);                <span class="hljs-comment">// false </span><br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>([] <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Array</span>);                    <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Function</span>);       <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(&#123;&#125; <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Object</span>);                   <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<p>可以看到，<code>instanceof</code><strong>只能正确判断引用数据类型</strong>，而不能判断基本数据类型。<code>instanceof</code> 运算符可以用来测试一个对象在其原型链中是否存在一个构造函数的 <code>prototype</code> 属性。</p>
<p><strong>（3） constructor</strong></p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>((<span class="hljs-number">2</span>).constructor === <span class="hljs-built_in">Number</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>((<span class="hljs-literal">true</span>).constructor === <span class="hljs-built_in">Boolean</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>((<span class="hljs-string">&#x27;str&#x27;</span>).constructor === String); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(([]).constructor === <span class="hljs-built_in">Array</span>); <span class="hljs-comment">// true</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>((<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;).constructor === <span class="hljs-keyword">Function</span>); // <span class="hljs-title function_">true</span><br><span class="hljs-title function_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-params">(&#123;&#125;</span>).<span class="hljs-title function_">constructor</span> === <span class="hljs-title function_">Object</span>); // <span class="hljs-title function_">true</span><br></code></pre></td></tr></table></figure>

<p><code>constructor</code>有两个作用，一是判断数据的类型，二是对象实例通过 <code>constrcutor</code> 对象访问它的构造函数。需要注意，如果创建一个对象来改变它的原型，<code>constructor</code>就不能用来判断数据类型了：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">function Fn()&#123;&#125;<span class="hljs-comment">;</span><br> <br>Fn.prototype <span class="hljs-operator">=</span> new Array()<span class="hljs-comment">;</span><br> <br>var f <span class="hljs-operator">=</span> new Fn()<span class="hljs-comment">;</span><br> <br>console.log(f.constructor<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Fn)<span class="hljs-comment">;    // false</span><br>console.log(f.constructor<span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span>Array)<span class="hljs-comment">; // true</span><br></code></pre></td></tr></table></figure>

<p><strong>（4）Object.prototype.toString.call()</strong></p>
<p><code>Object.prototype.toString.call()</code> 使用 Object 对象的原型方法 toString 来判断数据类型：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = Object.prototype.toString;<br> <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call(<span class="hljs-number">2</span>));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call(<span class="hljs-literal">true</span>));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call(<span class="hljs-string">&#x27;str&#x27;</span>));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call([]));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;&#125;));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call(&#123;&#125;));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call(<span class="hljs-literal">undefined</span>));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a.call(<span class="hljs-literal">null</span>));<br></code></pre></td></tr></table></figure>

<p>同样是检测对象obj调用toString方法，obj.toString()的结果和Object.prototype.toString.call(obj)的结果不一样，这是为什么？</p>
<p>这是因为toString是Object的原型方法，而Array、function等<strong>类型作为Object的实例，都重写了toString方法</strong>。不同的对象类型调用toString方法时，根据原型链的知识，调用的是对应的重写之后的toString方法（function类型返回内容为函数体的字符串，Array类型返回元素组成的字符串…），而不会去调用Object上原型toString方法（返回对象的具体类型），所以采用obj.toString()不能得到其对象类型，只能将obj转换为字符串类型；因此，在想要得到对象的具体类型时，应该调用Object原型上的toString方法。</p>
<h3 id="3-判断数组的方式有哪些"><a href="#3-判断数组的方式有哪些" class="headerlink" title="3. 判断数组的方式有哪些"></a>3. 判断数组的方式有哪些</h3><ul>
<li>通过Object.prototype.toString.call()做判断</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Object</span>.proto<span class="hljs-keyword">type</span>.toString.call(obj).slice(8,-1) === &#x27;<span class="hljs-type">Array&#x27;</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>通过原型链做判断</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">obj.__proto__ <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> Array.prototype<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<ul>
<li>通过ES6的Array.isArray()做判断</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Arrray(<span class="hljs-params">obj</span>)</span>;<br></code></pre></td></tr></table></figure>

<ul>
<li>通过instanceof做判断</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">obj <span class="hljs-keyword">instanceof</span> <span class="hljs-built_in">Array</span><br></code></pre></td></tr></table></figure>

<ul>
<li>通过Array.prototype.isPrototypeOf</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.isPrototypeOf(obj)<br></code></pre></td></tr></table></figure>

<h3 id="4-null和undefined区别"><a href="#4-null和undefined区别" class="headerlink" title="4. null和undefined区别"></a>4. null和undefined区别</h3><p>首先 Undefined 和 Null 都是基本数据类型，这两个基本数据类型分别都只有一个值，就是 undefined 和 null。</p>
<p>undefined 代表的含义是<strong>未定义</strong>，null 代表的含义是<strong>空对象</strong>。一般变量声明了但还没有定义的时候会返回 undefined，null主要用于赋值给一些可能会返回对象的变量，作为初始化。</p>
<p>undefined 在 JavaScript 中不是一个保留字，这意味着可以使用 undefined 来作为一个变量名，但是这样的做法是非常危险的，它会影响对 undefined 值的判断。我们可以通过一些方法获得安全的 undefined 值，比如说 void 0。</p>
<p>当对这两种类型使用 typeof 进行判断时，Null 类型化会返回 “object”，这是一个历史遗留的问题。当使用双等号对两种类型的值进行比较时会返回 true，使用三个等号时会返回 false。</p>
<h3 id="5-typeof-null-的结果是什么，为什么？"><a href="#5-typeof-null-的结果是什么，为什么？" class="headerlink" title="5. typeof null 的结果是什么，为什么？"></a>5. typeof null 的结果是什么，为什么？</h3><p>typeof null 的结果是Object。</p>
<p>在 JavaScript 第一个版本中，所有值都存储在 32 位的单元中，每个单元包含一个小的 <strong>类型标签(1-3 bits)</strong> 以及当前要存储值的真实数据。类型标签存储在每个单元的低位中，共有五种数据类型：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">000</span><span class="hljs-punctuation">:</span> <span class="hljs-string">object   - 当前存储的数据指向一个对象。</span><br>  <span class="hljs-attribute">1</span><span class="hljs-punctuation">:</span> <span class="hljs-string">int      - 当前存储的数据是一个 31 位的有符号整数。</span><br><span class="hljs-attribute">010</span><span class="hljs-punctuation">:</span> <span class="hljs-string">double   - 当前存储的数据指向一个双精度的浮点数。</span><br><span class="hljs-attribute">100</span><span class="hljs-punctuation">:</span> <span class="hljs-string">string   - 当前存储的数据指向一个字符串。</span><br><span class="hljs-attribute">110</span><span class="hljs-punctuation">:</span> <span class="hljs-string">boolean  - 当前存储的数据是布尔值。</span><br></code></pre></td></tr></table></figure>

<p>如果最低位是 1，则类型标签标志位的长度只有一位；如果最低位是 0，则类型标签标志位的长度占三位，为存储其他四种数据类型提供了额外两个 bit 的长度。</p>
<p>有两种特殊数据类型：</p>
<ul>
<li>undefined的值是 (-2)30(一个超出整数范围的数字)；</li>
<li>null 的值是机器码 NULL 指针(null 指针的值全是 0)</li>
</ul>
<p>那也就是说null的类型标签也是000，和Object的类型标签一样，所以会被判定为Object。</p>
<h3 id="6-intanceof-操作符的实现原理及实现"><a href="#6-intanceof-操作符的实现原理及实现" class="headerlink" title="6. intanceof 操作符的实现原理及实现"></a>6. intanceof 操作符的实现原理及实现</h3><p> instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">Instanceof(<span class="hljs-params">left</span>, <span class="hljs-params">right</span>)</span> &#123;<br>  <span class="hljs-comment">// 获取对象的原型</span><br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">left</span>)</span><br>  <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br>  <span class="hljs-keyword">let</span> prototype = right.prototype; <br> <br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) return <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto<span class="hljs-operator"> === </span>prototype) return <span class="hljs-literal">true</span>;<br>    <span class="hljs-comment">// 如果没有找到，就继续从其原型上找，Object.getPrototypeOf方法用来获取指定对象的原型</span><br>    proto = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">proto</span>)</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-为什么0-1-0-2-x3D-x3D-0-3，如何让其相等"><a href="#7-为什么0-1-0-2-x3D-x3D-0-3，如何让其相等" class="headerlink" title="7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等"></a>7. 为什么0.1+0.2 ! &#x3D;&#x3D; 0.3，如何让其相等</h3><p>在开发过程中遇到类似这样的问题：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> n1 = <span class="hljs-number">0</span>.<span class="hljs-number">1</span>, n2 = <span class="hljs-number">0</span>.<span class="hljs-number">2</span><br><span class="hljs-attribute">console</span>.log(n1 + n2)  // <span class="hljs-number">0</span>.<span class="hljs-number">30000000000000004</span><br></code></pre></td></tr></table></figure>

<p>这里得到的不是想要的结果，要想等于0.3，就要把它进行转化：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode"><span class="hljs-comment">(n1 + n2)</span>.toFixed<span class="hljs-comment">(2)</span> <span class="hljs-comment">// 注意，toFixed为四舍五入</span><br></code></pre></td></tr></table></figure>

<p><code>toFixed(num)</code> 方法可把 Number 四舍五入为指定小数位数的数字。那为什么会出现这样的结果呢？</p>
<p>计算机是通过二进制的方式存储数据的，所以计算机计算0.1+0.2的时候，实际上是计算的两个数的二进制的和。0.1的二进制是<code>0.0001100110011001100...</code>（1100循环），0.2的二进制是：<code>0.00110011001100...</code>（1100循环），这两个数的二进制都是无限循环的数。那JavaScript是如何处理无限循环的二进制小数呢？</p>
<p>一般我们认为数字包括整数和小数，但是在 JavaScript 中只有一种数字类型：Number，它的实现遵循IEEE 754标准，使用64位固定长度来表示，也就是标准的double双精度浮点数。在二进制科学表示法中，双精度浮点数的小数部分最多只能保留52位，再加上前面的1，其实就是保留53位有效数字，剩余的需要舍去，遵从“0舍1入”的原则。</p>
<p>根据这个原则，0.1和0.2的二进制数相加，再转化为十进制数就是：<code>0.30000000000000004</code>。</p>
<p>下面看一下<strong>双精度数是如何保存</strong>的：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603641384908-7958dffa-6d26-4e36-963e-b41c9e3ca8b0.png"  ><span class="image-caption">image</span></p>
<ul>
<li>第一部分（蓝色）：用来存储符号位（sign），用来区分正负数，0表示正数，占用1位</li>
<li>第二部分（绿色）：用来存储指数（exponent），占用11位</li>
<li>第三部分（红色）：用来存储小数（fraction），占用52位</li>
</ul>
<p>对于0.1，它的二进制为：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">0</span>.<span class="hljs-number">00011001100110011001100110011001100110011001100110011001</span> <span class="hljs-number">10011</span>...<br></code></pre></td></tr></table></figure>

<p>转为科学计数法（科学计数法的结果就是浮点数）：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">1</span>.<span class="hljs-number">1001100110011001100110011001100110011001100110011001</span>*<span class="hljs-number">2</span>^-<span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>可以看出0.1的符号位为0，指数位为-4，小数位为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1001100110011001100110011001100110011001100110011001<br></code></pre></td></tr></table></figure>

<p>那么问题又来了，<strong>指数位是负数，该如何保存</strong>呢？</p>
<p>IEEE标准规定了一个偏移量，对于指数部分，每次都加这个偏移量进行保存，这样即使指数是负数，那么加上这个偏移量也就是正数了。由于JavaScript的数字是双精度数，这里就以双精度数为例，它的指数部分为11位，能表示的范围就是0~2047，IEEE固定<strong>双精度数的偏移量为1023</strong>。</p>
<ul>
<li>当指数位不全是0也不全是1时(规格化的数值)，IEEE规定，阶码计算公式为 e-Bias。 此时e最小值是1，则1-1023&#x3D; -1022，e最大值是2046，则2046-1023&#x3D;1023，可以看到，这种情况下取值范围是<code>-1022~1013</code>。</li>
<li>当指数位全部是0的时候(非规格化的数值)，IEEE规定，阶码的计算公式为1-Bias，即1-1023&#x3D; -1022。</li>
<li>当指数位全部是1的时候(特殊值)，IEEE规定这个浮点数可用来表示3个特殊值，分别是正无穷，负无穷，NaN。 具体的，小数位不为0的时候表示NaN；小数位为0时，当符号位s&#x3D;0时表示正无穷，s&#x3D;1时候表示负无穷。</li>
</ul>
<p>对于上面的0.1的指数位为-4，-4+1023 &#x3D; 1019 转化为二进制就是：<code>1111111011</code>.</p>
<p>所以，0.1表示为：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span><span class="hljs-number">1111111011</span> <span class="hljs-number">1001100110011001100110011001100110011001100110011001</span><br></code></pre></td></tr></table></figure>

<p>说了这么多，是时候该最开始的问题了，如何实现0.1+0.2&#x3D;0.3呢？</p>
<p>对于这个问题，一个直接的解决方法就是设置一个误差范围，通常称为“机器精度”。对JavaScript来说，这个值通常为2-52，在ES6中，提供了<code>Number.EPSILON</code>属性，而它的值就是2-52，只要判断<code>0.1+0.2-0.3</code>是否小于<code>Number.EPSILON</code>，如果小于，就可以判断为0.1+0.2 &#x3D;&#x3D;&#x3D;0.3</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">numberepsilon</span>(<span class="hljs-params">arg1,arg2</span>)&#123;                   <br>  <span class="hljs-keyword">return</span> Math.<span class="hljs-built_in">abs</span>(arg1 - arg2) &lt; <span class="hljs-built_in">Number</span>.EPSILON;        <br>&#125;        <br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(numberepsilon(<span class="hljs-number">0.1</span> + <span class="hljs-number">0.2</span>, <span class="hljs-number">0.3</span>)); <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h3 id="8-如何获取安全的-undefined-值？"><a href="#8-如何获取安全的-undefined-值？" class="headerlink" title="8. 如何获取安全的 undefined 值？"></a>8. 如何获取安全的 undefined 值？</h3><p>因为 undefined 是一个标识符，所以可以被当作变量来使用和赋值，但是这样会影响 undefined 的正常判断。表达式 void ___ 没有返回值，因此返回结果是 undefined。void 并不改变表达式的结果，只是让表达式不返回值。因此可以用 void 0 来获得 undefined。</p>
<h3 id="9-typeof-NaN-的结果是什么？"><a href="#9-typeof-NaN-的结果是什么？" class="headerlink" title="9. typeof NaN 的结果是什么？"></a>9. typeof NaN 的结果是什么？</h3><p>NaN 指“不是一个数字”（not a number），NaN 是一个“警戒值”（sentinel value，有特殊用途的常规值），用于指出数字类型中的错误情况，即“执行数学运算没有成功，这是失败后返回的结果”。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">typeof</span> <span class="hljs-literal">NaN</span>; <span class="hljs-comment">// &quot;number&quot;</span><br></code></pre></td></tr></table></figure>

<p>NaN 是一个特殊值，它和自身不相等，是唯一一个非自反（自反，reflexive，即 x &#x3D;&#x3D;&#x3D; x 不成立）的值。而 NaN !&#x3D;&#x3D; NaN 为 true。</p>
<h3 id="10-isNaN-和-Number-isNaN-函数的区别？"><a href="#10-isNaN-和-Number-isNaN-函数的区别？" class="headerlink" title="10. isNaN 和 Number.isNaN 函数的区别？"></a>10. isNaN 和 Number.isNaN 函数的区别？</h3><ul>
<li>函数 isNaN 接收参数后，会尝试将这个参数转换为数值，任何不能被转换为数值的的值都会返回 true，因此非数字值传入也会返回 true ，会影响 NaN 的判断。</li>
<li>函数 Number.isNaN 会首先判断传入参数是否为数字，如果是数字再继续判断是否为 NaN ，不会进行数据类型的转换，这种方法对于 NaN 的判断更为准确。</li>
</ul>
<h3 id="11-x3D-x3D-操作符的强制类型转换规则？"><a href="#11-x3D-x3D-操作符的强制类型转换规则？" class="headerlink" title="11. &#x3D;&#x3D; 操作符的强制类型转换规则？"></a>11. &#x3D;&#x3D; 操作符的强制类型转换规则？</h3><p>对于 <code>==</code> 来说，如果对比双方的类型<strong>不一样</strong>，就会进行<strong>类型转换</strong>。假如对比 <code>x</code> 和 <code>y</code> 是否相同，就会进行如下判断流程：</p>
<ol>
<li>首先会判断两者类型是否<strong>相同，</strong>相同的话就比较两者的大小；</li>
<li>类型不相同的话，就会进行类型转换；</li>
<li>会先判断是否在对比 <code>null</code> 和 <code>undefined</code>，是的话就会返回 <code>true</code></li>
<li>判断两者类型是否为 <code>string</code> 和 <code>number</code>，是的话就会将字符串转换为 <code>number</code></li>
</ol>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-number">1</span> == &#x27;1&#x27;<br>      ↓<br><span class="hljs-number">1</span> ==  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<ol start="5">
<li>判断其中一方是否为 <code>boolean</code>，是的话就会把 <code>boolean</code> 转为 <code>number</code> 再进行判断</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-literal">true</span><br>        ↓<br><span class="hljs-string">&#x27;1&#x27;</span> ==  <span class="hljs-number">1</span><br>        ↓<br> <span class="hljs-number">1</span>  ==  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<ol start="6">
<li>判断其中一方是否为 <code>object</code> 且另一方为 <code>string</code>、<code>number</code> 或者 <code>symbol</code>，是的话就会把 <code>object</code> 转为原始类型再进行判断</li>
</ol>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-string">&#x27;1&#x27;</span> == &#123; <span class="hljs-type">name</span>: <span class="hljs-string">&#x27;js&#x27;</span> &#125;<br>        ↓<br><span class="hljs-string">&#x27;1&#x27;</span> == <span class="hljs-string">&#x27;[object Object]&#x27;</span><br></code></pre></td></tr></table></figure>

<p>其流程图如下：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615475217180-eabe8060-a66a-425d-ad4c-37c3ca638a68.png"  ><span class="image-caption">image</span></p>
<h3 id="12-其他值到字符串的转换规则？"><a href="#12-其他值到字符串的转换规则？" class="headerlink" title="12. 其他值到字符串的转换规则？"></a>12. 其他值到字符串的转换规则？</h3><ul>
<li>Null 和 Undefined 类型 ，null 转换为 “null”，undefined 转换为 “undefined”，</li>
<li>Boolean 类型，true 转换为 “true”，false 转换为 “false”。</li>
<li>Number 类型的值直接转换，不过那些极小和极大的数字会使用指数形式。</li>
<li>Symbol 类型的值直接转换，但是只允许显式强制类型转换，使用隐式强制类型转换会产生错误。</li>
<li>对普通对象来说，除非自行定义 toString() 方法，否则会调用 toString()（Object.prototype.toString()）来返回内部属性 [[Class]] 的值，如”[object Object]”。如果对象有自己的 toString() 方法，字符串化时就会调用该方法并使用其返回值。</li>
</ul>
<h3 id="13-其他值到数字值的转换规则？"><a href="#13-其他值到数字值的转换规则？" class="headerlink" title="13. 其他值到数字值的转换规则？"></a>13. 其他值到数字值的转换规则？</h3><ul>
<li>Undefined 类型的值转换为 NaN。</li>
<li>Null 类型的值转换为 0。</li>
<li>Boolean 类型的值，true 转换为 1，false 转换为 0。</li>
<li>String 类型的值转换如同使用 Number() 函数进行转换，如果包含非数字值则转换为 NaN，空字符串为 0。</li>
<li>Symbol 类型的值不能转换为数字，会报错。</li>
<li>对象（包括数组）会首先被转换为相应的基本类型值，如果返回的是非数字的基本类型值，则再遵循以上规则将其强制转换为数字。</li>
</ul>
<p>为了将值转换为相应的基本类型值，抽象操作 ToPrimitive 会首先（通过内部操作 DefaultValue）检查该值是否有valueOf()方法。如果有并且返回基本类型值，就使用该值进行强制类型转换。如果没有就使用 toString() 的返回值（如果存在）来进行强制类型转换。</p>
<p>如果 valueOf() 和 toString() 均不返回基本类型值，会产生 TypeError 错误。</p>
<h3 id="14-其他值到布尔类型的值的转换规则？"><a href="#14-其他值到布尔类型的值的转换规则？" class="headerlink" title="14. 其他值到布尔类型的值的转换规则？"></a>14. 其他值到布尔类型的值的转换规则？</h3><p>以下这些是假值：</p>
<p>• undefined</p>
<p>• null</p>
<p>• false</p>
<p>• +0、-0 和 NaN</p>
<p>• “”</p>
<p>假值的布尔强制类型转换结果为 false。从逻辑上说，假值列表以外的都应该是真值。</p>
<h3 id="15-和-amp-amp-操作符的返回值？"><a href="#15-和-amp-amp-操作符的返回值？" class="headerlink" title="15. || 和 &amp;&amp; 操作符的返回值？"></a>15. || 和 &amp;&amp; 操作符的返回值？</h3><p>|| 和 &amp;&amp; 首先会对第一个操作数执行条件判断，如果其不是布尔值就先强制转换为布尔类型，然后再执行条件判断。</p>
<ul>
<li>对于 || 来说，如果条件判断结果为 true 就返回第一个操作数的值，如果为 false 就返回第二个操作数的值。</li>
<li>&amp;&amp; 则相反，如果条件判断结果为 true 就返回第二个操作数的值，如果为 false 就返回第一个操作数的值。</li>
</ul>
<p>|| 和 &amp;&amp; 返回它们其中一个操作数的值，而非条件判断的结果</p>
<h3 id="16-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？"><a href="#16-Object-is-与比较操作符-“-x3D-x3D-x3D-”、“-x3D-x3D-”-的区别？" class="headerlink" title="16. Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？"></a>16. Object.is() 与比较操作符 “&#x3D;&#x3D;&#x3D;”、“&#x3D;&#x3D;” 的区别？</h3><ul>
<li>使用双等号（&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致，则会进行强制类型转化后再进行比较。</li>
<li>使用三等号（&#x3D;&#x3D;&#x3D;）进行相等判断时，如果两边的类型不一致时，不会做强制类型准换，直接返回 false。</li>
<li>使用 Object.is 来进行相等判断时，一般情况下和三等号的判断相同，它处理了一些特殊的情况，比如 -0 和 +0 不再相等，两个 NaN 是相等的。</li>
</ul>
<h3 id="17-什么是-JavaScript-中的包装类型？"><a href="#17-什么是-JavaScript-中的包装类型？" class="headerlink" title="17. 什么是 JavaScript 中的包装类型？"></a>17. 什么是 JavaScript 中的包装类型？</h3><p>在 JavaScript 中，基本类型是没有属性和方法的，但是为了便于操作基本类型的值，在调用基本类型的属性或方法时 JavaScript 会在后台隐式地将基本类型的值转换为对象，如：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">const a = <span class="hljs-string">&quot;abc&quot;</span>;<br>a.length; <span class="hljs-regexp">//</span> <span class="hljs-number">3</span><br>a.toUpperCase(); <span class="hljs-regexp">//</span> <span class="hljs-string">&quot;ABC&quot;</span><br></code></pre></td></tr></table></figure>

<p>在访问<code>&#39;abc&#39;.length</code>时，JavaScript 将<code>&#39;abc&#39;</code>在后台转换成<code>String(&#39;abc&#39;)</code>，然后再访问其<code>length</code>属性。</p>
<p>JavaScript也可以使用<code>Object</code>函数显式地将基本类型转换为包装类型：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-function"><span class="hljs-title">Object</span><span class="hljs-params">(a)</span></span> <span class="hljs-comment">// String &#123;&quot;abc&quot;&#125;</span><br></code></pre></td></tr></table></figure>

<p>也可以使用<code>valueOf</code>方法将包装类型倒转成基本类型：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-string">&#x27;abc&#x27;</span><br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = <span class="hljs-built_in">Object</span>(a)<br><span class="hljs-selector-tag">var</span> c = <span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.valueOf</span>() <span class="hljs-comment">// &#x27;abc&#x27;</span><br></code></pre></td></tr></table></figure>

<p>看看如下代码会打印出什么：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Boolean</span>( <span class="hljs-literal">false</span> );<br><span class="hljs-keyword">if</span> (!a) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( <span class="hljs-string">&quot;Oops&quot;</span> ); <span class="hljs-comment">// never runs</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>答案是什么都不会打印，因为虽然包裹的基本类型是<code>false</code>，但是<code>false</code>被包裹成包装类型后就成了对象，所以其非值为<code>false</code>，所以循环体中的内容不会运行。</p>
<h3 id="18-JavaScript-中如何进行隐式类型转换？"><a href="#18-JavaScript-中如何进行隐式类型转换？" class="headerlink" title="18. JavaScript 中如何进行隐式类型转换？"></a>18. JavaScript 中如何进行隐式类型转换？</h3><p>首先要介绍<code>ToPrimitive</code>方法，这是 JavaScript 中每个值隐含的自带的方法，用来将值 （无论是基本类型值还是对象）转换为基本类型值。如果值为基本类型，则直接返回值本身；如果值为对象，其看起来大概是这样：</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm">/**<br>* @obj 需要转换的对象<br>* @<span class="hljs-keyword">type</span> 期望的结果类型<br>*/<br><span class="hljs-type">ToPrimitive</span>(obj,<span class="hljs-keyword">type</span>)<br></code></pre></td></tr></table></figure>

<p><code>type</code>的值为<code>number</code>或者<code>string</code>。</p>
<p><strong>（1）当</strong><code>**type**</code><strong>为</strong><code>**number**</code><strong>时规则如下：</strong></p>
<ul>
<li>调用<code>obj</code>的<code>valueOf</code>方法，如果为原始值，则返回，否则下一步；</li>
<li>调用<code>obj</code>的<code>toString</code>方法，后续同上；</li>
<li>抛出<code>TypeError</code> 异常。</li>
</ul>
<p><strong>（2）当</strong><code>**type**</code><strong>为</strong><code>**string**</code><strong>时规则如下：</strong></p>
<ul>
<li>调用<code>obj</code>的<code>toString</code>方法，如果为原始值，则返回，否则下一步；</li>
<li>调用<code>obj</code>的<code>valueOf</code>方法，后续同上；</li>
<li>抛出<code>TypeError</code> 异常。</li>
</ul>
<p>可以看出两者的主要区别在于调用<code>toString</code>和<code>valueOf</code>的先后顺序。默认情况下：</p>
<ul>
<li>如果对象为 Date 对象，则<code>type</code>默认为<code>string</code>；</li>
<li>其他情况下，<code>type</code>默认为<code>number</code>。</li>
</ul>
<p>总结上面的规则，对于 Date 以外的对象，转换为基本类型的大概规则可以概括为一个函数：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">var objToNumber <span class="hljs-operator">=</span> value <span class="hljs-operator">=</span>&gt; Number(value.valueOf().toString())<br>objToNumber([]) <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> <span class="hljs-number">0</span><br>objToNumber(&#123;&#125;) <span class="hljs-operator">=</span><span class="hljs-operator">=</span><span class="hljs-operator">=</span> NaN<br></code></pre></td></tr></table></figure>

<p>而 JavaScript 中的隐式类型转换主要发生在<code>+、-、*、/</code>以及<code>==、&gt;、&lt;</code>这些运算符之间。而这些运算符只能操作基本类型值，所以在进行这些运算前的第一步就是将两边的值用<code>ToPrimitive</code>转换成基本类型，再进行操作。</p>
<p>以下是基本类型的值在不同操作符的情况下隐式转换的规则 （对于对象，其会被<code>ToPrimitive</code>转换成基本类型，所以最终还是要应用基本类型转换规则）：</p>
<ol>
<li>+操作符<code>+</code>操作符的两边有至少一个<code>string</code>类型变量时，两边的变量都会被隐式转换为字符串；其他情况下两边的变量都会被转换为数字。</li>
</ol>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-number">1</span> + <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;123&#x27;</span><br> <span class="hljs-number">1</span> + false <span class="hljs-regexp">//</span> <span class="hljs-number">1</span> <br> <span class="hljs-number">1</span> + Symbol() <span class="hljs-regexp">//</span> Uncaught TypeError: Cannot convert a Symbol value to a number<br> <span class="hljs-string">&#x27;1&#x27;</span> + false <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;1false&#x27;</span><br> false + true <span class="hljs-regexp">//</span> <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<ol start="2">
<li>-、*、\操作符NaN也是一个数字</li>
</ol>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-number">1</span> * <span class="hljs-string">&#x27;23&#x27;</span> <span class="hljs-comment">// 23</span><br> <span class="hljs-number">1</span> * <span class="hljs-literal">false</span> <span class="hljs-comment">// 0</span><br> <span class="hljs-number">1</span> / <span class="hljs-string">&#x27;aa&#x27;</span> <span class="hljs-comment">// NaN</span><br></code></pre></td></tr></table></figure>

<ol start="3">
<li>对于**<code>**==**</code>**操作符</li>
</ol>
<p>操作符两边的值都尽量转成<code>number</code>：</p>
<figure class="highlight autoit"><table><tr><td class="code"><pre><code class="hljs autoit"><span class="hljs-number">3</span> == <span class="hljs-literal">true</span> // <span class="hljs-literal">false</span>, <span class="hljs-number">3</span> 转为<span class="hljs-built_in">number</span>为<span class="hljs-number">3</span>，<span class="hljs-literal">true</span>转为<span class="hljs-built_in">number</span>为<span class="hljs-number">1</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-literal">false</span> //<span class="hljs-literal">true</span>, <span class="hljs-string">&#x27;0&#x27;</span>转为<span class="hljs-built_in">number</span>为<span class="hljs-number">0</span>，<span class="hljs-literal">false</span>转为<span class="hljs-built_in">number</span>为<span class="hljs-number">0</span><br><span class="hljs-string">&#x27;0&#x27;</span> == <span class="hljs-number">0</span> // <span class="hljs-string">&#x27;0&#x27;</span>转为<span class="hljs-built_in">number</span>为<span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<ol start="4">
<li>对于**<code>**&lt;**</code><strong>和</strong><code>**&gt;**</code>**比较符</li>
</ol>
<p>如果两边都是字符串，则比较字母表顺序：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;ca&#x27;</span> &lt; <span class="hljs-string">&#x27;bd&#x27;</span> <span class="hljs-regexp">//</span> false<br><span class="hljs-string">&#x27;a&#x27;</span> &lt; <span class="hljs-string">&#x27;b&#x27;</span> <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure>

<p>其他情况下，转换为数字再比较：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-string">&#x27;12&#x27;</span> &lt; <span class="hljs-number">13</span> <span class="hljs-regexp">//</span> true<br>false &gt; -<span class="hljs-number">1</span> <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure>

<p>以上说的是基本类型的隐式转换，而对象会被<code>ToPrimitive</code>转换为基本类型再进行转换：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = &#123;&#125;<br><span class="hljs-selector-tag">a</span> &gt; <span class="hljs-number">2</span> <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>其对比过程如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.valueOf</span>() <span class="hljs-comment">// &#123;&#125;, 上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;，现在是一个字符串了</span><br><span class="hljs-function"><span class="hljs-title">Number</span><span class="hljs-params">(a.toString()</span></span>) <span class="hljs-comment">// NaN，根据上面 &lt; 和 &gt; 操作符的规则，要转换成数字</span><br>NaN &gt; <span class="hljs-number">2</span> <span class="hljs-comment">//false，得出比较结果</span><br></code></pre></td></tr></table></figure>

<p>又比如：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = &#123;name:<span class="hljs-string">&#x27;Jack&#x27;</span>&#125;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">b</span> = &#123;age: <span class="hljs-number">18</span>&#125;<br><span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure>

<p>运算过程如下：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.valueOf</span>() <span class="hljs-comment">// &#123;&#125;，上面提到过，ToPrimitive默认type为number，所以先valueOf，结果还是个对象，下一步</span><br><span class="hljs-selector-tag">a</span><span class="hljs-selector-class">.toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.valueOf</span>() <span class="hljs-comment">// 同理</span><br><span class="hljs-selector-tag">b</span><span class="hljs-selector-class">.toString</span>() <span class="hljs-comment">// &quot;[object Object]&quot;</span><br><span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span> <span class="hljs-comment">// &quot;[object Object][object Object]&quot;</span><br></code></pre></td></tr></table></figure>

<h3 id="19-操作符什么时候用于字符串的拼接？"><a href="#19-操作符什么时候用于字符串的拼接？" class="headerlink" title="19. + 操作符什么时候用于字符串的拼接？"></a>19. <code>+</code> 操作符什么时候用于字符串的拼接？</h3><p>根据 ES5 规范，如果某个操作数是字符串或者能够通过以下步骤转换为字符串的话，+ 将进行拼接操作。如果其中一个操作数是对象（包括数组），则首先对其调用 ToPrimitive 抽象操作，该抽象操作再调用 [[DefaultValue]]，以数字作为上下文。如果不能转换为字符串，则会将其转换为数字类型来进行计算。</p>
<p>简单来说就是，如果 + 的其中一个操作数是字符串（或者通过以上步骤最终得到字符串），则执行字符串拼接，否则执行数字加法。</p>
<p>那么对于除了加法的运算符来说，只要其中一方是数字，那么另一方就会被转为数字。</p>
<h3 id="20-为什么会有BigInt的提案？"><a href="#20-为什么会有BigInt的提案？" class="headerlink" title="20. 为什么会有BigInt的提案？"></a>20. 为什么会有<strong>BigInt</strong>的提案？</h3><p>JavaScript中Number.MAX_SAFE_INTEGER表示最⼤安全数字，计算结果是9007199254740991，即在这个数范围内不会出现精度丢失（⼩数除外）。但是⼀旦超过这个范围，js就会出现计算不准确的情况，这在⼤数计算的时候不得不依靠⼀些第三⽅库进⾏解决，因此官⽅提出了BigInt来解决此问题。 </p>
<h3 id="21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别"><a href="#21-object-assign和扩展运算法是深拷贝还是浅拷贝，两者区别" class="headerlink" title="21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别"></a>21. object.assign和扩展运算法是深拷贝还是浅拷贝，两者区别</h3><p>扩展运算符：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">let outObj = &#123;<br>  inObj: &#123;<span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span>&#125;<br>&#125;<br>let newObj = &#123;...outObj&#125;<br>newObj<span class="hljs-selector-class">.inObj</span><span class="hljs-selector-class">.a</span> = <span class="hljs-number">2</span><br>console<span class="hljs-selector-class">.log</span>(outObj) <span class="hljs-comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br></code></pre></td></tr></table></figure>

<p>Object.assign():</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">let outObj = &#123;<br>  inObj: &#123;<span class="hljs-selector-tag">a</span>: <span class="hljs-number">1</span>, <span class="hljs-selector-tag">b</span>: <span class="hljs-number">2</span>&#125;<br>&#125;<br>let newObj = Object<span class="hljs-selector-class">.assign</span>(&#123;&#125;, outObj)<br>newObj<span class="hljs-selector-class">.inObj</span><span class="hljs-selector-class">.a</span> = <span class="hljs-number">2</span><br>console<span class="hljs-selector-class">.log</span>(outObj) <span class="hljs-comment">// &#123;inObj: &#123;a: 2, b: 2&#125;&#125;</span><br></code></pre></td></tr></table></figure>

<h2 id="二、ES6"><a href="#二、ES6" class="headerlink" title="二、ES6"></a>二、ES6</h2><h3 id="1-let、const、var的区别"><a href="#1-let、const、var的区别" class="headerlink" title="1. let、const、var的区别"></a>1. let、const、var的区别</h3><p><strong>（1）块级作用域：</strong>块作用域由 <code>&#123; &#125;</code>包括，let和const具有块级作用域，var不存在块级作用域。块级作用域解决了ES5中的两个问题：</p>
<ul>
<li>内层变量可能覆盖外层变量</li>
<li>用来计数的循环变量泄露为全局变量</li>
</ul>
<p><strong>（2）变量提升：</strong>var存在变量提升，let和const不存在变量提升，即在变量只能在声明之后使用，否在会报错。</p>
<p><strong>（3）给全局添加属性：</strong>浏览器的全局对象是window，Node的全局对象是global。var声明的变量为全局变量，并且会将该变量添加为全局对象的属性，但是let和const不会。</p>
<p><strong>（4）重复声明：</strong>var声明变量时，可以重复声明变量，后声明的同名变量会覆盖之前声明的遍历。const和let不允许重复声明变量。</p>
<p><strong>（5）暂时性死区：</strong>在使用let、const命令声明变量之前，该变量都是不可用的。这在语法上，称为<strong>暂时性死区</strong>。使用var声明的变量不存在暂时性死区。</p>
<p><strong>（6）初始值设置：</strong>在变量声明时，var 和 let 可以不用设置初始值。而const声明变量必须设置初始值。</p>
<p><strong>（7）指针指向：</strong>let和const都是ES6新增的用于创建变量的语法。 let创建的变量是可以更改指针指向（可以重新赋值）。但const声明的变量是不允许改变指针的指向。</p>
<table>
<thead>
<tr>
<th><strong>区别</strong></th>
<th><strong>var</strong></th>
<th><strong>let</strong></th>
<th><strong>const</strong></th>
</tr>
</thead>
<tbody><tr>
<td>是否有块级作用域</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否存在变量提升</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否添加全局属性</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>能否重复声明变量</td>
<td>✔️</td>
<td>×</td>
<td>×</td>
</tr>
<tr>
<td>是否存在暂时性死区</td>
<td>×</td>
<td>✔️</td>
<td>✔️</td>
</tr>
<tr>
<td>是否必须设置初始值</td>
<td>×</td>
<td>×</td>
<td>✔️</td>
</tr>
<tr>
<td>能否改变指针指向</td>
<td>✔️</td>
<td>✔️</td>
<td>×</td>
</tr>
</tbody></table>
<h3 id="2-const对象的属性可以修改吗"><a href="#2-const对象的属性可以修改吗" class="headerlink" title="2. const对象的属性可以修改吗"></a>2. const对象的属性可以修改吗</h3><p>const保证的并不是变量的值不能改动，而是变量指向的那个内存地址不能改动。对于基本类型的数据（数值、字符串、布尔值），其值就保存在变量指向的那个内存地址，因此等同于常量。</p>
<p>但对于引用类型的数据（主要是对象和数组）来说，变量指向数据的内存地址，保存的只是一个指针，const只能保证这个指针是固定不变的，至于它指向的数据结构是不是可变的，就完全不能控制了。</p>
<h3 id="3-如果new一个箭头函数的会怎么样"><a href="#3-如果new一个箭头函数的会怎么样" class="headerlink" title="3. 如果new一个箭头函数的会怎么样"></a>3. 如果new一个箭头函数的会怎么样</h3><p>箭头函数是ES6中的提出来的，它没有prototype，也没有自己的this指向，更不可以使用arguments参数，所以不能New一个箭头函数。</p>
<p>new操作符的实现步骤如下：</p>
<ol>
<li>创建一个对象</li>
<li>将构造函数的作用域赋给新对象（也就是将对象的__proto__属性指向构造函数的prototype属性）</li>
<li>指向构造函数中的代码，构造函数中的this指向该对象（也就是为这个对象添加属性和方法）</li>
<li>返回新的对象</li>
</ol>
<p>所以，上面的第二、三步，箭头函数都是没有办法执行的。</p>
<h3 id="4-箭头函数与普通函数的区别"><a href="#4-箭头函数与普通函数的区别" class="headerlink" title="4. 箭头函数与普通函数的区别"></a>4. 箭头函数与普通函数的区别</h3><p><strong>（1）箭头函数比普通函数更加简洁</strong></p>
<ul>
<li>如果没有参数，就直接写一个空括号即可</li>
<li>如果只有一个参数，可以省去参数的括号</li>
<li>如果有多个参数，用逗号分割</li>
<li>如果函数体的返回值只有一句，可以省略大括号</li>
<li>如果函数体不需要返回值，且只有一句话，可以给这个语句前面加一个void关键字。最常见的就是调用一个函数：</li>
</ul>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">let fn = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">void</span> doesNotReturn();<br></code></pre></td></tr></table></figure>

<p><strong>（2）箭头函数没有自己的this</strong></p>
<p>箭头函数不会创建自己的this， 所以它没有自己的this，它只会在自己作用域的上一层继承this。所以箭头函数中this的指向在它在定义时已经确定了，之后不会改变。</p>
<p><strong>（3）箭头函数继承来的this指向永远不会改变</strong></p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> id = <span class="hljs-string">&#x27;GLOBAL&#x27;</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">id</span>: <span class="hljs-string">&#x27;OBJ&#x27;</span>,<br>  <span class="hljs-attr">a</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.id);<br>  &#125;,<br>  <span class="hljs-attr">b</span>: <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.id);<br>  &#125;<br>&#125;;<br>obj.a();    <span class="hljs-comment">// &#x27;OBJ&#x27;</span><br>obj.b();    <span class="hljs-comment">// &#x27;GLOBAL&#x27;</span><br><span class="hljs-keyword">new</span> obj.a()  <span class="hljs-comment">// undefined</span><br><span class="hljs-keyword">new</span> obj.b()  <span class="hljs-comment">// Uncaught TypeError: obj.b is not a constructor</span><br></code></pre></td></tr></table></figure>

<p>对象obj的方法b是使用箭头函数定义的，这个函数中的this就永远指向它定义时所处的全局执行环境中的this，即便这个函数是作为对象obj的方法调用，this依旧指向Window对象。需要注意，定义对象的大括号<code>&#123;&#125;</code>是无法形成一个单独的执行环境的，它依旧是处于全局执行环境中。</p>
<p><strong>（4）call()、apply()、bind()等方法不能改变箭头函数中this的指向</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">var id = <span class="hljs-string">&#x27;Global&#x27;</span>;<br>let fun1 = () =&gt; &#123;<br>    console.log(this.id)<br>&#125;;<br>fun1();                     <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;Global&#x27;</span><br>fun1.call(&#123;id: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);     <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;Global&#x27;</span><br>fun1.apply(&#123;id: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;);    <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;Global&#x27;</span><br>fun1.bind(&#123;id: <span class="hljs-string">&#x27;Obj&#x27;</span>&#125;)();   <span class="hljs-regexp">//</span> <span class="hljs-string">&#x27;Global&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>（5）箭头函数不能作为构造函数使用</strong></p>
<p>构造函数在new的步骤在上面已经说过了，实际上第二步就是将函数中的this指向该对象。 但是由于箭头函数时没有自己的this的，且this指向外层的执行环境，且不能改变指向，所以不能当做构造函数使用。</p>
<p><strong>（6）箭头函数没有自己的arguments</strong></p>
<p>箭头函数没有自己的arguments对象。在箭头函数中访问arguments实际上获得的是它外层函数的arguments值。</p>
<p><strong>（7）箭头函数没有prototype</strong></p>
<p><strong>（8）箭头函数不能用作Generator函数，不能使用yeild关键字</strong></p>
<h3 id="5-箭头函数的this指向哪⾥？"><a href="#5-箭头函数的this指向哪⾥？" class="headerlink" title="5. 箭头函数的this指向哪⾥？"></a>5. 箭头函数的<strong>this</strong>指向哪⾥？</h3><p>箭头函数不同于传统JavaScript中的函数，箭头函数并没有属于⾃⼰的this，它所谓的this是捕获其所在上下⽂的 this 值，作为⾃⼰的 this 值，并且由于没有属于⾃⼰的this，所以是不会被new调⽤的，这个所谓的this也不会被改变。</p>
<p>可以⽤Babel理解⼀下箭头函数: </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// ES6 </span><br><span class="hljs-keyword">const</span> obj = &#123; <br>  <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>    <span class="hljs-keyword">return</span> <span class="hljs-function">() =&gt;</span> &#123; <br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span> === obj); <br>    &#125;; <br>  &#125; <br>&#125;<br></code></pre></td></tr></table></figure>

<p>转化后：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// ES5，由 Babel 转译</span><br><span class="hljs-keyword">var</span> obj = &#123; <br>   <span class="hljs-attr">getArrow</span>: <span class="hljs-keyword">function</span> <span class="hljs-title function_">getArrow</span>(<span class="hljs-params"></span>) &#123; <br>     <span class="hljs-keyword">var</span> _this = this; <br>     <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123; <br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(_this === obj); <br>     &#125;; <br>   &#125; <br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="6-扩展运算符的作用及使用场景"><a href="#6-扩展运算符的作用及使用场景" class="headerlink" title="6. 扩展运算符的作用及使用场景"></a>6. 扩展运算符的作用及使用场景</h3><p><strong>（1）对象扩展运算符</strong></p>
<p>对象的扩展运算符(…)用于取出参数对象中的所有可遍历属性，拷贝到当前对象之中。</p>
<figure class="highlight mipsasm"><table><tr><td class="code"><pre><code class="hljs mipsasm">let <span class="hljs-keyword">bar </span>= &#123; a: <span class="hljs-number">1</span>, <span class="hljs-keyword">b: </span><span class="hljs-number">2</span> &#125;;<br>let <span class="hljs-keyword">baz </span>= &#123; ...<span class="hljs-keyword">bar </span>&#125;<span class="hljs-comment">; // &#123; a: 1, b: 2 &#125;</span><br></code></pre></td></tr></table></figure>

<p>上述方法实际上等价于:</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> bar = &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> &#125;;<br><span class="hljs-attribute">let</span> baz = Object.assign(&#123;&#125;, bar); // &#123; a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span> &#125;<br></code></pre></td></tr></table></figure>

<p><code>Object.assign</code>方法用于对象的合并，将源对象<code>（source）</code>的所有可枚举属性，复制到目标对象<code>（target）</code>。<code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。(<strong>如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性</strong>)。</p>
<p>同样，如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> bar = &#123;a: <span class="hljs-number">1</span>, b: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-attribute">let</span> baz = &#123;...bar, ...&#123;a:<span class="hljs-number">2</span>, b: <span class="hljs-number">4</span>&#125;&#125;;  // &#123;a: <span class="hljs-number">2</span>, b: <span class="hljs-number">4</span>&#125;<br></code></pre></td></tr></table></figure>

<p>利用上述特性就可以很方便的修改对象的部分属性。在<code>redux</code>中的<code>reducer</code>函数规定必须是<strong>一个纯函数</strong>，<code>reducer</code>中的<code>state</code>对象要求不能直接修改，可以通过扩展运算符把修改路径的对象都复制一遍，然后产生一个新的对象返回。</p>
<p>需要注意：<strong>扩展运算符对****对象实例的拷贝属于浅拷贝</strong>。</p>
<p><strong>（2）数组扩展运算符</strong></p>
<p>数组的扩展运算符可以将一个数组转为用逗号分隔的参数序列，且每次只能展开一层数组。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(...[<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>])<br><span class="hljs-comment">// 1 2 3</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(...[<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], <span class="hljs-number">5</span>])<br><span class="hljs-comment">// 1 [2, 3, 4] 5</span><br></code></pre></td></tr></table></figure>

<p>下面是数组的扩展运算符的应用：</p>
<ul>
<li><strong>将数组转换为参数序列</strong></li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span><span class="hljs-params">(x, y)</span> &#123;<br>  <span class="hljs-keyword">return</span> x + y;<br>&#125;<br><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>add(...numbers) <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>复制数组</strong></li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> arr1 = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br><span class="hljs-keyword">const</span> arr2 = [...arr1];<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>合并数组</strong></li>
</ul>
<p>如果想在数组内合并数组，可以这样：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">const arr1 = [<span class="hljs-string">&#x27;two&#x27;</span>, <span class="hljs-string">&#x27;three&#x27;</span>];<br>const arr2 = [<span class="hljs-string">&#x27;one&#x27;</span>, ...arr1, <span class="hljs-string">&#x27;four&#x27;</span>, <span class="hljs-string">&#x27;five&#x27;</span>];<br>// [<span class="hljs-string">&quot;one&quot;</span>, <span class="hljs-string">&quot;two&quot;</span>, <span class="hljs-string">&quot;three&quot;</span>, <span class="hljs-string">&quot;four&quot;</span>, <span class="hljs-string">&quot;five&quot;</span>]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>扩展运算符与解构赋值结合起来，用于生成数组</strong></li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const [<span class="hljs-built_in">first</span>, ...rest] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];<br><span class="hljs-built_in">first</span> <span class="hljs-comment">// 1</span><br>rest  <span class="hljs-comment">// [2, 3, 4, 5]</span><br></code></pre></td></tr></table></figure>

<p>需要注意：<strong>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</strong></p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">const [...rest, <span class="hljs-keyword">last</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>];        <span class="hljs-comment"> // 报错</span><br>const [<span class="hljs-keyword">first</span>, ...rest, <span class="hljs-keyword">last</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]; <span class="hljs-comment"> // 报错</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>将字符串转为真正的数组</strong></li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">[...<span class="hljs-string">&#x27;hello&#x27;</span>]    <span class="hljs-regexp">//</span> [ <span class="hljs-string">&quot;h&quot;</span>, <span class="hljs-string">&quot;e&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;l&quot;</span>, <span class="hljs-string">&quot;o&quot;</span> ]<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>任何 Iterator 接口的对象，都可以用扩展运算符转为真正的数组</strong></li>
</ul>
<p>比较常见的应用是可以将某些数据结构转为数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// arguments对象</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">const</span> args = [...<span class="hljs-variable language_">arguments</span>];<br>&#125;<br></code></pre></td></tr></table></figure>

<p>用于替换<code>es5</code>中的<code>Array.prototype.slice.call(arguments)</code>写法。</p>
<ul>
<li><strong>使用</strong><code>**Math**</code><strong>函数获取数组中特定的值</strong></li>
</ul>
<figure class="highlight glsl"><table><tr><td class="code"><pre><code class="hljs glsl"><span class="hljs-keyword">const</span> numbers = [<span class="hljs-number">9</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>, <span class="hljs-number">1</span>];<br>Math.<span class="hljs-built_in">min</span>(...numbers); <span class="hljs-comment">// 1</span><br>Math.<span class="hljs-built_in">max</span>(...numbers); <span class="hljs-comment">// 9</span><br></code></pre></td></tr></table></figure>

<h3 id="7-Proxy-可以实现什么功能？"><a href="#7-Proxy-可以实现什么功能？" class="headerlink" title="7. Proxy 可以实现什么功能？"></a>7. Proxy 可以实现什么功能？</h3><p>在 Vue3.0 中通过 <code>Proxy</code> 来替换原本的 <code>Object.defineProperty</code> 来实现数据响应式。</p>
<p>Proxy 是 ES6 中新增的功能，它可以用来自定义对象中的操作。</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> p = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Proxy(<span class="hljs-params">target</span>, <span class="hljs-params">handler</span>)</span><br></code></pre></td></tr></table></figure>

<p><code>target</code> 代表需要添加代理的对象，<code>handler</code> 用来自定义对象中的操作，比如可以用来自定义 <code>set</code> 或者 <code>get</code> 函数。</p>
<p>下面来通过 <code>Proxy</code> 来实现一个数据响应式：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"><span class="hljs-keyword">let</span> onWatch = (obj, setBind, getLogger) =&gt; &#123;<br>  <span class="hljs-keyword">let</span> handler = &#123;<br>    get(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, receiver) &#123;<br>      getLogger(target, <span class="hljs-keyword">property</span><span class="hljs-string">)</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.get(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, receiver)<br>    &#125;,<br>    set(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, value, receiver) &#123;<br>      setBind(value, <span class="hljs-keyword">property</span><span class="hljs-string">)</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-built_in">Reflect</span>.set(target, <span class="hljs-keyword">property</span><span class="hljs-string"></span>, value)<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Proxy</span>(obj, handler)<br>&#125;<br><span class="hljs-keyword">let</span> obj = &#123; <span class="hljs-attribute">a</span>: <span class="hljs-number">1</span> &#125;<br><span class="hljs-keyword">let</span> p = onWatch(<br>  obj,<br>  (v, <span class="hljs-keyword">property</span><span class="hljs-string">) </span>=&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`监听到属性<span class="hljs-subst">$&#123;property&#125;</span>改变为<span class="hljs-subst">$&#123;v&#125;</span>`</span>)<br>  &#125;,<br>  (target, <span class="hljs-keyword">property</span><span class="hljs-string">) </span>=&gt; &#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">`&#x27;<span class="hljs-subst">$&#123;property&#125;</span>&#x27; = <span class="hljs-subst">$&#123;target[property]&#125;</span>`</span>)<br>  &#125;<br>)<br>p.a = <span class="hljs-number">2</span> <span class="hljs-comment">// 监听到属性a改变</span><br>p.a <span class="hljs-comment">// &#x27;a&#x27; = 2</span><br></code></pre></td></tr></table></figure>

<p>在上述代码中，通过自定义 <code>set</code> 和 <code>get</code> 函数的方式，在原本的逻辑中插入了我们的函数逻辑，实现了在对对象任何属性进行读写时发出通知。</p>
<p>当然这是简单版的响应式实现，如果需要实现一个 Vue 中的响应式，需要在 <code>get</code> 中收集依赖，在 <code>set</code> 派发更新，之所以 Vue3.0 要使用 <code>Proxy</code> 替换原本的 API 原因在于 <code>Proxy</code> 无需一层层递归为每个属性添加代理，一次即可完成以上操作，性能上更好，并且原本的实现有一些数据更新不能监听到，但是 <code>Proxy</code> 可以完美监听到任何方式的数据改变，唯一缺陷就是浏览器的兼容性不好。</p>
<h3 id="8-对对象与数组的解构的理解"><a href="#8-对对象与数组的解构的理解" class="headerlink" title="8. 对对象与数组的解构的理解"></a>8. 对对象与数组的解构的理解</h3><p>解构是 ES6 提供的一种新的提取数据的模式，这种模式能够从对象或数组里有针对性地拿到想要的数值。</p>
<p><strong>1）数组的解构</strong></p>
<p>在解构数组时，以元素的位置为匹配条件来提取想要的数据的：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">const <span class="hljs-comment">[a, b, c]</span> = <span class="hljs-comment">[1, 2, 3]</span><br></code></pre></td></tr></table></figure>

<p>最终，a、b、c分别被赋予了数组第0、1、2个索引位的值：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1616076913177-30749c84-8254-4543-a3e7-c2fb488a4228.jpeg"  ><span class="image-caption">image</span></p>
<p>数组里的0、1、2索引位的元素值，精准地被映射到了左侧的第0、1、2个变量里去，这就是数组解构的工作模式。还可以通过给左侧变量数组设置空占位的方式，实现对数组中某几个元素的精准提取：</p>
<figure class="highlight inform7"><table><tr><td class="code"><pre><code class="hljs inform7">const <span class="hljs-comment">[a,,c]</span> = <span class="hljs-comment">[1,2,3]</span><br></code></pre></td></tr></table></figure>

<p>通过把中间位留空，可以顺利地把数组第一位和最后一位的值赋给 a、c 两个变量：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1616076913186-eb8be693-9b19-48e5-bda5-9dbd7cc77ea6.jpeg"  ><span class="image-caption">image</span></p>
<p><strong>2）对象的解构</strong></p>
<p>对象解构比数组结构稍微复杂一些，也更显强大。在解构对象时，是以属性的名称为匹配条件，来提取想要的数据的。现在定义一个对象：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> stu = &#123;<br>  name: <span class="hljs-string">&#x27;Bob&#x27;</span>,<br>  age: <span class="hljs-number">24</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>假如想要解构它的两个自有属性，可以这样：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> &#123; name, age &#125; = stu<br></code></pre></td></tr></table></figure>

<p>这样就得到了 name 和 age 两个和 stu 平级的变量：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1616076913314-53687a23-07ef-4a01-a78a-a0304f2b2826.jpeg"  ><span class="image-caption">image</span></p>
<p>注意，对象解构严格以属性名作为定位依据，所以就算调换了 name 和 age 的位置，结果也是一样的：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> &#123; age, name &#125; = stu<br></code></pre></td></tr></table></figure>

<h3 id="9-如何提取高度嵌套的对象里的指定属性？"><a href="#9-如何提取高度嵌套的对象里的指定属性？" class="headerlink" title="9. 如何提取高度嵌套的对象里的指定属性？"></a>9. <strong>如何提取高度嵌套的对象里的指定属性？</strong></h3><p>有时会遇到一些嵌套程度非常深的对象：</p>
<figure class="highlight nestedtext"><table><tr><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">const school = &#123;</span><br><span class="hljs-attribute">   classes</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span><br>      <span class="hljs-attribute">stu</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#123;</span><br>         <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;Bob&#x27;,</span><br>         <span class="hljs-attribute">age</span><span class="hljs-punctuation">:</span> <span class="hljs-string">24,</span><br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>像此处的 name 这个变量，嵌套了四层，此时如果仍然尝试老方法来提取它：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">const &#123; name &#125; <span class="hljs-operator">=</span> school<br></code></pre></td></tr></table></figure>

<p>显然是不奏效的，因为 school 这个对象本身是没有 name 这个属性的，name 位于 school 对象的“儿子的儿子”对象里面。要想把 name 提取出来，一种比较笨的方法是逐层解构：</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">const</span> <span class="hljs-comment">&#123; classes &#125;</span> = school<br><span class="hljs-keyword">const</span> <span class="hljs-comment">&#123; stu &#125;</span> = classes<br><span class="hljs-keyword">const</span> <span class="hljs-comment">&#123; name &#125;</span> = stu<br><span class="hljs-keyword">name</span> <span class="hljs-comment">// &#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure>

<p>但是还有一种更标准的做法，可以用一行代码来解决这个问题：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">const &#123; classes: &#123; stu: &#123; <span class="hljs-type">name</span> &#125; &#125;&#125; = school<br>       <br>console.log(<span class="hljs-type">name</span>)  // <span class="hljs-string">&#x27;Bob&#x27;</span><br></code></pre></td></tr></table></figure>

<p>可以在解构出来的变量名右侧，通过冒号+{目标属性名}这种形式，进一步解构它，一直解构到拿到目标数据为止。</p>
<h3 id="10-对-rest-参数的理解"><a href="#10-对-rest-参数的理解" class="headerlink" title="10. 对 rest 参数的理解"></a>10. 对 rest 参数的理解</h3><p>扩展运算符被用在函数形参上时，<strong>它还可以把一个分离的参数序列整合成一个数组</strong>：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  let result = <span class="hljs-number">1</span>;<br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> val of args) &#123;<br>    result *= val;<br>  &#125;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br>mutiple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// 24</span><br></code></pre></td></tr></table></figure>

<p>这里，传入 mutiple 的是四个分离的参数，但是如果在 mutiple 函数里尝试输出 args 的值，会发现它是一个数组：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">mutiple</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  console.log(args)<br>&#125;<br>mutiple(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// [1, 2, 3, 4]</span><br></code></pre></td></tr></table></figure>

<p>这就是 … rest运算符的又一层威力了，它可以把函数的多个入参收敛进一个数组里。这一点<strong>经常用于获取函数的多余参数，或者像上面这样处理函数参数个数不确定的情况。</strong></p>
<h3 id="11-ES6中模板语法与字符串处理"><a href="#11-ES6中模板语法与字符串处理" class="headerlink" title="11. ES6中模板语法与字符串处理"></a>11. ES6中模板语法与字符串处理</h3><p>ES6 提出了“模板语法”的概念。在 ES6 以前，拼接字符串是很麻烦的事情：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-selector-tag">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-selector-tag">var</span> hobby = <span class="hljs-selector-attr">[<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]</span><br><span class="hljs-selector-tag">var</span> finalString = <span class="hljs-string">&#x27;my name is &#x27;</span> + name + <span class="hljs-string">&#x27;, I work as a &#x27;</span> + career + <span class="hljs-string">&#x27;, I love &#x27;</span> + hobby<span class="hljs-selector-attr">[0]</span> + <span class="hljs-string">&#x27; and &#x27;</span> + hobby<span class="hljs-selector-attr">[1]</span><br></code></pre></td></tr></table></figure>

<p>仅仅几个变量，写了这么多加号，还要时刻小心里面的空格和标点符号有没有跟错地方。但是有了模板字符串，拼接难度直线下降：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;css&#x27;</span>   <br><span class="hljs-keyword">var</span> career = <span class="hljs-string">&#x27;coder&#x27;</span> <br><span class="hljs-keyword">var</span> hobby = [<span class="hljs-string">&#x27;coding&#x27;</span>, <span class="hljs-string">&#x27;writing&#x27;</span>]<br><span class="hljs-keyword">var</span> finalString = <span class="hljs-string">`my name is <span class="hljs-subst">$&#123;name&#125;</span>, I work as a <span class="hljs-subst">$&#123;career&#125;</span> I love <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">0</span>]&#125;</span> and <span class="hljs-subst">$&#123;hobby[<span class="hljs-number">1</span>]&#125;</span>`</span><br></code></pre></td></tr></table></figure>

<p>字符串不仅更容易拼了，也更易读了，代码整体的质量都变高了。这就是模板字符串的第一个优势——允许用${}的方式嵌入变量。但这还不是问题的关键，模板字符串的关键优势有两个：</p>
<ul>
<li>在模板字符串中，空格、缩进、换行都会被保留</li>
<li>模板字符串完全支持“运算”式的表达式，可以在${}里完成一些计算</li>
</ul>
<p>基于第一点，可以在模板字符串里无障碍地直接写 html 代码：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">let</span> list = `<br>    <span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">        </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项1<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">        </span><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>列表项2<span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><span class="language-xml"></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span></span><br>`;<br>console.log(message); // 正确输出，不存在报错<br></code></pre></td></tr></table></figure>

<p>基于第二点，可以把一些简单的计算和调用丢进 ${} 来做：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>) &#123;<br>  const finalString = <span class="hljs-string">`<span class="hljs-subst">$&#123;a&#125;</span> + <span class="hljs-subst">$&#123;b&#125;</span> = <span class="hljs-subst">$&#123;a+b&#125;</span>`</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(finalString)<br>&#125;<br>add(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// 输出 &#x27;1 + 2 = 3&#x27;</span><br></code></pre></td></tr></table></figure>

<p>除了模板语法外， ES6中还新增了一系列的字符串方法用于提升开发效率：</p>
<ul>
<li><p><strong>存在性判定</strong>：在过去，当判断一个字符&#x2F;字符串是否在某字符串中时，只能用 indexOf &gt; -1 来做。现在 ES6 提供了三个方法：includes、startsWith、endsWith，它们都会返回一个布尔值来告诉你是否存在。</p>
</li>
<li><ul>
<li><strong>includes</strong>：判断字符串与子串的包含关系：</li>
</ul>
</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> son = <span class="hljs-string">&#x27;haha&#x27;</span> <br><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.includes(son) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><strong>startsWith</strong>：判断字符串是否以某个&#x2F;某串字符开头：</li>
</ul>
</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">const father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>father.startsWith(<span class="hljs-string">&#x27;haha&#x27;</span>) <span class="hljs-regexp">//</span> false<br>father.startsWith(<span class="hljs-string">&#x27;xixi&#x27;</span>) <span class="hljs-regexp">//</span> true<br></code></pre></td></tr></table></figure>

<ul>
<li><ul>
<li><strong>endsWith</strong>：判断字符串是否以某个&#x2F;某串字符结尾：</li>
</ul>
</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> father = <span class="hljs-string">&#x27;xixi haha hehe&#x27;</span><br>  father.endsWith(<span class="hljs-string">&#x27;hehe&#x27;</span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<ul>
<li><strong>自动重复</strong>：可以使用 repeat 方法来使同一个字符串输出多次（被连续复制多次）：</li>
</ul>
<figure class="highlight monkey"><table><tr><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">const</span> sourceCode = <span class="hljs-comment">&#x27;repeat for 3 times;&#x27;</span><br><span class="hljs-keyword">const</span> repeated = sourceCode.<span class="hljs-keyword">repeat</span>(<span class="hljs-number">3</span>) <br>console.<span class="hljs-built_in">log</span>(repeated) // <span class="hljs-keyword">repeat</span> <span class="hljs-keyword">for</span> <span class="hljs-number">3</span> times;<span class="hljs-keyword">repeat</span> <span class="hljs-keyword">for</span> <span class="hljs-number">3</span> times;<span class="hljs-keyword">repeat</span> <span class="hljs-keyword">for</span> <span class="hljs-number">3</span> times;<br></code></pre></td></tr></table></figure>

<h2 id="三、JavaScript基础"><a href="#三、JavaScript基础" class="headerlink" title="三、JavaScript基础"></a>三、JavaScript基础</h2><h3 id="1-new操作符的实现原理"><a href="#1-new操作符的实现原理" class="headerlink" title="1. new操作符的实现原理"></a>1. new操作符的实现原理</h3><p><strong>new操作符的执行过程：</strong></p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<p>具体实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断参数是否是一个函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag = result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-title function_">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure>

<h3 id="2-map和Object的区别"><a href="#2-map和Object的区别" class="headerlink" title="2. map和Object的区别"></a>2. map和Object的区别</h3><table>
<thead>
<tr>
<th></th>
<th>Map</th>
<th>Object</th>
</tr>
</thead>
<tbody><tr>
<td>意外的键</td>
<td>Map默认情况不包含任何键，只包含显式插入的键。</td>
<td>Object 有一个原型, 原型链上的键名有可能和自己在对象上的设置的键名产生冲突。</td>
</tr>
<tr>
<td>键的类型</td>
<td>Map的键可以是任意值，包括函数、对象或任意基本类型。</td>
<td>Object 的键必须是 String 或是Symbol。</td>
</tr>
<tr>
<td>键的顺序</td>
<td>Map 中的 key 是有序的。因此，当迭代的时候， Map 对象以插入的顺序返回键值。</td>
<td>Object 的键是无序的</td>
</tr>
<tr>
<td>Size</td>
<td>Map 的键值对个数可以轻易地通过size 属性获取</td>
<td>Object 的键值对个数只能手动计算</td>
</tr>
<tr>
<td>迭代</td>
<td>Map 是 iterable 的，所以可以直接被迭代。</td>
<td>迭代Object需要以某种方式获取它的键然后才能迭代。</td>
</tr>
<tr>
<td>性能</td>
<td>在频繁增删键值对的场景下表现更好。</td>
<td>在频繁添加和删除键值对的场景下未作出优化。</td>
</tr>
</tbody></table>
<h3 id="3-map和weakMap的区别"><a href="#3-map和weakMap的区别" class="headerlink" title="3. map和weakMap的区别"></a>3. map和weakMap的区别</h3><p><strong>（1）Map</strong></p>
<p>map本质上就是键值对的集合，但是普通的Object中的键值对中的键只能是字符串。而ES6提供的Map数据结构类似于对象，但是它的键不限制范围，可以是任意类型，是一种更加完善的Hash结构。如果Map的键是一个原始数据类型，只要两个键严格相同，就视为是同一个键。</p>
<p>实际上Map是一个数组，它的每一个数据也都是一个数组，其形式如下：</p>
<figure class="highlight prolog"><table><tr><td class="code"><pre><code class="hljs prolog">const map = [<br>     [<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;张三&quot;</span>],<br>     [<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">18</span>],<br>]<br></code></pre></td></tr></table></figure>

<p>Map数据结构有以下操作方法：</p>
<ul>
<li><strong>size</strong>： <code>map.size</code> 返回Map结构的成员总数。</li>
<li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
<li>**clear()**：map.clear()清除所有成员，没有返回值。</li>
</ul>
<p>Map结构原生提供是三个遍历器生成函数和一个遍历方法</p>
<ul>
<li>keys()：返回键名的遍历器。</li>
<li>values()：返回键值的遍历器。</li>
<li>entries()：返回所有成员的遍历器。</li>
<li>forEach()：遍历Map的所有成员。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>([<br>     [<span class="hljs-string">&quot;foo&quot;</span>,<span class="hljs-number">1</span>],<br>     [<span class="hljs-string">&quot;bar&quot;</span>,<span class="hljs-number">2</span>],<br>])<br><span class="hljs-keyword">for</span>(let key of <span class="hljs-built_in">map</span>.keys())&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(key);  <span class="hljs-comment">// foo bar</span><br>&#125;<br><span class="hljs-keyword">for</span>(let value of <span class="hljs-built_in">map</span>.values())&#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// 1 2</span><br>&#125;<br><span class="hljs-keyword">for</span>(let items of <span class="hljs-built_in">map</span>.entries())&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(items);  <span class="hljs-comment">// [&quot;foo&quot;,1]  [&quot;bar&quot;,2]</span><br>&#125;<br><span class="hljs-built_in">map</span>.forEach( <span class="hljs-function">(<span class="hljs-params">value,key,<span class="hljs-built_in">map</span></span>) =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(key,value); <span class="hljs-comment">// foo 1    bar 2</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>（2）WeakMap</strong></p>
<p>WeakMap 对象也是一组键值对的集合，其中的键是弱引用的。<strong>其键必须是对象</strong>，原始数据类型不能作为key值，而值可以是任意的。</p>
<p>该对象也有以下几种方法：</p>
<ul>
<li>**set(key,value)**：设置键名key对应的键值value，然后返回整个Map结构，如果key已经有值，则键值会被更新，否则就新生成该键。（因为返回的是当前Map对象，所以可以链式调用）</li>
<li>**get(key)**：该方法读取key对应的键值，如果找不到key，返回undefined。</li>
<li>**has(key)**：该方法返回一个布尔值，表示某个键是否在当前Map对象中。</li>
<li>**delete(key)**：该方法删除某个键，返回true，如果删除失败，返回false。</li>
</ul>
<p>其clear()方法已经被弃用，所以可以通过创建一个空的WeakMap并替换原对象来实现清除。</p>
<p>WeakMap的设计目的在于，有时想在某个对象上面存放一些数据，但是这会形成对于这个对象的引用。一旦不再需要这两个对象，就必须手动删除这个引用，否则垃圾回收机制就不会释放对象占用的内存。</p>
<p>而WeakMap的<strong>键名所引用的对象都是弱引用</strong>，即垃圾回收机制不将该引用考虑在内。因此，只要所引用的对象的其他引用都被清除，垃圾回收机制就会释放该对象所占用的内存。也就是说，一旦不再需要，WeakMap 里面的<strong>键名对象和所对应的键值对会自动消失，不用手动删除引用</strong>。</p>
<p><strong>总结：</strong></p>
<ul>
<li>Map 数据结构。它类似于对象，也是键值对的集合，但是“键”的范围不限于字符串，各种类型的值（包括对象）都可以当作键。</li>
<li>WeakMap 结构与 Map 结构类似，也是用于生成键值对的集合。但是 WeakMap 只接受对象作为键名（ null 除外），不接受其他类型的值作为键名。而且 WeakMap 的键名所指向的对象，不计入垃圾回收机制。</li>
</ul>
<h3 id="4-JavaScript有哪些内置对象"><a href="#4-JavaScript有哪些内置对象" class="headerlink" title="4. JavaScript有哪些内置对象"></a>4. JavaScript有哪些内置对象</h3><p>全局的对象（ global objects ）或称标准内置对象，不要和 “全局对象（global object）” 混淆。这里说的全局的对象是说在</p>
<p>全局作用域里的对象。全局作用域中的其他对象可以由用户的脚本创建或由宿主程序提供。</p>
<p><strong>标准内置对象的分类：</strong></p>
<p>（1）值属性，这些全局属性返回一个简单值，这些值没有自己的属性和方法。</p>
<p>例如 Infinity、NaN、undefined、null 字面量</p>
<p>（2）函数属性，全局函数可以直接调用，不需要在调用时指定所属对象，执行结束后会将结果直接返回给调用者。</p>
<p>例如 eval()、parseFloat()、parseInt() 等</p>
<p>（3）基本对象，基本对象是定义或使用其他对象的基础。基本对象包括一般对象、函数对象和错误对象。</p>
<p>例如 Object、Function、Boolean、Symbol、Error 等</p>
<p>（4）数字和日期对象，用来表示数字、日期和执行数学计算的对象。</p>
<p>例如 Number、Math、Date</p>
<p>（5）字符串，用来表示和操作字符串的对象。</p>
<p>例如 String、RegExp</p>
<p>（6）可索引的集合对象，这些对象表示按照索引值来排序的数据集合，包括数组和类型数组，以及类数组结构的对象。例如 Array</p>
<p>（7）使用键的集合对象，这些集合对象在存储数据时会使用到键，支持按照插入顺序来迭代元素。</p>
<p>例如 Map、Set、WeakMap、WeakSet</p>
<p>（8）矢量集合，SIMD 矢量集合中的数据会被组织为一个数据序列。</p>
<p>例如 SIMD 等</p>
<p>（9）结构化数据，这些对象用来表示和操作结构化的缓冲区数据，或使用 JSON 编码的数据。</p>
<p>例如 JSON 等</p>
<p>（10）控制抽象对象</p>
<p>例如 Promise、Generator 等</p>
<p>（11）反射</p>
<p>例如 Reflect、Proxy</p>
<p>（12）国际化，为了支持多语言处理而加入 ECMAScript 的对象。</p>
<p>例如 Intl、Intl.Collator 等</p>
<p>（13）WebAssembly</p>
<p>（14）其他</p>
<p>例如 arguments</p>
<p><strong>总结：</strong></p>
<p>js 中的内置对象主要指的是在程序执行前存在全局作用域里的由 js 定义的一些全局值属性、函数和用来实例化其他对象的构造函数对象。一般经常用到的如全局变量值 NaN、undefined，全局函数如 parseInt()、parseFloat() 用来实例化对象的构造函数如 Date、Object 等，还有提供数学计算的单体内置对象如 Math 对象。</p>
<h3 id="5-常用的正则表达式有哪些？"><a href="#5-常用的正则表达式有哪些？" class="headerlink" title="5. 常用的正则表达式有哪些？"></a>5. 常用的正则表达式有哪些？</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// （1）匹配 16 进制颜色值</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/#([0-9a-fA-F]&#123;6&#125;|[0-9a-fA-F]&#123;3&#125;)/g</span>;<br><br><span class="hljs-comment">// （2）匹配日期，如 yyyy-mm-dd 格式</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[0-9]&#123;4&#125;-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])$/</span>;<br><br><span class="hljs-comment">// （3）匹配 qq 号</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[1-9][0-9]&#123;4,10&#125;$/g</span>;<br><br><span class="hljs-comment">// （4）手机号码正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^1[34578]\d&#123;9&#125;$/g</span>;<br><br><span class="hljs-comment">// （5）用户名正则</span><br><span class="hljs-keyword">var</span> regex = <span class="hljs-regexp">/^[a-zA-Z\$][a-zA-Z0-9_\$]&#123;4,16&#125;$/</span>;<br></code></pre></td></tr></table></figure>

<h3 id="6-对JSON的理解"><a href="#6-对JSON的理解" class="headerlink" title="6. 对JSON的理解"></a>6. 对JSON的理解</h3><p>JSON 是一种基于文本的轻量级的数据交换格式。它可以被任何的编程语言读取和作为数据格式来传递。</p>
<p>在项目开发中，使用 JSON 作为前后端数据交换的方式。在前端通过将一个符合 JSON 格式的数据结构序列化为 </p>
<p>JSON 字符串，然后将它传递到后端，后端通过 JSON 格式的字符串解析后生成对应的数据结构，以此来实现前后端数据的一个传递。</p>
<p>因为 JSON 的语法是基于 js 的，因此很容易将 JSON 和 js 中的对象弄混，但是应该注意的是 JSON 和 js 中的对象不是一回事，JSON 中对象格式更加严格，比如说在 JSON 中属性值不能为函数，不能出现 NaN 这样的属性值等，因此大多数的 js 对象是不符合 JSON 对象的格式的。</p>
<p>在 js 中提供了两个函数来实现 js 数据结构和 JSON 格式的转换处理，</p>
<ul>
<li>JSON.stringify 函数，通过传入一个符合 JSON 格式的数据结构，将其转换为一个 JSON 字符串。如果传入的数据结构不符合 JSON 格式，那么在序列化的时候会对这些值进行对应的特殊处理，使其符合规范。在前端向后端发送数据时，可以调用这个函数将数据对象转化为 JSON 格式的字符串。</li>
<li>JSON.parse() 函数，这个函数用来将 JSON 格式的字符串转换为一个 js 数据结构，如果传入的字符串不是标准的 JSON 格式的字符串的话，将会抛出错误。当从后端接收到 JSON 格式的字符串时，可以通过这个方法来将其解析为一个 js 数据结构，以此来进行数据的访问。</li>
</ul>
<h3 id="7-JavaScript脚本延迟加载的方式有哪些？"><a href="#7-JavaScript脚本延迟加载的方式有哪些？" class="headerlink" title="7. JavaScript脚本延迟加载的方式有哪些？"></a>7. JavaScript脚本延迟加载的方式有哪些？</h3><p>延迟加载就是等页面加载完成之后再加载 JavaScript 文件。 js 延迟加载有助于提高页面加载速度。</p>
<p>一般有以下几种方式：</p>
<ul>
<li><strong>defer 属性：</strong>给 js 脚本添加 defer 属性，这个属性会让脚本的加载与文档的解析同步解析，然后在文档解析完成后再执行这个脚本文件，这样的话就能使页面的渲染不被阻塞。多个设置了 defer 属性的脚本按规范来说最后是顺序执行的，但是在一些浏览器中可能不是这样。</li>
<li><strong>async 属性：</strong>给 js 脚本添加 async 属性，这个属性会使脚本异步加载，不会阻塞页面的解析过程，但是当脚本加载完成后立即执行 js 脚本，这个时候如果文档没有解析完成的话同样会阻塞。多个 async 属性的脚本的执行顺序是不可预测的，一般不会按照代码的顺序依次执行。</li>
<li><strong>动态创建 DOM 方式：</strong>动态创建 DOM 标签的方式，可以对文档的加载事件进行监听，当文档加载完成后再动态的创建 script 标签来引入 js 脚本。</li>
<li><strong>使用 setTimeout 延迟方法：</strong>设置一个定时器来延迟加载js脚本文件</li>
<li><strong>让 JS 最后加载：</strong>将 js 脚本放在文档的底部，来使 js 脚本尽可能的在最后来加载执行。</li>
<li><strong>使用jquery的getscript：</strong>回调函数，文档加载完毕执行js</li>
</ul>
<h3 id="8-JavaScript-类数组对象的定义？"><a href="#8-JavaScript-类数组对象的定义？" class="headerlink" title="8. JavaScript 类数组对象的定义？"></a>8. JavaScript 类数组对象的定义？</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，还有一个函数也可以被看作是类数组对象，因为它含有 length 属性值，代表可接收的参数个数。</p>
<p>常见的类数组转换为数组的方法有这样几种：</p>
<p>（1）通过 call 调用数组的 slice 方法来实现转换</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.slice.call(arrayLike);<br></code></pre></td></tr></table></figure>

<p>（2）通过 call 调用数组的 splice 方法来实现转换</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.splice.call(arrayLike, 0);<br></code></pre></td></tr></table></figure>

<p>（3）通过 apply 调用数组的 concat 方法来实现转换</p>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.concat.apply([], arrayLike);<br></code></pre></td></tr></table></figure>

<p>（4）通过 Array.from 方法来实现转换</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">Array.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">array</span>Like);<br></code></pre></td></tr></table></figure>

<h3 id="9-数组有哪些原生方法？"><a href="#9-数组有哪些原生方法？" class="headerlink" title="9. 数组有哪些原生方法？"></a>9. 数组有哪些原生方法？</h3><ul>
<li>数组和字符串的转换方法：toString()、toLocalString()、join() 其中 join() 方法可以指定转换为字符串时的分隔符。</li>
<li>数组尾部操作的方法 pop() 和 push()，push 方法可以传入多个参数。</li>
<li>数组首部操作的方法 shift() 和 unshift() 重排序的方法 reverse() 和 sort()，sort() 方法可以传入一个函数来进行比较，传入前后两个值，如果返回值为正数，则交换两个参数的位置。</li>
<li>数组连接的方法 concat() ，返回的是拼接好的数组，不影响原数组。</li>
<li>数组截取办法 slice()，用于截取数组中的一部分返回，不影响原数组。</li>
<li>数组插入方法 splice()，影响原数组查找特定项的索引的方法，indexOf() 和 lastIndexOf() 迭代方法 every()、some()、filter()、map() 和 forEach() 方法</li>
<li>数组归并方法 reduce() 和 reduceRight() 方法</li>
</ul>
<h3 id="10-Unicode、UTF-8、UTF-16、UTF-32的区别？"><a href="#10-Unicode、UTF-8、UTF-16、UTF-32的区别？" class="headerlink" title="10. Unicode、UTF-8、UTF-16、UTF-32的区别？"></a>10. <strong>Unicode、UTF-8、UTF-16、UTF-32的区别？</strong></h3><h4 id="（1）Unicode"><a href="#（1）Unicode" class="headerlink" title="（1）Unicode"></a>（1）Unicode</h4><p>在说<code>Unicode</code>之前需要先了解一下<code>ASCII</code>码：ASCII 码（<code>American Standard Code for Information Interchange</code>）称为美国标准信息交换码。</p>
<ul>
<li>它是基于拉丁字母的一套电脑编码系统。</li>
<li>它定义了一个用于代表常见字符的字典。</li>
<li>它包含了”A-Z”(包含大小写)，数据”0-9” 以及一些常见的符号。</li>
<li>它是专门为英语而设计的，有128个编码，对其他语言无能为力</li>
</ul>
<p><code>ASCII</code>码可以表示的编码有限，要想表示其他语言的编码，还是要使用<code>Unicode</code>来表示，可以说<code>Unicode</code>是<code>ASCII</code> 的超集。</p>
<p><code>Unicode</code>全称 <code>Unicode Translation Format</code>，又叫做统一码、万国码、单一码。<code>Unicode</code> 是为了解决传统的字符编码方案的局限而产生的，它为每种语言中的每个字符设定了统一并且唯一的二进制编码，以满足跨语言、跨平台进行文本转换、处理的要求。</p>
<p><code>Unicode</code>的实现方式（也就是编码方式）有很多种，常见的是<strong>UTF-8</strong>、<strong>UTF-16</strong>、<strong>UTF-32</strong>和<strong>USC-2</strong>。</p>
<h4 id="（2）UTF-8"><a href="#（2）UTF-8" class="headerlink" title="（2）UTF-8"></a>（2）UTF-8</h4><p><code>UTF-8</code>是使用最广泛的<code>Unicode</code>编码方式，它是一种可变长的编码方式，可以是1—4个字节不等，它可以完全兼容<code>ASCII</code>码的128个字符。</p>
<p><strong>注意：</strong> <code>UTF-8</code> 是一种编码方式，<code>Unicode</code>是一个字符集合。</p>
<p><code>UTF-8</code>的编码规则：</p>
<ul>
<li>对于<strong>单字节</strong>的符号，字节的第一位为0，后面的7位为这个字符的<code>Unicode</code>编码，因此对于英文字母，它的<code>Unicode</code>编码和<code>ACSII</code>编码一样。</li>
<li>对于<strong>n字节</strong>的符号，第一个字节的前n位都是1，第n+1位设为0，后面字节的前两位一律设为10，剩下的没有提及的二进制位，全部为这个符号的<code>Unicode</code>码 。</li>
</ul>
<p>来看一下具体的<code>Unicode</code>编号范围与对应的<code>UTF-8</code>二进制格式 ：</p>
<table>
<thead>
<tr>
<th>编码范围（编号对应的十进制数）</th>
<th>二进制格式</th>
</tr>
</thead>
<tbody><tr>
<td>0x00—0x7F （0-127）</td>
<td>0xxxxxxx</td>
</tr>
<tr>
<td>0x80—0x7FF （128-2047）</td>
<td>110xxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x800—0xFFFF  （2048-65535）</td>
<td>1110xxxx 10xxxxxx 10xxxxxx</td>
</tr>
<tr>
<td>0x10000—0x10FFFF  （65536以上）</td>
<td>11110xxx 10xxxxxx 10xxxxxx 10xxxxxx</td>
</tr>
</tbody></table>
<p>那该如何通过具体的<code>Unicode</code>编码，进行具体的<code>UTF-8</code>编码呢？<strong>步骤如下：</strong></p>
<ul>
<li>找到该<code>Unicode</code>编码的所在的编号范围，进而找到与之对应的二进制格式</li>
<li>将<code>Unicode</code>编码转换为二进制数（去掉最高位的0）</li>
<li>将二进制数从右往左一次填入二进制格式的<code>X</code>中，如果有<code>X</code>未填，就设为0</li>
</ul>
<p>来看一个实际的例子：</p>
<p>“<strong>马</strong>” 字的<code>Unicode</code>编码是：<code>0x9A6C</code>，整数编号是<code>39532</code></p>
<p>（1）首选确定了该字符在第三个范围内，它的格式是 <code>1110xxxx 10xxxxxx 10xxxxxx</code></p>
<p>（2）39532对应的二进制数为<code>1001 1010 0110 1100</code></p>
<p>（3）将二进制数填入X中，结果是：<code>11101001 10101001 10101100</code></p>
<h4 id="（3）UTF-16"><a href="#（3）UTF-16" class="headerlink" title="（3）UTF-16"></a>（3）UTF-16</h4><p><strong>1. 平面的概念</strong></p>
<p>在了解<code>UTF-16</code>之前，先看一下<strong>平面</strong>的概念：</p>
<p><code>Unicode</code>编码中有很多很多的字符，它并不是一次性定义的，而是分区进行定义的，每个区存放<strong>65536</strong>（216）个字符，这称为一个<strong>平面</strong>，目前总共有17 个平面。</p>
<p>最前面的一个平面称为<strong>基本平面</strong>，它的码点从<strong>0 — 2**<strong>16</strong></strong>-1<strong>，写成16进制就是<code>U+0000 — U+FFFF</code>，那剩下的16个平面就是</strong>辅助平面**，码点范围是 <code>U+10000—U+10FFFF</code>。</p>
<p><strong>2. UTF-16 概念：</strong></p>
<p><code>UTF-16</code>也是<code>Unicode</code>编码集的一种编码形式，把<code>Unicode</code>字符集的抽象码位映射为16位长的整数（即码元）的序列，用于数据存储或传递。<code>Unicode</code>字符的码位需要1个或者2个16位长的码元来表示，因此<code>UTF-16</code>也是用变长字节表示的。</p>
<p><strong>3. UTF-16 编码规则：</strong></p>
<ul>
<li>编号在 <code>U+0000—U+FFFF</code> 的字符（常用字符集），直接用两个字节表示。</li>
<li>编号在 <code>U+10000—U+10FFFF</code> 之间的字符，需要用四个字节表示。</li>
</ul>
<p><strong>4. 编码识别</strong></p>
<p>那么问题来了，当遇到两个字节时，怎么知道是把它当做一个字符还是和后面的两个字节一起当做一个字符呢？</p>
<p><code>UTF-16</code> 编码肯定也考虑到了这个问题，在基本平面内，从 <code>U+D800 — U+DFFF</code> 是一个空段，也就是说这个区间的码点不对应任何的字符，因此这些空段就可以用来映射辅助平面的字符。</p>
<p>辅助平面共有 <strong>2****20</strong> 个字符位，因此表示这些字符至少需要 20 个二进制位。<code>UTF-16</code> 将这 20 个二进制位分成两半，前 10 位映射在 <code>U+D800 — U+DBFF</code>，称为<strong>高位</strong>（H），后 10 位映射在 <code>U+DC00 — U+DFFF</code>，称为<strong>低位</strong>（L）。这就相当于，将一个辅助平面的字符拆成了两个基本平面的字符来表示。</p>
<p>因此，当遇到两个字节时，发现它的码点在 <code>U+D800 —U+DBFF</code>之间，就可以知道，它后面的两个字节的码点应该在 <code>U+DC00 — U+DFFF</code> 之间，这四个字节必须放在一起进行解读。</p>
<p><strong>5. 举例说明</strong></p>
<p>以 “<strong>𡠀</strong>“ 字为例，它的 <code>Unicode</code> 码点为 <code>0x21800</code>，该码点超出了基本平面的范围，因此需要用四个字节来表示，步骤如下：</p>
<ul>
<li>首先计算超出部分的结果：<code>0x21800 - 0x10000</code></li>
<li>将上面的计算结果转为20位的二进制数，不足20位就在前面补0，结果为：<code>0001000110 0000000000</code></li>
<li>将得到的两个10位二进制数分别对应到两个区间中</li>
<li><code>U+D800</code> 对应的二进制数为 <code>1101100000000000</code>， 将<code>0001000110</code>填充在它的后10 个二进制位，得到 <code>1101100001000110</code>，转成 16 进制数为 <code>0xD846</code>。同理，低位为 <code>0xDC00</code>，所以这个字的<code>UTF-16</code> 编码为 <code>0xD846 0xDC00</code></li>
</ul>
<h4 id="（4）-UTF-32"><a href="#（4）-UTF-32" class="headerlink" title="（4） UTF-32"></a>（4） UTF-32</h4><p><code>UTF-32</code> 就是字符所对应编号的整数二进制形式，每个字符占四个字节，这个是直接进行转换的。该编码方式占用的储存空间较多，所以使用较少。</p>
<p>比如“<strong>马</strong>” 字的Unicode编号是：<code>U+9A6C</code>，整数编号是<code>39532</code>，直接转化为二进制：<code>1001 1010 0110 1100</code>，这就是它的UTF-32编码。</p>
<h4 id="（5）总结"><a href="#（5）总结" class="headerlink" title="（5）总结"></a>（5）总结</h4><p><strong>Unicode、UTF-8、UTF-16、UTF-32有什么区别？</strong></p>
<ul>
<li><code>Unicode</code> 是编码字符集（字符集），而<code>UTF-8</code>、<code>UTF-16</code>、<code>UTF-32</code>是字符集编码（编码规则）；</li>
<li><code>UTF-16</code> 使用变长码元序列的编码方式，相较于定长码元序列的<code>UTF-32</code>算法更复杂，甚至比同样是变长码元序列的<code>UTF-8</code>也更为复杂，因为其引入了独特的<strong>代理对</strong>这样的代理机制；</li>
<li><code>UTF-8</code>需要判断每个字节中的开头标志信息，所以如果某个字节在传送过程中出错了，就会导致后面的字节也会解析出错；而<code>UTF-16</code>不会判断开头标志，即使错也只会错一个字符，所以容错能力教强；</li>
<li>如果字符内容全部英文或英文与其他文字混合，但英文占绝大部分，那么用<code>UTF-8</code>就比<code>UTF-16</code>节省了很多空间；而如果字符内容全部是中文这样类似的字符或者混合字符中中文占绝大多数，那么<code>UTF-16</code>就占优势了，可以节省很多空间；</li>
</ul>
<h3 id="11-常见的位运算符有哪些？其计算规则是什么？"><a href="#11-常见的位运算符有哪些？其计算规则是什么？" class="headerlink" title="11. 常见的位运算符有哪些？其计算规则是什么？"></a>11. 常见的位运算符有哪些？其计算规则是什么？</h3><p>现代计算机中数据都是以二进制的形式存储的，即0、1两种状态，计算机对二进制数据进行的运算加减乘除等都是叫位运算，即将符号位共同参与运算的运算。</p>
<p>常见的位运算有以下几种：</p>
<table>
<thead>
<tr>
<th>运算符</th>
<th>描述</th>
<th>运算规则</th>
</tr>
</thead>
<tbody><tr>
<td><code>&amp;</code></td>
<td>与</td>
<td>两个位都为1时，结果才为1</td>
</tr>
<tr>
<td>&#96;</td>
<td>&#96;</td>
<td>或</td>
</tr>
<tr>
<td><code>^</code></td>
<td>异或</td>
<td>两个位相同为0，相异为1</td>
</tr>
<tr>
<td><code>~</code></td>
<td>取反</td>
<td>0变1，1变0</td>
</tr>
<tr>
<td><code>&lt;&lt;</code></td>
<td>左移</td>
<td>各二进制位全部左移若干位，高位丢弃，低位补0</td>
</tr>
<tr>
<td><code>&gt;&gt;</code></td>
<td>右移</td>
<td>各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃</td>
</tr>
</tbody></table>
<h4 id="1-按位与运算符（-amp-）"><a href="#1-按位与运算符（-amp-）" class="headerlink" title="1. 按位与运算符（&amp;）"></a>1. 按位与运算符（&amp;）</h4><p><strong>定义：</strong> 参加运算的两个数据<strong>按二进制位</strong>进行“与”运算。</p>
<p><strong>运算规则：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>&amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-symbol">0 </span>&amp; <span class="hljs-number">1</span> = <span class="hljs-number">0</span>  <br><span class="hljs-symbol">1 </span>&amp; <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-symbol">1 </span>&amp; <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>总结：两位同时为1，结果才为1，否则结果为0。</p>
<p>例如：3&amp;5 即：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">0000 </span><span class="hljs-number">0011</span> <br>   <span class="hljs-number">0000 </span><span class="hljs-number">0101</span> <br> <span class="hljs-string">=</span> <span class="hljs-number">0000 </span><span class="hljs-number">0001</span><br></code></pre></td></tr></table></figure>

<p>因此 3&amp;5 的值为1。</p>
<p>注意：负数按补码形式参加按位与运算。</p>
<p><strong>用途：</strong></p>
<p><strong>（1）判断奇偶</strong></p>
<p>只要根据最未位是0还是1来决定，为0就是偶数，为1就是奇数。因此可以用<code>if ((i &amp; 1) == 0)</code>代替<code>if (i % 2 == 0)</code>来判断a是不是偶数。</p>
<p><strong>（2）清零</strong></p>
<p>如果想将一个单元清零，即使其全部二进制位为0，只要与一个各位都为零的数值相与，结果为零。</p>
<h4 id="2-按位或运算符（-）"><a href="#2-按位或运算符（-）" class="headerlink" title="2. 按位或运算符（|）"></a>2. 按位或运算符（|）</h4><p><strong>定义：</strong> 参加运算的两个对象按二进制位进行“或”运算。</p>
<p><strong>运算规则：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>| <span class="hljs-number">0</span> = <span class="hljs-number">0</span><br><span class="hljs-symbol">0 </span>| <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-symbol">1 </span>| <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-symbol">1 </span>| <span class="hljs-number">1</span> = <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>总结：参加运算的两个对象只要有一个为1，其值为1。</p>
<p>例如：3|5即：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">0000 0011<br><span class="hljs-code">  0000 0101 </span><br><span class="hljs-section">= 0000 0111</span><br></code></pre></td></tr></table></figure>

<p>因此，3|5的值为7。</p>
<p>注意：负数按补码形式参加按位或运算。</p>
<h4 id="3-异或运算符（-）"><a href="#3-异或运算符（-）" class="headerlink" title="3. 异或运算符（^）"></a>3. 异或运算符（^）</h4><p><strong>定义：</strong> 参加运算的两个数据按二进制位进行“异或”运算。</p>
<p><strong>运算规则：</strong></p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">0 </span>^ <span class="hljs-number">0</span> = <span class="hljs-number">0</span>  <br><span class="hljs-symbol">0 </span>^ <span class="hljs-number">1</span> = <span class="hljs-number">1</span>  <br><span class="hljs-symbol">1 </span>^ <span class="hljs-number">0</span> = <span class="hljs-number">1</span>  <br><span class="hljs-symbol">1 </span>^ <span class="hljs-number">1</span> = <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure>

<p>总结：参加运算的两个对象，如果两个相应位相同为0，相异为1。</p>
<p>例如：3|5即：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">0000 0011<br><span class="hljs-code">  0000 0101 </span><br><span class="hljs-section">= 0000 0110</span><br></code></pre></td></tr></table></figure>

<p>因此，3^5的值为6。</p>
<p>异或运算的性质:</p>
<ul>
<li>交换律：<code>(a^b)^c == a^(b^c)</code></li>
<li>结合律：<code>(a + b)^c == a^b + b^c</code></li>
<li>对于任何数x，都有 <code>x^x=0，x^0=x</code></li>
<li>自反性: <code>a^b^b=a^0=a</code>;</li>
</ul>
<h4 id="4-取反运算符"><a href="#4-取反运算符" class="headerlink" title="4. 取反运算符 (~)"></a>4. 取反运算符 (~)</h4><p><strong>定义：</strong> 参加运算的一个数据按二进制进行“取反”运算。</p>
<p>运算规则：</p>
<figure class="highlight haml"><table><tr><td class="code"><pre><code class="hljs haml">~ 1 = 0<br>~ 0 = 1<br></code></pre></td></tr></table></figure>

<p>总结：对一个二进制数按位取反，即将0变1，1变0。</p>
<p>例如：~6 即：</p>
<figure class="highlight asciidoc"><table><tr><td class="code"><pre><code class="hljs asciidoc">0000 0110<br><span class="hljs-section">= 1111 1001</span><br></code></pre></td></tr></table></figure>

<p>在计算机中，正数用原码表示，负数使用补码存储，首先看最高位，最高位1表示负数，0表示正数。此计算机二进制码为负数，最高位为符号位。</p>
<p>当发现按位取反为负数时，就<strong>直接取其补码</strong>，变为十进制：</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-number">0000 </span><span class="hljs-number">0110</span><br>   <span class="hljs-string">=</span> <span class="hljs-number">1111 </span><span class="hljs-number">1001</span><br><span class="hljs-string">反码：1000</span> <span class="hljs-number">0110</span><br><span class="hljs-string">补码：1000</span> <span class="hljs-number">0111</span><br></code></pre></td></tr></table></figure>

<p>因此，~6的值为-7。</p>
<h4 id="5-左移运算符（-lt-lt-）"><a href="#5-左移运算符（-lt-lt-）" class="headerlink" title="5. 左移运算符（&lt;&lt;）"></a>5. 左移运算符（&lt;&lt;）</h4><p><strong>定义：</strong> 将一个运算对象的各二进制位全部左移若干位，左边的二进制位丢弃，右边补0。</p>
<p>设 a&#x3D;1010 1110，a &#x3D; a&lt;&lt; 2 将a的二进制位左移2位、右补0，即得a&#x3D;1011 1000。</p>
<p>若左移时舍弃的高位不包含1，则每左移一位，相当于该数乘以2。</p>
<h4 id="6-右移运算符（-gt-gt-）"><a href="#6-右移运算符（-gt-gt-）" class="headerlink" title="6. 右移运算符（&gt;&gt;）"></a>6. 右移运算符（&gt;&gt;）</h4><p><strong>定义：</strong> 将一个数的各二进制位全部右移若干位，正数左补0，负数左补1，右边丢弃。</p>
<p>例如：a&#x3D;a&gt;&gt;2 将a的二进制位右移2位，左补0 或者 左补1得看被移数是正还是负。</p>
<p>操作数每右移一位，相当于该数除以2。</p>
<h4 id="7-原码、补码、反码"><a href="#7-原码、补码、反码" class="headerlink" title="7. 原码、补码、反码"></a>7. 原码、补码、反码</h4><p>上面提到了补码、反码等知识，这里就补充一下。</p>
<p>计算机中的<strong>有符号数</strong>有三种表示方法，即原码、反码和补码。三种表示方法均有符号位和数值位两部分，符号位都是用0表示“正”，用1表示“负”，而数值位，三种表示方法各不相同。</p>
<p><strong>（1）原码</strong></p>
<p>原码就是一个数的二进制数。</p>
<p>例如：10的原码为0000 1010</p>
<p><strong>（2）反码</strong></p>
<ul>
<li>正数的反码与原码相同，如：10 反码为 0000 1010</li>
<li>负数的反码为除符号位，按位取反，即0变1，1变0。</li>
</ul>
<p>例如：-10</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">原码：<span class="hljs-number">1000 1010</span><br>反码：<span class="hljs-number">1111 0101</span><br></code></pre></td></tr></table></figure>

<p><strong>（3）补码</strong></p>
<ul>
<li>正数的补码与原码相同，如：10 补码为 0000 1010</li>
<li>负数的补码是原码除符号位外的所有位取反即0变1，1变0，然后加1，也就是反码加1。</li>
</ul>
<p>例如：-10</p>
<figure class="highlight dns"><table><tr><td class="code"><pre><code class="hljs dns">原码：<span class="hljs-number">1000 1010</span><br>反码：<span class="hljs-number">1111 0101</span><br>补码：<span class="hljs-number">1111 0110</span><br></code></pre></td></tr></table></figure>

<h3 id="12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组"><a href="#12-为什么函数的-arguments-参数是类数组而不是数组？如何遍历类数组" class="headerlink" title="12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?"></a>12. 为什么函数的 arguments 参数是类数组而不是数组？如何遍历类数组?</h3><p><code>arguments</code>是一个对象，它的属性是从 0 开始依次递增的数字，还有<code>callee</code>和<code>length</code>等属性，与数组相似；但是它却没有数组常见的方法属性，如<code>forEach</code>, <code>reduce</code>等，所以叫它们类数组。</p>
<p>要遍历类数组，有三个方法：</p>
<p>（1）将数组的方法应用到类数组上，这时候就可以使用<code>call</code>和<code>apply</code>方法，如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">forEach</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>, <span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（2）使用Array.from方法将类数组转化成数组：‌</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>  const arrArgs = <span class="hljs-built_in">Array</span>.from(arguments) <br>  arrArgs.forEach(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a))<br>&#125;<br></code></pre></td></tr></table></figure>

<p>（3）使用展开运算符将类数组转化成数组</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>)&#123; <br>    const arrArgs = [...arguments] <br>    arrArgs.forEach(<span class="hljs-function"><span class="hljs-params">a</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a)) <br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="13-什么是-DOM-和-BOM？"><a href="#13-什么是-DOM-和-BOM？" class="headerlink" title="13. 什么是 DOM 和 BOM？"></a>13. 什么是 DOM 和 BOM？</h3><ul>
<li>DOM 指的是文档对象模型，它指的是把文档当做一个对象，这个对象主要定义了处理网页内容的方法和接口。</li>
<li>BOM 指的是浏览器对象模型，它指的是把浏览器当做一个对象来对待，这个对象主要定义了与浏览器进行交互的法和接口。BOM的核心是 window，而 window 对象具有双重角色，它既是通过 js 访问浏览器窗口的一个接口，又是一个 Global（全局）对象。这意味着在网页中定义的任何对象，变量和函数，都作为全局对象的一个属性或者方法存在。window 对象含有 location 对象、navigator 对象、screen 对象等子对象，并且 DOM 的最根本的对象 document 对象也是 BOM 的 window 对象的子对象。</li>
</ul>
<h3 id="14-对类数组对象的理解，如何转化为数组"><a href="#14-对类数组对象的理解，如何转化为数组" class="headerlink" title="14. 对类数组对象的理解，如何转化为数组"></a>14. 对类数组对象的理解，如何转化为数组</h3><p>一个拥有 length 属性和若干索引属性的对象就可以被称为类数组对象，类数组对象和数组类似，但是不能调用数组的方法。常见的类数组对象有 arguments 和 DOM 方法的返回结果，函数参数也可以被看作是类数组对象，因为它含有 length属性值，代表可接收的参数个数。</p>
<p>常见的类数组转换为数组的方法有这样几种：</p>
<ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.slice.call(arrayLike);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.splice.call(arrayLike, 0);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.concat.apply([], arrayLike);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">Array.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">array</span>Like);<br></code></pre></td></tr></table></figure>

<h3 id="15-escape、encodeURI、encodeURIComponent-的区别"><a href="#15-escape、encodeURI、encodeURIComponent-的区别" class="headerlink" title="15. escape、encodeURI、encodeURIComponent 的区别"></a>15. escape、encodeURI、encodeURIComponent 的区别</h3><ul>
<li>encodeURI 是对整个 URI 进行转义，将 URI 中的非法字符转换为合法字符，所以对于一些在 URI 中有特殊意义的字符不会进行转义。</li>
<li>encodeURIComponent 是对 URI 的组成部分进行转义，所以一些特殊字符也会得到转义。</li>
<li>escape 和 encodeURI 的作用相同，不过它们对于 unicode 编码为 0xff 之外字符的时候会有区别，escape 是直接在字符的 unicode 编码前加上 %u，而 encodeURI 首先会将字符转换为 UTF-8 的格式，再在每个字节前加上 %。</li>
</ul>
<h3 id="16-对AJAX的理解，实现一个AJAX请求"><a href="#16-对AJAX的理解，实现一个AJAX请求" class="headerlink" title="16. 对AJAX的理解，实现一个AJAX请求"></a>16. 对AJAX的理解，实现一个AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><strong>创建一个 XMLHttpRequest 对象。</strong></li>
<li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p>使用Promise封装AJAX：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// promise 封装实现：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="17-JavaScript为什么要进行变量提升，它导致了什么问题？"><a href="#17-JavaScript为什么要进行变量提升，它导致了什么问题？" class="headerlink" title="17. JavaScript为什么要进行变量提升，它导致了什么问题？"></a>17. JavaScript为什么要进行变量提升，它导致了什么问题？</h3><p>变量提升的表现是，无论在函数中何处位置声明的变量，好像都被提升到了函数的首部，可以在变量声明前访问到而不会报错。</p>
<p>造成变量声明提升的<strong>本质原因</strong>是 js 引擎在代码执行前有一个解析的过程，创建了执行上下文，初始化了一些代码执行时需要用到的对象。当访问一个变量时，会到当前执行上下文中的作用域链中去查找，而作用域链的首端指向的是当前执行上下文的变量对象，这个变量对象是执行上下文的一个属性，它包含了函数的形参、所有的函数和变量声明，这个对象的是在代码解析的时候创建的。</p>
<p>首先要知道，JS在拿到一个变量或者一个函数的时候，会有两步操作，即解析和执行。</p>
<ul>
<li><p><strong>在解析阶段</strong>，JS会检查语法，并对函数进行预编译。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
</li>
<li><ul>
<li>全局上下文：变量定义，函数声明</li>
<li>函数上下文：变量定义，函数声明，this，arguments</li>
</ul>
</li>
<li><p><strong>在执行阶段</strong>，就是按照代码的顺序依次执行。</p>
</li>
</ul>
<p>那为什么会进行变量提升呢？主要有以下两个原因：</p>
<ul>
<li>提高性能</li>
<li>容错性更好</li>
</ul>
<p><strong>（1）提高性能</strong></p>
<p>在JS代码执行之前，会进行语法检查和预编译，并且这一操作只进行一次。这么做就是为了提高性能，如果没有这一步，那么每次执行代码前都必须重新解析一遍该变量（函数），而这是没有必要的，因为变量（函数）的代码并不会改变，解析一遍就够了。</p>
<p>在解析的过程中，还会为函数生成预编译代码。在预编译时，会统计声明了哪些变量、创建了哪些函数，并对函数的代码进行压缩，去除注释、不必要的空白等。这样做的好处就是每次执行函数时都可以直接为该函数分配栈空间（不需要再解析一遍去获取代码中声明了哪些变量，创建了哪些函数），并且因为代码压缩的原因，代码执行也更快了。</p>
<p><strong>（2）容错性更好</strong></p>
<p>变量提升可以在一定程度上提高JS的容错性，看下面的代码：</p>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">a</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span><span class="hljs-comment">;</span><br>var a<span class="hljs-comment">;</span><br>console.log(a)<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>如果没有变量提升，这两行代码就会报错，但是因为有了变量提升，这段代码就可以正常执行。</p>
<p>虽然，在可以开发过程中，可以完全避免这样写，但是有时代码很复杂的时候。可能因为疏忽而先使用后定义了，这样也不会影响正常使用。由于变量提升的存在，而会正常运行。</p>
<p><strong>总结：</strong></p>
<ul>
<li>解析和预编译过程中的声明提升可以提高性能，让函数可以在执行时预先为变量分配栈空间</li>
<li>声明提升还可以提高JS代码的容错性，使一些不规范的代码也可以正常执行</li>
</ul>
<p>变量提升虽然有一些优点，但是他也会造成一定的问题，在ES6中提出了let、const来定义变量，它们就没有变量提升的机制。下面看一下变量提升可能会导致的问题：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> tmp = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Date</span>();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-literal">false</span>)&#123;<br>        <span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>    &#125;<br>&#125;<br><br>fn();  <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<p>在这个函数中，原本是要打印出外层的tmp变量，但是因为变量提升的问题，内层定义的tmp被提到函数内部的最顶部，相当于覆盖了外层的tmp，所以打印结果为undefined。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> tmp = <span class="hljs-string">&#x27;hello world&#x27;</span>;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; tmp.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(tmp[i]);<br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i); <span class="hljs-comment">// 11</span><br></code></pre></td></tr></table></figure>

<p>由于遍历时定义的i会变量提升成为一个全局变量，在函数结束之后不会被销毁，所以打印出来11。</p>
<h3 id="18-什么是尾调用，使用尾调用有什么好处？"><a href="#18-什么是尾调用，使用尾调用有什么好处？" class="headerlink" title="18. 什么是尾调用，使用尾调用有什么好处？"></a>18. 什么是尾调用，使用尾调用有什么好处？</h3><p>尾调用指的是函数的最后一步调用另一个函数。代码执行是基于执行栈的，所以当在一个函数里调用另一个函数时，会保留当前的执行上下文，然后再新建另外一个执行上下文加入栈中。使用尾调用的话，因为已经是函数的最后一步，所以这时可以不必再保留当前的执行上下文，从而节省了内存，这就是尾调用优化。但是 ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<h3 id="19-ES6模块与CommonJS模块有什么异同？"><a href="#19-ES6模块与CommonJS模块有什么异同？" class="headerlink" title="19.  ES6模块与CommonJS模块有什么异同？"></a>19.  <strong>ES6</strong>模块与<strong>CommonJS</strong>模块有什么异同？</h3><p>ES6 Module和CommonJS模块的区别： </p>
<ul>
<li>CommonJS是对模块的浅拷⻉，ES6 Module是对模块的引⽤，即ES6 Module只存只读，不能改变其值，也就是指针指向不能变，类似const；</li>
<li>import的接⼝是read-only（只读状态），不能修改其变量值。 即不能修改其变量的指针指向，但可以改变变量内部指针指向，可以对commonJS对重新赋值（改变指针指向），但是对ES6 Module赋值会编译报错。</li>
</ul>
<p>ES6 Module和CommonJS模块的共同点： </p>
<ul>
<li>CommonJS和ES6 Module都可以对引⼊的对象进⾏赋值，即对对象内部属性的值进⾏改变。</li>
</ul>
<h3 id="20-常见的DOM操作有哪些"><a href="#20-常见的DOM操作有哪些" class="headerlink" title="20. 常见的DOM操作有哪些"></a>20. 常见的DOM操作有哪些</h3><h4 id="1）DOM-节点的获取"><a href="#1）DOM-节点的获取" class="headerlink" title="1）DOM 节点的获取"></a>1）DOM 节点的获取</h4><p>DOM 节点的获取的API及使用：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">getElementById <span class="hljs-regexp">//</span> 按照 id 查询<br>getElementsByTagName <span class="hljs-regexp">//</span> 按照标签名查询<br>getElementsByClassName <span class="hljs-regexp">//</span> 按照类名查询<br>querySelectorAll <span class="hljs-regexp">//</span> 按照 css 选择器查询<br><br><span class="hljs-regexp">//</span> 按照 id 查询<br>var imooc = document.getElementById(<span class="hljs-string">&#x27;imooc&#x27;</span>) <span class="hljs-regexp">//</span> 查询到 id 为 imooc 的元素<br><span class="hljs-regexp">//</span> 按照标签名查询<br>var pList = document.getElementsByTagName(<span class="hljs-string">&#x27;p&#x27;</span>)  <span class="hljs-regexp">//</span> 查询到标签为 p 的集合<br>console.log(divList.length)<br>console.log(divList[<span class="hljs-number">0</span>])<br><span class="hljs-regexp">//</span> 按照类名查询<br>var moocList = document.getElementsByClassName(<span class="hljs-string">&#x27;mooc&#x27;</span>) <span class="hljs-regexp">//</span> 查询到类名为 mooc 的集合<br><span class="hljs-regexp">//</span> 按照 css 选择器查询<br>var pList = document.querySelectorAll(<span class="hljs-string">&#x27;.mooc&#x27;</span>) <span class="hljs-regexp">//</span> 查询到类名为 mooc 的集合<br></code></pre></td></tr></table></figure>

<h4 id="2）DOM-节点的创建"><a href="#2）DOM-节点的创建" class="headerlink" title="2）DOM 节点的创建"></a>2）DOM 节点的创建</h4><p><strong>创建一个新节点，并把它添加到指定节点的后面。</strong>已知的 HTML 结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>要求添加一个有内容的 span 节点到 id 为 title 的节点后面，做法就是：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 首先获取父节点</span><br><span class="hljs-selector-tag">var</span> container = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>)<br><span class="hljs-comment">// 创建新节点</span><br><span class="hljs-selector-tag">var</span> targetSpan = document<span class="hljs-selector-class">.createElement</span>(<span class="hljs-string">&#x27;span&#x27;</span>)<br><span class="hljs-comment">// 设置 span 节点的内容</span><br>targetSpan<span class="hljs-selector-class">.innerHTML</span> = <span class="hljs-string">&#x27;hello world&#x27;</span><br><span class="hljs-comment">// 把新创建的元素塞进父节点里去</span><br>container<span class="hljs-selector-class">.appendChild</span>(targetSpan)<br></code></pre></td></tr></table></figure>

<h4 id="3）DOM-节点的删除"><a href="#3）DOM-节点的删除" class="headerlink" title="3）DOM 节点的删除"></a>3）DOM 节点的删除</h4><p><strong>删除指定的 DOM 节点，</strong>已知的 HTML 结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>需要删除 id 为 title 的元素，做法是：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 获取目标元素的父元素</span><br><span class="hljs-selector-tag">var</span> container = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>)<br><span class="hljs-comment">// 获取目标元素</span><br><span class="hljs-selector-tag">var</span> targetNode = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;title&#x27;</span>)<br><span class="hljs-comment">// 删除目标元素</span><br>container<span class="hljs-selector-class">.removeChild</span>(targetNode)<br></code></pre></td></tr></table></figure>

<p>或者通过子节点数组来完成删除：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 获取目标元素的父元素</span><br><span class="hljs-selector-tag">var</span> container = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;container&#x27;</span>)<br><span class="hljs-comment">// 获取目标元素</span><br><span class="hljs-selector-tag">var</span> targetNode = container<span class="hljs-selector-class">.childNodes</span><span class="hljs-selector-attr">[1]</span><br><span class="hljs-comment">// 删除目标元素</span><br>container<span class="hljs-selector-class">.removeChild</span>(targetNode)<br></code></pre></td></tr></table></figure>

<h4 id="4）修改-DOM-元素"><a href="#4）修改-DOM-元素" class="headerlink" title="4）修改 DOM 元素"></a>4）修改 DOM 元素</h4><p>修改 DOM 元素这个动作可以分很多维度，比如说移动 DOM 元素的位置，修改 DOM 元素的属性等。</p>
<p><strong>将指定的两个 DOM 元素交换位置，</strong>已知的 HTML 结构如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">html</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">head</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">title</span>&gt;</span>DEMO<span class="hljs-tag">&lt;/<span class="hljs-name">title</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">head</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">body</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span> <br>      <span class="hljs-tag">&lt;<span class="hljs-name">h1</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;title&quot;</span>&gt;</span>我是标题<span class="hljs-tag">&lt;/<span class="hljs-name">h1</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">p</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;content&quot;</span>&gt;</span>我是内容<span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span>   <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">body</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">html</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>现在需要调换 title 和 content 的位置，可以考虑 insertBefore 或者 appendChild：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-comment">// 获取父元素</span><br><span class="hljs-keyword">var</span> container = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;container&#x27;</span>)   <br> <br><span class="hljs-comment">// 获取两个需要被交换的元素</span><br><span class="hljs-keyword">var</span> title = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;title&#x27;</span>)<br><span class="hljs-keyword">var</span> content = <span class="hljs-built_in">document</span>.getElementById(<span class="hljs-string">&#x27;content&#x27;</span>)<br><span class="hljs-comment">// 交换两个元素，把 content 置于 title 前面</span><br>container.insertBefore(content, title)<br></code></pre></td></tr></table></figure>

<h3 id="21-use-strict是什么意思-使用它区别是什么？"><a href="#21-use-strict是什么意思-使用它区别是什么？" class="headerlink" title="21. use strict是什么意思 ? 使用它区别是什么？"></a>21. use strict是什么意思 ? 使用它区别是什么？</h3><p>use strict 是一种 ECMAscript5 添加的（严格模式）运行模式，这种模式使得 Javascript 在更严格的条件下运行。设立严格模式的目的如下：</p>
<ul>
<li>消除 Javascript 语法的不合理、不严谨之处，减少怪异行为;</li>
<li>消除代码运行的不安全之处，保证代码运行的安全；</li>
<li>提高编译器效率，增加运行速度；</li>
<li>为未来新版本的 Javascript 做好铺垫。</li>
</ul>
<p>区别：</p>
<ul>
<li>禁止使用 with 语句。</li>
<li>禁止 this 关键字指向全局对象。</li>
<li>对象不能有重名的属性。</li>
</ul>
<h3 id="22-如何判断一个对象是否属于某个类？"><a href="#22-如何判断一个对象是否属于某个类？" class="headerlink" title="22. 如何判断一个对象是否属于某个类？"></a>22. 如何判断一个对象是否属于某个类？</h3><ul>
<li>第一种方式，使用 instanceof 运算符来判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</li>
<li>第二种方式，通过对象的 constructor 属性来判断，对象的 constructor 属性指向该对象的构造函数，但是这种方式不是很安全，因为 constructor 属性可以被改写。</li>
<li>第三种方式，如果需要判断的是某个内置的引用类型的话，可以使用 Object.prototype.toString() 方法来打印对象的[[Class]] 属性来进行判断。</li>
</ul>
<h3 id="23-强类型语言和弱类型语言的区别"><a href="#23-强类型语言和弱类型语言的区别" class="headerlink" title="23. 强类型语言和弱类型语言的区别"></a>23. 强类型语言和弱类型语言的区别</h3><ul>
<li><strong>强类型语言</strong>：强类型语言也称为强类型定义语言，是一种总是强制类型定义的语言，要求变量的使用要严格符合定义，所有变量都必须先定义后使用。Java和C++等语言都是强制类型定义的，也就是说，一旦一个变量被指定了某个数据类型，如果不经过强制转换，那么它就永远是这个数据类型了。例如你有一个整数，如果不显式地进行转换，你不能将其视为一个字符串。</li>
<li><strong>弱类型语言</strong>：弱类型语言也称为弱类型定义语言，与强类型定义相反。JavaScript语言就属于弱类型语言。简单理解就是一种变量类型可以被忽略的语言。比如JavaScript是弱类型定义的，在JavaScript中就可以将字符串’12’和整数3进行连接得到字符串’123’，在相加的时候会进行强制类型转换。</li>
</ul>
<p>两者对比：强类型语言在速度上可能略逊色于弱类型语言，但是强类型语言带来的严谨性可以有效地帮助避免许多错误。</p>
<h3 id="24-解释性语言和编译型语言的区别"><a href="#24-解释性语言和编译型语言的区别" class="headerlink" title="24. 解释性语言和编译型语言的区别"></a>24. 解释性语言和编译型语言的区别</h3><p>（1）解释型语言</p>
<p>使用专门的解释器对源程序逐行解释成特定平台的机器码并立即执行。是代码在执行时才被解释器一行行动态翻译和执行，而不是在执行之前就完成翻译。解释型语言不需要事先编译，其直接将源代码解释成机器码并立即执行，所以只要某一平台提供了相应的解释器即可运行该程序。其特点总结如下</p>
<ul>
<li>解释型语言每次运行都需要将源代码解释称机器码并执行，效率较低；</li>
<li>只要平台提供相应的解释器，就可以运行源代码，所以可以方便源程序移植；</li>
<li>JavaScript、Python等属于解释型语言。</li>
</ul>
<p>（2）编译型语言</p>
<p>使用专门的编译器，针对特定的平台，将高级语言源代码一次性的编译成可被该平台硬件执行的机器码，并包装成该平台所能识别的可执行性程序的格式。在编译型语言写的程序执行之前，需要一个专门的编译过程，把源代码编译成机器语言的文件，如exe格式的文件，以后要再运行时，直接使用编译结果即可，如直接运行exe文件。因为只需编译一次，以后运行时不需要编译，所以编译型语言执行效率高。其特点总结如下：</p>
<ul>
<li>一次性的编译成平台相关的机器语言文件，运行时脱离开发环境，运行效率高；</li>
<li>与特定平台相关，一般无法移植到其他平台；</li>
<li>C、C++等属于编译型语言。</li>
</ul>
<p><strong>两者主要区别在于：</strong>前者源程序编译后即可在该平台运行，后者是在运行期间才编译。所以前者运行速度快，后者跨平台性好。</p>
<h3 id="25-for…in和for…of的区别"><a href="#25-for…in和for…of的区别" class="headerlink" title="25. for…in和for…of的区别"></a>25. for…in和for…of的区别</h3><p>for…of 是ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，和ES3中的for…in的区别如下</p>
<ul>
<li>for…of 遍历获取的是对象的键值，for…in 获取的是对象的键名；</li>
<li>for… in 会遍历对象的整个原型链，性能非常差不推荐使用，而 for … of 只遍历当前对象不会遍历原型链；</li>
<li>对于数组的遍历，for…in 会返回数组中所有可枚举的属性(包括原型链上可枚举的属性)，for…of 只返回数组的下标对应的属性值；</li>
</ul>
<p><strong>总结：</strong>for…in 循环主要是为了遍历对象而生，不适用于遍历数组；for…of 循环可以用来遍历数组、类数组对象，字符串、Set、Map 以及 Generator 对象。</p>
<h3 id="26-如何使用for…of遍历对象"><a href="#26-如何使用for…of遍历对象" class="headerlink" title="26. 如何使用for…of遍历对象"></a>26. 如何使用for…of遍历对象</h3><p>for…of是作为ES6新增的遍历方式，允许遍历一个含有iterator接口的数据结构（数组、对象等）并且返回各项的值，普通的对象用for..of遍历是会报错的。</p>
<p>如果需要遍历的对象是类数组对象，用Array.from转成数组即可。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-number">0</span>:<span class="hljs-string">&#x27;one&#x27;</span>,<br>    <span class="hljs-number">1</span>:<span class="hljs-string">&#x27;two&#x27;</span>,<br>    <span class="hljs-attr">length</span>: <span class="hljs-number">2</span><br>&#125;;<br>obj = <span class="hljs-built_in">Array</span>.from(obj);<br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k of obj)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(k)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果不是类数组对象，就给对象添加一个[Symbol.iterator]属性，并指向一个迭代器即可。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//方法一：</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>:<span class="hljs-number">3</span><br>&#125;;<br><br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(<span class="hljs-variable language_">this</span>);<br>    <span class="hljs-keyword">var</span> count = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> &#123;<br>        <span class="hljs-title function_">next</span>(<span class="hljs-params"></span>)&#123;<br>            <span class="hljs-keyword">if</span>(count&lt;keys.<span class="hljs-property">length</span>)&#123;<br>                <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>: obj[keys[count++]],<span class="hljs-attr">done</span>:<span class="hljs-literal">false</span>&#125;;<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                <span class="hljs-keyword">return</span> &#123;<span class="hljs-attr">value</span>:<span class="hljs-literal">undefined</span>,<span class="hljs-attr">done</span>:<span class="hljs-literal">true</span>&#125;;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k);<br>&#125;<br><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">a</span>:<span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>:<span class="hljs-number">2</span>,<br>    <span class="hljs-attr">c</span>:<span class="hljs-number">3</span><br>&#125;;<br>obj[<span class="hljs-title class_">Symbol</span>.<span class="hljs-property">iterator</span>] = <span class="hljs-keyword">function</span>*()&#123;<br>    <span class="hljs-keyword">var</span> keys = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">keys</span>(obj);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> k <span class="hljs-keyword">of</span> keys)&#123;<br>        <span class="hljs-keyword">yield</span> [k,obj[k]]<br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> [k,v] <span class="hljs-keyword">of</span> obj)&#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(k,v);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="27-ajax、axios、fetch的区别"><a href="#27-ajax、axios、fetch的区别" class="headerlink" title="27. ajax、axios、fetch的区别"></a>27. ajax、axios、fetch的区别</h3><p><strong>（1）AJAX</strong></p>
<p>Ajax 即“AsynchronousJavascriptAndXML”（异步 JavaScript 和 XML），是指一种创建交互式<a href="https://link.zhihu.com/?target=https://baike.baidu.com/item/%E7%BD%91%E9%A1%B5">网页</a>应用的网页开发技术。它是一种在无需重新加载整个网页的情况下，能够更新部分网页的技术。通过在后台与服务器进行少量数据交换，Ajax 可以使网页实现异步更新。这意味着可以在不重新加载整个网页的情况下，对网页的某部分进行更新。传统的网页（不使用 Ajax）如果需要更新内容，必须重载整个网页页面。其缺点如下：</p>
<ul>
<li>本身是针对MVC编程，不符合前端MVVM的浪潮</li>
<li>基于原生XHR开发，XHR本身的架构不清晰</li>
<li>不符合关注分离（Separation of Concerns）的原则</li>
<li>配置和调用方式非常混乱，而且基于事件的异步模型不友好。</li>
</ul>
<p><strong>（2）Fetch</strong></p>
<p>fetch号称是AJAX的替代品，是在ES6出现的，使用了ES6中的promise对象。Fetch是基于promise设计的。Fetch的代码结构比起ajax简单多。<strong>fetch不是ajax的进一步封装，而是原生js，没有使用XMLHttpRequest对象</strong>。</p>
<p>fetch的优点：</p>
<ul>
<li>语法简洁，更加语义化</li>
<li>基于标准 Promise 实现，支持 async&#x2F;await</li>
<li>更加底层，提供的API丰富（request, response）</li>
<li>脱离了XHR，是ES规范里新的实现方式</li>
</ul>
<p>fetch的缺点：</p>
<ul>
<li>fetch只对网络请求报错，对400，500都当做成功的请求，服务器返回 400，500 错误码时并不会 reject，只有网络错误这些导致请求不能完成时，fetch 才会被 reject。</li>
<li>fetch默认不会带cookie，需要添加配置项： fetch(url, {credentials: ‘include’})</li>
<li>fetch不支持abort，不支持超时控制，使用setTimeout及Promise.reject的实现的超时控制并不能阻止请求过程继续在后台运行，造成了流量的浪费</li>
<li>fetch没有办法原生监测请求的进度，而XHR可以</li>
</ul>
<p><strong>（3）Axios</strong></p>
<p>Axios 是一种基于Promise封装的HTTP客户端，其特点如下：</p>
<ul>
<li>浏览器端发起XMLHttpRequests请求</li>
<li>node端发起http请求</li>
<li>支持Promise API</li>
<li>监听请求和返回</li>
<li>对请求和返回进行转化</li>
<li>取消请求</li>
<li>自动转换json数据</li>
<li>客户端支持抵御XSRF攻击</li>
</ul>
<h3 id="28-数组的遍历方法有哪些"><a href="#28-数组的遍历方法有哪些" class="headerlink" title="28. 数组的遍历方法有哪些"></a>28. 数组的遍历方法有哪些</h3><table>
<thead>
<tr>
<th><strong>方法</strong></th>
<th><strong>是否改变原数组</strong></th>
<th><strong>特点</strong></th>
</tr>
</thead>
<tbody><tr>
<td>forEach()</td>
<td>否</td>
<td>数组方法，不改变原数组，没有返回值</td>
</tr>
<tr>
<td>map()</td>
<td>否</td>
<td>数组方法，不改变原数组，有返回值，可链式调用</td>
</tr>
<tr>
<td>filter()</td>
<td>否</td>
<td>数组方法，过滤数组，返回包含符合条件的元素的数组，可链式调用</td>
</tr>
<tr>
<td>for…of</td>
<td>否</td>
<td>for…of遍历具有Iterator迭代器的对象的属性，返回的是数组的元素、对象的属性值，不能遍历普通的obj对象，将异步循环变成同步循环</td>
</tr>
<tr>
<td>every() 和 some()</td>
<td>否</td>
<td>数组方法，some()只要有一个是true，便返回true；而every()只要有一个是false，便返回false.</td>
</tr>
<tr>
<td>find() 和 findIndex()</td>
<td>否</td>
<td>数组方法，find()返回的是第一个符合条件的值；findIndex()返回的是第一个返回条件的值的索引值</td>
</tr>
<tr>
<td>reduce() 和 reduceRight()</td>
<td>否</td>
<td>数组方法，reduce()对数组正序操作；reduceRight()对数组逆序操作</td>
</tr>
</tbody></table>
<p>遍历方法的详细解释：<a href="https://cuggz.blog.csdn.net/article/details/107649549">《细数JavaScript中那些遍历和循环》</a></p>
<h3 id="29-forEach和map方法有什么区别"><a href="#29-forEach和map方法有什么区别" class="headerlink" title="29. forEach和map方法有什么区别"></a>29. forEach和map方法有什么区别</h3><p>这方法都是用来遍历数组的，两者区别如下：</p>
<ul>
<li>forEach()方法会针对每一个元素执行提供的函数，对数据的操作会改变原数组，该方法没有返回值；</li>
<li>map()方法不会改变原数组的值，返回一个新数组，新数组中的值为原数组调用函数处理之后的值；</li>
</ul>
<h2 id="四、原型与原型链"><a href="#四、原型与原型链" class="headerlink" title="四、原型与原型链"></a>四、原型与原型链</h2><h3 id="1-对原型、原型链的理解"><a href="#1-对原型、原型链的理解" class="headerlink" title="1. 对原型、原型链的理解"></a>1. 对原型、原型链的理解</h3><p>在JavaScript中是使用构造函数来新建一个对象的，每一个构造函数的内部都有一个 prototype 属性，它的属性值是一个对象，这个对象包含了可以由该构造函数的所有实例共享的属性和方法。当使用构造函数新建一个对象后，在这个对象的内部将包含一个指针，这个指针指向构造函数的 prototype 属性对应的值，在 ES5 中这个指针被称为对象的原型。一般来说不应该能够获取到这个值的，但是现在浏览器中都实现了 <strong>proto</strong> 属性来访问这个属性，但是最好不要使用这个属性，因为它不是规范中规定的。ES5 中新增了一个 Object.getPrototypeOf() 方法，可以通过这个方法来获取对象的原型。</p>
<p>当访问一个对象的属性时，如果这个对象内部不存在这个属性，那么它就会去它的原型对象里找这个属性，这个原型对象又会有自己的原型，于是就这样一直找下去，也就是原型链的概念。原型链的尽头一般来说都是 Object.prototype 所以这就是新建的对象为什么能够使用 toString() 等方法的原因。</p>
<p><strong>特点：</strong>JavaScript 对象是通过引用来传递的，创建的每个新对象实体中并没有一份属于自己的原型副本。当修改原型时，与之相关的对象也会继承这一改变。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615475711487-c474af95-b5e0-4778-a90b-9484208d724d.png"  ><span class="image-caption">image</span></p>
<h3 id="2-原型修改、重写"><a href="#2-原型修改、重写" class="headerlink" title="2. 原型修改、重写"></a>2. 原型修改、重写</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Person</span>(<span class="hljs-params">name</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = name<br>&#125;<br><span class="hljs-comment">// 修改原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getName</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// 重写原型</span><br><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<p>可以看到修改原型的时候p的构造函数不是指向Person了，因为直接给Person的原型对象直接用对象赋值时，它的构造函数指向的了根构造函数Object，所以这时候<code>p.constructor === Object</code> ，而不是<code>p.constructor === Person</code>。要想成立，就要用constructor指回来：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = &#123;<br>    <span class="hljs-attr">getName</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;<br>&#125;<br><span class="hljs-keyword">var</span> p = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Person</span>(<span class="hljs-string">&#x27;hello&#x27;</span>)<br>p.<span class="hljs-property">constructor</span> = <span class="hljs-title class_">Person</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === <span class="hljs-title class_">Person</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>)        <span class="hljs-comment">// true</span><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(p.<span class="hljs-property">__proto__</span> === p.<span class="hljs-property">constructor</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>) <span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure>

<h3 id="3-原型链指向"><a href="#3-原型链指向" class="headerlink" title="3. 原型链指向"></a>3. 原型链指向</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span>.__proto__  <span class="hljs-comment">// Person.prototype</span><br>Person<span class="hljs-selector-class">.prototype</span>.__proto__  <span class="hljs-comment">// Object.prototype</span><br><span class="hljs-selector-tag">p</span>.__proto__.__proto__ <span class="hljs-comment">//Object.prototype</span><br><span class="hljs-selector-tag">p</span>.__proto__<span class="hljs-selector-class">.constructor</span><span class="hljs-selector-class">.prototype</span>.__proto__ <span class="hljs-comment">// Object.prototype</span><br>Person<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.constructor</span><span class="hljs-selector-class">.prototype</span>.__proto__ <span class="hljs-comment">// Object.prototype</span><br>p1.__proto__<span class="hljs-selector-class">.constructor</span> <span class="hljs-comment">// Person</span><br>Person<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.constructor</span>  <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure>

<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">p</span>.__proto__  <span class="hljs-comment">// Person.prototype</span><br>Person<span class="hljs-selector-class">.prototype</span>.__proto__  <span class="hljs-comment">// Object.prototype</span><br><span class="hljs-selector-tag">p</span>.__proto__.__proto__ <span class="hljs-comment">//Object.prototype</span><br><span class="hljs-selector-tag">p</span>.__proto__<span class="hljs-selector-class">.constructor</span><span class="hljs-selector-class">.prototype</span>.__proto__ <span class="hljs-comment">// Object.prototype</span><br>Person<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.constructor</span><span class="hljs-selector-class">.prototype</span>.__proto__ <span class="hljs-comment">// Object.prototype</span><br>p1.__proto__<span class="hljs-selector-class">.constructor</span> <span class="hljs-comment">// Person</span><br>Person<span class="hljs-selector-class">.prototype</span><span class="hljs-selector-class">.constructor</span>  <span class="hljs-comment">// Person</span><br></code></pre></td></tr></table></figure>

<h3 id="4-原型链的终点是什么？如何打印出原型链的终点？"><a href="#4-原型链的终点是什么？如何打印出原型链的终点？" class="headerlink" title="4. 原型链的终点是什么？如何打印出原型链的终点？"></a>4. 原型链的终点是什么？如何打印出原型链的终点？</h3><p>由于<code>Object</code>是构造函数，原型链终点是<code>Object.prototype.__proto__</code>，而<code>Object.prototype.__proto__=== null // true</code>，所以，原型链的终点是<code>null</code>。原型链上的所有原型都是对象，所有的对象最终都是由<code>Object</code>构造的，而<code>Object.prototype</code>的下一级是<code>Object.prototype.__proto__</code>。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/jpeg/1500604/1605247722640-5bcb9156-a8b4-4d7c-83d7-9ff80930e1de.jpeg"  ><span class="image-caption">image</span></p>
<h3 id="5-如何获得对象非原型链上的属性？"><a href="#5-如何获得对象非原型链上的属性？" class="headerlink" title="5. 如何获得对象非原型链上的属性？"></a>5. 如何获得对象非原型链上的属性？</h3><p>使用后<code>hasOwnProperty()</code>方法来判断属性是否属于原型链的属性：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima">function iterate(obj)&#123;<br>   <span class="hljs-built_in">var</span> res=[];<br>   <span class="hljs-keyword">for</span>(<span class="hljs-built_in">var</span> <span class="hljs-built_in">key</span> <span class="hljs-keyword">in</span> obj)&#123;<br>        <span class="hljs-keyword">if</span>(obj.hasOwnProperty(<span class="hljs-built_in">key</span>))<br>           res.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">key</span>+&#x27;: &#x27;+obj[<span class="hljs-built_in">key</span>]);<br>   &#125;<br>   <span class="hljs-built_in">return</span> res;<br>&#125; <br></code></pre></td></tr></table></figure>

<h2 id="五、执行上下文-x2F-作用域链-x2F-闭包"><a href="#五、执行上下文-x2F-作用域链-x2F-闭包" class="headerlink" title="五、执行上下文&#x2F;作用域链&#x2F;闭包"></a>五、执行上下文&#x2F;作用域链&#x2F;闭包</h2><h3 id="1-对闭包的理解"><a href="#1-对闭包的理解" class="headerlink" title="1. 对闭包的理解"></a>1. 对闭包的理解</h3><p><strong>闭包是指有权访问另一个函数作用域中变量的函数</strong>，创建闭包的最常见的方式就是在一个函数内创建另一个函数，创建的函数可以访问到当前函数的局部变量。</p>
<p>闭包有两个常用的用途；</p>
<ul>
<li>闭包的第一个用途是使我们在函数外部能够访问到函数内部的变量。通过使用闭包，可以通过在外部调用闭包函数，从而在外部访问到函数内部的变量，可以使用这种方法来创建私有变量。</li>
<li>闭包的另一个用途是使已经运行结束的函数上下文中的变量对象继续留在内存中，因为闭包函数保留了这个变量对象的引用，所以这个变量对象不会被回收。</li>
</ul>
<p>比如，函数 A 内部有一个函数 B，函数 B 可以访问到函数 A 中的变量，那么函数 B 就是闭包。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">A</span>() &#123;<br>  let <span class="hljs-selector-tag">a</span> = <span class="hljs-number">1</span><br>  window<span class="hljs-selector-class">.B</span> = function () &#123;<br>      console<span class="hljs-selector-class">.log</span>(a)<br>  &#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-title">A</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">B</span><span class="hljs-params">()</span></span> <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>在 JS 中，闭包存在的意义就是让我们可以间接访问函数内部的变量。经典面试题：循环中使用闭包解决 var 定义函数的问题</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>首先因为 <code>setTimeout</code> 是个异步函数，所以会先把循环全部执行完毕，这时候 <code>i</code> 就是 6 了，所以会输出一堆 6。解决办法有三种：</p>
<ul>
<li>第一种是使用闭包的方式</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  ;(<span class="hljs-keyword">function</span>(<span class="hljs-params">j</span>) &#123;<br>    setTimeout(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(j)<br>    &#125;, j * <span class="hljs-number">1000</span>)<br>  &#125;)(i)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在上述代码中，首先使用了立即执行函数将 <code>i</code> 传入函数内部，这个时候值就被固定在了参数 <code>j</code> 上面不会改变，当下次执行 <code>timer</code> 这个闭包的时候，就可以使用外部函数的变量 <code>j</code>，从而达到目的。</p>
<ul>
<li>第二种就是使用 <code>setTimeout</code> 的第三个参数，这个参数会被当成 <code>timer</code> 函数的参数传入。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  setTimeout(<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params">j</span>) &#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(j)<br>    &#125;,<br>    i * <span class="hljs-number">1000</span>,<br>    i<br>  )<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>第三种就是使用 <code>let</code> 定义 <code>i</code> 了来解决问题了，这个也是最为推荐的方式</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span> <span class="hljs-title function_">timer</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i)<br>  &#125;, i * <span class="hljs-number">1000</span>)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-对作用域、作用域链的理解"><a href="#2-对作用域、作用域链的理解" class="headerlink" title="2. 对作用域、作用域链的理解"></a>2. 对作用域、作用域链的理解</h3><h5 id="1）全局作用域和函数作用域"><a href="#1）全局作用域和函数作用域" class="headerlink" title="1）全局作用域和函数作用域"></a>1）全局作用域和函数作用域</h5><p>（1）全局作用域</p>
<ul>
<li>最外层函数和最外层函数外面定义的变量拥有全局作用域</li>
<li>所有未定义直接赋值的变量自动声明为全局作用域</li>
<li>所有window对象的属性拥有全局作用域</li>
<li>全局作用域有很大的弊端，过多的全局作用域变量会污染全局命名空间，容易引起命名冲突。</li>
</ul>
<p>（2）函数作用域</p>
<ul>
<li>函数作用域声明在函数内部的变零，一般只有固定的代码片段可以访问到</li>
<li>作用域是分层的，内层作用域可以访问外层作用域，反之不行</li>
</ul>
<h5 id="2）块级作用域"><a href="#2）块级作用域" class="headerlink" title="2）块级作用域"></a>2）块级作用域</h5><ul>
<li>使用ES6中新增的let和const指令可以声明块级作用域，块级作用域可以在函数中创建也可以在一个代码块中的创建（由<code>&#123; &#125;</code>包裹的代码片段）</li>
<li>let和const声明的变量不会有变量提升，也不可以重复声明</li>
<li>在循环中比较适合绑定块级作用域，这样就可以把声明的计数器变量限制在循环内部。</li>
</ul>
<p><strong>作用域链：</strong></p>
<p>在当前作用域中查找所需变量，但是该作用域没有这个变量，那这个变量就是自由变量。如果在自己作用域找不到该变量就去父级作用域查找，依次向上级作用域查找，直到访问到window对象就被终止，这一层层的关系就是作用域链。</p>
<p>作用域链的作用是<strong>保证对执行环境有权访问的所有变量和函数的有序访问，通过作用域链，可以访问到外层环境的变量和函数。</strong></p>
<p>作用域链的本质上是一个指向变量对象的指针列表。变量对象是一个包含了执行环境中所有变量和函数的对象。作用域链的前端始终都是当前执行上下文的变量对象。全局执行上下文的变量对象（也就是全局对象）始终是作用域链的最后一个对象。</p>
<p>当查找一个变量时，如果当前执行环境中没有找到，可以沿着作用域链向后查找。</p>
<h3 id="3-对执行上下文的理解"><a href="#3-对执行上下文的理解" class="headerlink" title="3. 对执行上下文的理解"></a>3. 对执行上下文的理解</h3><h5 id="1-执行上下文类型"><a href="#1-执行上下文类型" class="headerlink" title="1. 执行上下文类型"></a>1. 执行上下文类型</h5><p><strong>（1）全局执行上下文</strong></p>
<p>任何不在函数内部的都是全局执行上下文，它首先会创建一个全局的window对象，并且设置this的值等于这个全局对象，一个程序中只有一个全局执行上下文。</p>
<p><strong>（2）函数执行上下文</strong></p>
<p>当一个函数被调用时，就会为该函数创建一个新的执行上下文，函数的上下文可以有任意多个。</p>
<p><strong>（3）</strong><code>**eval**</code><strong>函数执行上下文</strong></p>
<p>执行在eval函数中的代码会有属于他自己的执行上下文，不过eval函数不常使用，不做介绍。</p>
<h5 id="2-执行上下文栈"><a href="#2-执行上下文栈" class="headerlink" title="2. 执行上下文栈"></a>2. 执行上下文栈</h5><ul>
<li>JavaScript引擎使用执行上下文栈来管理执行上下文</li>
<li>当JavaScript执行代码时，首先遇到全局代码，会创建一个全局执行上下文并且压入执行栈中，每当遇到一个函数调用，就会为该函数创建一个新的执行上下文并压入栈顶，引擎会执行位于执行上下文栈顶的函数，当函数执行完成之后，执行上下文从栈中弹出，继续执行下一个上下文。当所有的代码都执行完毕之后，从栈中弹出全局执行上下文。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let a = <span class="hljs-string">&#x27;Hello World!&#x27;</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">first</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Inside first function&#x27;</span>);<br>  <span class="hljs-built_in">second</span>();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Again inside first function&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">second</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Inside second function&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">first</span>();<br><span class="hljs-comment">//执行顺序</span><br><span class="hljs-comment">//先执行second(),在执行first()</span><br></code></pre></td></tr></table></figure>

<h5 id="3-创建执行上下文"><a href="#3-创建执行上下文" class="headerlink" title="3. 创建执行上下文"></a>3. 创建执行上下文</h5><p>创建执行上下文有两个阶段：<strong>创建阶段</strong>和<strong>执行阶段</strong></p>
<p><strong>1）创建阶段</strong></p>
<p>（1）this绑定</p>
<ul>
<li>在全局执行上下文中，this指向全局对象（window对象）</li>
<li>在函数执行上下文中，this指向取决于函数如何调用。如果它被一个引用对象调用，那么 this 会被设置成那个对象，否则 this 的值被设置为全局对象或者 undefined</li>
</ul>
<p>（2）创建词法环境组件</p>
<ul>
<li>词法环境是一种有<strong>标识符——变量映射</strong>的数据结构，标识符是指变量&#x2F;函数名，变量是对实际对象或原始数据的引用。</li>
<li>词法环境的内部有两个组件：<strong>加粗样式</strong>：环境记录器:用来储存变量个函数声明的实际位置<strong>外部环境的引用</strong>：可以访问父级作用域</li>
</ul>
<p>（3）创建变量环境组件</p>
<ul>
<li>变量环境也是一个词法环境，其环境记录器持有变量声明语句在执行上下文中创建的绑定关系。</li>
</ul>
<p><strong>2）执行阶段</strong></p>
<p>此阶段会完成对变量的分配，最后执行完代码。</p>
<p><strong>简单来说执行上下文就是指：</strong></p>
<p>在执行一点JS代码之前，需要先解析代码。解析的时候会先创建一个全局执行上下文环境，先把代码中即将执行的变量、函数声明都拿出来，变量先赋值为undefined，函数先声明好可使用。这一步执行完了，才开始正式的执行程序。</p>
<p>在一个函数执行之前，也会创建一个函数执行上下文环境，跟全局执行上下文类似，不过函数执行上下文会多出this、arguments和函数的参数。</p>
<ul>
<li>全局上下文：变量定义，函数声明</li>
<li>函数上下文：变量定义，函数声明，<code>this</code>，<code>arguments</code></li>
</ul>
<h2 id="六、this-x2F-call-x2F-apply-x2F-bind"><a href="#六、this-x2F-call-x2F-apply-x2F-bind" class="headerlink" title="六、this&#x2F;call&#x2F;apply&#x2F;bind"></a>六、this&#x2F;call&#x2F;apply&#x2F;bind</h2><h3 id="1-对this对象的理解"><a href="#1-对this对象的理解" class="headerlink" title="1. 对this对象的理解"></a>1. 对this对象的理解</h3><p>this 是执行上下文中的一个属性，它指向最后一次调用这个方法的对象。在实际开发中，this 的指向可以通过四种调用模式来判断。</p>
<ul>
<li>第一种是<strong>函数调用模式</strong>，当一个函数不是一个对象的属性时，直接作为函数来调用时，this 指向全局对象。</li>
<li>第二种是<strong>方法调用模式</strong>，如果一个函数作为一个对象的方法来调用时，this 指向这个对象。</li>
<li>第三种是<strong>构造器调用模式</strong>，如果一个函数用 new 调用时，函数执行前会新创建一个对象，this 指向这个新创建的对象。</li>
<li>第四种是 <strong>apply 、 call 和 bind 调用模式</strong>，这三个方法都可以显示的指定调用函数的 this 指向。其中 apply 方法接收两个参数：一个是 this 绑定的对象，一个是参数数组。call 方法接收的参数，第一个是 this 绑定的对象，后面的其余参数是传入函数执行的参数。也就是说，在使用 call() 方法时，传递给函数的参数必须逐个列举出来。bind 方法通过传入一个对象，返回一个 this 绑定了传入对象的新函数。这个函数的 this 指向除了使用 new 时会被改变，其他情况下都不会改变。</li>
</ul>
<p>这四种方式，使用构造器调用模式的优先级最高，然后是 apply、call 和 bind 调用模式，然后是方法调用模式，然后是函数调用模式。</p>
<h3 id="2-call-和-apply-的区别？"><a href="#2-call-和-apply-的区别？" class="headerlink" title="2. call() 和 apply() 的区别？"></a>2. call() 和 apply() 的区别？</h3><p>它们的作用一模一样，区别仅在于传入参数的形式的不同。</p>
<ul>
<li>apply 接受两个参数，第一个参数指定了函数体内 this 对象的指向，第二个参数为一个带下标的集合，这个集合可以为数组，也可以为类数组，apply 方法把这个集合中的元素作为参数传递给被调用的函数。</li>
<li>call 传入的参数数量不固定，跟 apply 相同的是，第一个参数也是代表函数体内的 this 指向，从第二个参数开始往后，每个参数被依次传入函数。</li>
</ul>
<h3 id="3-实现call、apply-及-bind-函数"><a href="#3-实现call、apply-及-bind-函数" class="headerlink" title="3. 实现call、apply 及 bind 函数"></a>3. 实现call、apply 及 bind 函数</h3><p><strong>（1）call 函数的实现步骤：</strong></p>
<ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>（2）apply 函数的实现步骤：</strong></p>
<ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p><strong>（3）bind 函数的实现步骤：</strong></p>
<ul>
<li>判断调用对象是否为函数，即使是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>    fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h2 id="七、异步编程"><a href="#七、异步编程" class="headerlink" title="七、异步编程"></a>七、异步编程</h2><h3 id="1-异步编程的实现方式？"><a href="#1-异步编程的实现方式？" class="headerlink" title="1. 异步编程的实现方式？"></a>1. 异步编程的实现方式？</h3><p>JavaScript中的异步机制可以分为以下几种：</p>
<ul>
<li><strong>回调函数</strong> 的方式，使用回调函数的方式有一个缺点是，多个回调函数嵌套的时候会造成回调函数地狱，上下两层的回调函数间的代码耦合度太高，不利于代码的可维护。</li>
<li><strong>Promise</strong> 的方式，使用 Promise 的方式可以将嵌套的回调函数作为链式调用。但是使用这种方法，有时会造成多个 then 的链式调用，可能会造成代码的语义不够明确。</li>
<li><strong>generator</strong> 的方式，它可以在函数的执行过程中，将函数的执行权转移出去，在函数外部还可以将执行权转移回来。当遇到异步函数执行的时候，将函数执行权转移出去，当异步函数执行完毕时再将执行权给转移回来。因此在 generator 内部对于异步操作的方式，可以以同步的顺序来书写。使用这种方式需要考虑的问题是何时将函数的控制权转移回来，因此需要有一个自动执行 generator 的机制，比如说 co 模块等方式来实现 generator 的自动执行。</li>
<li><strong>async 函数</strong> 的方式，async 函数是 generator 和 promise 实现的一个自动执行的语法糖，它内部自带执行器，当函数内部执行到一个 await 语句的时候，如果语句返回一个 promise 对象，那么函数将会等待 promise 对象的状态变为 resolve 后再继续向下执行。因此可以将异步逻辑，转化为同步的顺序来书写，并且这个函数可以自动执行。</li>
</ul>
<h3 id="2-setTimeout、Promise、Async-x2F-Await-的区别"><a href="#2-setTimeout、Promise、Async-x2F-Await-的区别" class="headerlink" title="2. setTimeout、Promise、Async&#x2F;Await 的区别"></a>2. setTimeout、Promise、Async&#x2F;Await 的区别</h3><h4 id="（1）setTimeout"><a href="#（1）setTimeout" class="headerlink" title="（1）setTimeout"></a>（1）setTimeout</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>) <span class="hljs-comment">//1. 打印 script start</span><br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)   <span class="hljs-comment">// 4. 打印 settimeout</span><br>&#125;)  <span class="hljs-comment">// 2. 调用 setTimeout 函数，并定义其完成后执行的回调函数</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)   <span class="hljs-comment">//3. 打印 script start</span><br><span class="hljs-comment">// 输出顺序：script start-&gt;script end-&gt;settimeout</span><br></code></pre></td></tr></table></figure>

<h4 id="（2）Promise"><a href="#（2）Promise" class="headerlink" title="（2）Promise"></a>（2）Promise</h4><p>Promise本身是<strong>同步的立即执行函数</strong>， 当在executor中执行resolve或者reject的时候, 此时是异步操作， 会先执行then&#x2F;catch等，当主栈完成后，才会去调用resolve&#x2F;reject中存放的方法执行，打印p的时候，是打印的返回结果，一个Promise实例。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br>let promise1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    resolve()<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1 end&#x27;</span>)<br>&#125;).then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>&#125;)<br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;settimeout&#x27;</span>)<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序: script start-&gt;promise1-&gt;promise1 end-&gt;script end-&gt;promise2-&gt;settimeout</span><br></code></pre></td></tr></table></figure>

<p>当JS主线程执行到Promise对象时：</p>
<ul>
<li>promise1.then() 的回调就是一个 task</li>
<li>promise1 是 resolved或rejected: 那这个 task 就会放入当前事件循环回合的 microtask queue</li>
<li>promise1 是 pending: 这个 task 就会放入 事件循环的未来的某个(可能下一个)回合的 microtask queue 中</li>
<li>setTimeout 的回调也是个 task ，它会被放入 macrotask queue 即使是 0ms 的情况</li>
</ul>
<h4 id="（3）async-x2F-await"><a href="#（3）async-x2F-await" class="headerlink" title="（3）async&#x2F;await"></a>（3）async&#x2F;await</h4><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>    await async2();<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br>async1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br><span class="hljs-comment">// 输出顺序：script start-&gt;async1 start-&gt;async2-&gt;script end-&gt;async1 end</span><br></code></pre></td></tr></table></figure>

<p>async 函数返回一个 Promise 对象，当函数执行的时候，一旦遇到 await 就会先返回，等到触发的异步操作完成，再执行函数体内后面的语句。可以理解为，是让出了线程，跳出了 async 函数体。</p>
<p>例如：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">async <span class="hljs-keyword">function</span> <span class="hljs-title">func1</span>() &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">1</span><br>&#125;<br>console.log(func1())<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604021075237-8249a8df-3a28-4bca-9f22-02923aba8618.png?x-oss-process=image/resize,w_1038"  ><span class="image-caption">img</span></p>
<p>func1的运行结果其实就是一个Promise对象。因此也可以使用then来处理后续逻辑。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">func1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);  <span class="hljs-comment">// 30</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>await的含义为等待，也就是 async 函数需要等待await后的函数执行完成并且有了返回结果（Promise对象）之后，才能继续执行下面的代码。await通过返回一个Promise对象来实现同步的效果。</p>
<h3 id="3-对Promise的理解"><a href="#3-对Promise的理解" class="headerlink" title="3. 对Promise的理解"></a>3. 对Promise的理解</h3><p>Promise是异步编程的一种解决方案，它是一个对象，可以获取异步操作的消息，他的出现大大改善了异步编程的困境，避免了地狱回调，它比传统的解决方案回调函数和事件更合理和更强大。</p>
<p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p>
<p>（1）Promise的实例有<strong>三个状态</strong>:</p>
<ul>
<li>Pending（进行中）</li>
<li>Resolved（已完成）</li>
<li>Rejected（已拒绝）</li>
</ul>
<p>当把一件事情交给promise时，它的状态就是Pending，任务完成了状态就变成了Resolved、没有完成失败了就变成了Rejected。</p>
<p>（2）Promise的实例有<strong>两个过程</strong>：</p>
<ul>
<li>pending -&gt; fulfilled : Resolved（已完成）</li>
<li>pending -&gt; rejected：Rejected（已拒绝）</li>
</ul>
<p>注意：一旦从进行状态变成为其他状态就永远不能更改状态了。</p>
<p><strong>Promise的特点：</strong></p>
<ul>
<li>对象的状态不受外界影响。promise对象代表一个异步操作，有三种状态，<code>pending</code>（进行中）、<code>fulfilled</code>（已成功）、<code>rejected</code>（已失败）。只有异步操作的结果，可以决定当前是哪一种状态，任何其他操作都无法改变这个状态，这也是promise这个名字的由来——“<strong>承诺</strong>”；</li>
<li>一旦状态改变就不会再变，任何时候都可以得到这个结果。promise对象的状态改变，只有两种可能：从<code>pending</code>变为<code>fulfilled</code>，从<code>pending</code>变为<code>rejected</code>。这时就称为<code>resolved</code>（已定型）。如果改变已经发生了，你再对promise对象添加回调函数，也会立即得到这个结果。这与事件（event）完全不同，事件的特点是：如果你错过了它，再去监听是得不到结果的。</li>
</ul>
<p><strong>Promise的缺点：</strong></p>
<ul>
<li>无法取消Promise，一旦新建它就会立即执行，无法中途取消。</li>
<li>如果不设置回调函数，Promise内部抛出的错误，不会反应到外部。</li>
<li>当处于pending状态时，无法得知目前进展到哪一个阶段（刚刚开始还是即将完成）。</li>
</ul>
<p><strong>总结：</strong></p>
<p>Promise 对象是异步编程的一种解决方案，最早由社区提出。Promise 是一个构造函数，接收一个函数作为参数，返回一个 Promise 实例。一个 Promise 实例有三种状态，分别是pending、resolved 和 rejected，分别代表了进行中、已成功和已失败。实例的状态只能由 pending 转变 resolved 或者rejected 状态，并且状态一经改变，就凝固了，无法再被改变了。</p>
<p>状态的改变是通过 resolve() 和 reject() 函数来实现的，可以在异步操作结束后调用这两个函数改变 Promise 实例的状态，它的原型上定义了一个 then 方法，使用这个 then 方法可以为两个状态的改变注册回调函数。这个回调函数属于微任务，会在本轮事件循环的末尾执行。</p>
<p><strong>注意：</strong>在构造 <code>Promise</code> 的时候，构造函数内部的代码是立即执行的</p>
<h3 id="4-Promise的基本用法"><a href="#4-Promise的基本用法" class="headerlink" title="4. Promise的基本用法"></a>4. Promise的基本用法</h3><h4 id="（1）创建Promise对象"><a href="#（1）创建Promise对象" class="headerlink" title="（1）创建Promise对象"></a>（1）创建Promise对象</h4><p>Promise对象代表一个异步操作，有三种状态：pending（进行中）、fulfilled（已成功）和rejected（已失败）。</p>
<p>Promise构造函数接受一个函数作为参数，该函数的两个参数分别是<code>resolve</code>和<code>reject</code>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>  <span class="hljs-comment">// ... some code</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-comment">/* 异步操作成功 */</span>)&#123;<br>    <span class="hljs-title function_">resolve</span>(value);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-title function_">reject</span>(error);<br>  &#125;<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>一般情况下都会使用</strong><code>**new Promise()**</code><strong>来创建promise对象，但是也可以使用</strong><code>**promise.resolve**</code><strong>和</strong> <code>**promise.reject**</code><strong>这两个方法：</strong></p>
<ul>
<li><strong>Promise.resolve</strong></li>
</ul>
<p><code>Promise.resolve(value)</code>的返回值也是一个promise对象，可以对返回值进行.then调用，代码如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.resolve(<span class="hljs-number">11</span>).then(<span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(value); <span class="hljs-comment">// 打印出11</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><code>resolve(11)</code>代码中，会让promise对象进入确定(<code>resolve</code>状态)，并将参数<code>11</code>传递给后面的<code>then</code>所指定的<code>onFulfilled</code> 函数；</p>
<p>创建promise对象可以使用<code>new Promise</code>的形式创建对象，也可以使用<code>Promise.resolve(value)</code>的形式创建promise对象；</p>
<ul>
<li><strong>Promise.reject</strong></li>
</ul>
<p><code>Promise.reject</code> 也是<code>new Promise</code>的快捷形式，也创建一个promise对象。代码如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-built_in">Promise</span>.reject(<span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(“我错了，请原谅俺！！”));<br></code></pre></td></tr></table></figure>

<p>就是下面的代码new Promise的简单形式：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>,<span class="hljs-params">reject</span>)</span>&#123;<br>   reject(<span class="hljs-keyword">new</span> <span class="hljs-constructor">Error(<span class="hljs-string">&quot;我错了，请原谅俺！！&quot;</span>)</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>下面是使用resolve方法和reject方法：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testPromise</span>(<span class="hljs-params">ready</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve,reject</span>)&#123;<br>    <span class="hljs-keyword">if</span>(ready) &#123;<br>      resolve(<span class="hljs-string">&quot;hello world&quot;</span>);<br>    &#125;<span class="hljs-keyword">else</span> &#123;<br>      reject(<span class="hljs-string">&quot;No thanks&quot;</span>);<br>    &#125;<br>  &#125;);<br>&#125;;<br><span class="hljs-comment">// 方法调用</span><br>testPromise(<span class="hljs-literal">true</span>).then(<span class="hljs-keyword">function</span>(<span class="hljs-params">msg</span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(msg);<br>&#125;,<span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(error);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>上面的代码的含义是给<code>testPromise</code>方法传递一个参数，返回一个promise对象，如果为<code>true</code>的话，那么调用promise对象中的<code>resolve()</code>方法，并且把其中的参数传递给后面的<code>then</code>第一个函数内，因此打印出 “<code>hello world</code>”, 如果为<code>false</code>的话，会调用promise对象中的<code>reject()</code>方法，则会进入<code>then</code>的第二个函数内，会打印<code>No thanks</code>；</p>
<h4 id="（2）Promise方法"><a href="#（2）Promise方法" class="headerlink" title="（2）Promise方法"></a>（2）Promise方法</h4><p>Promise有五个常用的方法：then()、catch()、all()、race()、finally。下面就来看一下这些方法。</p>
<ol>
<li><strong>then()</strong></li>
</ol>
<p>当Promise执行的内容符合成功条件时，调用<code>resolve</code>函数，失败就调用<code>reject</code>函数。Promise创建完了，那该如何调用呢？</p>
<figure class="highlight wren"><table><tr><td class="code"><pre><code class="hljs wren"><span class="hljs-variable">promise</span>.<span class="hljs-property">then</span>(<span class="hljs-title function_">function</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// success</span><br>&#125;, <span class="hljs-title function_">function</span>(<span class="hljs-params">error</span>) &#123;<br>  <span class="hljs-comment">// failure</span><br>&#125;);<br></code></pre></td></tr></table></figure>

<p><code>then</code>方法可以接受两个回调函数作为参数。第一个回调函数是Promise对象的状态变为<code>resolved</code>时调用，第二个回调函数是Promise对象的状态变为<code>rejected</code>时调用。其中第二个参数可以省略。</p>
<p><code>then</code>方法返回的是一个新的Promise实例（不是原来那个Promise实例）。因此可以采用链式写法，即<code>then</code>方法后面再调用另一个then方法。</p>
<p>当要写有顺序的异步事件时，需要串行时，可以这样写：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;first&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>        <span class="hljs-title function_">resolve</span>(res);<br>    &#125;)<br>&#125;)<br>promise.<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resovle,reject</span>)=&gt;</span>&#123;<br>        <span class="hljs-title function_">ajax</span>(<span class="hljs-string">&#x27;second&#x27;</span>).<span class="hljs-title function_">success</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>)&#123;<br>            <span class="hljs-title function_">resolve</span>(res)<br>        &#125;)<br>    &#125;)<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-function"><span class="hljs-params">res</span>=&gt;</span>&#123;<br>    <br>&#125;)<br></code></pre></td></tr></table></figure>

<p>那当要写的事件没有顺序或者关系时，还如何写呢？可以使用<code>all</code> 方法来解决。</p>
<p><strong>2. catch()</strong></p>
<p>Promise对象除了有then方法，还有一个catch方法，该方法相当于<code>then</code>方法的第二个参数，指向<code>reject</code>的回调函数。不过<code>catch</code>方法还有一个作用，就是在执行<code>resolve</code>回调函数时，如果出现错误，抛出异常，不会停止运行，而是进入<code>catch</code>方法中。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;,(err) =&gt; &#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>     &#125;<br>); <br>p.then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;resolved&#x27;</span>,data);<br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">err</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;rejected&#x27;</span>,err);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p><strong>3. all()</strong></p>
<p><code>all</code>方法可以完成并行任务， 它接收一个数组，数组的每一项都是一个<code>promise</code>对象。当数组中所有的<code>promise</code>的状态都达到<code>resolved</code>的时候，<code>all</code>方法的状态就会变成<code>resolved</code>，如果有一个状态变成了<code>rejected</code>，那么<code>all</code>方法的状态就会变成<code>rejected</code>。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">javascript<br>let promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>       resolve(<span class="hljs-number">1</span>);<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br>let promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>       resolve(<span class="hljs-number">2</span>);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br>let promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>       resolve(<span class="hljs-number">3</span>);<br>    &#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-built_in">Promise</span>.all([promise1,promise2,promise3]).<span class="hljs-keyword">then</span>(res=&gt;&#123;<br>    console.log(res);<br>    <span class="hljs-regexp">//</span>结果为：[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>] <br>&#125;)<br></code></pre></td></tr></table></figure>

<p>调用<code>all</code>方法时的结果成功的时候是回调函数的参数也是一个数组，这个数组按顺序保存着每一个promise对象<code>resolve</code>执行时的值。</p>
<p><strong>（4）race()</strong></p>
<p><code>race</code>方法和<code>all</code>一样，接受的参数是一个每项都是<code>promise</code>的数组，但是与<code>all</code>不同的是，当最先执行完的事件执行完之后，就直接返回该<code>promise</code>对象的值。如果第一个<code>promise</code>对象状态变成<code>resolved</code>，那自身的状态变成了<code>resolved</code>；反之第一个<code>promise</code>变成<code>rejected</code>，那自身状态就会变成<code>rejected</code>。</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">let promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>       reject(<span class="hljs-number">1</span>);<br>    &#125;,<span class="hljs-number">2000</span>)<br>&#125;);<br>let promise2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>       resolve(<span class="hljs-number">2</span>);<br>    &#125;,<span class="hljs-number">1000</span>)<br>&#125;);<br>let promise3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve,reject)</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>       resolve(<span class="hljs-number">3</span>);<br>    &#125;,<span class="hljs-number">3000</span>)<br>&#125;);<br><span class="hljs-built_in">Promise</span>.race([promise1,promise2,promise3]).<span class="hljs-keyword">then</span>(res=&gt;&#123;<br>    console.log(res);<br>    <span class="hljs-regexp">//</span>结果：<span class="hljs-number">2</span><br>&#125;,rej=&gt;&#123;<br>    console.log(rej)&#125;;<br>)<br></code></pre></td></tr></table></figure>

<p>那么<code>race</code>方法有什么实际作用呢？当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">Promise<span class="hljs-selector-class">.race</span>(<span class="hljs-selector-attr">[promise1,timeOutPromise(5000)]</span>)<span class="hljs-selector-class">.then</span>(res=&gt;&#123;&#125;)<br></code></pre></td></tr></table></figure>

<p><strong>5. finally()</strong></p>
<p><code>finally</code>方法用于指定不管 Promise 对象最后状态如何，都会执行的操作。该方法是 ES2018 引入标准的。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">promise<br>.then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;···&#125;)<br>.catch(<span class="hljs-function"><span class="hljs-params">error</span> =&gt;</span> &#123;···&#125;)<br>.finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;···&#125;);<br></code></pre></td></tr></table></figure>

<p>上面代码中，不管<code>promise</code>最后的状态，在执行完<code>then</code>或<code>catch</code>指定的回调函数以后，都会执行<code>finally</code>方法指定的回调函数。</p>
<p>下面是一个例子，服务器使用 Promise 处理请求，然后使用<code>finally</code>方法关掉服务器。</p>
<figure class="highlight axapta"><table><tr><td class="code"><pre><code class="hljs axapta"><span class="hljs-keyword">server</span>.listen(port)<br>  .then(function () &#123;<br>    <span class="hljs-comment">// ...</span><br>  &#125;)<br>  .<span class="hljs-keyword">finally</span>(<span class="hljs-keyword">server</span>.stop);<br></code></pre></td></tr></table></figure>

<p><code>finally</code>方法的回调函数不接受任何参数，这意味着没有办法知道，前面的 Promise 状态到底是<code>fulfilled</code>还是<code>rejected</code>。这表明，<code>finally</code>方法里面的操作，应该是与状态无关的，不依赖于 Promise 的执行结果。<code>finally</code>本质上是<code>then</code>方法的特例：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">promise<br>.<span class="hljs-keyword">finally</span>(() =&gt; &#123;<br>  <span class="hljs-comment">// 语句</span><br>&#125;);<br><span class="hljs-comment">// 等同于</span><br>promise<br>.then(<br>  result =&gt; &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;,<br>  error =&gt; &#123;<br>    <span class="hljs-comment">// 语句</span><br>    <span class="hljs-keyword">throw</span> error;<br>  &#125;<br>);<br></code></pre></td></tr></table></figure>

<p>上面代码中，如果不使用<code>finally</code>方法，同样的语句需要为成功和失败两种情况各写一次。有了<code>finally</code>方法，则只需要写一次。</p>
<h3 id="5-Promise解决了什么问题"><a href="#5-Promise解决了什么问题" class="headerlink" title="5. Promise解决了什么问题"></a>5. Promise解决了什么问题</h3><p>在工作中经常会碰到这样一个需求，比如我使用ajax发一个A请求后，成功后拿到数据，需要把数据传给B请求；那么需要如下编写代码：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> fs = require(&#x27;fs&#x27;)<br>fs.read<span class="hljs-constructor">File(&#x27;.<span class="hljs-operator">/</span><span class="hljs-params">a</span>.<span class="hljs-params">txt</span>&#x27;,&#x27;<span class="hljs-params">utf8</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">err</span>,<span class="hljs-params">data</span>)</span>&#123;<br>  fs.read<span class="hljs-constructor">File(<span class="hljs-params">data</span>,&#x27;<span class="hljs-params">utf8</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">err</span>,<span class="hljs-params">data</span>)</span>&#123;<br>    fs.read<span class="hljs-constructor">File(<span class="hljs-params">data</span>,&#x27;<span class="hljs-params">utf8</span>&#x27;,<span class="hljs-params">function</span>(<span class="hljs-params">err</span>,<span class="hljs-params">data</span>)</span>&#123;<br>      console.log(data)<br>    &#125;)<br>  &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>上面的代码有如下缺点：</p>
<ul>
<li>后一个请求需要依赖于前一个请求成功后，将数据往下传递，会导致多个ajax请求嵌套的情况，代码不够直观。</li>
<li>如果前后两个请求不需要传递参数的情况下，那么后一个请求也需要前一个请求成功后再执行下一步操作，这种情况下，那么也需要如上编写代码，导致代码不够直观。</li>
</ul>
<p><code>Promise</code>出现之后，代码变成这样：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let fs = require(<span class="hljs-string">&#x27;fs&#x27;</span>)<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">read</span>(<span class="hljs-params">url</span>)&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>    fs.readFile(url,<span class="hljs-string">&#x27;utf8&#x27;</span>,<span class="hljs-keyword">function</span>(<span class="hljs-params">error,data</span>)&#123;<br>      error &amp;&amp; reject(error)<br>      resolve(data)<br>    &#125;)<br>  &#125;)<br>&#125;<br>read(<span class="hljs-string">&#x27;./a.txt&#x27;</span>).then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> read(data) <br>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-keyword">return</span> read(data)  <br>&#125;).then(<span class="hljs-function"><span class="hljs-params">data</span>=&gt;</span>&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这样代码看起了就简洁了很多，解决了地狱回调的问题。</p>
<h3 id="6-Promise-all和Promise-race的区别的使用场景"><a href="#6-Promise-all和Promise-race的区别的使用场景" class="headerlink" title="6. Promise.all和Promise.race的区别的使用场景"></a>6. Promise.all和Promise.race的区别的使用场景</h3><p><strong>（1）****Promise.all</strong></p>
<p><code>Promise.all</code>可以将多个<code>Promise</code>实例包装成一个新的Promise实例。同时，成功和失败的返回值是不同的，成功的时候返回的是<strong>一个结果数组</strong>，而失败的时候则返回<strong>最先被reject失败状态的值</strong>。</p>
<p>Promise.all中传入的是数组，返回的也是是数组，并且会将进行映射，传入的promise对象返回的值是按照顺序在数组中排列的，但是注意的是他们执行的顺序并不是按照顺序的，除非可迭代对象为空。</p>
<p>需要注意，Promise.all获得的成功结果的数组里面的数据顺序和Promise.all接收到的数组顺序是一致的，这样当遇到发送多个请求并根据请求顺序获取和使用数据的场景，就可以使用Promise.all来解决。</p>
<p><strong>（2）Promise.race</strong></p>
<p>顾名思义，Promse.race就是赛跑的意思，意思就是说，Promise.race([p1, p2, p3])里面哪个结果获得的快，就返回那个结果，不管结果本身是成功状态还是失败状态。当要做一件事，超过多长时间就不做了，可以用这个方法来解决：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">Promise<span class="hljs-selector-class">.race</span>(<span class="hljs-selector-attr">[promise1,timeOutPromise(5000)]</span>)<span class="hljs-selector-class">.then</span>(res=&gt;&#123;&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="7-对async-x2F-await-的理解"><a href="#7-对async-x2F-await-的理解" class="headerlink" title="7.  对async&#x2F;await 的理解"></a>7.  对async&#x2F;await 的理解</h3><p>async&#x2F;await其实是<code>Generator</code> 的语法糖，它能实现的效果都能用then链来实现，它是为优化then链而开发出来的。从字面上来看，async是“异步”的简写，await则为等待，所以很好理解async 用于申明一个 function 是异步的，而 await 用于等待一个异步方法执行完成。当然语法上强制规定await只能出现在asnyc函数中，先来看看async函数返回了什么： </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span>;<br>&#125;<br><span class="hljs-keyword">let</span> result = <span class="hljs-title function_">testAsy</span>(); <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(result)<br></code></pre></td></tr></table></figure>

<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1605099411873-d2eac25a-5d8c-4586-bc36-769bce79010e.png"  ><span class="image-caption">img</span></p>
<p>所以，async 函数返回的是一个 Promise 对象。async 函数（包含函数语句、函数表达式、Lambda表达式）会返回一个 Promise 对象，如果在函数中 <code>return</code> 一个直接量，async 会把这个直接量通过 <code>Promise.resolve()</code> 封装成 Promise 对象。</p>
<p>async 函数返回的是一个 Promise 对象，所以在最外层不能用 await 获取其返回值的情况下，当然应该用原来的方式：<code>then()</code> 链来处理这个 Promise 对象，就像这样：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;hello world&#x27;</span><br>&#125;<br>let result = testAsy() <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result)<br>result.then(<span class="hljs-function"><span class="hljs-params">v</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(v)   <span class="hljs-comment">// hello world</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>那如果 async 函数没有返回值，又该如何？很容易想到，它会返回 <code>Promise.resolve(undefined)</code>。</p>
<p>联想一下 Promise 的特点——无等待，所以在没有 <code>await</code> 的情况下执行 async 函数，它会立即执行，返回一个 Promise 对象，并且，绝不会阻塞后面的语句。这和普通返回 Promise 对象的函数并无二致。</p>
<p><strong>注意：</strong><code>Promise.resolve(x)</code> 可以看作是 <code>new Promise(resolve =&gt; resolve(x))</code> 的简写，可以用于快速封装字面量对象或其他对象，将其封装成 Promise 实例。</p>
<h3 id="8-await-到底在等啥？"><a href="#8-await-到底在等啥？" class="headerlink" title="8. await 到底在等啥？"></a>8. await 到底在等啥？</h3><p><strong>await 在等待什么呢？</strong>一般来说，都认为 await 是在等待一个 async 函数完成。不过按语法说明，await 等待的是一个表达式，这个表达式的计算结果是 Promise 对象或者其它值（换句话说，就是没有特殊限定）。</p>
<p>因为 async 函数返回一个 Promise 对象，所以 await 可以用于等待一个 async 函数的返回值——这也可以说是 await 在等 async 函数，但要清楚，它等的实际是一个返回值。注意到 await 不仅仅用于等 Promise 对象，它可以等任意表达式的结果，所以，await 后面实际是可以接普通函数调用或者直接量的。所以下面这个示例完全可以正确运行：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getSomething</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;something&quot;</span>;<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsync</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">resolve</span>(<span class="hljs-string">&quot;hello async&quot;</span>);<br>&#125;<br><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">test</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">const</span> v1 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">getSomething</span>();<br>    <span class="hljs-keyword">const</span> v2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">testAsync</span>();<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(v1, v2);<br>&#125;<br><span class="hljs-title function_">test</span>();<br></code></pre></td></tr></table></figure>

<p>await 表达式的运算结果取决于它等的是什么。</p>
<ul>
<li>如果它等到的不是一个 Promise 对象，那 await 表达式的运算结果就是它等到的东西。</li>
<li>如果它等到的是一个 Promise 对象，await 就忙起来了，它会阻塞后面的代码，等着 Promise 对象 resolve，然后得到 resolve 的值，作为 await 表达式的运算结果。</li>
</ul>
<p>来看一个例子：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">testAsy</span>(<span class="hljs-params">x</span>)&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span>=&gt;</span>&#123;setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>       resolve(x);<br>     &#125;, <span class="hljs-number">3000</span>)<br>    &#125;<br>   )<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">testAwt</span>(<span class="hljs-params"></span>)&#123;    <br>  let result =  await testAsy(<span class="hljs-string">&#x27;hello world&#x27;</span>);<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(result);    <span class="hljs-comment">// 3秒钟之后出现hello world</span><br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;cuger&#x27;</span>)   <span class="hljs-comment">// 3秒钟之后出现cug</span><br>&#125;<br>testAwt();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;cug&#x27;</span>)  <span class="hljs-comment">//立即输出cug</span><br></code></pre></td></tr></table></figure>

<p>这就是 await 必须用在 async 函数中的原因。async 函数调用不会造成阻塞，它内部所有的阻塞都被封装在一个 Promise 对象中异步执行。await暂停当前async的执行，所以’cug’’最先输出，hello world’和‘cuger’是3秒钟后同时出现的。</p>
<h3 id="9-async-x2F-await的优势"><a href="#9-async-x2F-await的优势" class="headerlink" title="9.  async&#x2F;await的优势"></a>9.  async&#x2F;await的优势</h3><p>单一的 Promise 链并不能发现 async&#x2F;await 的优势，但是，如果需要处理由多个 Promise 组成的 then 链的时候，优势就能体现出来了（很有意思，Promise 通过 then 链来解决多层回调的问题，现在又用 async&#x2F;await 来进一步优化它）。</p>
<p>假设一个业务，分多个步骤完成，每个步骤都是异步的，而且依赖于上一个步骤的结果。仍然用 <code>setTimeout</code> 来模拟异步操作：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 传入参数 n，表示这个函数执行的时间（毫秒）</span><br><span class="hljs-comment"> * 执行的结果是 n + 200，这个值将用于下一步骤</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">takeLongTime</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> resolve(n + <span class="hljs-number">200</span>), n);<br>    &#125;);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step1</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`step1 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step2</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`step2 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">step3</span>(<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`step3 with <span class="hljs-subst">$&#123;n&#125;</span>`</span>);<br>    <span class="hljs-keyword">return</span> takeLongTime(n);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>现在用 Promise 方式来实现这三个步骤的处理：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.time(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    const time1 = <span class="hljs-number">300</span>;<br>    step1(time1)<br>        .then(<span class="hljs-function"><span class="hljs-params">time2</span> =&gt;</span> step2(time2))<br>        .then(<span class="hljs-function"><span class="hljs-params">time3</span> =&gt;</span> step3(time3))<br>        .then(<span class="hljs-function"><span class="hljs-params">result</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>            <span class="hljs-built_in">console</span>.timeEnd(<span class="hljs-string">&quot;doIt&quot;</span>);<br>        &#125;);<br>&#125;<br>doIt();<br><span class="hljs-comment">// c:\var\test&gt;node --harmony_async_await .</span><br><span class="hljs-comment">// step1 with 300</span><br><span class="hljs-comment">// step2 with 500</span><br><span class="hljs-comment">// step3 with 700</span><br><span class="hljs-comment">// result is 900</span><br><span class="hljs-comment">// doIt: 1507.251ms</span><br></code></pre></td></tr></table></figure>

<p>如果用 async&#x2F;await 来实现呢，会是这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">doIt</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">time</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>    <span class="hljs-keyword">const</span> time1 = <span class="hljs-number">300</span>;<br>    <span class="hljs-keyword">const</span> time2 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step1</span>(time1);<br>    <span class="hljs-keyword">const</span> time3 = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step2</span>(time2);<br>    <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> <span class="hljs-title function_">step3</span>(time3);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">`result is <span class="hljs-subst">$&#123;result&#125;</span>`</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">timeEnd</span>(<span class="hljs-string">&quot;doIt&quot;</span>);<br>&#125;<br><span class="hljs-title function_">doIt</span>();<br></code></pre></td></tr></table></figure>

<p>结果和之前的 Promise 实现是一样的，但是这个代码看起来是不是清晰得多，几乎跟同步代码一样</p>
<h3 id="10-async-x2F-await对比Promise的优势"><a href="#10-async-x2F-await对比Promise的优势" class="headerlink" title="10. async&#x2F;await对比Promise的优势"></a>10. async&#x2F;await对比Promise的优势</h3><ul>
<li>代码读起来更加同步，Promise虽然摆脱了回调地狱，但是then的链式调⽤也会带来额外的阅读负担 </li>
<li>Promise传递中间值⾮常麻烦，⽽async&#x2F;await⼏乎是同步的写法，⾮常优雅 </li>
<li>错误处理友好，async&#x2F;await可以⽤成熟的try&#x2F;catch，Promise的错误捕获⾮常冗余 </li>
<li>调试友好，Promise的调试很差，由于没有代码块，你不能在⼀个返回表达式的箭头函数中设置断点，如果你在⼀个.then代码块中使⽤调试器的步进(step-over)功能，调试器并不会进⼊后续的.then代码块，因为调试器只能跟踪同步代码的每⼀步。</li>
</ul>
<h3 id="11-async-x2F-await-如何捕获异常"><a href="#11-async-x2F-await-如何捕获异常" class="headerlink" title="11. async&#x2F;await 如何捕获异常"></a>11. async&#x2F;await 如何捕获异常</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">async</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">try</span>&#123;<br>        <span class="hljs-keyword">let</span> a = <span class="hljs-keyword">await</span> <span class="hljs-title class_">Promise</span>.<span class="hljs-title function_">reject</span>(<span class="hljs-string">&#x27;error&#x27;</span>)<br>    &#125;<span class="hljs-keyword">catch</span>(error)&#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(error)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="12-并发与并行的区别？"><a href="#12-并发与并行的区别？" class="headerlink" title="12. 并发与并行的区别？"></a>12. 并发与并行的区别？</h3><ul>
<li>并发是宏观概念，我分别有任务 A 和任务 B，在一段时间内通过任务间的切换完成了这两个任务，这种情况就可以称之为并发。</li>
<li>并行是微观概念，假设 CPU 中存在两个核心，那么我就可以同时完成任务 A、B。同时完成多个任务的情况就可以称之为并行。</li>
</ul>
<h3 id="13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"><a href="#13-什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？" class="headerlink" title="13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？"></a>13. 什么是回调函数？回调函数有什么缺点？如何解决回调地狱问题？</h3><p>以下代码就是一个回调函数的例子：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">ajax</span><span class="hljs-params">(url, ()</span></span> =&gt; &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>回调函数有一个致命的弱点，就是容易写出回调地狱（Callback hell）。假设多个请求存在依赖性，可能会有如下代码：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">ajax(url, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-regexp">//</span> 处理逻辑<br>    ajax(url1, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-regexp">//</span> 处理逻辑<br>        ajax(url2, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-regexp">//</span> 处理逻辑<br>        &#125;)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>以上代码看起来不利于阅读和维护，当然，也可以把函数分开来写：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> first<span class="hljs-constructor">Ajax()</span> &#123;<br>  ajax(url1,<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>    second<span class="hljs-constructor">Ajax()</span><br>  &#125;)<br>&#125;<br><span class="hljs-keyword">function</span> second<span class="hljs-constructor">Ajax()</span> &#123;<br>  ajax(url2,<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 处理逻辑</span><br>  &#125;)<br>&#125;<br>ajax(url,<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-comment">// 处理逻辑</span><br>  first<span class="hljs-constructor">Ajax()</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>以上的代码虽然看上去利于阅读了，但是还是没有解决根本问题。回调地狱的根本问题就是：</p>
<ol>
<li>嵌套函数存在耦合性，一旦有所改动，就会牵一发而动全身</li>
<li>嵌套函数一多，就很难处理错误</li>
</ol>
<p>当然，回调函数还存在着别的几个缺点，比如不能使用 <code>try catch</code> 捕获错误，不能直接 <code>return</code>。</p>
<h3 id="14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？"><a href="#14-setTimeout、setInterval、requestAnimationFrame-各有什么特点？" class="headerlink" title="14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？"></a>14. setTimeout、setInterval、requestAnimationFrame 各有什么特点？</h3><p>异步编程当然少不了定时器了，常见的定时器函数有 <code>setTimeout</code>、<code>setInterval</code>、<code>requestAnimationFrame</code>。最常用的是<code>setTimeout</code>，很多人认为 <code>setTimeout</code> 是延时多久，那就应该是多久后执行。</p>
<p>其实这个观点是错误的，因为 JS 是单线程执行的，如果前面的代码影响了性能，就会导致 <code>setTimeout</code> 不会按期执行。当然了，可以通过代码去修正 <code>setTimeout</code>，从而使定时器相对准确：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">let</span> period = <span class="hljs-number">60</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span><span class="hljs-operator"> * </span><span class="hljs-number">60</span><span class="hljs-operator"> * </span><span class="hljs-number">2</span><br><span class="hljs-keyword">let</span> startTime = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span><br><span class="hljs-keyword">let</span> count = <span class="hljs-number">0</span><br><span class="hljs-keyword">let</span> <span class="hljs-keyword">end</span> = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span> + period<br><span class="hljs-keyword">let</span> interval = <span class="hljs-number">1000</span><br><span class="hljs-keyword">let</span> currentInterval = interval<br><span class="hljs-keyword">function</span> loop<span class="hljs-literal">()</span> &#123;<br>  count++<br>  <span class="hljs-comment">// 代码执行所消耗的时间</span><br>  <span class="hljs-keyword">let</span> offset = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span> - (startTime + count<span class="hljs-operator"> * </span>interval);<br>  <span class="hljs-keyword">let</span> diff = <span class="hljs-keyword">end</span> - <span class="hljs-keyword">new</span> <span class="hljs-constructor">Date()</span>.get<span class="hljs-constructor">Time()</span><br>  <span class="hljs-keyword">let</span> h = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor(diff<span class="hljs-operator"> / </span>(<span class="hljs-number">60</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span><span class="hljs-operator"> * </span><span class="hljs-number">60</span>))<br>  <span class="hljs-keyword">let</span> hdiff = diff % (<span class="hljs-number">60</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span><span class="hljs-operator"> * </span><span class="hljs-number">60</span>)<br>  <span class="hljs-keyword">let</span> m = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor(hdiff<span class="hljs-operator"> / </span>(<span class="hljs-number">60</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">let</span> mdiff = hdiff % (<span class="hljs-number">60</span><span class="hljs-operator"> * </span><span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">let</span> s = mdiff<span class="hljs-operator"> / </span>(<span class="hljs-number">1000</span>)<br>  <span class="hljs-keyword">let</span> sCeil = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>ceil(s)<br>  <span class="hljs-keyword">let</span> sFloor = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Math</span>.</span></span>floor(s)<br>  <span class="hljs-comment">// 得到下一次循环所消耗的时间</span><br>  currentInterval = interval - offset <br>  console.log(&#x27;时：&#x27;+h, &#x27;分：&#x27;+m, &#x27;毫秒：&#x27;+s, &#x27;秒向上取整：&#x27;+sCeil, &#x27;代码执行时间：&#x27;+offset, &#x27;下次循环间隔&#x27;+currentInterval) <br>  set<span class="hljs-constructor">Timeout(<span class="hljs-params">loop</span>, <span class="hljs-params">currentInterval</span>)</span><br>&#125;<br>set<span class="hljs-constructor">Timeout(<span class="hljs-params">loop</span>, <span class="hljs-params">currentInterval</span>)</span><br></code></pre></td></tr></table></figure>

<p>接下来看 <code>setInterval</code>，其实这个函数作用和 <code>setTimeout</code> 基本一致，只是该函数是每隔一段时间执行一次回调函数。</p>
<p>通常来说不建议使用 <code>setInterval</code>。第一，它和 <code>setTimeout</code> 一样，不能保证在预期的时间执行任务。第二，它存在执行累积的问题，请看以下伪代码</p>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss">function <span class="hljs-built_in">demo</span>() &#123;<br>  <span class="hljs-built_in">setInterval</span>(function()&#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">2</span>)<br>  &#125;,<span class="hljs-number">1000</span>)<br>  <span class="hljs-built_in">sleep</span>(<span class="hljs-number">2000</span>)<br>&#125;<br><span class="hljs-built_in">demo</span>()<br></code></pre></td></tr></table></figure>

<p>以上代码在浏览器环境中，如果定时器执行过程中出现了耗时操作，多个回调函数会在耗时操作结束以后同时执行，这样可能就会带来性能上的问题。</p>
<p>如果有循环定时器的需求，其实完全可以通过 <code>requestAnimationFrame</code> 来实现：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">setInterval</span>(<span class="hljs-params">callback, interval</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer<br>  <span class="hljs-keyword">const</span> now = <span class="hljs-title class_">Date</span>.<span class="hljs-property">now</span><br>  <span class="hljs-keyword">let</span> startTime = <span class="hljs-title function_">now</span>()<br>  <span class="hljs-keyword">let</span> endTime = startTime<br>  <span class="hljs-keyword">const</span> <span class="hljs-title function_">loop</span> = (<span class="hljs-params"></span>) =&gt; &#123;<br>    timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>    endTime = <span class="hljs-title function_">now</span>()<br>    <span class="hljs-keyword">if</span> (endTime - startTime &gt;= interval) &#123;<br>      startTime = endTime = <span class="hljs-title function_">now</span>()<br>      <span class="hljs-title function_">callback</span>(timer)<br>    &#125;<br>  &#125;<br>  timer = <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">requestAnimationFrame</span>(loop)<br>  <span class="hljs-keyword">return</span> timer<br>&#125;<br><span class="hljs-keyword">let</span> a = <span class="hljs-number">0</span><br><span class="hljs-built_in">setInterval</span>(<span class="hljs-function"><span class="hljs-params">timer</span> =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-number">1</span>)<br>  a++<br>  <span class="hljs-keyword">if</span> (a === <span class="hljs-number">3</span>) <span class="hljs-title function_">cancelAnimationFrame</span>(timer)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<p>首先 <code>requestAnimationFrame</code> 自带函数节流功能，基本可以保证在 16.6 毫秒内只执行一次（不掉帧的情况下），并且该函数的延时效果是精确的，没有其他定时器时间不准的问题，当然你也可以通过该函数来实现 <code>setTimeout</code>。</p>
<h2 id="八、面向对象"><a href="#八、面向对象" class="headerlink" title="八、面向对象"></a>八、面向对象</h2><h3 id="1-对象创建的方式有哪些？"><a href="#1-对象创建的方式有哪些？" class="headerlink" title="1. 对象创建的方式有哪些？"></a>1. 对象创建的方式有哪些？</h3><p>一般使用字面量的形式直接创建对象，但是这种创建方式对于创建大量相似对象的时候，会产生大量的重复代码。但 js和一般的面向对象的语言不同，在 ES6 之前它没有类的概念。但是可以使用函数来进行模拟，从而产生出可复用的对象创建方式，常见的有以下几种：</p>
<p>（1）第一种是工厂模式，工厂模式的主要工作原理是用函数来封装创建对象的细节，从而通过调用函数来达到复用的目的。但是它有一个很大的问题就是创建出来的对象无法和某个类型联系起来，它只是简单的封装了复用代码，而没有建立起对象和类型间的关系。</p>
<p>（2）第二种是构造函数模式。js 中每一个函数都可以作为构造函数，只要一个函数是通过 new 来调用的，那么就可以把它称为构造函数。执行构造函数首先会创建一个对象，然后将对象的原型指向构造函数的 prototype 属性，然后将执行上下文中的 this 指向这个对象，最后再执行整个函数，如果返回值不是对象，则返回新建的对象。因为 this 的值指向了新建的对象，因此可以使用 this 给对象赋值。构造函数模式相对于工厂模式的优点是，所创建的对象和构造函数建立起了联系，因此可以通过原型来识别对象的类型。但是构造函数存在一个缺点就是，造成了不必要的函数对象的创建，因为在 js 中函数也是一个对象，因此如果对象属性中如果包含函数的话，那么每次都会新建一个函数对象，浪费了不必要的内存空间，因为函数是所有的实例都可以通用的。</p>
<p>（3）第三种模式是原型模式，因为每一个函数都有一个 prototype 属性，这个属性是一个对象，它包含了通过构造函数创建的所有实例都能共享的属性和方法。因此可以使用原型对象来添加公用属性和方法，从而实现代码的复用。这种方式相对于构造函数模式来说，解决了函数对象的复用问题。但是这种模式也存在一些问题，一个是没有办法通过传入参数来初始化值，另一个是如果存在一个引用类型如 Array 这样的值，那么所有的实例将共享一个对象，一个实例对引用类型值的改变会影响所有的实例。</p>
<p>（4）第四种模式是组合使用构造函数模式和原型模式，这是创建自定义类型的最常见方式。因为构造函数模式和原型模式分开使用都存在一些问题，因此可以组合使用这两种模式，通过构造函数来初始化对象的属性，通过原型对象来实现函数方法的复用。这种方法很好的解决了两种模式单独使用时的缺点，但是有一点不足的就是，因为使用了两种不同的模式，所以对于代码的封装性不够好。</p>
<p>（5）第五种模式是动态原型模式，这一种模式将原型方法赋值的创建过程移动到了构造函数的内部，通过对属性是否存在的判断，可以实现仅在第一次调用函数时对原型对象赋值一次的效果。这一种方式很好地对上面的混合模式进行了封装。</p>
<p>（6）第六种模式是寄生构造函数模式，这一种模式和工厂模式的实现基本相同，我对这个模式的理解是，它主要是基于一个已有的类型，在实例化时对实例化的对象进行扩展。这样既不用修改原来的构造函数，也达到了扩展对象的目的。它的一个缺点和工厂模式一样，无法实现对象的识别。</p>
<h3 id="2-对象继承的方式有哪些？"><a href="#2-对象继承的方式有哪些？" class="headerlink" title="2. 对象继承的方式有哪些？"></a>2. 对象继承的方式有哪些？</h3><p>（1）第一种是以原型链的方式来实现继承，但是这种实现方式存在的缺点是，在包含有引用类型的数据时，会被所有的实例对象所共享，容易造成修改的混乱。还有就是在创建子类型的时候不能向超类型传递参数。</p>
<p>（2）第二种方式是使用借用构造函数的方式，这种方式是通过在子类型的函数中调用超类型的构造函数来实现的，这一种方法解决了不能向超类型传递参数的缺点，但是它存在的一个问题就是无法实现函数方法的复用，并且超类型原型定义的方法子类型也没有办法访问到。</p>
<p>（3）第三种方式是组合继承，组合继承是将原型链和借用构造函数组合起来使用的一种方式。通过借用构造函数的方式来实现类型的属性的继承，通过将子类型的原型设置为超类型的实例来实现方法的继承。这种方式解决了上面的两种模式单独使用时的问题，但是由于我们是以超类型的实例来作为子类型的原型，所以调用了两次超类的构造函数，造成了子类型的原型中多了很多不必要的属性。</p>
<p>（4）第四种方式是原型式继承，原型式继承的主要思路就是基于已有的对象来创建新的对象，实现的原理是，向函数中传入一个对象，然后返回一个以这个对象为原型的对象。这种继承的思路主要不是为了实现创造一种新的类型，只是对某个对象实现一种简单继承，ES5 中定义的 Object.create() 方法就是原型式继承的实现。缺点与原型链方式相同。</p>
<p>（5）第五种方式是寄生式继承，寄生式继承的思路是创建一个用于封装继承过程的函数，通过传入一个对象，然后复制一个对象的副本，然后对象进行扩展，最后返回这个对象。这个扩展的过程就可以理解是一种继承。这种继承的优点就是对一个简单对象实现继承，如果这个对象不是自定义类型时。缺点是没有办法实现函数的复用。</p>
<p>（6）第六种方式是寄生式组合继承，组合继承的缺点就是使用超类型的实例做为子类型的原型，导致添加了不必要的原型属性。寄生式组合继承的方式是使用超类型的原型的副本来作为子类型的原型，这样就避免了创建不必要的属性。</p>
<h2 id="九、垃圾回收与内存泄漏"><a href="#九、垃圾回收与内存泄漏" class="headerlink" title="九、垃圾回收与内存泄漏"></a>九、垃圾回收与内存泄漏</h2><h3 id="1-浏览器的垃圾回收机制"><a href="#1-浏览器的垃圾回收机制" class="headerlink" title="1. 浏览器的垃圾回收机制"></a>1. 浏览器的垃圾回收机制</h3><h4 id="（1）垃圾回收的概念"><a href="#（1）垃圾回收的概念" class="headerlink" title="（1）垃圾回收的概念"></a>（1）垃圾回收的概念</h4><p><strong>垃圾回收</strong>：JavaScript代码运行时，需要分配内存空间来储存变量和值。当变量不在参与运行时，就需要系统收回被占用的内存空间，这就是垃圾回收。</p>
<p><strong>回收机制</strong>：</p>
<ul>
<li>Javascript 具有自动垃圾回收机制，会定期对那些不再使用的变量、对象所占用的内存进行释放，原理就是找到不再使用的变量，然后释放掉其占用的内存。</li>
<li>JavaScript中存在两种变量：局部变量和全局变量。全局变量的生命周期会持续要页面卸载；而局部变量声明在函数中，它的生命周期从函数执行开始，直到函数执行结束，在这个过程中，局部变量会在堆或栈中存储它们的值，当函数执行结束后，这些局部变量不再被使用，它们所占有的空间就会被释放。</li>
<li>不过，当局部变量被外部函数使用时，其中一种情况就是闭包，在函数执行结束后，函数外部的变量依然指向函数内部的局部变量，此时局部变量依然在被使用，所以不会回收。</li>
</ul>
<h4 id="（2）垃圾回收的方式"><a href="#（2）垃圾回收的方式" class="headerlink" title="（2）垃圾回收的方式"></a>（2）垃圾回收的方式</h4><p>浏览器通常使用的垃圾回收方法有两种：标记清除，引用计数。</p>
<p><strong>1）标记清除</strong></p>
<ul>
<li>标记清除是浏览器常见的垃圾回收方式，当变量进入执行环境时，就标记这个变量“进入环境”，被标记为“进入环境”的变量是不能被回收的，因为他们正在被使用。当变量离开环境时，就会被标记为“离开环境”，被标记为“离开环境”的变量会被内存释放。</li>
<li>垃圾收集器在运行的时候会给存储在内存中的所有变量都加上标记。然后，它会去掉环境中的变量以及被环境中的变量引用的标记。而在此之后再被加上标记的变量将被视为准备删除的变量，原因是环境中的变量已经无法访问到这些变量了。最后。垃圾收集器完成内存清除工作，销毁那些带标记的值，并回收他们所占用的内存空间。</li>
</ul>
<p><strong>2）引用计数</strong></p>
<ul>
<li>另外一种垃圾回收机制就是引用计数，这个用的相对较少。引用计数就是跟踪记录每个值被引用的次数。当声明了一个变量并将一个引用类型赋值给该变量时，则这个值的引用次数就是1。相反，如果包含对这个值引用的变量又取得了另外一个值，则这个值的引用次数就减1。当这个引用次数变为0时，说明这个变量已经没有价值，因此，在在机回收期下次再运行时，这个变量所占有的内存空间就会被释放出来。</li>
<li>这种方法会引起<strong>循环引用</strong>的问题：例如：<code> obj1</code>和<code>obj2</code>通过属性进行相互引用，两个对象的引用次数都是2。当使用循环计数时，由于函数执行完后，两个对象都离开作用域，函数执行结束，<code>obj1</code>和<code>obj2</code>还将会继续存在，因此它们的引用次数永远不会是0，就会引起循环引用。</li>
</ul>
<figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">function fun() &#123;<br>    let obj1 <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br>    let obj2 <span class="hljs-operator">=</span> &#123;&#125;<span class="hljs-comment">;</span><br>    obj1.a <span class="hljs-operator">=</span> obj2<span class="hljs-comment">; // obj1 引用 obj2</span><br>    obj2.a <span class="hljs-operator">=</span> obj1<span class="hljs-comment">; // obj2 引用 obj1</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>这种情况下，就要手动释放变量占用的内存：</p>
<figure class="highlight ini"><table><tr><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">obj1.a</span> =  null<br> <span class="hljs-attr">obj2.a</span> =  null<br></code></pre></td></tr></table></figure>

<h4 id="（3）减少垃圾回收"><a href="#（3）减少垃圾回收" class="headerlink" title="（3）减少垃圾回收"></a>（3）减少垃圾回收</h4><p>虽然浏览器可以进行垃圾自动回收，但是当代码比较复杂时，垃圾回收所带来的代价比较大，所以应该尽量减少垃圾回收。</p>
<ul>
<li><strong>对数组进行优化：</strong>在清空一个数组时，最简单的方法就是给其赋值为[ ]，但是与此同时会创建一个新的空对象，可以将数组的长度设置为0，以此来达到清空数组的目的。</li>
<li><strong>对</strong><code>**object**</code><strong>进行优化：</strong>对象尽量复用，对于不再使用的对象，就将其设置为null，尽快被回收。</li>
<li><strong>对函数进行优化：</strong>在循环中的函数表达式，如果可以复用，尽量放在函数的外面。</li>
</ul>
<h3 id="2-哪些情况会导致内存泄漏"><a href="#2-哪些情况会导致内存泄漏" class="headerlink" title="2. 哪些情况会导致内存泄漏"></a>2. 哪些情况会导致内存泄漏</h3><p>以下四种情况会造成内存的泄漏：</p>
<ul>
<li><strong>意外的全局变量：</strong>由于使用未声明的变量，而意外的创建了一个全局变量，而使这个变量一直留在内存中无法被回收。</li>
<li><strong>被遗忘的计时器或回调函数：</strong>设置了 setInterval 定时器，而忘记取消它，如果循环函数有对外部变量的引用的话，那么这个变量会被一直留在内存中，而无法被回收。</li>
<li><strong>脱离 DOM 的引用：</strong>获取一个 DOM 元素的引用，而后面这个元素被删除，由于一直保留了对这个元素的引用，所以它也无法被回收。</li>
<li><strong>闭包：</strong>不合理的使用闭包，从而导致某些变量一直被留在内存当中。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Vue</title>
    <url>/2022/08/22/Vue/</url>
    <content><![CDATA[<h2 id="Vue"><a href="#Vue" class="headerlink" title="Vue"></a>Vue</h2><span id="more"></span>

<p><img  src="/images/image/vue.png"  ><span class="image-caption">Vue面试题.png</span></p>
<h2 id="一、Vue-基础"><a href="#一、Vue-基础" class="headerlink" title="一、Vue 基础"></a>一、Vue 基础</h2><h3 id="1-Vue的基本原理"><a href="#1-Vue的基本原理" class="headerlink" title="1. Vue的基本原理"></a>1. Vue的基本原理</h3><p>当一个Vue实例创建时，Vue会遍历data中的属性，用 Object.defineProperty（vue3.0使用proxy ）将它们转为 getter&#x2F;setter，并且在内部追踪相关依赖，在属性被访问和修改时通知变化。 每个组件实例都有相应的 watcher 程序实例，它会在组件渲染的过程中把属性记录为依赖，之后当依赖项的setter被调用时，会通知watcher重新计算，从而致使它关联的组件得以更新。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1620128979608-f7465ffc-9411-43e3-a6bc-96ab44dd77df.png"  ><span class="image-caption">0_tB3MJCzh_cB6i3mS-1.png</span></p>
<h3 id="2-双向数据绑定的原理"><a href="#2-双向数据绑定的原理" class="headerlink" title="2. 双向数据绑定的原理"></a>2. 双向数据绑定的原理</h3><p>Vue.js 是采用<strong>数据劫持</strong>结合<strong>发布者-订阅者模式</strong>的方式，通过Object.defineProperty()来劫持各个属性的setter，getter，在数据变动时发布消息给订阅者，触发相应的监听回调。主要分为以下几个步骤：</p>
<ol>
<li>需要observe的数据对象进行递归遍历，包括子属性对象的属性，都加上setter和getter这样的话，给这个对象的某个值赋值，就会触发setter，那么就能监听到了数据变化</li>
<li>compile解析模板指令，将模板中的变量替换成数据，然后初始化渲染页面视图，并将每个指令对应的节点绑定更新函数，添加监听数据的订阅者，一旦数据有变动，收到通知，更新视图</li>
<li>Watcher订阅者是Observer和Compile之间通信的桥梁，主要做的事情是: ①在自身实例化时往属性订阅器(dep)里面添加自己 ②自身必须有一个update()方法 ③待属性变动dep.notice()通知时，能调用自身的update()方法，并触发Compile中绑定的回调，则功成身退。</li>
<li>MVVM作为数据绑定的入口，整合Observer、Compile和Watcher三者，通过Observer来监听自己的model数据变化，通过Compile来解析编译模板指令，最终利用Watcher搭起Observer和Compile之间的通信桥梁，达到数据变化 -&gt; 视图更新；视图交互变化(input) -&gt; 数据model变更的双向绑定效果。</li>
</ol>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1618656573096-ebdc520c-5d60-4d12-ad04-5df4ebbb5fe7.png"  ><span class="image-caption">image</span></p>
<h3 id="3-使用-Object-defineProperty-来进行数据劫持有什么缺点？"><a href="#3-使用-Object-defineProperty-来进行数据劫持有什么缺点？" class="headerlink" title="3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？"></a>3. 使用 Object.defineProperty() 来进行数据劫持有什么缺点？</h3><p>在对一些属性进行操作时，使用这种方法无法拦截，比如通过下标方式修改数组数据或者给对象新增属性，这都不能触发组件的重新渲染，因为 Object.defineProperty 不能拦截到这些操作。更精确的来说，对于数组而言，大部分操作都是拦截不到的，只是 Vue 内部通过重写函数的方式解决了这个问题。</p>
<p>在 Vue3.0 中已经不使用这种方式了，而是通过使用 Proxy 对对象进行代理，从而实现数据劫持。使用Proxy 的好处是它可以完美的监听到任何方式的数据改变，唯一的缺点是兼容性的问题，因为 Proxy 是 ES6 的语法。</p>
<h3 id="4-MVVM、MVC、MVP的区别"><a href="#4-MVVM、MVC、MVP的区别" class="headerlink" title="4. MVVM、MVC、MVP的区别"></a>4. MVVM、MVC、MVP的区别</h3><p>MVC、MVP 和 MVVM 是三种常见的软件架构设计模式，主要通过分离关注点的方式来组织代码结构，优化开发效率。</p>
<p>在开发单页面应用时，往往一个路由页面对应了一个脚本文件，所有的页面逻辑都在一个脚本文件里。页面的渲染、数据的获取，对用户事件的响应所有的应用逻辑都混合在一起，这样在开发简单项目时，可能看不出什么问题，如果项目变得复杂，那么整个文件就会变得冗长、混乱，这样对项目开发和后期的项目维护是非常不利的。</p>
<p><strong>（1）MVC</strong></p>
<p>MVC 通过分离 Model、View 和 Controller 的方式来组织代码结构。其中 View 负责页面的显示逻辑，Model 负责存储页面的业务数据，以及对相应数据的操作。并且 View 和 Model 应用了观察者模式，当 Model 层发生改变的时候它会通知有关 View 层更新页面。Controller 层是 View 层和 Model 层的纽带，它主要负责用户与应用的响应操作，当用户与页面产生交互的时候，Controller 中的事件触发器就开始工作了，通过调用 Model 层，来完成对 Model 的修改，然后 Model 层再去通知 View 层更新。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603814137582-5a9aa62f-0045-4272-bef0-447dedb25596.png"  ><span class="image-caption">image.png</span></p>
<p>（2）MVVM</p>
<p>MVVM 分为 Model、View、ViewModel：</p>
<ul>
<li>Model代表数据模型，数据和业务逻辑都在Model层中定义；</li>
<li>View代表UI视图，负责数据的展示；</li>
<li>ViewModel负责监听Model中数据的改变并且控制视图的更新，处理用户交互操作；</li>
</ul>
<p>Model和View并无直接关联，而是通过ViewModel来进行联系的，Model和ViewModel之间有着双向数据绑定的联系。因此当Model中的数据改变时会触发View层的刷新，View中由于用户交互操作而改变的数据也会在Model中同步。</p>
<p>这种模式实现了 Model和View的数据自动同步，因此开发者只需要专注于数据的维护操作即可，而不需要自己操作DOM。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603814104939-8c8ac923-735d-4476-937a-cb1f795ffe84.png"  ><span class="image-caption">image.png</span></p>
<p><strong>（3）MVP</strong></p>
<p>MVP 模式与 MVC 唯一不同的在于 Presenter 和 Controller。在 MVC 模式中使用观察者模式，来实现当 Model 层数据发生变化的时候，通知 View 层的更新。这样 View 层和 Model 层耦合在一起，当项目逻辑变得复杂的时候，可能会造成代码的混乱，并且可能会对代码的复用性造成一些问题。MVP 的模式通过使用 Presenter 来实现对 View 层和 Model 层的解耦。MVC 中的Controller 只知道 Model 的接口，因此它没有办法控制 View 层的更新，MVP 模式中，View 层的接口暴露给了 Presenter 因此可以在 Presenter 中将 Model 的变化和 View 的变化绑定在一起，以此来实现 View 和 Model 的同步更新。这样就实现了对 View 和 Model 的解耦，Presenter 还包含了其他的响应逻辑。</p>
<h3 id="5-Computed-和-Watch-的区别"><a href="#5-Computed-和-Watch-的区别" class="headerlink" title="5. Computed 和 Watch 的区别"></a>5. Computed 和 Watch 的区别</h3><p><strong>对于Computed：</strong></p>
<ul>
<li>它支持缓存，只有依赖的数据发生了变化，才会重新计算</li>
<li>不支持异步，当Computed中有异步操作时，无法监听数据的变化</li>
<li>computed的值会默认走缓存，计算属性是基于它们的响应式依赖进行缓存的，也就是基于data声明过，或者父组件传递过来的props中的数据进行计算的。</li>
<li>如果一个属性是由其他属性计算而来的，这个属性依赖其他的属性，一般会使用computed</li>
<li>如果computed属性的属性值是函数，那么默认使用get方法，函数的返回值就是属性的属性值；在computed中，属性有一个get方法和一个set方法，当数据发生变化时，会调用set方法。</li>
</ul>
<p><strong>对于Watch：</strong></p>
<ul>
<li><p>它不支持缓存，数据变化时，它就会触发相应的操作</p>
</li>
<li><p>支持异步监听</p>
</li>
<li><p>监听的函数接收两个参数，第一个参数是最新的值，第二个是变化之前的值</p>
</li>
<li><p>当一个属性发生变化时，就需要执行相应的操作</p>
</li>
<li><p>监听数据必须是data中声明的或者父组件传递过来的props中的数据，当发生变化时，会触发其他操作，函数有两个的参数：</p>
</li>
<li><ul>
<li>immediate：组件加载立即触发回调函数</li>
<li>deep：深度监听，发现数据内部的变化，在复杂数据类型中使用，例如数组中的对象发生变化。需要注意的是，deep无法监听到数组和对象内部的变化。</li>
</ul>
</li>
</ul>
<p>当想要执行异步或者昂贵的操作以响应不断的变化时，就需要使用watch。</p>
<p><strong>总结：</strong></p>
<ul>
<li>computed 计算属性 : 依赖其它属性值，并且 computed 的值有缓存，只有它依赖的属性值发生改变，下一次获取 computed 的值时才会重新计算 computed 的值。 </li>
<li>watch 侦听器 : 更多的是<strong>观察</strong>的作用，<strong>无缓存性</strong>，类似于某些数据的监听回调，每当监听的数据变化时都会执行回调进行后续操作。</li>
</ul>
<p><strong>运用场景：</strong> </p>
<ul>
<li>当需要进行数值计算,并且依赖于其它数据时，应该使用 computed，因为可以利用 computed 的缓存特性，避免每次获取值时都要重新计算。 </li>
<li>当需要在数据变化时执行异步或开销较大的操作时，应该使用 watch，使用 watch 选项允许执行异步操作 ( 访问一个 API )，限制执行该操作的频率，并在得到最终结果前，设置中间状态。这些都是计算属性无法做到的。</li>
</ul>
<h3 id="6-Computed-和-Methods-的区别"><a href="#6-Computed-和-Methods-的区别" class="headerlink" title="6. Computed 和 Methods 的区别"></a>6. Computed 和 Methods 的区别</h3><p>可以将同一函数定义为一个 method 或者一个计算属性。对于最终的结果，两种方式是相同的 </p>
<p><strong>不同点：</strong> </p>
<ul>
<li>computed: 计算属性是基于它们的依赖进行缓存的，只有在它的相关依赖发生改变时才会重新求值；</li>
<li>method 调用总会执行该函数。</li>
</ul>
<h3 id="7-slot是什么？有什么作用？原理是什么？"><a href="#7-slot是什么？有什么作用？原理是什么？" class="headerlink" title="7. slot是什么？有什么作用？原理是什么？"></a>7. slot是什么？有什么作用？原理是什么？</h3><p>slot又名插槽，是Vue的内容分发机制，组件内部的模板引擎使用slot元素作为承载分发内容的出口。插槽slot是子组件的一个模板标签元素，而这一个标签元素是否显示，以及怎么显示是由父组件决定的。slot又分三类，默认插槽，具名插槽和作用域插槽。</p>
<ul>
<li>默认插槽：又名匿名查抄，当slot没有指定name属性值的时候一个默认显示插槽，一个组件内只有有一个匿名插槽。</li>
<li>具名插槽：带有具体名字的插槽，也就是带有name属性的slot，一个组件可以出现多个具名插槽。</li>
<li>作用域插槽：默认插槽、具名插槽的一个变体，可以是匿名插槽，也可以是具名插槽，该插槽的不同点是在子组件渲染作用域插槽时，可以将子组件内部的数据传递给父组件，让父组件根据子组件的传递过来的数据决定如何渲染该插槽。</li>
</ul>
<p>实现原理：当子组件vm实例化时，获取到父组件传入的slot标签的内容，存放在<code>vm.$slot</code>中，默认插槽为<code>vm.$slot.default</code>，具名插槽为<code>vm.$slot.xxx</code>，xxx 为插槽名，当组件执行渲染函数时候，遇到slot标签，使用<code>$slot</code>中的内容进行替换，此时可以为插槽传递数据，若存在数据，则可称该插槽为作用域插槽。</p>
<h3 id="8-过滤器的作用，如何实现一个过滤器"><a href="#8-过滤器的作用，如何实现一个过滤器" class="headerlink" title="8. 过滤器的作用，如何实现一个过滤器"></a>8. 过滤器的作用，如何实现一个过滤器</h3><p>根据过滤器的名称，过滤器是用来过滤数据的，在Vue中使用<code>filters</code>来过滤数据，<code>filters</code>不会修改数据，而是过滤数据，改变用户看到的输出（计算属性 <code>computed</code> ，方法 <code>methods</code> 都是通过修改数据来处理数据格式的输出显示）。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>需要格式化数据的情况，比如需要处理时间、价格等数据格式的输出 &#x2F; 显示。</li>
<li>比如后端返回一个 <strong>年月日的日期字符串</strong>，前端需要展示为 <strong>多少天前</strong> 的数据格式，此时就可以用<code>fliters</code>过滤器来处理数据。</li>
</ul>
<p>过滤器是一个函数，它会把表达式中的值始终当作函数的第一个参数。过滤器用在<strong>插值表达式</strong> <code>**&#123;&#123; &#125;&#125;**</code> 和 <code>**v-bind**</code> <strong>表达式</strong> 中，然后放在操作符“ <code>**|**</code> ”后面进行指示。</p>
<p>例如，在显示金额，给商品价格添加单位：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">li</span>&gt;</span>商品价格：</span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item.price</span> | filterPrice&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"> filters: &#123;</span><br><span class="language-xml">    filterPrice (price) &#123;</span><br><span class="language-xml">      return price ? (&#x27;￥&#x27; + price) : &#x27;--&#x27;</span><br><span class="language-xml">    &#125;</span><br><span class="language-xml">  &#125;</span><br></code></pre></td></tr></table></figure>

<h3 id="9-如何保存页面的当前的状态"><a href="#9-如何保存页面的当前的状态" class="headerlink" title="9. 如何保存页面的当前的状态"></a>9. 如何保存页面的当前的状态</h3><p>既然是要保持页面的状态（其实也就是组件的状态），那么会出现以下两种情况：</p>
<ul>
<li>前组件会被卸载</li>
<li>前组件不会被卸载</li>
</ul>
<p>那么可以按照这两种情况分别得到以下方法：</p>
<p><strong>组件会被卸载：</strong></p>
<p><strong>（1）将状态存储在LocalStorage &#x2F; SessionStorage</strong></p>
<p>只需要在组件即将被销毁的生命周期 <code>componentWillUnmount</code> （react）中在 LocalStorage &#x2F; SessionStorage 中把当前组件的 state 通过 JSON.stringify() 储存下来就可以了。在这里面需要注意的是组件更新状态的时机。</p>
<p>比如从 B 组件跳转到 A 组件的时候，A 组件需要更新自身的状态。但是如果从别的组件跳转到 B 组件的时候，实际上是希望 B 组件重新渲染的，也就是不要从 Storage 中读取信息。所以需要在 Storage 中的状态加入一个 flag 属性，用来控制 A 组件是否读取 Storage 中的状态。</p>
<h5 id="优点"><a href="#优点" class="headerlink" title="优点"></a>优点</h5><ul>
<li>兼容性好，不需要额外库或工具。</li>
<li>简单快捷，基本可以满足大部分需求。</li>
</ul>
<h5 id="缺点"><a href="#缺点" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>状态通过 JSON 方法储存（相当于深拷贝），如果状态中有特殊情况（比如 Date 对象、Regexp 对象等）的时候会得到字符串而不是原来的值。（具体参考用 JSON 深拷贝的缺点）</li>
<li>如果 B 组件后退或者下一页跳转并不是前组件，那么 flag 判断会失效，导致从其他页面进入 A 组件页面时 A 组件会重新读取 Storage，会造成很奇怪的现象</li>
</ul>
<p><strong>（2）路由传值</strong></p>
<p>通过 react-router 的 Link 组件的 prop —— to 可以实现路由间传递参数的效果。</p>
<p>在这里需要用到 state 参数，在 B 组件中通过 history.location.state 就可以拿到 state 值，保存它。返回 A 组件时再次携带 state 达到路由状态保持的效果。</p>
<h5 id="优点-1"><a href="#优点-1" class="headerlink" title="优点"></a>优点</h5><ul>
<li>简单快捷，不会污染 LocalStorage &#x2F; SessionStorage。</li>
<li>可以传递 Date、RegExp 等特殊对象（不用担心 JSON.stringify &#x2F; parse 的不足）</li>
</ul>
<h5 id="缺点-1"><a href="#缺点-1" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>如果 A 组件可以跳转至多个组件，那么在每一个跳转组件内都要写相同的逻辑。</li>
</ul>
<p><strong>组件不会被卸载：</strong></p>
<p><strong>（1）单页面渲染</strong></p>
<p>要切换的组件作为子组件全屏渲染，父组件中正常储存页面状态。</p>
<h5 id="优点-2"><a href="#优点-2" class="headerlink" title="优点"></a>优点</h5><ul>
<li>代码量少</li>
<li>不需要考虑状态传递过程中的错误</li>
</ul>
<h5 id="缺点-2"><a href="#缺点-2" class="headerlink" title="缺点"></a>缺点</h5><ul>
<li>增加 A 组件维护成本</li>
<li>需要传入额外的 prop 到 B 组件</li>
<li>无法利用路由定位页面</li>
</ul>
<p>除此之外，在Vue中，还可以是用keep-alive来缓存页面，当组件在keep-alive内被切换时组件的<strong>activated、deactivated</strong>这两个生命周期钩子函数会被执行</p>
<p>被包裹在keep-alive中的组件的状态将会被保留：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">keep-alive</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">router-view</span> <span class="hljs-attr">v-if</span>=<span class="hljs-string">&quot;$route.meta.keepAlive&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">router-view</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">kepp-alive</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>router.js</strong></p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">&#123;<br>  path: <span class="hljs-string">&#x27;/&#x27;</span>,<br>  name: <span class="hljs-string">&#x27;xxx&#x27;</span>,<br>  component: <span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span><span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;../src/views/xxx.vue&#x27;</span>),<br>  meta:&#123;<br>    keepAlive: <span class="hljs-literal">true</span> <span class="hljs-regexp">//</span> 需要被缓存<br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure>

<h3 id="10-常见的事件修饰符及其作用"><a href="#10-常见的事件修饰符及其作用" class="headerlink" title="10. 常见的事件修饰符及其作用"></a>10. 常见的事件修饰符及其作用</h3><ul>
<li><code>.stop</code>：等同于 JavaScript 中的 <code>event.stopPropagation()</code> ，防止事件冒泡；</li>
<li><code>.prevent</code> ：等同于 JavaScript 中的 <code>event.preventDefault()</code> ，防止执行预设的行为（如果事件可取消，则取消该事件，而不停止事件的进一步传播）；</li>
<li><code>.capture</code> ：与事件冒泡的方向相反，事件捕获由外到内；</li>
<li><code>.self</code> ：只会触发自己范围内的事件，不包含子元素；</li>
<li><code>.once</code> ：只会触发一次。</li>
</ul>
<h3 id="11-v-if、v-show、v-html-的原理"><a href="#11-v-if、v-show、v-html-的原理" class="headerlink" title="11. v-if、v-show、v-html 的原理"></a>11. v-if、v-show、v-html 的原理</h3><ul>
<li>v-if会调用addIfCondition方法，生成vnode的时候会忽略对应节点，render的时候就不会渲染；</li>
<li>v-show会生成vnode，render的时候也会渲染成真实节点，只是在render过程中会在节点的属性中修改show属性值，也就是常说的display； </li>
<li>v-html会先移除节点下的所有节点，调用html方法，通过addProp添加innerHTML属性，归根结底还是设置innerHTML为v-html的值。</li>
</ul>
<h3 id="13-v-if和v-show的区别"><a href="#13-v-if和v-show的区别" class="headerlink" title="13. v-if和v-show的区别"></a>13. v-if和v-show的区别</h3><ul>
<li><strong>手段</strong>：v-if是动态的向DOM树内添加或者删除DOM元素；v-show是通过设置DOM元素的display样式属性控制显隐；</li>
<li><strong>编译过程</strong>：v-if切换有一个局部编译&#x2F;卸载的过程，切换过程中合适地销毁和重建内部的事件监听和子组件；v-show只是简单的基于css切换；</li>
<li><strong>编译条件</strong>：v-if是惰性的，如果初始条件为假，则什么也不做；只有在条件第一次变为真时才开始局部编译; v-show是在任何条件下，无论首次条件是否为真，都被编译，然后被缓存，而且DOM元素保留；</li>
<li><strong>性能消耗</strong>：v-if有更高的切换消耗；v-show有更高的初始渲染消耗；</li>
<li><strong>使用场景</strong>：v-if适合运营条件不大可能改变；v-show适合频繁切换。</li>
</ul>
<h3 id="14-v-model-是如何实现的，语法糖实际是什么？"><a href="#14-v-model-是如何实现的，语法糖实际是什么？" class="headerlink" title="14. v-model 是如何实现的，语法糖实际是什么？"></a>14. v-model 是如何实现的，语法糖实际是什么？</h3><p><strong>（1）作用在表单元素上</strong></p>
<p>动态绑定了 input 的 value 指向了 messgae 变量，并且在触发 input 事件的时候去动态把 message设置为目标值：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">&lt;input v-model=<span class="hljs-string">&quot;sth&quot;</span> /&gt;<br><span class="hljs-regexp">//</span>  等同于<br>&lt;input <br>    v-bind:value=<span class="hljs-string">&quot;message&quot;</span> <br>    v-on:input=<span class="hljs-string">&quot;message=$event.target.value&quot;</span><br>&gt;<br><span class="hljs-regexp">//</span><span class="hljs-variable">$event</span> 指代当前触发的事件对象;<br><span class="hljs-regexp">//</span><span class="hljs-variable">$event</span>.target 指代当前触发的事件对象的dom;<br><span class="hljs-regexp">//</span><span class="hljs-variable">$event</span>.target.value 就是当前dom的value值;<br><span class="hljs-regexp">//</span>在@input方法中，value =&gt; sth;<br><span class="hljs-regexp">//</span>在:value中,sth =&gt; value;<br></code></pre></td></tr></table></figure>

<p><strong>（2）作用在组件上</strong></p>
<p>在自定义组件中，v-model 默认会利用名为 value 的 prop和名为 input 的事件</p>
<p><strong>本质是一个父子组件通信的语法糖，通过prop和$.emit实现。</strong>因此父组件 v-model 语法糖本质上可以修改为：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">:value</span>=<span class="hljs-string">&quot;message&quot;</span>  @<span class="hljs-attr">input</span>=<span class="hljs-string">&quot;function(e)</span></span></span><span class="hljs-template-variable">&#123;message = e&#125;</span><span class="language-xml"><span class="hljs-tag"><span class="hljs-string">&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>在组件的实现中，可以通过 v-model属性来配置子组件接收的prop名称，以及派发的事件名称。</p>
<p>例子：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp"><span class="hljs-comment">// 父组件</span><br>&lt;aa-<span class="hljs-keyword">input</span> v-model=<span class="hljs-string">&quot;aa&quot;</span>&gt;&lt;/aa-<span class="hljs-keyword">input</span>&gt;<br><span class="hljs-comment">// 等价于</span><br>&lt;aa-<span class="hljs-keyword">input</span> v-bind:value=<span class="hljs-string">&quot;aa&quot;</span> v-<span class="hljs-keyword">on</span>:<span class="hljs-keyword">input</span>=<span class="hljs-string">&quot;aa=$event.target.value&quot;</span>&gt;&lt;/aa-<span class="hljs-keyword">input</span>&gt;<br><br><span class="hljs-comment">// 子组件：</span><br>&lt;<span class="hljs-keyword">input</span> v-bind:value=<span class="hljs-string">&quot;aa&quot;</span> v-<span class="hljs-keyword">on</span>:<span class="hljs-keyword">input</span>=<span class="hljs-string">&quot;onmessage&quot;</span>&gt;&lt;/aa-<span class="hljs-keyword">input</span>&gt;<br><br>props:&#123;value:aa,&#125;<br>methods:&#123;<br>    onmessage(e)&#123;<br>        $emit(<span class="hljs-string">&#x27;input&#x27;</span>,e.target.value)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>默认情况下，一个组件上的v-model 会把 value 用作 prop且把 input 用作 event。但是一些输入类型比如单选框和复选框按钮可能想使用 value prop 来达到不同的目的。使用 model 选项可以回避这些情况产生的冲突。js 监听input 输入框输入数据改变，用oninput，数据改变以后就会立刻出发这个事件。通过input事件把数据$emit 出去，在父组件接受。父组件设置v-model的值为input $emit过来的值。</p>
<h3 id="15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？"><a href="#15-v-model-可以被用在自定义组件上吗？如果可以，如何使用？" class="headerlink" title="15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？"></a>15. v-model 可以被用在自定义组件上吗？如果可以，如何使用？</h3><p>可以。v-model 实际上是一个语法糖，如：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;input <span class="hljs-attribute">v-model</span>=<span class="hljs-string">&quot;searchText&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>实际上相当于：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp">&lt;<span class="hljs-keyword">input</span><br>  v-bind:value=<span class="hljs-string">&quot;searchText&quot;</span><br>  v-<span class="hljs-keyword">on</span>:<span class="hljs-keyword">input</span>=<span class="hljs-string">&quot;searchText = $event.target.value&quot;</span><br>&gt;<br></code></pre></td></tr></table></figure>

<p>用在自定义组件上也是同理：</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><code class="hljs routeros">&lt;custom-input <span class="hljs-attribute">v-model</span>=<span class="hljs-string">&quot;searchText&quot;</span>&gt;<br></code></pre></td></tr></table></figure>

<p>相当于：</p>
<figure class="highlight hsp"><table><tr><td class="code"><pre><code class="hljs hsp">&lt;custom-<span class="hljs-keyword">input</span><br>  v-bind:value=<span class="hljs-string">&quot;searchText&quot;</span><br>  v-<span class="hljs-keyword">on</span>:<span class="hljs-keyword">input</span>=<span class="hljs-string">&quot;searchText = $event&quot;</span><br>&gt;&lt;/custom-<span class="hljs-keyword">input</span>&gt;<br></code></pre></td></tr></table></figure>

<p>显然，custom-input 与父组件的交互如下：</p>
<ol>
<li>父组件将<code>searchText</code>变量传入custom-input 组件，使用的 prop 名为<code>value</code>；</li>
<li>custom-input 组件向父组件传出名为<code>input</code>的事件，父组件将接收到的值赋值给<code>searchText</code>；</li>
</ol>
<p>所以，custom-input 组件的实现应该类似于这样：</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php">Vue.<span class="hljs-title function_ invoke__">component</span>(<span class="hljs-string">&#x27;custom-input&#x27;</span>, &#123;<br>  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;value&#x27;</span>],<br>  <span class="hljs-attr">template</span>: `<br>    &lt;input<br>      v-<span class="hljs-attr">bind</span>:value=<span class="hljs-string">&quot;value&quot;</span><br>      v-<span class="hljs-attr">on</span>:input=<span class="hljs-string">&quot;<span class="hljs-subst">$emit</span>(&#x27;input&#x27;, <span class="hljs-subst">$event</span>.target.value)&quot;</span><br>    &gt;<br>  `<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="16-data为什么是一个函数而不是对象"><a href="#16-data为什么是一个函数而不是对象" class="headerlink" title="16. data为什么是一个函数而不是对象"></a>16. data为什么是一个函数而不是对象</h3><p>JavaScript中的对象是引用类型的数据，当多个实例引用同一个对象时，只要一个实例对这个对象进行操作，其他实例中的数据也会发生变化。</p>
<p>而在Vue中，更多的是想要复用组件，那就需要每个组件都有自己的数据，这样组件之间才不会相互干扰。</p>
<p>所以组件的数据不能写成对象的形式，而是要写成函数的形式。数据以函数返回值的形式定义，这样当每次复用组件的时候，就会返回一个新的data，也就是说每个组件都有自己的私有数据空间，它们各自维护自己的数据，不会干扰其他组件的正常运行。</p>
<h3 id="17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？"><a href="#17-对keep-alive的理解，它是如何实现的，具体缓存的是什么？" class="headerlink" title="17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？"></a>17. 对keep-alive的理解，它是如何实现的，具体缓存的是什么？</h3><p>如果需要在组件切换的时候，保存一些组件的状态防止多次渲染，就可以使用 keep-alive 组件包裹需要保存的组件。</p>
<p><strong>（1）****keep-alive</strong></p>
<p>keep-alive有以下三个属性：</p>
<ul>
<li>include 字符串或正则表达式，只有名称匹配的组件会被匹配；</li>
<li>exclude 字符串或正则表达式，任何名称匹配的组件都不会被缓存；</li>
<li>max 数字，最多可以缓存多少组件实例。</li>
</ul>
<p>注意：keep-alive 包裹动态组件时，会缓存不活动的组件实例。</p>
<p><strong>主要流程</strong></p>
<ol>
<li>判断组件 name ，不在 include 或者在 exclude 中，直接返回 vnode，说明该组件不被缓存。</li>
<li>获取组件实例 key ，如果有获取实例的 key，否则重新生成。</li>
<li>key生成规则，cid +”∶∶”+ tag ，仅靠cid是不够的，因为相同的构造函数可以注册为不同的本地组件。</li>
<li>如果缓存对象内存在，则直接从缓存对象中获取组件实例给 vnode ，不存在则添加到缓存对象中。 5.最大缓存数量，当缓存组件数量超过 max 值时，清除 keys 数组内第一个组件。</li>
</ol>
<p><strong>（2）keep-alive 的实现</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-attr">patternTypes</span>: <span class="hljs-title class_">Array</span>&lt;<span class="hljs-title class_">Function</span>&gt; = [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">RegExp</span>, <span class="hljs-title class_">Array</span>] <span class="hljs-comment">// 接收：字符串，正则，数组</span><br><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;keep-alive&#x27;</span>,<br>  <span class="hljs-attr">abstract</span>: <span class="hljs-literal">true</span>, <span class="hljs-comment">// 抽象组件，是一个抽象组件：它自身不会渲染一个 DOM 元素，也不会出现在父组件链中。</span><br><br>  <span class="hljs-attr">props</span>: &#123;<br>    <span class="hljs-attr">include</span>: patternTypes, <span class="hljs-comment">// 匹配的组件，缓存</span><br>    <span class="hljs-attr">exclude</span>: patternTypes, <span class="hljs-comment">// 不去匹配的组件，不缓存</span><br>    <span class="hljs-attr">max</span>: [<span class="hljs-title class_">String</span>, <span class="hljs-title class_">Number</span>], <span class="hljs-comment">// 缓存组件的最大实例数量, 由于缓存的是组件实例（vnode），数量过多的时候，会占用过多的内存，可以用max指定上限</span><br>  &#125;,<br><br>  <span class="hljs-title function_">created</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 用于初始化缓存虚拟DOM数组和vnode的key</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span> = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(<span class="hljs-literal">null</span>)<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span> = []<br>  &#125;,<br><br>  <span class="hljs-title function_">destroyed</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 销毁缓存cache的组件实例</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">const</span> key <span class="hljs-keyword">in</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>) &#123;<br>      <span class="hljs-title function_">pruneCacheEntry</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">cache</span>, key, <span class="hljs-variable language_">this</span>.<span class="hljs-property">keys</span>)<br>    &#125;<br>  &#125;,<br><br>  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// prune 削减精简[v.]</span><br>    <span class="hljs-comment">// 去监控include和exclude的改变，根据最新的include和exclude的内容，来实时削减缓存的组件的内容</span><br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;include&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> <span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>    <span class="hljs-variable language_">this</span>.$watch(<span class="hljs-string">&#x27;exclude&#x27;</span>, <span class="hljs-function">(<span class="hljs-params">val</span>) =&gt;</span> &#123;<br>      <span class="hljs-title function_">pruneCache</span>(<span class="hljs-variable language_">this</span>, <span class="hljs-function">(<span class="hljs-params">name</span>) =&gt;</span> !<span class="hljs-title function_">matches</span>(val, name))<br>    &#125;)<br>  &#125;,<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>render函数：</strong></p>
<ol>
<li>会在 keep-alive 组件内部去写自己的内容，所以可以去获取默认 slot 的内容，然后根据这个去获取组件</li>
<li>keep-alive 只对第一个组件有效，所以获取第一个子组件。</li>
<li>和 keep-alive 搭配使用的一般有：动态组件 和router-view</li>
</ol>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">render () &#123;<br>  <span class="hljs-comment">//</span><br>  function getFirstComponentChild (children: ?Array&lt;VNode&gt;): ?VNode &#123;<br>    <span class="hljs-keyword">if</span> (Array.isArray(children)) &#123;<br>  <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; children.length; i++) &#123;<br>    <span class="hljs-keyword">const</span> c = children[i]<br>    <span class="hljs-keyword">if</span> (isDef(c) &amp;&amp; (isDef(c.componentOptions) || isAsyncPlaceholder(c))) &#123;<br>      <span class="hljs-keyword">return</span> c<br>    &#125;<br>  &#125;<br>  &#125;<br>  &#125;<br>  <span class="hljs-keyword">const</span> slot = <span class="hljs-keyword">this</span>.$slots.default <span class="hljs-comment">// 获取默认插槽</span><br>  <span class="hljs-keyword">const</span> vnode: VNode = getFirstComponentChild(slot)<span class="hljs-comment">// 获取第一个子组件</span><br>  <span class="hljs-keyword">const</span> componentOptions: ?VNodeComponentOptions = vnode &amp;&amp; vnode.componentOptions <span class="hljs-comment">// 组件参数</span><br>  <span class="hljs-keyword">if</span> (componentOptions) &#123; <span class="hljs-comment">// 是否有组件参数</span><br>    <span class="hljs-comment">// check pattern</span><br>    <span class="hljs-keyword">const</span> name: ?string = getComponentName(componentOptions) <span class="hljs-comment">// 获取组件名</span><br>    <span class="hljs-keyword">const</span> &#123; include, exclude &#125; = <span class="hljs-keyword">this</span><br>    <span class="hljs-keyword">if</span> (<br>      <span class="hljs-comment">// not included</span><br>      (include &amp;&amp; (!name || !matches(include, name))) ||<br>      <span class="hljs-comment">// excluded</span><br>      (exclude &amp;&amp; name &amp;&amp; matches(exclude, name))<br>    ) &#123;<br>      <span class="hljs-comment">// 如果不匹配当前组件的名字和include以及exclude</span><br>      <span class="hljs-comment">// 那么直接返回组件的实例</span><br>      <span class="hljs-keyword">return</span> vnode<br>    &#125;<br><br>    <span class="hljs-keyword">const</span> &#123; cache, keys &#125; = <span class="hljs-keyword">this</span><br><br>    <span class="hljs-comment">// 获取这个组件的key</span><br>    <span class="hljs-keyword">const</span> key: ?string = vnode.key == <span class="hljs-literal">null</span><br>      <span class="hljs-comment">// same constructor may get registered as different local components</span><br>      <span class="hljs-comment">// so cid alone is not enough (#3269)</span><br>      ? componentOptions.Ctor.cid + (componentOptions.tag ? `::$&#123;componentOptions.tag&#125;` : <span class="hljs-string">&#x27;&#x27;</span>)<br>      : vnode.key<br><br>    <span class="hljs-keyword">if</span> (cache[key]) &#123;<br>      <span class="hljs-comment">// LRU缓存策略执行</span><br>      vnode.componentInstance = cache[key].componentInstance <span class="hljs-comment">// 组件初次渲染的时候componentInstance为undefined</span><br><br>      <span class="hljs-comment">// make current key freshest</span><br>      remove(keys, key)<br>      keys.push(key)<br>      <span class="hljs-comment">// 根据LRU缓存策略执行，将key从原来的位置移除，然后将这个key值放到最后面</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 在缓存列表里面没有的话，则加入，同时判断当前加入之后，是否超过了max所设定的范围，如果是，则去除</span><br>      <span class="hljs-comment">// 使用时间间隔最长的一个</span><br>      cache[key] = vnode<br>      keys.push(key)<br>      <span class="hljs-comment">// prune oldest entry</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.max &amp;&amp; keys.length &gt; parseInt(<span class="hljs-keyword">this</span>.max)) &#123;<br>        pruneCacheEntry(cache, keys[<span class="hljs-number">0</span>], keys, <span class="hljs-keyword">this</span>._vnode)<br>      &#125;<br>    &#125;<br>    <span class="hljs-comment">// 将组件的keepAlive属性设置为true</span><br>    vnode.<span class="hljs-keyword">data</span>.keepAlive = <span class="hljs-literal">true</span> <span class="hljs-comment">// 作用：判断是否要执行组件的created、mounted生命周期函数</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> vnode || (slot &amp;&amp; slot[<span class="hljs-number">0</span>])<br>&#125;<br></code></pre></td></tr></table></figure>

<p>keep-alive 具体是通过 cache 数组缓存所有组件的 vnode 实例。当 cache 内原有组件被使用时会将该组件 key 从 keys 数组中删除，然后 push 到 keys数组最后，以便清除最不常用组件。</p>
<p><strong>实现步骤：</strong></p>
<ol>
<li>获取 keep-alive 下第一个子组件的实例对象，通过他去获取这个组件的组件名</li>
<li>通过当前组件名去匹配原来 include 和 exclude，判断当前组件是否需要缓存，不需要缓存，直接返回当前组件的实例vNode</li>
<li>需要缓存，判断他当前是否在缓存数组里面：</li>
</ol>
<ul>
<li>存在，则将他原来位置上的 key 给移除，同时将这个组件的 key 放到数组最后面（LRU）</li>
<li>不存在，将组件 key 放入数组，然后判断当前 key数组是否超过 max 所设置的范围，超过，那么削减未使用时间最长的一个组件的 key</li>
</ul>
<ol>
<li>最后将这个组件的 keepAlive 设置为 true</li>
</ol>
<p><strong>（3）keep-alive 本身的创建过程和 patch 过程</strong></p>
<p>缓存渲染的时候，会根据 vnode.componentInstance（首次渲染 vnode.componentInstance 为 undefined） 和 keepAlive 属性判断不会执行组件的 created、mounted 等钩子函数，而是对缓存的组件执行 patch 过程∶ 直接把缓存的 DOM 对象直接插入到目标元素中，完成了数据更新的情况下的渲染过程。</p>
<p><strong>首次渲染</strong></p>
<ul>
<li>组件的首次渲染∶判断组件的 abstract 属性，才往父组件里面挂载 DOM</li>
</ul>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// core/instance/lifecycle</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">initLifecycle</span> (<span class="hljs-params">vm: Component</span>) </span>&#123;<br>  <span class="hljs-keyword">const</span> <span class="hljs-variable constant_">options</span> = vm.<span class="hljs-variable">$options</span><br><br>  <span class="hljs-comment">// locate first non-abstract parent</span><br>  let <span class="hljs-built_in">parent</span> = options.<span class="hljs-built_in">parent</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">parent</span> &amp;&amp; !options.<span class="hljs-keyword">abstract</span>) &#123; <span class="hljs-comment">// 判断组件的abstract属性，才往父组件里面挂载DOM</span><br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">parent</span>.<span class="hljs-variable">$options</span>.<span class="hljs-keyword">abstract</span> &amp;&amp; <span class="hljs-built_in">parent</span>.<span class="hljs-variable">$parent</span>) &#123;<br>      <span class="hljs-built_in">parent</span> = <span class="hljs-built_in">parent</span>.<span class="hljs-variable">$parent</span><br>    &#125;<br>    <span class="hljs-built_in">parent</span>.<span class="hljs-variable">$children</span>.<span class="hljs-title function_ invoke__">push</span>(vm)<br>  &#125;<br><br>  vm.<span class="hljs-variable">$parent</span> = <span class="hljs-built_in">parent</span><br>  vm.<span class="hljs-variable">$root</span> = <span class="hljs-built_in">parent</span> ? <span class="hljs-built_in">parent</span>.<span class="hljs-variable">$root</span> : vm<br><br>  vm.<span class="hljs-variable">$children</span> = []<br>  vm.<span class="hljs-variable">$refs</span> = &#123;&#125;<br><br>  vm._watcher = <span class="hljs-literal">null</span><br>  vm._inactive = <span class="hljs-literal">null</span><br>  vm._directInactive = <span class="hljs-literal">false</span><br>  vm._isMounted = <span class="hljs-literal">false</span><br>  vm._isDestroyed = <span class="hljs-literal">false</span><br>  vm._isBeingDestroyed = <span class="hljs-literal">false</span><br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>判断当前 keepAlive 和 componentInstance 是否存在来判断是否要执行组件 prepatch 还是执行创建 componentlnstance</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> core<span class="hljs-regexp">/vdom/</span>create-component<br>init (vnode: VNodeWithData, hydrating: boolean): ?boolean &#123;<br>    <span class="hljs-keyword">if</span> (<br>      vnode.componentInstance &amp;&amp;<br>      !vnode.componentInstance._isDestroyed &amp;&amp;<br>      vnode.data.keepAlive<br>    ) &#123; <span class="hljs-regexp">//</span> componentInstance在初次是undefined!!!<br>      <span class="hljs-regexp">//</span> kept-alive components, treat as a patch<br>      const mountedNode: any = vnode <span class="hljs-regexp">//</span> work around flow<br>      componentVNodeHooks.prepatch(mountedNode, mountedNode) <span class="hljs-regexp">//</span> prepatch函数执行的是组件更新的过程<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      const child = vnode.componentInstance = createComponentInstanceForVnode(<br>        vnode,<br>        activeInstance<br>      )<br>      child.<span class="hljs-variable">$mount</span>(hydrating ? vnode.elm : undefined, hydrating)<br>    &#125;<br>  &#125;,<br></code></pre></td></tr></table></figure>

<p>prepatch 操作就不会在执行组件的 mounted 和 created 生命周期函数，而是直接将 DOM 插入</p>
<p><strong>（4）LRU （least recently used）缓存策略</strong></p>
<p>LRU 缓存策略∶ 从内存中找出最久未使用的数据并置换新的数据。</p>
<p>LRU（Least rencently used）算法根据数据的历史访问记录来进行淘汰数据，其核心思想是**”如果数据最近被访问过，那么将来被访问的几率也更高”**。 最常见的实现是使用一个链表保存缓存数据，详细算法实现如下∶ </p>
<ul>
<li>新数据插入到链表头部</li>
<li>每当缓存命中（即缓存数据被访问），则将数据移到链表头部</li>
<li>链表满的时候，将链表尾部的数据丢弃。</li>
</ul>
<h3 id="18-nextTick-原理及作用"><a href="#18-nextTick-原理及作用" class="headerlink" title="18. $nextTick 原理及作用"></a>18. $nextTick 原理及作用</h3><p>Vue 的 nextTick 其本质是对 JavaScript 执行原理 EventLoop 的一种应用。</p>
<p>nextTick 的核心是利用了如 Promise 、MutationObserver、setImmediate、setTimeout的原生 JavaScript 方法来模拟对应的微&#x2F;宏任务的实现，本质是为了利用 JavaScript 的这些异步回调任务队列来实现 Vue 框架中自己的异步回调队列。</p>
<p>nextTick 不仅是 Vue 内部的异步队列的调用方法，同时也允许开发者在实际项目中使用这个方法来满足实际应用中对 DOM 更新数据时机的后续逻辑处理</p>
<p>nextTick 是典型的将底层 JavaScript 执行原理应用到具体案例中的示例，引入异步更新队列机制的原因∶</p>
<ul>
<li>如果是同步更新，则多次对一个或多个属性赋值，会频繁触发 UI&#x2F;DOM 的渲染，可以减少一些无用渲染</li>
<li>同时由于 VirtualDOM 的引入，每一次状态发生变化后，状态变化的信号会发送给组件，组件内部使用 VirtualDOM 进行计算得出需要更新的具体的 DOM 节点，然后对 DOM 进行更新操作，每次更新状态后的渲染过程需要更多的计算，而这种无用功也将浪费更多的性能，所以异步渲染变得更加至关重要</li>
</ul>
<p>Vue采用了数据驱动视图的思想，但是在一些情况下，仍然需要操作DOM。有时候，可能遇到这样的情况，DOM1的数据发生了变化，而DOM2需要从DOM1中获取数据，那这时就会发现DOM2的视图并没有更新，这时就需要用到了<code>nextTick</code>了。</p>
<p>由于Vue的DOM操作是异步的，所以，在上面的情况中，就要将DOM2获取数据的操作写在<code>$nextTick</code>中。</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">this.$nextTick(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-comment">// 获取数据的操作...</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<p>所以，在以下情况下，会用到nextTick：</p>
<ul>
<li>在数据变化后执行的某个操作，而这个操作需要使用随数据变化而变化的DOM结构的时候，这个操作就需要方法在<code>nextTick()</code>的回调函数中。</li>
<li>在vue生命周期中，如果在created()钩子进行DOM操作，也一定要放在<code>nextTick()</code>的回调函数中。</li>
</ul>
<p>因为在created()钩子函数中，页面的DOM还未渲染，这时候也没办法操作DOM，所以，此时如果想要操作DOM，必须将操作的代码放在<code>nextTick()</code>的回调函数中。</p>
<h3 id="19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？"><a href="#19-Vue-中给-data-中的对象属性添加一个新的属性时会发生什么？如何解决？" class="headerlink" title="19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？"></a><strong>19. Vue 中给 data 中的对象属性添加一个新的属性时会发生什么？如何解决？</strong></h3><figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span> </span><br><span class="language-xml">   <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">ul</span>&gt;</span></span><br><span class="language-xml">         <span class="hljs-tag">&lt;<span class="hljs-name">li</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;value in obj&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;value&quot;</span>&gt;</span> </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">value</span>&#125;&#125;</span><span class="language-xml"> <span class="hljs-tag">&lt;/<span class="hljs-name">li</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;/<span class="hljs-name">ul</span>&gt;</span> </span><br><span class="language-xml">      <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;addObjB&quot;</span>&gt;</span>添加 obj.b<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span> </span><br><span class="language-xml">   <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123; </span></span><br><span class="language-javascript"><span class="language-xml">       data () &#123; </span></span><br><span class="language-javascript"><span class="language-xml">          <span class="hljs-keyword">return</span> &#123; </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-attr">obj</span>: &#123; </span></span><br><span class="language-javascript"><span class="language-xml">                  <span class="hljs-attr">a</span>: <span class="hljs-string">&#x27;obj.a&#x27;</span> </span></span><br><span class="language-javascript"><span class="language-xml">              &#125; </span></span><br><span class="language-javascript"><span class="language-xml">          &#125; </span></span><br><span class="language-javascript"><span class="language-xml">       &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">       <span class="hljs-attr">methods</span>: &#123; </span></span><br><span class="language-javascript"><span class="language-xml">          addObjB () &#123; </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>.<span class="hljs-property">b</span> = <span class="hljs-string">&#x27;obj.b&#x27;</span> </span></span><br><span class="language-javascript"><span class="language-xml">              <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">obj</span>) </span></span><br><span class="language-javascript"><span class="language-xml">          &#125; </span></span><br><span class="language-javascript"><span class="language-xml">      &#125;</span></span><br><span class="language-javascript"><span class="language-xml">   &#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>点击 button 会发现，obj.b 已经成功添加，但是视图并未刷新。这是因为在Vue实例创建时，obj.b并未声明，因此就没有被Vue转换为响应式的属性，自然就不会触发视图的更新，这时就需要使用Vue的全局 api <strong>$set()：</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">addObjB () (<br>   <span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.obj, <span class="hljs-string">&#x27;b&#x27;</span>, <span class="hljs-string">&#x27;obj.b&#x27;</span>)<br>   console.log(<span class="hljs-keyword">this</span>.obj)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>$set()方法相当于手动的去把obj.b处理成一个响应式的属性，此时视图也会跟着改变了。</p>
<h3 id="20-Vue中封装的数组方法有哪些，其如何实现页面更新"><a href="#20-Vue中封装的数组方法有哪些，其如何实现页面更新" class="headerlink" title="20. Vue中封装的数组方法有哪些，其如何实现页面更新"></a>20. Vue中封装的数组方法有哪些，其如何实现页面更新</h3><p>在Vue中，对响应式处理利用的是Object.defineProperty对数据进行拦截，而这个方法并不能监听到数组内部变化，数组长度变化，数组的截取变化等，所以需要对这些操作进行hack，让Vue能监听到其中的变化。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604019269329-d88e91cf-b33d-4b2d-b014-e5739e9b7dbc.png"  ><span class="image-caption">image.png</span></p>
<p>那Vue是如何实现让这些数组方法实现元素的实时更新的呢，下面是Vue中对这些方法的封装：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-comment">// 缓存数组原型</span><br><span class="hljs-keyword">const</span> arrayProto = Array.prototype;<br><span class="hljs-comment">// 实现 arrayMethods.__proto__ === Array.prototype</span><br>export <span class="hljs-keyword">const</span> arrayMethods = Object.create(arrayProto);<br><span class="hljs-comment">// 需要进行功能拓展的方法</span><br><span class="hljs-keyword">const</span> methodsToPatch = [<br>  <span class="hljs-string">&quot;push&quot;</span>,<br>  <span class="hljs-string">&quot;pop&quot;</span>,<br>  <span class="hljs-string">&quot;shift&quot;</span>,<br>  <span class="hljs-string">&quot;unshift&quot;</span>,<br>  <span class="hljs-string">&quot;splice&quot;</span>,<br>  <span class="hljs-string">&quot;sort&quot;</span>,<br>  <span class="hljs-string">&quot;reverse&quot;</span><br>];<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Intercept mutating methods and emit events</span><br><span class="hljs-comment"> */</span><br>methodsToPatch.forEach(<span class="hljs-keyword">function</span><span class="hljs-params">(method)</span> &#123;<br>  <span class="hljs-comment">// 缓存原生数组方法</span><br>  <span class="hljs-keyword">const</span> original = arrayProto[method];<br>  def(arrayMethods, method, <span class="hljs-keyword">function</span> <span class="hljs-title function_">mutator</span><span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-comment">// 执行并缓存原生数组功能</span><br>    <span class="hljs-keyword">const</span> result = original.apply(<span class="hljs-keyword">this</span>, args);<br>    <span class="hljs-comment">// 响应式处理</span><br>    <span class="hljs-keyword">const</span> ob = <span class="hljs-keyword">this</span>.__ob__;<br>    let inserted;<br>    <span class="hljs-keyword">switch</span> (method) &#123;<br>    <span class="hljs-comment">// push、unshift会新增索引，所以要手动observer</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;push&quot;</span>:<br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;unshift&quot;</span>:<br>        inserted = args;<br>        <span class="hljs-keyword">break</span>;<br>      <span class="hljs-comment">// splice方法，如果传入了第三个参数，也会有索引加入，也要手动observer。</span><br>      <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;splice&quot;</span>:<br>        inserted = args.slice(<span class="hljs-number">2</span>);<br>        <span class="hljs-keyword">break</span>;<br>    &#125;<br>    <span class="hljs-comment">// </span><br>    <span class="hljs-keyword">if</span> (inserted) ob.observeArray(inserted);<span class="hljs-comment">// 获取插入的值，并设置响应式监听</span><br>    <span class="hljs-comment">// notify change</span><br>    ob.dep.notify();<span class="hljs-comment">// 通知依赖更新</span><br>    <span class="hljs-comment">// 返回原生数组方法的执行结果</span><br>    <span class="hljs-keyword">return</span> result;<br>  &#125;);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>简单来说就是，重写了数组中的那些原生方法，首先获取到这个数组的__ob__，也就是它的Observer对象，如果有新的值，就调用observeArray继续对新的值观察变化（也就是通过<code>target__proto__ == arrayMethods</code>来改变了数组实例的型），然后手动调用notify，通知渲染watcher，执行update。</p>
<h3 id="21-Vue-单页应用与多页应用的区别"><a href="#21-Vue-单页应用与多页应用的区别" class="headerlink" title="21. Vue 单页应用与多页应用的区别"></a>21. Vue 单页应用与多页应用的区别</h3><p><strong>概念：</strong></p>
<ul>
<li>SPA单页面应用（SinglePage Web Application），指只有一个主页面的应用，一开始只需要加载一次js、css等相关资源。所有内容都包含在主页面，对每一个功能模块组件化。单页应用跳转，就是切换相关组件，仅仅刷新局部资源。</li>
<li>MPA多页面应用 （MultiPage Application），指有多个独立页面的应用，每个页面必须重复加载js、css等相关资源。多页应用跳转，需要整页资源刷新。</li>
</ul>
<p><strong>区别：</strong></p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1609521413572-54d0bd0f-8ed6-4438-997a-c890e4cd9c5e.jpeg"  ><span class="image-caption">775316ebb4c727f7c8771cc2c06e06dd.jpg</span></p>
<h3 id="22-Vue-template-到-render-的过程"><a href="#22-Vue-template-到-render-的过程" class="headerlink" title="22. Vue template 到 render 的过程"></a>22. Vue template 到 render 的过程</h3><p>vue的模版编译过程主要如下：<strong>template -&gt; ast -&gt; render函数</strong></p>
<p>vue 在模版编译版本的码中会执行 compileToFunctions 将template转化为render函数：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 将模板编译为render函数</span><br>const &#123; render, staticRenderFns &#125; = compile<span class="hljs-constructor">ToFunctions(<span class="hljs-params">template</span>,<span class="hljs-params">options</span><span class="hljs-operator">/</span><span class="hljs-operator">/</span>省略&#125;, <span class="hljs-params">this</span>)</span><br></code></pre></td></tr></table></figure>

<p>CompileToFunctions中的主要逻辑如下∶</p>
<p><strong>（1）调用parse方法将template转化为ast（抽象语法树）</strong></p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">constast = parse(<span class="hljs-keyword">template</span>.trim(), <span class="hljs-keyword">options</span>)<br></code></pre></td></tr></table></figure>

<ul>
<li><strong>parse的目标</strong>：把tamplate转换为AST树，它是一种用 JavaScript对象的形式来描述整个模板。</li>
<li><strong>解析过程</strong>：利用正则表达式顺序解析模板，当解析到开始标签、闭合标签、文本的时候都会分别执行对应的 回调函数，来达到构造AST树的目的。</li>
</ul>
<p>AST元素节点总共三种类型：type为1表示普通元素、2为表达式、3为纯文本</p>
<p><strong>（2）对静态节点做优化</strong></p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-function"><span class="hljs-title">optimize</span><span class="hljs-params">(ast,options)</span></span><br></code></pre></td></tr></table></figure>

<p>这个过程主要分析出哪些是静态节点，给其打一个标记，为后续更新渲染可以直接跳过静态节点做优化</p>
<p>深度遍历AST，查看每个子树的节点元素是否为静态节点或者静态节点根。如果为静态节点，他们生成的DOM永远不会改变，这对运行时模板更新起到了极大的优化作用。</p>
<p><strong>（3）生成代码</strong></p>
<figure class="highlight verilog"><table><tr><td class="code"><pre><code class="hljs verilog"><span class="hljs-keyword">const</span> code = <span class="hljs-keyword">generate</span>(ast, options)<br></code></pre></td></tr></table></figure>

<p>generate将ast抽象语法树编译成 render字符串并将静态部分放到 staticRenderFns 中，最后通过 <code>new Function(`` render``)</code> 生成render函数。</p>
<h3 id="23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"><a href="#23-Vue-data-中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？" class="headerlink" title="23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？"></a>23. Vue data 中某一个属性的值发生改变后，视图会立即同步执行重新渲染吗？</h3><p>不会立即同步执行重新渲染。Vue 实现响应式并不是数据发生变化之后 DOM 立即变化，而是按一定的策略进行 DOM 的更新。Vue 在更新 DOM 时是异步执行的。只要侦听到数据变化， Vue 将开启一个队列，并缓冲在同一事件循环中发生的所有数据变更。</p>
<p>如果同一个watcher被多次触发，只会被推入到队列中一次。这种在缓冲时去除重复数据对于避免不必要的计算和 DOM 操作是非常重要的。然后，在下一个的事件循环tick中，Vue 刷新队列并执行实际（已去重的）工作。</p>
<h3 id="24-简述-mixin、extends-的覆盖逻辑"><a href="#24-简述-mixin、extends-的覆盖逻辑" class="headerlink" title="24. 简述 mixin、extends 的覆盖逻辑"></a>24. 简述 mixin、extends 的覆盖逻辑</h3><p><strong>（1）mixin 和 extends</strong></p>
<p>mixin 和 extends均是用于合并、拓展组件的，两者均通过 mergeOptions 方法实现合并。</p>
<ul>
<li>mixins 接收一个混入对象的数组，其中混入对象可以像正常的实例对象一样包含实例选项，这些选项会被合并到最终的选项中。Mixin 钩子按照传入顺序依次调用，并在调用组件自身的钩子之前被调用。</li>
<li>extends 主要是为了便于扩展单文件组件，接收一个对象或构造函数。</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1609518480272-8cb1af01-a4a8-4d54-91bb-5546aafac510.jpeg?x-oss-process=image/resize,w_1500"  ><span class="image-caption">bb253b1d177f421741af0e7dd0f52b5e.jpg</span></p>
<p><strong>（2）mergeOptions 的执行过程</strong></p>
<ul>
<li>规范化选项（normalizeProps、normalizelnject、normalizeDirectives)</li>
<li>对未合并的选项，进行判断</li>
</ul>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">if</span>(!child._base) &#123;<br>    <span class="hljs-keyword">if</span>(child.extends) &#123;<br>        parent = merge<span class="hljs-constructor">Options(<span class="hljs-params">parent</span>, <span class="hljs-params">child</span>.<span class="hljs-params">extends</span>, <span class="hljs-params">vm</span>)</span><br>    &#125;<br>    <span class="hljs-keyword">if</span>(child.mixins) &#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, l = child.mixins.length; i &lt; l; i++)&#123;<br>            parent = merge<span class="hljs-constructor">Options(<span class="hljs-params">parent</span>, <span class="hljs-params">child</span>.<span class="hljs-params">mixins</span>[<span class="hljs-params">i</span>], <span class="hljs-params">vm</span>)</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<ul>
<li>合并处理。根据一个通用 Vue 实例所包含的选项进行分类逐一判断合并，如 props、data、 methods、watch、computed、生命周期等，将合并结果存储在新定义的 options 对象里。</li>
<li>返回合并结果 options。</li>
</ul>
<h3 id="25-描述下Vue自定义指令"><a href="#25-描述下Vue自定义指令" class="headerlink" title="25. 描述下Vue自定义指令"></a>25. 描述下Vue自定义指令</h3><p>在 Vue2.0 中，代码复用和抽象的主要形式是组件。然而，有的情况下，你仍然需要对普通 DOM 元素进行底层操作，这时候就会用到自定义指令。</p>
<p>一般需要对DOM元素进行底层操作时使用，尽量只用来操作 DOM展示，不修改内部的值。当使用自定义指令直接修改 value 值时绑定v-model的值也不会同步更新；如必须修改可以在自定义指令中使用keydown事件，在vue组件中使用 change事件，回调中修改vue数据; </p>
<p><strong>（1）自定义指令基本内容</strong></p>
<ul>
<li>全局定义：<code>Vue.directive(&quot;focus&quot;,&#123;&#125;)</code></li>
<li>局部定义：<code>directives:&#123;focus:&#123;&#125;&#125;</code></li>
<li>钩子函数：指令定义对象提供钩子函数</li>
</ul>
<p>​    o bind：只调用一次，指令第一次绑定到元素时调用。在这里可以进行一次性的初始化设置。</p>
<p>​    o inSerted：被绑定元素插入父节点时调用（仅保证父节点存在，但不一定已被插入文档中）。</p>
<p>​    o update：所在组件的VNode更新时调用，但是可能发生在其子VNode更新之前调用。指令的值可能发生了改变，也可能没有。但是可以通过比较更新前后的值来忽略不必要的模板更新。</p>
<p>​    o ComponentUpdate：指令所在组件的 VNode及其子VNode全部更新后调用。</p>
<p>​    o unbind：只调用一次，指令与元素解绑时调用。</p>
<ul>
<li>钩子函数参数</li>
</ul>
<p>​    o el：绑定元素</p>
<p>​    o bing： 指令核心对象，描述指令全部信息属性</p>
<p>​    o name</p>
<p>​    o value</p>
<p>​    o oldValue</p>
<p>​    o expression</p>
<p>​    o arg</p>
<p>​    o modifers</p>
<p>​    o vnode  虚拟节点</p>
<p>​    o oldVnode：上一个虚拟节点（更新钩子函数中才有用）</p>
<p><strong>（2）使用场景</strong></p>
<ul>
<li>普通DOM元素进行底层操作的时候，可以使用自定义指令</li>
<li>自定义指令是用来操作DOM的。尽管Vue推崇数据驱动视图的理念，但并非所有情况都适合数据驱动。自定义指令就是一种有效的补充和扩展，不仅可用于定义任何的DOM操作，并且是可复用的。</li>
</ul>
<p><strong>（3）使用案例</strong></p>
<p>初级应用：</p>
<ul>
<li>鼠标聚焦</li>
<li>下拉菜单</li>
<li>相对时间转换</li>
<li>滚动动画</li>
</ul>
<p>高级应用：</p>
<ul>
<li>自定义指令实现图片懒加载</li>
<li>自定义指令集成第三方插件</li>
</ul>
<h3 id="26-子组件可以直接改变父组件的数据吗？"><a href="#26-子组件可以直接改变父组件的数据吗？" class="headerlink" title="26. 子组件可以直接改变父组件的数据吗？"></a>26. 子组件可以直接改变父组件的数据吗？</h3><p>子组件不可以直接改变父组件的数据。这样做主要是为了维护父子组件的单向数据流。每次父级组件发生更新时，子组件中所有的 prop 都将会刷新为最新的值。如果这样做了，Vue 会在浏览器的控制台中发出警告。</p>
<p>Vue提倡单向数据流，即父级 props 的更新会流向子组件，但是反过来则不行。这是为了防止意外的改变父组件状态，使得应用的数据流变得难以理解，导致数据流混乱。如果破坏了单向数据流，当应用复杂时，debug 的成本会非常高。</p>
<p><strong>只能通过</strong> <code>**$emit**</code> <strong>派发一个自定义事件，父组件接收到后，由父组件修改。</strong></p>
<h3 id="27-Vue是如何收集依赖的？"><a href="#27-Vue是如何收集依赖的？" class="headerlink" title="27. Vue是如何收集依赖的？"></a>27. Vue是如何收集依赖的？</h3><p>在初始化 Vue 的每个组件时，会对组件的 data 进行初始化，就会将由普通对象变成响应式对象，在这个过程中便会进行依赖收集的相关逻辑，如下所示∶</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">defieneReactive</span> (<span class="hljs-params">obj, key, val</span>)</span>&#123;<br>  <span class="hljs-keyword">const</span> dep = <span class="hljs-keyword">new</span> Dep();<br>  ...<br>  <span class="hljs-built_in">Object</span>.defineProperty(obj, key, &#123;<br>    ...<br>    <span class="hljs-attribute">get</span>: <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">reactiveGetter</span> (<span class="hljs-params"></span>) </span>&#123;<br>      <span class="hljs-keyword">if</span>(Dep.target)&#123;<br>        dep.depend();<br>        ...<br>      &#125;<br>      <span class="hljs-keyword">return</span> val<br>    &#125;<br>    ...<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>以上只保留了关键代码，主要就是 <code>const dep = new Dep()</code>实例化一个 Dep 的实例，然后在 get 函数中通过 <code>dep.depend()</code> 进行依赖收集。</p>
<p><strong>（1）Dep</strong></p>
<p>Dep是整个依赖收集的核心，其关键代码如下：</p>
<figure class="highlight perl"><table><tr><td class="code"><pre><code class="hljs perl">class Dep &#123;<br>  static target;<br>  subs;<br><br>  constructor () &#123;<br>    ...<br>    this.subs = [];<br>  &#125;<br>  addSub (<span class="hljs-function"><span class="hljs-keyword">sub</span>) </span>&#123;<br>    this.subs.push(<span class="hljs-function"><span class="hljs-keyword">sub</span>)</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">  <span class="hljs-title">removeSub</span> (<span class="hljs-title">sub</span>) </span>&#123;<br>    remove(this.sub, <span class="hljs-function"><span class="hljs-keyword">sub</span>)</span><br><span class="hljs-function">  &#125;</span><br><span class="hljs-function">  <span class="hljs-title">depend</span> () </span>&#123;<br>    <span class="hljs-keyword">if</span>(Dep.target)&#123;<br>      Dep.target.addDep(this)<br>    &#125;<br>  &#125;<br>  notify () &#123;<br>    const subs = this.subds.slice();<br>    <span class="hljs-keyword">for</span>(let i = <span class="hljs-number">0</span>;i &lt; subs.length; i++)&#123;<br>      subs[i].update()<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Dep 是一个 class ，其中有一个关 键的静态属性 static，它指向了一个全局唯一 Watcher，保证了同一时间全局只有一个 watcher 被计算，另一个属性 subs 则是一个 Watcher 的数组，所以 Dep 实际上就是对 Watcher 的管理，再看看 Watcher 的相关代码∶</p>
<p><strong>（2）Watcher</strong></p>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Watcher</span> &#123;<br>  getter;<br>  ...<br>  <span class="hljs-keyword">constructor</span> (vm, expression)&#123;<br>    ...<br>    <span class="hljs-keyword">this</span>.getter = expression;<br>    <span class="hljs-keyword">this</span>.<span class="hljs-keyword">get</span>();<br>  &#125;<br>  <span class="hljs-keyword">get</span> () &#123;<br>    pushTarget(<span class="hljs-keyword">this</span>);<br>    value = <span class="hljs-keyword">this</span>.getter.call(vm, vm)<br>    ...<br>    <span class="hljs-keyword">return</span> value<br>  &#125;<br>  addDep (dep)&#123;<br>        ...<br>    dep.addSub(<span class="hljs-keyword">this</span>)<br>  &#125;<br>  ...<br>&#125;<br>function pushTarget (_target) &#123;<br>  Dep.target = _target<br>&#125;<br></code></pre></td></tr></table></figure>

<p>Watcher 是一个 class，它定义了一些方法，其中和依赖收集相关的主要有 get、addDep 等。</p>
<p><strong>（3）过程</strong></p>
<p>在实例化 Vue 时，依赖收集的相关过程如下∶</p>
<p>初 始 化 状 态 initState ， 这 中 间 便 会 通 过 defineReactive 将数据变成响应式对象，其中的 getter 部分便是用来依赖收集的。</p>
<p>初始化最终会走 mount 过程，其中会实例化 Watcher ，进入 Watcher 中，便会执行 this.get() 方法，</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml">updateComponent =<span class="hljs-function"> <span class="hljs-params">()</span> =&gt;</span> &#123;<br>  vm.<span class="hljs-constructor">_update(<span class="hljs-params">vm</span>.<span class="hljs-params">_render</span>()</span>)<br>&#125;<br><span class="hljs-keyword">new</span> <span class="hljs-constructor">Watcher(<span class="hljs-params">vm</span>, <span class="hljs-params">updateComponent</span>)</span><br></code></pre></td></tr></table></figure>

<p>get 方法中的 pushTarget 实际上就是把 Dep.target 赋值为当前的 watcher。</p>
<p>this.getter.call（vm，vm），这里的 getter 会执行 vm._render() 方法，在这个过程中便会触发数据对象的 getter。那么每个对象值的 getter 都持有一个 dep，在触发 getter 的时候会调用 dep.depend() 方法，也就会执行 Dep.target.addDep(this)。刚才 Dep.target 已经被赋值为 watcher，于是便会执行 addDep 方法，然后走到 dep.addSub() 方法，便将当前的 watcher 订阅到这个数据持有的 dep 的 subs 中，这个目的是为后续数据变化时候能通知到哪些 subs 做准备。所以在 vm._render() 过程中，会触发所有数据的 getter，这样便已经完成了一个依赖收集的过程。</p>
<h3 id="28-对-React-和-Vue-的理解，它们的异同"><a href="#28-对-React-和-Vue-的理解，它们的异同" class="headerlink" title="28. 对 React 和 Vue 的理解，它们的异同"></a>28. 对 React 和 Vue 的理解，它们的异同</h3><p><strong>相似之处：</strong></p>
<ul>
<li>都将注意力集中保持在核心库，而将其他功能如路由和全局状态管理交给相关的库；</li>
<li>都有自己的构建工具，能让你得到一个根据最佳实践设置的项目模板；</li>
<li>都使用了Virtual DOM（虚拟DOM）提高重绘性能；</li>
<li>都有props的概念，允许组件间的数据传递；</li>
<li>都鼓励组件化应用，将应用分拆成一个个功能明确的模块，提高复用性。</li>
</ul>
<p><strong>不同之处 ：</strong></p>
<p><strong>1）数据流</strong></p>
<p>Vue默认支持数据双向绑定，而React一直提倡单向数据流 </p>
<p><strong>2）虚拟DOM</strong></p>
<p>Vue2.x开始引入”Virtual DOM”，消除了和React在这方面的差异，但是在具体的细节还是有各自的特点。 </p>
<ul>
<li>Vue宣称可以更快地计算出Virtual DOM的差异，这是由于它在渲染过程中，会跟踪每一个组件的依赖关系，不需要重新渲染整个组件树。</li>
<li>对于React而言，每当应用的状态被改变时，全部子组件都会重新渲染。当然，这可以通过 PureComponent&#x2F;shouldComponentUpdate这个生命周期方法来进行控制，但Vue将此视为默认的优化。</li>
</ul>
<p><strong>3）组件化</strong></p>
<p>React与Vue最大的不同是模板的编写。</p>
<ul>
<li>Vue鼓励写近似常规HTML的模板。写起来很接近标准 HTML元素，只是多了一些属性。</li>
<li>React推荐你所有的模板通用JavaScript的语法扩展——JSX书写。</li>
</ul>
<p>具体来讲：React中render函数是支持闭包特性的，所以import的组件在render中可以直接调用。但是在Vue中，由于模板中使用的数据都必须挂在 this 上进行一次中转，所以 import 一个组件完了之后，还需要在 components 中再声明下。</p>
<p><strong>4）监听数据变化的实现原理不同</strong></p>
<ul>
<li>Vue 通过 getter&#x2F;setter 以及一些函数的劫持，能精确知道数据变化，不需要特别的优化就能达到很好的性能</li>
<li>React 默认是通过比较引用的方式进行的，如果不优化（PureComponent&#x2F;shouldComponentUpdate）可能导致大量不必要的vDOM的重新渲染。这是因为 Vue 使用的是可变数据，而React更强调数据的不可变。</li>
</ul>
<p><strong>5）高阶组件</strong></p>
<p>react可以通过高阶组件（HOC）来扩展，而Vue需要通过mixins来扩展。</p>
<p>高阶组件就是高阶函数，而React的组件本身就是纯粹的函数，所以高阶函数对React来说易如反掌。相反Vue.js使用HTML模板创建视图组件，这时模板无法有效的编译，因此Vue不能采用HOC来实现。</p>
<p><strong>6）构建工具</strong></p>
<p>两者都有自己的构建工具：</p>
<ul>
<li>React &#x3D;&#x3D;&gt; Create React APP</li>
<li>Vue &#x3D;&#x3D;&gt; vue-cli</li>
</ul>
<p><strong>7）跨平台</strong></p>
<ul>
<li>React &#x3D;&#x3D;&gt; React Native</li>
<li>Vue &#x3D;&#x3D;&gt; Weex</li>
</ul>
<h3 id="29-Vue的优点"><a href="#29-Vue的优点" class="headerlink" title="29. Vue的优点"></a>29. Vue的优点</h3><ul>
<li>轻量级框架：只关注视图层，是一个构建数据的视图集合，大小只有几十 <code>kb</code> ；</li>
<li>简单易学：国人开发，中文文档，不存在语言障碍 ，易于理解和学习；</li>
<li>双向数据绑定：保留了 <code>angular</code> 的特点，在数据操作方面更为简单；</li>
<li>组件化：保留了 <code>react</code> 的优点，实现了 <code>html</code> 的封装和重用，在构建单页面应用方面有着独特的优势；</li>
<li>视图，数据，结构分离：使数据的更改更为简单，不需要进行逻辑代码的修改，只需要操作数据就能完成相关操作；</li>
<li>虚拟DOM：<code>dom</code> 操作是非常耗费性能的，不再使用原生的 <code>dom</code> 操作节点，极大解放 <code>dom</code> 操作，但具体操作的还是 <code>dom</code> 不过是换了另一种方式；</li>
<li>运行速度更快：相比较于 <code>react</code> 而言，同样是操作虚拟 <code>dom</code>，就性能而言， <code>vue</code> 存在很大的优势。</li>
</ul>
<h3 id="30-assets和static的区别"><a href="#30-assets和static的区别" class="headerlink" title="30. assets和static的区别"></a>30. assets和static的区别</h3><p><strong>相同点：</strong> <code>assets</code> 和 <code>static</code> 两个都是存放静态资源文件。项目中所需要的资源文件图片，字体图标，样式文件等都可以放在这两个文件下，这是相同点</p>
<p><strong>不相同点：</strong><code>assets</code> 中存放的静态资源文件在项目打包时，也就是运行 <code>npm run build</code> 时会将 <code>assets</code> 中放置的静态资源文件进行打包上传，所谓打包简单点可以理解为压缩体积，代码格式化。而压缩后的静态资源文件最终也都会放置在 <code>static</code> 文件中跟着 <code>index.html</code> 一同上传至服务器。<code>static</code> 中放置的静态资源文件就不会要走打包压缩格式化等流程，而是直接进入打包好的目录，直接上传至服务器。因为避免了压缩直接进行上传，在打包时会提高一定的效率，但是 <code>static</code> 中的资源文件由于没有进行压缩等操作，所以文件的体积也就相对于 <code>assets</code> 中打包后的文件提交较大点。在服务器中就会占据更大的空间。</p>
<p><strong>建议：</strong> 将项目中 <code>template</code>需要的样式文件js文件等都可以放置在 <code>assets</code> 中，走打包这一流程。减少体积。而项目中引入的第三方的资源文件如<code>iconfoont.css</code> 等文件可以放置在 <code>static</code> 中，因为这些引入的第三方文件已经经过处理，不再需要处理，直接上传。</p>
<h3 id="31-delete和Vue-delete删除数组的区别"><a href="#31-delete和Vue-delete删除数组的区别" class="headerlink" title="31. delete和Vue.delete删除数组的区别"></a>31. delete和Vue.delete删除数组的区别</h3><ul>
<li><code>delete</code> 只是被删除的元素变成了 <code>empty/undefined</code> 其他的元素的键值还是不变。</li>
<li><code>Vue.delete</code> 直接删除了数组 改变了数组的键值。</li>
</ul>
<h3 id="32-vue如何监听对象或者数组某个属性的变化"><a href="#32-vue如何监听对象或者数组某个属性的变化" class="headerlink" title="32. vue如何监听对象或者数组某个属性的变化"></a>32. vue如何监听对象或者数组某个属性的变化</h3><p>当在项目中直接设置数组的某一项的值，或者直接设置对象的某个属性值，这个时候，你会发现页面并没有更新。这是因为Object.defineProperty()限制，监听不到变化。</p>
<p>解决方式：</p>
<ul>
<li>this.$set(你要改变的数组&#x2F;对象，你要改变的位置&#x2F;key，你要改成什么value)</li>
</ul>
<figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.arr, <span class="hljs-number">0</span>, <span class="hljs-string">&quot;OBKoro1&quot;</span>); <span class="hljs-comment">// 改变数组</span><br><span class="hljs-keyword">this</span>.$<span class="hljs-keyword">set</span>(<span class="hljs-keyword">this</span>.obj, <span class="hljs-string">&quot;c&quot;</span>, <span class="hljs-string">&quot;OBKoro1&quot;</span>); <span class="hljs-comment">// 改变对象</span><br></code></pre></td></tr></table></figure>

<ul>
<li>调用以下几个数组的方法</li>
</ul>
<figure class="highlight scss"><table><tr><td class="code"><pre><code class="hljs scss"><span class="hljs-built_in">splice</span>()、 <span class="hljs-built_in">push</span>()、<span class="hljs-built_in">pop</span>()、<span class="hljs-built_in">shift</span>()、<span class="hljs-built_in">unshift</span>()、<span class="hljs-built_in">sort</span>()、<span class="hljs-built_in">reverse</span>()<br></code></pre></td></tr></table></figure>

<p>vue源码里缓存了array的原型链，然后重写了这几个方法，触发这几个方法的时候会observer数据，意思是使用这些方法不用再进行额外的操作，视图自动进行更新。 推荐使用splice方法会比较好自定义,因为splice可以在数组的任何位置进行删除&#x2F;添加操作</p>
<p>vm.<code>$set</code> 的实现原理是：</p>
<ul>
<li>如果目标是数组，直接使用数组的 splice 方法触发相应式；</li>
<li>如果目标是对象，会先判读属性是否存在、对象是否是响应式，最终如果要对属性进行响应式处理，则是通过调用 defineReactive 方法进行响应式处理（ defineReactive 方法就是 Vue 在初始化对象时，给对象属性采用 Object.defineProperty 动态添加 getter 和 setter 的功能所调用的方法）</li>
</ul>
<h3 id="33-什么是-mixin-？"><a href="#33-什么是-mixin-？" class="headerlink" title="33. 什么是 mixin ？"></a>33. 什么是 mixin ？</h3><ul>
<li>Mixin 使我们能够为 Vue 组件编写可插拔和可重用的功能。</li>
<li>如果希望在多个组件之间重用一组组件选项，例如生命周期 hook、 方法等，则可以将其编写为 mixin，并在组件中简单的引用它。</li>
<li>然后将 mixin 的内容合并到组件中。如果你要在 mixin 中定义生命周期 hook，那么它在执行时将优化于组件自已的 hook。</li>
</ul>
<h3 id="34-Vue模版编译原理"><a href="#34-Vue模版编译原理" class="headerlink" title="34. Vue模版编译原理"></a>34. Vue模版编译原理</h3><p>vue中的模板template无法被浏览器解析并渲染，因为这不属于浏览器的标准，不是正确的HTML语法，所有需要将template转化成一个JavaScript函数，这样浏览器就可以执行这一个函数并渲染出对应的HTML元素，就可以让视图跑起来了，这一个转化的过程，就成为模板编译。模板编译又分三个阶段，解析parse，优化optimize，生成generate，最终生成可执行函数render。</p>
<ul>
<li><strong>解析阶段</strong>：使用大量的正则表达式对template字符串进行解析，将标签、指令、属性等转化为抽象语法树AST。</li>
<li><strong>优化阶段</strong>：遍历AST，找到其中的一些静态节点并进行标记，方便在页面重渲染的时候进行diff比较时，直接跳过这一些静态节点，优化runtime的性能。</li>
<li><strong>生成阶段</strong>：将最终的AST转化为render函数字符串。</li>
</ul>
<h3 id="35-对SSR的理解"><a href="#35-对SSR的理解" class="headerlink" title="35. 对SSR的理解"></a>35. 对SSR的理解</h3><p>SSR也就是服务端渲染，也就是将Vue在客户端把标签渲染成HTML的工作放在服务端完成，然后再把html直接返回给客户端</p>
<p>SSR的优势：</p>
<ul>
<li>更好的SEO</li>
<li>首屏加载速度更快</li>
</ul>
<p>SSR的缺点：</p>
<ul>
<li>开发条件会受到限制，服务器端渲染只支持beforeCreate和created两个钩子；</li>
<li>当需要一些外部扩展库时需要特殊处理，服务端渲染应用程序也需要处于Node.js的运行环境；</li>
<li>更多的服务端负载。</li>
</ul>
<h3 id="36-Vue的性能优化有哪些"><a href="#36-Vue的性能优化有哪些" class="headerlink" title="36. Vue的性能优化有哪些"></a>36. Vue的性能优化有哪些</h3><p><strong>（1）编码阶段</strong></p>
<ul>
<li>尽量减少data中的数据，data中的数据都会增加getter和setter，会收集对应的watcher</li>
<li>v-if和v-for不能连用</li>
<li>如果需要使用v-for给每项元素绑定事件时使用事件代理</li>
<li>SPA 页面采用keep-alive缓存组件</li>
<li>在更多的情况下，使用v-if替代v-show</li>
<li>key保证唯一</li>
<li>使用路由懒加载、异步组件</li>
<li>防抖、节流</li>
<li>第三方模块按需导入</li>
<li>长列表滚动到可视区域动态加载</li>
<li>图片懒加载</li>
</ul>
<p><strong>（2）SEO优化</strong></p>
<ul>
<li>预渲染</li>
<li>服务端渲染SSR</li>
</ul>
<p><strong>（3）打包优化</strong></p>
<ul>
<li>压缩代码</li>
<li>Tree Shaking&#x2F;Scope Hoisting</li>
<li>使用cdn加载第三方模块</li>
<li>多线程打包happypack</li>
<li>splitChunks抽离公共文件</li>
<li>sourceMap优化</li>
</ul>
<p><strong>（4）用户体验</strong></p>
<ul>
<li>骨架屏</li>
<li>PWA</li>
<li>还可以使用缓存(客户端缓存、服务端缓存)优化、服务端开启gzip压缩等。</li>
</ul>
<h3 id="37-对-SPA-单页面的理解，它的优缺点分别是什么？"><a href="#37-对-SPA-单页面的理解，它的优缺点分别是什么？" class="headerlink" title="37. 对 SPA 单页面的理解，它的优缺点分别是什么？"></a>37. 对 SPA 单页面的理解，它的优缺点分别是什么？</h3><p>SPA（ single-page application ）仅在 Web 页面初始化时加载相应的 HTML、JavaScript 和 CSS。一旦页面加载完成，SPA 不会因为用户的操作而进行页面的重新加载或跳转；取而代之的是利用路由机制实现 HTML 内容的变换，UI 与用户的交互，避免页面的重新加载。</p>
<p><strong>优点：</strong></p>
<ul>
<li>用户体验好、快，内容的改变不需要重新加载整个页面，避免了不必要的跳转和重复渲染；</li>
<li>基于上面一点，SPA 相对对服务器压力小；</li>
<li>前后端职责分离，架构清晰，前端进行交互逻辑，后端负责数据处理；</li>
</ul>
<p><strong>缺点：</strong></p>
<ul>
<li>初次加载耗时多：为实现单页 Web 应用功能及显示效果，需要在加载页面的时候将 JavaScript、CSS 统一加载，部分页面按需加载；</li>
<li>前进后退路由管理：由于单页应用在一个页面中显示所有的内容，所以不能使用浏览器的前进后退功能，所有的页面切换需要自己建立堆栈管理；</li>
<li>SEO 难度较大：由于所有的内容都在一个页面中动态替换显示，所以在 SEO 上其有着天然的弱势。</li>
</ul>
<h3 id="38-template和jsx的有什么分别？"><a href="#38-template和jsx的有什么分别？" class="headerlink" title="38. template和jsx的有什么分别？"></a>38. template和jsx的有什么分别？</h3><p>对于 runtime 来说，只需要保证组件存在 render 函数即可，而有了预编译之后，只需要保证构建过程中生成 render 函数就可以。在 webpack 中，使用<code>vue-loader</code>编译.vue文件，内部依赖的<code>vue-template-compiler</code>模块，在 webpack 构建过程中，将template预编译成 render 函数。与 react 类似，在添加了jsx的语法糖解析器<code>babel-plugin-transform-vue-jsx</code>之后，就可以直接手写render函数。</p>
<p>所以，template和jsx的都是render的一种表现形式，不同的是：JSX相对于template而言，具有更高的灵活性，在复杂的组件中，更具有优势，而 template 虽然显得有些呆滞。但是 template 在代码结构上更符合视图与逻辑分离的习惯，更简单、更直观、更好维护。</p>
<h3 id="39-vue初始化页面闪动问题"><a href="#39-vue初始化页面闪动问题" class="headerlink" title="39. vue初始化页面闪动问题"></a>39. vue初始化页面闪动问题</h3><p>使用vue开发时，在vue初始化之前，由于div是不归vue管的，所以我们写的代码在还没有解析的情况下会容易出现花屏现象，看到类似于的字样，虽然一般情况下这个时间很短暂，但是还是有必要让解决这个问题的。</p>
<p>首先：在css里加上以下代码：</p>
<figure class="highlight css"><table><tr><td class="code"><pre><code class="hljs css"><span class="hljs-selector-attr">[v-cloak]</span> &#123;<br>    <span class="hljs-attribute">display</span>: none;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>如果没有彻底解决问题，则在根元素加上<code>style=&quot;display: none;&quot; :style=&quot;&#123;display: &#39;block&#39;&#125;&quot;</code></p>
<h3 id="40-extend-有什么作用"><a href="#40-extend-有什么作用" class="headerlink" title="40. extend 有什么作用"></a>40. extend 有什么作用</h3><p>这个 API 很少用到，作用是扩展组件生成一个构造器，通常会与 <code>$mount</code> 一起使用。</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-comment">// 创建组件构造器</span><br>let Component = Vue<span class="hljs-selector-class">.extend</span>(&#123;<br>  template: <span class="hljs-string">&#x27;&lt;div&gt;test&lt;/div&gt;&#x27;</span><br>&#125;)<br><span class="hljs-comment">// 挂载到 #app 上</span><br>new <span class="hljs-built_in">Component</span>().<span class="hljs-variable">$mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br><span class="hljs-comment">// 除了上面的方式，还可以用来扩展已有的组件</span><br>let SuperComponent = Vue<span class="hljs-selector-class">.extend</span>(Component)<br>new <span class="hljs-built_in">SuperComponent</span>(&#123;<br>    <span class="hljs-built_in">created</span>() &#123;<br>        console<span class="hljs-selector-class">.log</span>(<span class="hljs-number">1</span>)<br>    &#125;<br>&#125;)<br>new <span class="hljs-built_in">SuperComponent</span>().<span class="hljs-variable">$mount</span>(<span class="hljs-string">&#x27;#app&#x27;</span>)<br></code></pre></td></tr></table></figure>

<h3 id="41-mixin-和-mixins-区别"><a href="#41-mixin-和-mixins-区别" class="headerlink" title="41. mixin 和 mixins 区别"></a>41. mixin 和 mixins 区别</h3><p><code>mixin</code> 用于全局混入，会影响到每个组件实例，通常插件都是这样做初始化的。</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">Vue.<span class="hljs-keyword">mixin</span>(&#123;<br>    beforeCreate() &#123;<br>        <span class="hljs-comment">// ...逻辑</span><br>        <span class="hljs-comment">// 这种方式会影响到每个组件的 beforeCreate 钩子函数</span><br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>虽然文档不建议在应用中直接使用 <code>mixin</code>，但是如果不滥用的话也是很有帮助的，比如可以全局混入封装好的 <code>ajax</code> 或者一些工具函数等等。</p>
<p><code>mixins</code> 应该是最常使用的扩展组件的方式了。如果多个组件中有相同的业务逻辑，就可以将这些逻辑剥离出来，通过 <code>mixins</code> 混入代码，比如上拉下拉加载数据这种逻辑等等。</p>
<p>另外需要注意的是 <code>mixins</code> 混入的钩子函数会先于组件内的钩子函数执行，并且在遇到同名选项的时候也会有选择性的进行合并。</p>
<h3 id="42-MVVM的优缺点"><a href="#42-MVVM的优缺点" class="headerlink" title="42. MVVM的优缺点**?**"></a>42. <strong>MVVM</strong>的优缺点**?**</h3><p>优点: </p>
<ul>
<li>分离视图（View）和模型（Model），降低代码耦合，提⾼视图或者逻辑的重⽤性: ⽐如视图（View）可以独⽴于Model变化和修改，⼀个ViewModel可以绑定不同的”View”上，当View变化的时候Model不可以不变，当Model变化的时候View也可以不变。你可以把⼀些视图逻辑放在⼀个ViewModel⾥⾯，让很多view重⽤这段视图逻辑 </li>
<li>提⾼可测试性: ViewModel的存在可以帮助开发者更好地编写测试代码 </li>
<li>⾃动更新dom: 利⽤双向绑定,数据更新后视图⾃动更新,让开发者从繁琐的⼿动dom中解放</li>
</ul>
<p>缺点: </p>
<ul>
<li>Bug很难被调试: 因为使⽤双向绑定的模式，当你看到界⾯异常了，有可能是你View的代码有Bug，也可能是Model的代码有问题。数据绑定使得⼀个位置的Bug被快速传递到别的位置，要定位原始出问题的地⽅就变得不那么容易了。另外，数据绑定的声明是指令式地写在View的模版当中的，这些内容是没办法去打断点debug的 </li>
<li>⼀个⼤的模块中model也会很⼤，虽然使⽤⽅便了也很容易保证了数据的⼀致性，当时⻓期持有，不释放内存就造成了花费更多的内存 </li>
<li>对于⼤型的图形应⽤程序，视图状态较多，ViewModel的构建和维护的成本都会⽐较⾼。</li>
</ul>
<h3 id="43-Vue-use的实现原理"><a href="#43-Vue-use的实现原理" class="headerlink" title="43. Vue.use的实现原理"></a>43. Vue.use的实现原理</h3><h2 id="二、生命周期"><a href="#二、生命周期" class="headerlink" title="二、生命周期"></a>二、生命周期</h2><h3 id="1-说一下Vue的生命周期"><a href="#1-说一下Vue的生命周期" class="headerlink" title="1. 说一下Vue的生命周期"></a>1. 说一下Vue的生命周期</h3><p>Vue 实例有⼀个完整的⽣命周期，也就是从开始创建、初始化数据、编译模版、挂载Dom -&gt; 渲染、更新 -&gt; 渲染、卸载 等⼀系列过程，称这是Vue的⽣命周期。 </p>
<ol>
<li><strong>beforeCreate（创建前）</strong>：数据观测和初始化事件还未开始，此时 data 的响应式追踪、event&#x2F;watcher 都还没有被设置，也就是说不能访问到data、computed、watch、methods上的方法和数据。</li>
<li><strong>created****（创建后）</strong> ：实例创建完成，实例上配置的 options 包括 data、computed、watch、methods 等都配置完成，但是此时渲染得节点还未挂载到 DOM，所以不能访问到 <code>$el</code> 属性。</li>
<li><strong>beforeMount（挂载前）</strong>：在挂载开始之前被调用，相关的render函数首次被调用。实例已完成以下的配置：编译模板，把data里面的数据和模板生成html。此时还没有挂载html到页面上。</li>
<li><strong>mounted（挂载后）</strong>：在el被新创建的 vm.$el 替换，并挂载到实例上去之后调用。实例已完成以下的配置：用上面编译好的html内容替换el属性指向的DOM对象。完成模板中的html渲染到html 页面中。此过程中进行ajax交互。</li>
<li><strong>beforeUpdate（更新前）</strong>：响应式数据更新时调用，此时虽然响应式数据更新了，但是对应的真实 DOM 还没有被渲染。</li>
<li><strong>updated（更新后）</strong> ：在由于数据更改导致的虚拟DOM重新渲染和打补丁之后调用。此时 DOM 已经根据响应式数据的变化更新了。调用时，组件 DOM已经更新，所以可以执行依赖于DOM的操作。然而在大多数情况下，应该避免在此期间更改状态，因为这可能会导致更新无限循环。该钩子在服务器端渲染期间不被调用。</li>
<li><strong>beforeDestroy（销毁前）</strong>：实例销毁之前调用。这一步，实例仍然完全可用，<code>this</code> 仍能获取到实例。</li>
<li><strong>destroyed（销毁后）</strong>：实例销毁后调用，调用后，Vue 实例指示的所有东西都会解绑定，所有的事件监听器会被移除，所有的子实例也会被销毁。该钩子在服务端渲染期间不被调用。</li>
</ol>
<p>另外还有 <code>keep-alive</code> 独有的生命周期，分别为 <code>activated</code> 和 <code>deactivated</code> 。用 <code>keep-alive</code> 包裹的组件在切换时不会进行销毁，而是缓存到内存中并执行 <code>deactivated</code> 钩子函数，命中缓存渲染后会执行 <code>activated</code> 钩子函数。</p>
<h3 id="2-Vue-子组件和父组件执行顺序"><a href="#2-Vue-子组件和父组件执行顺序" class="headerlink" title="2. Vue 子组件和父组件执行顺序"></a>2. Vue 子组件和父组件执行顺序</h3><p><strong>加载渲染过程：</strong></p>
<p>1.父组件 beforeCreate</p>
<p>2.父组件 created</p>
<p>3.父组件 beforeMount</p>
<p>4.子组件 beforeCreate</p>
<p>5.子组件 created</p>
<p>6.子组件 beforeMount</p>
<p>7.子组件 mounted</p>
<p>8.父组件 mounted</p>
<p><strong>更新过程：</strong></p>
<p>\1. 父组件 beforeUpdate</p>
<p>2.子组件 beforeUpdate</p>
<p>3.子组件 updated</p>
<p>4.父组件 updated</p>
<p><strong>销毁过程：</strong></p>
<p>\1. 父组件 beforeDestroy</p>
<p>2.子组件 beforeDestroy</p>
<p>3.子组件 destroyed</p>
<p>4.父组件 destoryed</p>
<h3 id="3-created和mounted的区别"><a href="#3-created和mounted的区别" class="headerlink" title="3. created和mounted的区别"></a>3. created和mounted的区别</h3><ul>
<li>created:在模板渲染成html前调用，即通常初始化某些属性值，然后再渲染成视图。</li>
<li>mounted:在模板渲染成html后调用，通常是初始化页面完成后，再对html的dom节点进行一些需要的操作。</li>
</ul>
<h3 id="4-一般在哪个生命周期请求异步数据"><a href="#4-一般在哪个生命周期请求异步数据" class="headerlink" title="4. 一般在哪个生命周期请求异步数据"></a>4. 一般在哪个生命周期请求异步数据</h3><p>我们可以在钩子函数 created、beforeMount、mounted 中进行调用，因为在这三个钩子函数中，data 已经创建，可以将服务端端返回的数据进行赋值。</p>
<p>推荐在 created 钩子函数中调用异步请求，因为在 created 钩子函数中调用异步请求有以下优点：</p>
<ul>
<li>能更快获取到服务端数据，减少页面加载时间，用户体验更好；</li>
<li>SSR不支持 beforeMount 、mounted 钩子函数，放在 created 中有助于一致性。</li>
</ul>
<h3 id="5-keep-alive-中的生命周期哪些"><a href="#5-keep-alive-中的生命周期哪些" class="headerlink" title="5. keep-alive 中的生命周期哪些"></a>5. keep-alive 中的生命周期哪些</h3><p>keep-alive是 Vue 提供的一个内置组件，用来对组件进行缓存——在组件切换过程中将状态保留在内存中，防止重复渲染DOM。</p>
<p>如果为一个组件包裹了 keep-alive，那么它会多出两个生命周期：deactivated、activated。同时，beforeDestroy 和 destroyed 就不会再被触发了，因为组件不会被真正销毁。</p>
<p>当组件被换掉时，会被缓存到内存中、触发 deactivated 生命周期；当组件被切回来时，再去缓存里找这个组件、触发 activated钩子函数。</p>
<h2 id="三、组件通信"><a href="#三、组件通信" class="headerlink" title="三、组件通信"></a>三、组件通信</h2><p>组件通信的方式如下：</p>
<h3 id="（1）-props-x2F-emit"><a href="#（1）-props-x2F-emit" class="headerlink" title="（1） props  &#x2F;  $emit"></a>（1） props  &#x2F;  $emit</h3><p>父组件通过<code>props</code>向子组件传递数据，子组件通过<code>$emit</code>和父组件通信</p>
<h5 id="1-父组件向子组件传值"><a href="#1-父组件向子组件传值" class="headerlink" title="1. 父组件向子组件传值"></a>1. 父组件向子组件传值</h5><ul>
<li><code>props</code>只能是父组件向子组件进行传值，<code>props</code>使得父子组件之间形成了一个单向下行绑定。子组件的数据会随着父组件不断更新。</li>
<li><code>props</code> 可以显示定义一个或一个以上的数据，对于接收的数据，可以是各种数据类型，同样也可以传递一个函数。</li>
<li><code>props</code>属性名规则：若在<code>props</code>中使用驼峰形式，模板中需要使用短横线的形式</li>
</ul>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">// 父组件<br><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;father&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">son</span> <span class="hljs-attr">:msg</span>=<span class="hljs-string">&quot;msgData&quot;</span> <span class="hljs-attr">:fn</span>=<span class="hljs-string">&quot;myFunction&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">son</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> son <span class="hljs-keyword">from</span> <span class="hljs-string">&quot;./son.vue&quot;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">name</span>: father,</span><br><span class="language-javascript">    <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">msgData</span>: <span class="hljs-string">&quot;父组件数据&quot;</span>;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">myFunction</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&quot;vue&quot;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123;</span><br><span class="language-javascript">        son</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;son&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;fn&quot;</span>&gt;</span>按钮<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;son&quot;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&quot;msg&quot;</span>, <span class="hljs-string">&quot;fn&quot;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h5 id="2-子组件向父组件传值"><a href="#2-子组件向父组件传值" class="headerlink" title="2. 子组件向父组件传值"></a>2. 子组件向父组件传值</h5><ul>
<li><code>$emit</code>绑定一个自定义事件，当这个事件被执行的时就会将参数传递给父组件，而父组件通过<code>v-on</code>监听并接收参数。</li>
</ul>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;section&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">com-article</span> <span class="hljs-attr">:articles</span>=<span class="hljs-string">&quot;articleList&quot;</span> @<span class="hljs-attr">onEmitIndex</span>=<span class="hljs-string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com-article</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">currentIndex</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> comArticle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test/article.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;comArticle&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; comArticle &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">currentIndex</span>: -<span class="hljs-number">1</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">articleList</span>: [<span class="hljs-string">&#x27;红楼梦&#x27;</span>, <span class="hljs-string">&#x27;西游记&#x27;</span>, <span class="hljs-string">&#x27;三国演义&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onEmitIndex</span>(<span class="hljs-params">idx</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentIndex</span> = idx</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 父组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;section&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">com-article</span> <span class="hljs-attr">:articles</span>=<span class="hljs-string">&quot;articleList&quot;</span> @<span class="hljs-attr">onEmitIndex</span>=<span class="hljs-string">&quot;onEmitIndex&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">com-article</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">currentIndex</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> comArticle <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test/article.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;comArticle&#x27;</span>,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; comArticle &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">currentIndex</span>: -<span class="hljs-number">1</span>,</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">articleList</span>: [<span class="hljs-string">&#x27;红楼梦&#x27;</span>, <span class="hljs-string">&#x27;西游记&#x27;</span>, <span class="hljs-string">&#x27;三国演义&#x27;</span>]</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onEmitIndex</span>(<span class="hljs-params">idx</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">currentIndex</span> = idx</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">//子组件</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">v-for</span>=<span class="hljs-string">&quot;(item, index) in articles&quot;</span> <span class="hljs-attr">:key</span>=<span class="hljs-string">&quot;index&quot;</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;emitIndex(index)&quot;</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">item</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;articles&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">emitIndex</span>(<span class="hljs-params">index</span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;onEmitIndex&#x27;</span>, index) <span class="hljs-comment">// 触发父组件的方法，并传递参数index</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<h3 id="（2）eventBus事件总线（-emit-x2F-on）"><a href="#（2）eventBus事件总线（-emit-x2F-on）" class="headerlink" title="（2）eventBus事件总线（$emit &#x2F; $on）"></a>（2）eventBus事件总线（$emit &#x2F; $on）</h3><p><code>eventBus</code>事件总线适用于<strong>父子组件</strong>、<strong>非父子组件</strong>等之间的通信，使用步骤如下：</p>
<p><strong>（1）创建事件中心管理组件之间的通信</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// event-bus.js</span><br><br><span class="hljs-keyword">import</span> <span class="hljs-title class_">Vue</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> <span class="hljs-title class_">EventBus</span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Vue</span>()<br></code></pre></td></tr></table></figure>

<p><strong>（2）发送事件</strong></p>
<p>假设有两个兄弟组件<code>firstCom</code>和<code>secondCom</code>：</p>
<figure class="highlight dust"><table><tr><td class="code"><pre><code class="hljs dust"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">first-com</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">first-com</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">second-com</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">second-com</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> firstCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./firstCom.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> secondCom <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./secondCom.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> </span></span><span class="hljs-template-variable">&#123;</span><br><span class="hljs-template-variable">  components: &#123; firstCom, secondCom &#125;</span><span class="language-xml"></span><br><span class="language-xml">&#125;</span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>在<code>firstCom</code>组件中发送事件：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;add&quot;</span>&gt;</span>加法<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span>    <br>  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> &#123;<span class="hljs-title class_">EventBus</span>&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span> <span class="hljs-comment">// 引入事件中心</span></span><br><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">    <span class="hljs-keyword">return</span>&#123;</span><br><span class="language-javascript">      <span class="hljs-attr">num</span>:<span class="hljs-number">0</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;,</span><br><span class="language-javascript">  <span class="hljs-attr">methods</span>:&#123;</span><br><span class="language-javascript">    <span class="hljs-title function_">add</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">      <span class="hljs-title class_">EventBus</span>.$emit(<span class="hljs-string">&#x27;addition&#x27;</span>, &#123;</span><br><span class="language-javascript">        <span class="hljs-attr">num</span>:<span class="hljs-variable language_">this</span>.<span class="hljs-property">num</span>++</span><br><span class="language-javascript">      &#125;)</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript">&#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p><strong>（3）接收事件</strong></p>
<p>在<code>secondCom</code>组件中发送事件：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span>求和: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">count</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; <span class="hljs-title class_">EventBus</span> &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./event-bus.js&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">count</span>: <span class="hljs-number">0</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title class_">EventBus</span>.$on(<span class="hljs-string">&#x27;addition&#x27;</span>, <span class="hljs-function"><span class="hljs-params">param</span> =&gt;</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> = <span class="hljs-variable language_">this</span>.<span class="hljs-property">count</span> + param.<span class="hljs-property">num</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;)</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>在上述代码中，这就相当于将<code>num</code>值存贮在了事件总线中，在其他组件中可以直接访问。事件总线就相当于一个桥梁，不用组件通过它来通信。</p>
<p>虽然看起来比较简单，但是这种方法也有不变之处，如果项目过大，使用这种方式进行通信，后期维护起来会很困难。</p>
<h3 id="（3）依赖注入（project-x2F-inject）"><a href="#（3）依赖注入（project-x2F-inject）" class="headerlink" title="（3）依赖注入（project &#x2F; inject）"></a>（3）依赖注入（project &#x2F; inject）</h3><p>这种方式就是Vue中的<strong>依赖注入</strong>，该方法用于<strong>父子组件之间的通信</strong>。当然这里所说的父子不一定是真正的父子，也可以是祖孙组件，在层数很深的情况下，可以使用这种方法来进行传值。就不用一层一层的传递了。</p>
<p><code>project / inject</code>是Vue提供的两个钩子，和<code>data</code>、<code>methods</code>是同级的。并且<code>project</code>的书写形式和<code>data</code>一样。</p>
<ul>
<li><code>project</code> 钩子用来发送数据或方法</li>
<li><code>inject</code>钩子用来接收数据或方法</li>
</ul>
<p>在父组件中：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart">provide() &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-built_in">num</span>: <span class="hljs-keyword">this</span>.<span class="hljs-built_in">num</span><br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在子组件中：</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle"><span class="hljs-keyword">inject</span>: [<span class="hljs-string">&#x27;num&#x27;</span>]<br></code></pre></td></tr></table></figure>

<p>还可以这样写，这样写就可以访问父组件中的所有属性：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">provide</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">app</span>: <span class="hljs-variable language_">this</span><br>  &#125;;<br>&#125;<br><span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;<br> <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-attr">num</span>: <span class="hljs-number">1</span><br>  &#125;;<br>&#125;<br><br><span class="hljs-attr">inject</span>: [<span class="hljs-string">&#x27;app&#x27;</span>]<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">app</span>.<span class="hljs-property">num</span>)<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong> 依赖注入所提供的属性是<strong>非响应式</strong>的。</p>
<h3 id="（3）ref-x2F-refs"><a href="#（3）ref-x2F-refs" class="headerlink" title="（3）ref &#x2F; $refs"></a>（3）ref &#x2F; $refs</h3><p>这种方式也是实现<strong>父子组件</strong>之间的通信。</p>
<p><code>ref</code>： 这个属性用在子组件上，它的引用就指向了子组件的实例。可以通过实例来访问组件的数据和方法。</p>
<p>在子组件中：</p>
<figure class="highlight haskell"><table><tr><td class="code"><pre><code class="hljs haskell"><span class="hljs-title">export</span> <span class="hljs-keyword">default</span> &#123;<br>  <span class="hljs-class"><span class="hljs-keyword">data</span> () &#123;</span><br><span class="hljs-class">    <span class="hljs-title">return</span> &#123;</span><br><span class="hljs-class">      <span class="hljs-title">name</span>: &#x27;<span class="hljs-type">JavaScript</span>&#x27;</span><br><span class="hljs-class">    &#125;</span><br>  &#125;,<br>  methods: &#123;<br>    sayHello () &#123;<br>      console.log(&#x27;hello&#x27;)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>在父组件中：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">child</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;child&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">component-a</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript">  <span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span><br><span class="language-javascript">  <span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123; child &#125;,</span><br><span class="language-javascript">    mounted () &#123;</span><br><span class="language-javascript">      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-property">name</span>);  <span class="hljs-comment">// JavaScript</span></span><br><span class="language-javascript">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$refs</span>.<span class="hljs-property">child</span>.<span class="hljs-title function_">sayHello</span>();  <span class="hljs-comment">// hello</span></span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  &#125;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="（4）-parent-x2F-children"><a href="#（4）-parent-x2F-children" class="headerlink" title="（4）$parent &#x2F; $children"></a>（4）$parent &#x2F; $children</h3><ul>
<li>使用<code>$parent</code>可以让组件访问父组件的实例（访问的是上一级父组件的属性和方法）</li>
<li>使用<code>$children</code>可以让组件访问子组件的实例，但是，<code>$children</code>并不能保证顺序，并且访问的数据也不是响应式的。</li>
</ul>
<p>在子组件中：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">span</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">message</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">span</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>获取父组件的值为:  </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">parentVal</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">message</span>: <span class="hljs-string">&#x27;Vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">computed</span>:&#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">parentVal</span>(<span class="hljs-params"></span>)&#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">$parent</span>.<span class="hljs-property">msg</span>;</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>在父组件中：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml">// 父组件中</span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;hello_world&quot;</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span>&gt;</span></span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">msg</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">child</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;change&quot;</span>&gt;</span>点击改变子组件值<span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> child <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./child.vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">components</span>: &#123; child &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">data</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-attr">msg</span>: <span class="hljs-string">&#x27;Welcome&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-attr">methods</span>: &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">change</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-comment">// 获取到子组件</span></span></span><br><span class="language-javascript"><span class="language-xml">      <span class="hljs-variable language_">this</span>.<span class="hljs-property">$children</span>[<span class="hljs-number">0</span>].<span class="hljs-property">message</span> = <span class="hljs-string">&#x27;JavaScript&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>在上面的代码中，子组件获取到了父组件的<code>parentVal</code>值，父组件改变了子组件中<code>message</code>的值。</p>
<p><strong>需要注意：</strong></p>
<ul>
<li>通过<code>$parent</code>访问到的是上一级父组件的实例，可以使用<code>$root</code>来访问根组件的实例</li>
<li>在组件中使用<code>$children</code>拿到的是所有的子组件的实例，它是一个数组，并且是无序的</li>
<li>在根组件<code>#app</code>上拿<code>$parent</code>得到的是<code>new Vue()</code>的实例，在这实例上再拿<code>$parent</code>得到的是<code>undefined</code>，而在最底层的子组件拿<code>$children</code>是个空数组</li>
<li><code>$children</code> 的值是<strong>数组</strong>，而<code>$parent</code>是个<strong>对象</strong></li>
</ul>
<h3 id="（5）-attrs-x2F-listeners"><a href="#（5）-attrs-x2F-listeners" class="headerlink" title="（5）$attrs &#x2F; $listeners"></a>（5）$attrs &#x2F; $listeners</h3><p>考虑一种场景，如果A是B组件的父组件，B是C组件的父组件。如果想要组件A给组件C传递数据，这种隔代的数据，该使用哪种方式呢？</p>
<p>如果是用<code>props/$emit</code>来一级一级的传递，确实可以完成，但是比较复杂；如果使用事件总线，在多人开发或者项目较大的时候，维护起来很麻烦；如果使用Vuex，的确也可以，但是如果仅仅是传递数据，那可能就有点浪费了。</p>
<p>针对上述情况，Vue引入了<code>$attrs / $listeners</code>，实现组件之间的跨代通信。</p>
<p>先来看一下<code>inheritAttrs</code>，它的默认值true，继承所有的父组件属性除<code>props</code>之外的所有属性；<code>inheritAttrs：false</code> 只继承class属性 。</p>
<ul>
<li><code>$attrs</code>：继承所有的父组件属性（除了prop传递的属性、class 和 style ），一般用在子组件的子元素上</li>
<li><code>$listeners</code>：该属性是一个对象，里面包含了作用在这个组件上的所有监听器，可以配合 <code>v-on=&quot;$listeners&quot;</code> 将所有的事件监听器指向这个组件的某个特定的子元素。（相当于子组件继承父组件的事件）</li>
</ul>
<p>A组件（<code>APP.vue</code>）：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;app&quot;</span>&gt;</span><br>        //此处监听了两个事件，可以在B组件或者C组件中直接触发 <br>        <span class="hljs-tag">&lt;<span class="hljs-name">child1</span> <span class="hljs-attr">:p-child1</span>=<span class="hljs-string">&quot;child1&quot;</span> <span class="hljs-attr">:p-child2</span>=<span class="hljs-string">&quot;child2&quot;</span> @<span class="hljs-attr">test1</span>=<span class="hljs-string">&quot;onTest1&quot;</span> @<span class="hljs-attr">test2</span>=<span class="hljs-string">&quot;onTest2&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child1</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child1</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child1.vue&#x27;</span>;</span><br><span class="language-javascript"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span><br><span class="language-javascript">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child1</span> &#125;,</span><br><span class="language-javascript">    <span class="hljs-attr">methods</span>: &#123;</span><br><span class="language-javascript">        <span class="hljs-title function_">onTest1</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test1 running&#x27;</span>);</span><br><span class="language-javascript">        &#125;,</span><br><span class="language-javascript">        <span class="hljs-title function_">onTest2</span>(<span class="hljs-params"></span>) &#123;</span><br><span class="language-javascript">            <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;test2 running&#x27;</span>);</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">&#125;;</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<p>B组件（<code>Child1.vue</code>）：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-1&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">pChild1</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$attrs</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">child2</span> <span class="hljs-attr">v-bind</span>=<span class="hljs-string">&quot;$attrs&quot;</span> <span class="hljs-attr">v-on</span>=<span class="hljs-string">&quot;$listeners&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">child2</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> <span class="hljs-title class_">Child2</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./Child2.vue&#x27;</span>;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;pChild1&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">components</span>: &#123; <span class="hljs-title class_">Child2</span> &#125;,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;test1&#x27;</span>); <span class="hljs-comment">// 触发APP.vue中的test1方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>C 组件 (<code>Child2.vue</code>)：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;child-2&quot;</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>props: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">pChild2</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">        <span class="hljs-tag">&lt;<span class="hljs-name">p</span>&gt;</span>$attrs: </span><span class="hljs-template-variable">&#123;&#123;<span class="hljs-name">$attrs</span>&#125;&#125;</span><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">p</span>&gt;</span></span><br><span class="language-xml">    <span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">props</span>: [<span class="hljs-string">&#x27;pChild2&#x27;</span>],</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-attr">inheritAttrs</span>: <span class="hljs-literal">false</span>,</span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">mounted</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">        <span class="hljs-variable language_">this</span>.$emit(<span class="hljs-string">&#x27;test2&#x27;</span>);<span class="hljs-comment">// 触发APP.vue中的test2方法</span></span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>在上述代码中：</p>
<ul>
<li>C组件中能直接触发test的原因在于 B组件调用C组件时 使用 v-on 绑定了<code>$listeners</code> 属性</li>
<li>在B组件中通过v-bind 绑定<code>$attrs</code>属性，C组件可以直接获取到A组件中传递下来的props（除了B组件中props声明的）</li>
</ul>
<h3 id="（6）总结"><a href="#（6）总结" class="headerlink" title="（6）总结"></a>（6）总结</h3><p><strong>（1）父子组件间通信</strong></p>
<ul>
<li>子组件通过 props 属性来接受父组件的数据，然后父组件在子组件上注册监听事件，子组件通过 emit 触发事件来向父组件发送数据。</li>
<li>通过 ref 属性给子组件设置一个名字。父组件通过 $refs 组件名来获得子组件，子组件通过 $parent 获得父组件，这样也可以实现通信。</li>
<li>使用 provide&#x2F;inject，在父组件中通过 provide提供变量，在子组件中通过 inject 来将变量注入到组件中。不论子组件有多深，只要调用了 inject 那么就可以注入 provide中的数据。</li>
</ul>
<p><strong>（2）兄弟组件间通信</strong></p>
<ul>
<li>使用 eventBus 的方法，它的本质是通过创建一个空的 Vue 实例来作为消息传递的对象，通信的组件引入这个实例，通信的组件通过在这个实例上监听和触发事件，来实现消息的传递。</li>
<li>通过 $parent&#x2F;$refs 来获取到兄弟组件，也可以进行通信。</li>
</ul>
<p><strong>（3）任意组件之间</strong></p>
<ul>
<li>使用 eventBus ，其实就是创建一个事件中心，相当于中转站，可以用它来传递事件和接收事件。</li>
</ul>
<p>如果业务逻辑复杂，很多组件之间需要同时处理一些公共的数据，这个时候采用上面这一些方法可能不利于项目的维护。这个时候可以使用 vuex ，vuex 的思想就是将这一些公共的数据抽离出来，将它作为一个全局的变量来管理，然后其他组件就可以对这个公共数据进行读写操作，这样达到了解耦的目的。</p>
<h2 id="四、路由"><a href="#四、路由" class="headerlink" title="四、路由"></a>四、路由</h2><h3 id="1-Vue-Router-的懒加载如何实现"><a href="#1-Vue-Router-的懒加载如何实现" class="headerlink" title="1. Vue-Router 的懒加载如何实现"></a>1. Vue-Router 的懒加载如何实现</h3><p>非懒加载：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">import</span> <span class="hljs-title class_">List</span> <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;@/components/list.vue&#x27;</span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">VueRouter</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>    &#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>, <span class="hljs-attr">component</span>: <span class="hljs-title class_">List</span> &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>（1）方案一(常用)：使用箭头函数+import动态加载</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const List = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> <span class="hljs-keyword">import</span>(<span class="hljs-string">&#x27;@/components/list.vue&#x27;</span>)<br>const router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  routes: [<br>    &#123; path: <span class="hljs-string">&#x27;/list&#x27;</span>, component: List &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>（2）方案二：使用箭头函数+require动态加载</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Router</span>(&#123;<br>  <span class="hljs-attr">routes</span>: [<br>   &#123;<br>     <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>     <span class="hljs-attr">component</span>: <span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> <span class="hljs-built_in">require</span>([<span class="hljs-string">&#x27;@/components/list&#x27;</span>], resolve)<br>   &#125;<br>  ]<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>（3）方案三：使用webpack的require.ensure技术，也可以实现按需加载。 这种情况下，多个路由指定相同的chunkName，会合并打包成一个js文件。</p>
<figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// r就是resolve</span><br><span class="hljs-keyword">const</span> List = r =&gt; <span class="hljs-keyword">require</span>.ensure([], () =&gt; r(<span class="hljs-keyword">require</span>(<span class="hljs-string">&#x27;@/components/list&#x27;</span>)), <span class="hljs-string">&#x27;list&#x27;</span>);<br><span class="hljs-comment">// 路由也是正常的写法  这种是官方推荐的写的 按模块划分懒加载 </span><br><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> Router(&#123;<br>  routes: [<br>  &#123;<br>    path: <span class="hljs-string">&#x27;/list&#x27;</span>,<br>    component: List,<br>    name: <span class="hljs-string">&#x27;list&#x27;</span><br>  &#125;<br> ]<br>&#125;))<br></code></pre></td></tr></table></figure>

<h3 id="2-路由的hash和history模式的区别"><a href="#2-路由的hash和history模式的区别" class="headerlink" title="2. 路由的hash和history模式的区别"></a>2. 路由的hash和history模式的区别</h3><p>Vue-Router有两种模式：<strong>hash模式</strong>和<strong>history模式</strong>。默认的路由模式是hash模式。</p>
<h4 id="1-hash模式"><a href="#1-hash模式" class="headerlink" title="1. hash模式"></a>1. hash模式</h4><p><strong>简介：</strong> hash模式是开发中默认的模式，它的URL带着一个#，例如：<a href="http://www.abc.com/#/vue%EF%BC%8C%E5%AE%83%E7%9A%84hash%E5%80%BC%E5%B0%B1%E6%98%AF%60#/vue%60%E3%80%82">http://www.abc.com/#/vue，它的hash值就是`#/vue`。</a></p>
<p><strong>特点</strong>：hash值会出现在URL里面，但是不会出现在HTTP请求中，对后端完全没有影响。所以改变hash值，不会重新加载页面。这种模式的浏览器支持度很好，低版本的IE浏览器也支持这种模式。hash路由被称为是前端路由，已经成为SPA（单页面应用）的标配。</p>
<p><strong>原理：</strong> hash模式的主要原理就是<strong>onhashchange()事件</strong>：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">window.onhashchange = <span class="hljs-keyword">function</span>(<span class="hljs-params">event</span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(event.oldURL, event.newURL);<br>    let <span class="hljs-built_in">hash</span> = location.<span class="hljs-built_in">hash</span>.<span class="hljs-built_in">slice</span>(<span class="hljs-number">1</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>使用onhashchange()事件的好处就是，在页面的hash值发生变化时，无需向后端发起请求，window就可以监听事件的改变，并按规则加载相应的代码。除此之外，hash值变化对应的URL都会被浏览器记录下来，这样浏览器就能实现页面的前进和后退。虽然是没有请求后端服务器，但是页面的hash值和对应的URL关联起来了。</p>
<h4 id="2-history模式"><a href="#2-history模式" class="headerlink" title="2. history模式"></a>2. history模式</h4><p><strong>简介：</strong> history模式的URL中没有#，它使用的是传统的路由分发模式，即用户在输入一个URL时，服务器会接收这个请求，并解析这个URL，然后做出相应的逻辑处理。</p>
<p><strong>特点：</strong> 当使用history模式时，URL就像这样：<a href="http://abc.com/user/id%E3%80%82%E7%9B%B8%E6%AF%94hash%E6%A8%A1%E5%BC%8F%E6%9B%B4%E5%8A%A0%E5%A5%BD%E7%9C%8B%E3%80%82%E4%BD%86%E6%98%AF%EF%BC%8Chistory%E6%A8%A1%E5%BC%8F%E9%9C%80%E8%A6%81%E5%90%8E%E5%8F%B0%E9%85%8D%E7%BD%AE%E6%94%AF%E6%8C%81%E3%80%82%E5%A6%82%E6%9E%9C%E5%90%8E%E5%8F%B0%E6%B2%A1%E6%9C%89%E6%AD%A3%E7%A1%AE%E9%85%8D%E7%BD%AE%EF%BC%8C%E8%AE%BF%E9%97%AE%E6%97%B6%E4%BC%9A%E8%BF%94%E5%9B%9E404%E3%80%82">http://abc.com/user/id。相比hash模式更加好看。但是，history模式需要后台配置支持。如果后台没有正确配置，访问时会返回404。</a></p>
<p><strong>API：</strong> history api可以分为两大部分，切换历史状态和修改历史状态：</p>
<ul>
<li><strong>修改历史状态</strong>：包括了 HTML5 History Interface 中新增的 <code>pushState()</code> 和 <code>replaceState()</code> 方法，这两个方法应用于浏览器的历史记录栈，提供了对历史记录进行修改的功能。只是当他们进行修改时，虽然修改了url，但浏览器不会立即向后端发送请求。如果要做到改变url但又不刷新页面的效果，就需要前端用上这两个API。</li>
<li><strong>切换历史状态：</strong> 包括<code>forward()</code>、<code>back()</code>、<code>go()</code>三个方法，对应浏览器的前进，后退，跳转操作。</li>
</ul>
<p>虽然history模式丢弃了丑陋的#。但是，它也有自己的缺点，就是在刷新页面的时候，如果没有相应的路由或资源，就会刷出404来。</p>
<p>如果想要切换到history模式，就要进行以下配置（后端也要进行配置）：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">const</span> router = <span class="hljs-keyword">new</span> VueRouter(&#123;<br>  mode: <span class="hljs-string">&#x27;history&#x27;</span>,<br>  routes: [...]<br>&#125;)<br></code></pre></td></tr></table></figure>

<h4 id="3-两种模式对比"><a href="#3-两种模式对比" class="headerlink" title="3. 两种模式对比"></a>3. 两种模式对比</h4><p>调用 history.pushState() 相比于直接修改 hash，存在以下优势:</p>
<ul>
<li>pushState() 设置的新 URL 可以是与当前 URL 同源的任意 URL；而 hash 只可修改 # 后面的部分，因此只能设置与当前 URL 同文档的 URL；</li>
<li>pushState() 设置的新 URL 可以与当前 URL 一模一样，这样也会把记录添加到栈中；而 hash 设置的新值必须与原来不一样才会触发动作将记录添加到栈中；</li>
<li>pushState() 通过 stateObject 参数可以添加任意类型的数据到记录中；而 hash 只可添加短字符串；</li>
<li>pushState() 可额外设置 title 属性供后续使用。</li>
<li>hash模式下，仅hash符号之前的url会被包含在请求中，后端如果没有做到对路由的全覆盖，也不会返回404错误；history模式下，前端的url必须和实际向后端发起请求的url一致，如果没有对用的路由处理，将返回404错误。</li>
</ul>
<p>hash模式和history模式都有各自的优势和缺陷，还是要根据实际情况选择性的使用。</p>
<h3 id="3-如何获取页面的hash变化"><a href="#3-如何获取页面的hash变化" class="headerlink" title="3. 如何获取页面的hash变化"></a>3. 如何获取页面的hash变化</h3><p><strong>（1）监听$route的变化</strong></p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 监听,当路由发生变化的时候执行</span><br>watch: &#123;<br>  <span class="hljs-symbol">$route</span>: &#123;<br>    <span class="hljs-attr">handler</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">val, oldVal</span>)&#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(val);<br>    &#125;,<br>    <span class="hljs-comment">// 深度观察监听</span><br>    deep: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;,<br></code></pre></td></tr></table></figure>

<p><strong>（2）window.location.hash读取#值</strong></p>
<p>window.location.hash 的值可读可写，读取来判断状态是否改变，写入时可以在不重载网页的前提下，添加一条历史访问记录。</p>
<h3 id="4-route-和-router-的区别"><a href="#4-route-和-router-的区别" class="headerlink" title="4. $route 和$router 的区别"></a>4. $route 和$router 的区别</h3><ul>
<li>$route 是“路由信息对象”，包括 path，params，hash，query，fullPath，matched，name 等路由信息参数</li>
<li>$router 是“路由实例”对象包括了路由的跳转方法，钩子函数等。</li>
</ul>
<h3 id="5-如何定义动态路由？如何获取传过来的动态参数？"><a href="#5-如何定义动态路由？如何获取传过来的动态参数？" class="headerlink" title="5. 如何定义动态路由？如何获取传过来的动态参数？"></a>5. 如何定义动态路由？如何获取传过来的动态参数？</h3><p><strong>（1）param方式</strong></p>
<ul>
<li>配置路由格式：<code>/router/:id</code></li>
<li>传递的方式：在path后面跟上对应的值</li>
<li>传递后形成的路径：<code>/router/123</code></li>
</ul>
<p>1）路由定义</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span>在APP.vue中<br>&lt;router-link :to=<span class="hljs-string">&quot;&#x27;/user/&#x27;+userId&quot;</span> replace&gt;用户&lt;/router-link&gt;    <br><br><span class="hljs-regexp">//</span>在index.js<br>&#123;<br>   path: <span class="hljs-string">&#x27;/user/:userid&#x27;</span>,<br>   component: User,<br>&#125;,<br></code></pre></td></tr></table></figure>

<p>2）路由跳转</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> 方法<span class="hljs-number">1</span>：<br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; name: &#x27;users&#x27;, params: &#123; uname: wade &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link<br><br><span class="hljs-regexp">//</span> 方法<span class="hljs-number">2</span>：<br>this.<span class="hljs-variable">$router</span>.push(&#123;name:<span class="hljs-string">&#x27;users&#x27;</span>,params:&#123;uname:wade&#125;&#125;)<br><br><span class="hljs-regexp">//</span> 方法<span class="hljs-number">3</span>：<br>this.<span class="hljs-variable">$router</span>.push(<span class="hljs-string">&#x27;/user/&#x27;</span> + wade)<br></code></pre></td></tr></table></figure>

<p>3）参数获取</p>
<p>通过 <code>$route.params.userid</code> 获取传递的值</p>
<p><strong>（2）query方式</strong></p>
<ul>
<li>配置路由格式：<code>/router</code>，也就是普通配置</li>
<li>传递的方式：对象中使用query的key作为传递方式</li>
<li>传递后形成的路径：<code>/route?id=123</code></li>
</ul>
<p>1）路由定义</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">//方式1：直接在router-link 标签上以对象的形式</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123;path:&#x27;/profile&#x27;,query:&#123;name:&#x27;why&#x27;,age:28,height:188&#125;&#125;&quot;</span>&gt;档案&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方式2：写成按钮以点击事件形式</span><br>&lt;button @click=<span class="hljs-string">&#x27;profileClick&#x27;</span>&gt;我的&lt;/button&gt;    <br><br><span class="hljs-title function_ invoke__">profileClick</span>()&#123;<br>  this.<span class="hljs-variable">$router</span>.<span class="hljs-title function_ invoke__">push</span>(&#123;<br>    <span class="hljs-attr">path</span>: <span class="hljs-string">&quot;/profile&quot;</span>,<br>    <span class="hljs-attr">query</span>: &#123;<br>        <span class="hljs-attr">name</span>: <span class="hljs-string">&quot;kobi&quot;</span>,<br>        <span class="hljs-attr">age</span>: <span class="hljs-string">&quot;28&quot;</span>,<br>        <span class="hljs-attr">height</span>: <span class="hljs-number">198</span><br>    &#125;<br>  &#125;);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>2）跳转方法</p>
<figure class="highlight php"><table><tr><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 方法1：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; name: &#x27;users&#x27;, query: &#123; uname: james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方法2：</span><br>this.<span class="hljs-variable">$router</span>.<span class="hljs-title function_ invoke__">push</span>(&#123; <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;users&#x27;</span>, <span class="hljs-attr">query</span>:&#123; <span class="hljs-attr">uname</span>:james &#125;&#125;)<br><br><span class="hljs-comment">// 方法3：</span><br>&lt;router-link :to=<span class="hljs-string">&quot;&#123; path: &#x27;/user&#x27;, query: &#123; uname:james &#125;&#125;&quot;</span>&gt;按钮&lt;/router-link&gt;<br><br><span class="hljs-comment">// 方法4：</span><br>this.<span class="hljs-variable">$router</span>.<span class="hljs-title function_ invoke__">push</span>(&#123; <span class="hljs-attr">path</span>: <span class="hljs-string">&#x27;/user&#x27;</span>, <span class="hljs-attr">query</span>:&#123; <span class="hljs-attr">uname</span>:james &#125;&#125;)<br><br><span class="hljs-comment">// 方法5：</span><br>this.<span class="hljs-variable">$router</span>.<span class="hljs-title function_ invoke__">push</span>(<span class="hljs-string">&#x27;/user?uname=&#x27;</span> + jsmes)<br></code></pre></td></tr></table></figure>

<p>3）获取参数</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">通过<span class="hljs-variable">$route</span><span class="hljs-selector-class">.query</span> 获取传递的值<br></code></pre></td></tr></table></figure>

<h3 id="6-Vue-router-路由钩子在生命周期的体现"><a href="#6-Vue-router-路由钩子在生命周期的体现" class="headerlink" title="6. Vue-router 路由钩子在生命周期的体现"></a>6. Vue-router 路由钩子在生命周期的体现</h3><p>一、Vue-Router导航守卫</p>
<p>有的时候，需要通过路由来进行一些操作，比如最常见的登录权限验证，当用户满足条件时，才让其进入导航，否则就取消跳转，并跳到登录页面让其登录。</p>
<p>为此有很多种方法可以植入路由的导航过程：全局的，单个路由独享的，或者组件级的</p>
<ol>
<li>全局路由钩子</li>
</ol>
<p>vue-router全局有三个路由钩子;</p>
<ul>
<li>router.beforeEach 全局前置守卫 进入路由之前</li>
<li>router.beforeResolve 全局解析守卫（2.5.0+）在 beforeRouteEnter 调用之后调用</li>
<li>router.afterEach 全局后置钩子 进入路由之后</li>
</ul>
<p>具体使用∶</p>
<ul>
<li>beforeEach（判断是否登录了，没登录就跳转到登录页）</li>
</ul>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">router.beforeEach((to, from, <span class="hljs-keyword">next</span>) =&gt; &#123;  <br>    let ifInfo = Vue.prototype.<span class="hljs-variable">$common</span>.getSession(<span class="hljs-string">&#x27;userData&#x27;</span>);  <span class="hljs-regexp">//</span> 判断是否登录的存储信息<br>    <span class="hljs-keyword">if</span> (!ifInfo) &#123; <br>        <span class="hljs-regexp">//</span> sessionStorage里没有储存user信息    <br>        <span class="hljs-keyword">if</span> (to.path == <span class="hljs-string">&#x27;/&#x27;</span>) &#123; <br>            <span class="hljs-regexp">//</span>如果是登录页面路径，就直接<span class="hljs-keyword">next</span>()      <br>            <span class="hljs-keyword">next</span>();    <br>        &#125; <span class="hljs-keyword">else</span> &#123; <br>            <span class="hljs-regexp">//</span>不然就跳转到登录      <br>            Message.warning(<span class="hljs-string">&quot;请重新登录！&quot;</span>);     <br>            window.location.href = Vue.prototype.<span class="hljs-variable">$loginUrl</span>;    <br>        &#125;  <br>    &#125; <span class="hljs-keyword">else</span> &#123;    <br>        return <span class="hljs-keyword">next</span>();  <br>    &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<ul>
<li>afterEach （跳转之后滚动条回到顶部）</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">router.<span class="hljs-title function_">afterEach</span>(<span class="hljs-function">(<span class="hljs-params">to, <span class="hljs-keyword">from</span></span>) =&gt;</span> &#123;  <br>    <span class="hljs-comment">// 跳转之后滚动条回到顶部  </span><br>    <span class="hljs-variable language_">window</span>.<span class="hljs-title function_">scrollTo</span>(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<ol>
<li>单个路由独享钩子</li>
</ol>
<p><strong>beforeEnter</strong></p>
<p>如果不想全局配置守卫的话，可以为某些路由单独配置守卫，有三个参数∶ to、from、next</p>
<figure class="highlight moonscript"><table><tr><td class="code"><pre><code class="hljs moonscript"><span class="hljs-keyword">export</span> default [    <br>    &#123;        <br>        <span class="hljs-name">path</span>: <span class="hljs-string">&#x27;/&#x27;</span>,        <br>        <span class="hljs-name">name</span>: <span class="hljs-string">&#x27;login&#x27;</span>,        <br>        <span class="hljs-name">component</span>: login,        <br>        <span class="hljs-name">beforeEnter</span>: <span class="hljs-function"><span class="hljs-params">(to, <span class="hljs-keyword">from</span>, <span class="hljs-built_in">next</span>)</span> =&gt;</span> &#123;          <br>            console.log(<span class="hljs-string">&#x27;即将进入登录页面&#x27;</span>)          <br>            <span class="hljs-built_in">next</span>()        <br>        &#125;    <br>    &#125;<br>]<br></code></pre></td></tr></table></figure>

<ol>
<li>组件内钩子</li>
</ol>
<p>beforeRouteUpdate、beforeRouteEnter、beforeRouteLeave</p>
<p>这三个钩子都有三个参数∶to、from、next</p>
<ul>
<li>beforeRouteEnter∶ 进入组件前触发</li>
<li>beforeRouteUpdate∶ 当前地址改变并且改组件被复用时触发，举例来说，带有动态参数的路径foo&#x2F;∶id，在 &#x2F;foo&#x2F;1 和 &#x2F;foo&#x2F;2 之间跳转的时候，由于会渲染同样的foa组件，这个钩子在这种情况下就会被调用</li>
<li>beforeRouteLeave∶ 离开组件被调用</li>
</ul>
<p>注意点，beforeRouteEnter组件内还访问不到this，因为该守卫执行前组件实例还没有被创建，需要传一个回调给 next来访问，例如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title function_">beforeRouteEnter</span>(<span class="hljs-params">to, <span class="hljs-keyword">from</span>, next</span>) &#123;      <br>    <span class="hljs-title function_">next</span>(<span class="hljs-function"><span class="hljs-params">target</span> =&gt;</span> &#123;        <br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">from</span>.<span class="hljs-property">path</span> == <span class="hljs-string">&#x27;/classProcess&#x27;</span>) &#123;          <br>            target.<span class="hljs-property">isFromProcess</span> = <span class="hljs-literal">true</span>        <br>        &#125;      <br>    &#125;)    <br>&#125;<br></code></pre></td></tr></table></figure>

<p>二、Vue路由钩子在生命周期函数的体现</p>
<ol>
<li>完整的路由导航解析流程（不包括其他生命周期）</li>
</ol>
<ul>
<li>触发进入其他路由。</li>
<li>调用要离开路由的组件守卫beforeRouteLeave</li>
<li>调用局前置守卫∶ beforeEach</li>
<li>在重用的组件里调用 beforeRouteUpdate</li>
<li>调用路由独享守卫 beforeEnter。</li>
<li>解析异步路由组件。</li>
<li>在将要进入的路由组件中调用 beforeRouteEnter</li>
<li>调用全局解析守卫 beforeResolve</li>
<li>导航被确认。</li>
<li>调用全局后置钩子的 afterEach 钩子。</li>
<li>触发DOM更新（mounted）。</li>
<li>执行beforeRouteEnter 守卫中传给 next 的回调函数</li>
</ul>
<ol>
<li>触发钩子的完整顺序</li>
</ol>
<p>路由导航、keep-alive、和组件生命周期钩子结合起来的，触发顺序，假设是从a组件离开，第一次进入b组件∶</p>
<ul>
<li>beforeRouteLeave：路由组件的组件离开路由前钩子，可取消路由离开。</li>
<li>beforeEach：路由全局前置守卫，可用于登录验证、全局路由loading等。</li>
<li>beforeEnter：路由独享守卫</li>
<li>beforeRouteEnter：路由组件的组件进入路由前钩子。</li>
<li>beforeResolve：路由全局解析守卫</li>
<li>afterEach：路由全局后置钩子</li>
<li>beforeCreate：组件生命周期，不能访问tAis。</li>
<li>created;组件生命周期，可以访问tAis，不能访问dom。</li>
<li>beforeMount：组件生命周期</li>
<li>deactivated：离开缓存组件a，或者触发a的beforeDestroy和destroyed组件销毁钩子。</li>
<li>mounted：访问&#x2F;操作dom。</li>
<li>activated：进入缓存组件，进入a的嵌套子组件（如果有的话）。</li>
<li>执行beforeRouteEnter回调函数next。</li>
</ul>
<ol>
<li>导航行为被触发到导航完成的整个过程</li>
</ol>
<ul>
<li>导航行为被触发，此时导航未被确认。</li>
<li>在失活的组件里调用离开守卫 beforeRouteLeave。</li>
<li>调用全局的 beforeEach守卫。</li>
<li>在重用的组件里调用 beforeRouteUpdate 守卫(2.2+)。</li>
<li>在路由配置里调用 beforeEnteY。 </li>
<li>解析异步路由组件（如果有）。</li>
<li>在被激活的组件里调用 beforeRouteEnter。</li>
<li>调用全局的 beforeResolve 守卫（2.5+），标示解析阶段完成。</li>
<li>导航被确认。</li>
<li>调用全局的 afterEach 钩子。</li>
<li>非重用组件，开始组件实例的生命周期：beforeCreate&amp;created、beforeMount&amp;mounted</li>
<li>触发 DOM 更新。</li>
<li>用创建好的实例调用 beforeRouteEnter守卫中传给 next 的回调函数。</li>
<li>导航完成</li>
</ul>
<h3 id="7-Vue-router跳转和location-href有什么区别"><a href="#7-Vue-router跳转和location-href有什么区别" class="headerlink" title="7. Vue-router跳转和location.href有什么区别"></a>7. Vue-router跳转和location.href有什么区别</h3><ul>
<li>使用 <code>location.href= /url </code>来跳转，简单方便，但是刷新了页面；</li>
<li>使用 <code>history.pushState( /url )</code> ，无刷新页面，静态跳转；</li>
<li>引进 router ，然后使用 <code>router.push( /url )</code> 来跳转，使用了 <code>diff</code> 算法，实现了按需加载，减少了 dom 的消耗。其实使用 router 跳转和使用 <code>history.pushState()</code> 没什么差别的，因为vue-router就是用了 <code>history.pushState()</code> ，尤其是在history模式下。</li>
</ul>
<h3 id="8-params和query的区别"><a href="#8-params和query的区别" class="headerlink" title="8. params和query的区别"></a>8. params和query的区别</h3><p><strong>用法</strong>：query要用path来引入，params要用name来引入，接收参数都是类似的，分别是 <code>this.$route.query.name</code> 和 <code>this.$route.params.name</code> 。</p>
<p><strong>url地址显示</strong>：query更加类似于ajax中get传参，params则类似于post，说的再简单一点，前者在浏览器地址栏中显示参数，后者则不显示</p>
<p><strong>注意</strong>：query刷新不会丢失query里面的数据 params刷新会丢失 params里面的数据。</p>
<h3 id="9-Vue-router-导航守卫有哪些"><a href="#9-Vue-router-导航守卫有哪些" class="headerlink" title="9. Vue-router 导航守卫有哪些"></a>9. Vue-router 导航守卫有哪些</h3><ul>
<li>全局前置&#x2F;钩子：beforeEach、beforeResolve、afterEach</li>
<li>路由独享的守卫：beforeEnter</li>
<li>组件内的守卫：beforeRouteEnter、beforeRouteUpdate、beforeRouteLeave</li>
</ul>
<h3 id="10-对前端路由的理解"><a href="#10-对前端路由的理解" class="headerlink" title="10. 对前端路由的理解"></a>10. 对前端路由的理解</h3><p>在前端技术早期，一个 url 对应一个页面，如果要从 A 页面切换到 B 页面，那么必然伴随着页面的刷新。这个体验并不好，不过在最初也是无奈之举——用户只有在刷新页面的情况下，才可以重新去请求数据。</p>
<p>后来，改变发生了——Ajax 出现了，它允许人们在不刷新页面的情况下发起请求；与之共生的，还有“不刷新页面即可更新页面内容”这种需求。在这样的背景下，出现了 <strong>SPA（单页面应用</strong>）。</p>
<p>SPA极大地提升了用户体验，它允许页面在不刷新的情况下更新页面内容，使内容的切换更加流畅。但是在 SPA 诞生之初，人们并没有考虑到“定位”这个问题——在内容切换前后，页面的 URL 都是一样的，这就带来了两个问题：</p>
<ul>
<li>SPA 其实并不知道当前的页面“进展到了哪一步”。可能在一个站点下经过了反复的“前进”才终于唤出了某一块内容，但是此时只要刷新一下页面，一切就会被清零，必须重复之前的操作、才可以重新对内容进行定位——SPA 并不会“记住”你的操作。</li>
<li>由于有且仅有一个 URL 给页面做映射，这对 SEO 也不够友好，搜索引擎无法收集全面的信息</li>
</ul>
<p>为了解决这个问题，前端路由出现了。</p>
<p>前端路由可以帮助我们在仅有一个页面的情况下，“记住”用户当前走到了哪一步——为 SPA 中的各个视图匹配一个唯一标识。这意味着用户前进、后退触发的新内容，都会映射到不同的 URL 上去。此时即便他刷新页面，因为当前的 URL 可以标识出他所处的位置，因此内容也不会丢失。</p>
<p>那么如何实现这个目的呢？首先要解决两个问题：</p>
<ul>
<li>当用户刷新页面时，浏览器会默认根据当前 URL 对资源进行重新定位（发送请求）。这个动作对 SPA 是不必要的，因为我们的 SPA 作为单页面，无论如何也只会有一个资源与之对应。此时若走正常的请求-刷新流程，反而会使用户的前进后退操作无法被记录。</li>
<li>单页面应用对服务端来说，就是一个URL、一套资源，那么如何做到用“不同的URL”来映射不同的视图内容呢？</li>
</ul>
<p>从这两个问题来看，服务端已经完全救不了这个场景了。所以要靠咱们前端自力更生，不然怎么叫“前端路由”呢？作为前端，可以提供这样的解决思路：</p>
<ul>
<li>拦截用户的刷新操作，避免服务端盲目响应、返回不符合预期的资源内容。把刷新这个动作完全放到前端逻辑里消化掉。</li>
<li>感知 URL 的变化。这里不是说要改造 URL、凭空制造出 N 个 URL 来。而是说 URL 还是那个 URL，只不过我们可以给它做一些微小的处理——这些处理并不会影响 URL 本身的性质，不会影响服务器对它的识别，只有我们前端感知的到。一旦我们感知到了，我们就根据这些变化、用 JS 去给它生成不同的内容。</li>
</ul>
<h2 id="五、Vuex"><a href="#五、Vuex" class="headerlink" title="五、Vuex"></a>五、Vuex</h2><h3 id="1-Vuex-的原理"><a href="#1-Vuex-的原理" class="headerlink" title="1. Vuex 的原理"></a>1. Vuex 的原理</h3><p>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。每一个 Vuex 应用的核心就是 store（仓库）。“store” 基本上就是一个容器，它包含着你的应用中大部分的状态 ( state )。</p>
<ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化。</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/jpeg/1500604/1609522434579-ff590978-32e1-4cf5-bbbd-d8caf932f8d6.jpeg"  ><span class="image-caption">b025e120ca3d0bd2ded3d038d58cacf4.jpg</span></p>
<p>Vuex为Vue Components建立起了一个完整的生态圈，包括开发中的API调用一环。 </p>
<p><strong>（1）核心流程中的主要功能：</strong></p>
<ul>
<li>Vue Components 是 vue 组件，组件会触发（dispatch）一些事件或动作，也就是图中的 Actions;</li>
<li>在组件中发出的动作，肯定是想获取或者改变数据的，但是在 vuex 中，数据是集中管理的，不能直接去更改数据，所以会把这个动作提交（Commit）到 Mutations 中;</li>
<li>然后 Mutations 就去改变（Mutate）State 中的数据;</li>
<li>当 State 中的数据被改变之后，就会重新渲染（Render）到 Vue Components 中去，组件展示更新后的数据，完成一个流程。</li>
</ul>
<p><strong>（2）各模块在核心流程中的主要功能：</strong></p>
<ul>
<li><code>Vue Components</code>∶ Vue组件。HTML页面上，负责接收用户操作等交互行为，执行dispatch方法触发对应action进行回应。</li>
<li><code>dispatch</code>∶操作行为触发方法，是唯一能执行action的方法。</li>
<li><code>actions</code>∶ 操作行为处理模块。负责处理Vue Components接收到的所有交互行为。包含同步&#x2F;异步操作，支持多个同名方法，按照注册的顺序依次触发。向后台API请求的操作就在这个模块中进行，包括触发其他action以及提交mutation的操作。该模块提供了Promise的封装，以支持action的链式触发。</li>
<li><code>commit</code>∶状态改变提交操作方法。对mutation进行提交，是唯一能执行mutation的方法。</li>
<li><code>mutations</code>∶状态改变操作方法。是Vuex修改state的唯一推荐方法，其他修改方式在严格模式下将会报错。该方法只能进行同步操作，且方法名只能全局唯一。操作之中会有一些hook暴露出来，以进行state的监控等。</li>
<li><code>state</code>∶ 页面状态管理容器对象。集中存储Vuecomponents中data对象的零散数据，全局唯一，以进行统一的状态管理。页面显示所需的数据从该对象中进行读取，利用Vue的细粒度数据响应机制来进行高效的状态更新。</li>
<li><code>getters</code>∶ state对象读取方法。图中没有单独列出该模块，应该被包含在了render中，Vue Components通过该方法读取全局state对象。</li>
</ul>
<h3 id="2-Vuex中action和mutation的区别"><a href="#2-Vuex中action和mutation的区别" class="headerlink" title="2. Vuex中action和mutation的区别"></a>2. Vuex中action和mutation的区别</h3><p>mutation中的操作是一系列的同步函数，用于修改state中的变量的的状态。当使用vuex时需要通过commit来提交需要操作的内容。mutation 非常类似于事件：每个 mutation 都有一个字符串的 事件类型 (type) 和 一个 回调函数 (handler)。这个回调函数就是实际进行状态更改的地方，并且它会接受 state 作为第一个参数：</p>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>: &#123;<br>    count: <span class="hljs-number">1</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (<span class="hljs-keyword">state</span>) &#123;<br>      <span class="hljs-keyword">state</span>.count++      // 变更状态<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>当触发一个类型为 increment 的 mutation 时，需要调用此函数：</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql">store.<span class="hljs-keyword">commit</span>(<span class="hljs-string">&#x27;increment&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>而Action类似于mutation，不同点在于：</p>
<ul>
<li>Action 可以包含任意异步操作。</li>
<li>Action 提交的是 mutation，而不是直接变更状态。</li>
</ul>
<figure class="highlight pf"><table><tr><td class="code"><pre><code class="hljs pf"><span class="hljs-keyword">const</span> store = new Vuex.Store(&#123;<br>  <span class="hljs-keyword">state</span>: &#123;<br>    count: <span class="hljs-number">0</span><br>  &#125;,<br>  mutations: &#123;<br>    increment (<span class="hljs-keyword">state</span>) &#123;<br>      <span class="hljs-keyword">state</span>.count++<br>    &#125;<br>  &#125;,<br>  actions: &#123;<br>    increment (context) &#123;<br>      context.commit(&#x27;increment&#x27;)<br>    &#125;<br>  &#125;<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。</p>
<p>所以，两者的不同点如下：</p>
<ul>
<li>Mutation专注于修改State，理论上是修改State的唯一途径；Action业务代码、异步请求。</li>
<li>Mutation：必须同步执行；Action：可以异步，但不能直接操作State。</li>
<li>在视图更新时，先触发actions，actions再触发mutation</li>
<li>mutation的参数是state，它包含store中的数据；store的参数是context，它是 state 的父级，包含 state、getters</li>
</ul>
<h3 id="3-Vuex-和-localStorage-的区别"><a href="#3-Vuex-和-localStorage-的区别" class="headerlink" title="3. Vuex 和 localStorage 的区别"></a>3. Vuex 和 localStorage 的区别</h3><p><strong>（1）最重要的区别</strong></p>
<ul>
<li>vuex存储在内存中</li>
<li>localstorage 则以文件的方式存储在本地，只能存储字符串类型的数据，存储对象需要 JSON的stringify和parse方法进行处理。 读取内存比读取硬盘速度要快</li>
</ul>
<p><strong>（2）应用场景</strong></p>
<ul>
<li>Vuex 是一个专为 Vue.js 应用程序开发的状态管理模式。它采用集中式存储管理应用的所有组件的状态，并以相应的规则保证状态以一种可预测的方式发生变化。vuex用于组件之间的传值。</li>
<li>localstorage是本地存储，是将数据存储到浏览器的方法，一般是在跨页面传递数据时使用 。</li>
<li>Vuex能做到数据的响应式，localstorage不能</li>
</ul>
<p><strong>（3）永久性</strong></p>
<p>刷新页面时vuex存储的值会丢失，localstorage不会。</p>
<p><strong>注意：</strong>对于不变的数据确实可以用localstorage可以代替vuex，但是当两个组件共用一个数据源（对象或数组）时，如果其中一个组件改变了该数据源，希望另一个组件响应该变化时，localstorage无法做到，原因就是区别1。</p>
<h3 id="4-Redux-和-Vuex-有什么区别，它们的共同思想"><a href="#4-Redux-和-Vuex-有什么区别，它们的共同思想" class="headerlink" title="4. Redux 和 Vuex 有什么区别，它们的共同思想"></a>4. Redux 和 Vuex 有什么区别，它们的共同思想</h3><p><strong>（1）Redux 和 Vuex区别</strong></p>
<ul>
<li>Vuex改进了Redux中的Action和Reducer函数，以mutations变化函数取代Reducer，无需switch，只需在对应的mutation函数里改变state值即可</li>
<li>Vuex由于Vue自动重新渲染的特性，无需订阅重新渲染函数，只要生成新的State即可</li>
<li>Vuex数据流的顺序是∶View调用store.commit提交对应的请求到Store中对应的mutation函数-&gt;store改变（vue检测到数据变化自动渲染）</li>
</ul>
<p>通俗点理解就是，vuex 弱化 dispatch，通过commit进行 store状态的一次更变;取消了action概念，不必传入特定的 action形式进行指定变更;弱化reducer，基于commit参数直接对数据进行转变，使得框架更加简易; </p>
<p><strong>（2）共同思想</strong></p>
<ul>
<li>单—的数据源 </li>
<li>变化可以预测</li>
</ul>
<p>本质上：redux与vuex都是对mvvm思想的服务，将数据从视图中抽离的一种方案;</p>
<p>形式上：vuex借鉴了redux，将store作为全局的数据中心，进行mode管理;</p>
<h3 id="5-为什么要用-Vuex-或者-Redux"><a href="#5-为什么要用-Vuex-或者-Redux" class="headerlink" title="5. 为什么要用 Vuex 或者 Redux"></a>5. 为什么要用 Vuex 或者 Redux</h3><p>由于传参的方法对于多层嵌套的组件将会非常繁琐，并且对于兄弟组件间的状态传递无能为力。我们经常会采用父子组件直接引用或者通过事件来变更和同步状态的多份拷贝。以上的这些模式非常脆弱，通常会导致代码无法维护。</p>
<p>所以需要把组件的共享状态抽取出来，以一个全局单例模式管理。在这种模式下，组件树构成了一个巨大的”视图”，不管在树的哪个位置，任何组件都能获取状态或者触发行为。</p>
<p>另外，通过定义和隔离状态管理中的各种概念并强制遵守一定的规则，代码将会变得更结构化且易维护。</p>
<h3 id="6-Vuex有哪几种属性？"><a href="#6-Vuex有哪几种属性？" class="headerlink" title="6. Vuex有哪几种属性？"></a>6. Vuex有哪几种属性？</h3><p>有五种，分别是 State、 Getter、Mutation 、Action、 Module</p>
<ul>
<li>state &#x3D;&gt; 基本数据(数据源存放地)</li>
<li>getters &#x3D;&gt; 从基本数据派生出来的数据</li>
<li>mutations &#x3D;&gt; 提交更改数据的方法，同步</li>
<li>actions &#x3D;&gt; 像一个装饰器，包裹mutations，使之可以异步。</li>
<li>modules &#x3D;&gt; 模块化Vuex</li>
</ul>
<h3 id="7-Vuex和单纯的全局对象有什么区别？"><a href="#7-Vuex和单纯的全局对象有什么区别？" class="headerlink" title="7. Vuex和单纯的全局对象有什么区别？"></a>7. Vuex和单纯的全局对象有什么区别？</h3><ul>
<li>Vuex 的状态存储是响应式的。当 Vue 组件从 store 中读取状态的时候，若 store 中的状态发生变化，那么相应的组件也会相应地得到高效更新。</li>
<li>不能直接改变 store 中的状态。改变 store 中的状态的唯一途径就是显式地提交 (commit) mutation。这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li>
</ul>
<h3 id="8-为什么-Vuex-的-mutation-中不能做异步操作？"><a href="#8-为什么-Vuex-的-mutation-中不能做异步操作？" class="headerlink" title="8. 为什么 Vuex 的 mutation 中不能做异步操作？"></a>8. 为什么 Vuex 的 mutation 中不能做异步操作？</h3><ul>
<li>Vuex中所有的状态更新的唯一途径都是mutation，异步操作通过 Action 来提交 mutation实现，这样可以方便地跟踪每一个状态的变化，从而能够实现一些工具帮助更好地了解我们的应用。</li>
<li>每个mutation执行完成后都会对应到一个新的状态变更，这样devtools就可以打个快照存下来，然后就可以实现 time-travel 了。如果mutation支持异步操作，就没有办法知道状态是何时更新的，无法很好的进行状态的追踪，给调试带来困难。</li>
</ul>
<h3 id="9-Vuex的严格模式是什么-有什么作用，如何开启？"><a href="#9-Vuex的严格模式是什么-有什么作用，如何开启？" class="headerlink" title="9. Vuex的严格模式是什么,有什么作用，如何开启？"></a>9. Vuex的严格模式是什么,有什么作用，如何开启？</h3><p>在严格模式下，无论何时发生了状态变更且不是由mutation函数引起的，将会抛出错误。这能保证所有的状态变更都能被调试工具跟踪到。</p>
<p>在Vuex.Store 构造器选项中开启,如下</p>
<figure class="highlight monkey"><table><tr><td class="code"><pre><code class="hljs monkey"><span class="hljs-keyword">const</span> store = <span class="hljs-keyword">new</span> Vuex.Store(&#123;<br>    <span class="hljs-meta">strict</span>:<span class="hljs-literal">true</span>,<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="10-如何在组件中批量使用Vuex的getter属性"><a href="#10-如何在组件中批量使用Vuex的getter属性" class="headerlink" title="10. 如何在组件中批量使用Vuex的getter属性"></a>10. 如何在组件中批量使用Vuex的getter属性</h3><p>使用mapGetters辅助函数, 利用对象展开运算符将getter混入computed 对象中</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-keyword">import</span> &#123;mapGetters&#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span>&#123;<br>    computed:&#123;<br>        ...mapGetters([<span class="hljs-string">&#x27;total&#x27;</span>,<span class="hljs-string">&#x27;discountTotal&#x27;</span>])<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="11-如何在组件中重复使用Vuex的mutation"><a href="#11-如何在组件中重复使用Vuex的mutation" class="headerlink" title="11. 如何在组件中重复使用Vuex的mutation"></a>11. 如何在组件中重复使用Vuex的mutation</h3><p>使用mapMutations辅助函数,在组件中这么使用</p>
<figure class="highlight clean"><table><tr><td class="code"><pre><code class="hljs clean"><span class="hljs-keyword">import</span> &#123; mapMutations &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vuex&#x27;</span><br>methods:&#123;<br>    ...mapMutations(&#123;<br>        setNumber:<span class="hljs-string">&#x27;SET_NUMBER&#x27;</span>,<br>    &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后调用<code>this.setNumber(10)</code>相当调用<code>this.$store.commit(&#39;SET_NUMBER&#39;,10)</code></p>
<h2 id="六、Vue-3-0"><a href="#六、Vue-3-0" class="headerlink" title="六、Vue 3.0"></a>六、Vue 3.0</h2><h3 id="1-Vue3-0有什么更新"><a href="#1-Vue3-0有什么更新" class="headerlink" title="1. Vue3.0有什么更新"></a>1. Vue3.0有什么更新</h3><p><strong>（1）监测机制的改变</strong></p>
<ul>
<li>3.0 将带来基于代理 Proxy的 observer 实现，提供全语言覆盖的反应性跟踪。</li>
<li>消除了 Vue 2 当中基于 Object.defineProperty 的实现所存在的很多限制：</li>
</ul>
<p><strong>（2）只能监测属性，不能监测对象</strong></p>
<ul>
<li>检测属性的添加和删除；</li>
<li>检测数组索引和长度的变更；</li>
<li>支持 Map、Set、WeakMap 和 WeakSet。</li>
</ul>
<p><strong>（3）模板</strong></p>
<ul>
<li>作用域插槽，2.x 的机制导致作用域插槽变了，父组件会重新渲染，而 3.0 把作用域插槽改成了函数的方式，这样只会影响子组件的重新渲染，提升了渲染的性能。</li>
<li>同时，对于 render 函数的方面，vue3.0 也会进行一系列更改来方便习惯直接使用 api 来生成 vdom 。</li>
</ul>
<p><strong>（4）对象式的组件声明方式</strong></p>
<ul>
<li>vue2.x 中的组件是通过声明的方式传入一系列 option，和 TypeScript 的结合需要通过一些装饰器的方式来做，虽然能实现功能，但是比较麻烦。</li>
<li>3.0 修改了组件的声明方式，改成了类式的写法，这样使得和 TypeScript 的结合变得很容易</li>
</ul>
<p><strong>（5）其它方面的更改</strong></p>
<ul>
<li>支持自定义渲染器，从而使得 weex 可以通过自定义渲染器的方式来扩展，而不是直接 fork 源码来改的方式。</li>
<li>支持 Fragment（多个根节点）和 Protal（在 dom 其他部分渲染组建内容）组件，针对一些特殊的场景做了处理。</li>
<li>基于 tree shaking 优化，提供了更多的内置功能。</li>
</ul>
<h3 id="2-defineProperty和proxy的区别"><a href="#2-defineProperty和proxy的区别" class="headerlink" title="2. defineProperty和proxy的区别"></a>2. defineProperty和proxy的区别</h3><p>Vue 在实例初始化时遍历 data 中的所有属性，并使用 Object.defineProperty 把这些属性全部转为 getter&#x2F;setter。这样当追踪数据发生变化时，setter 会被自动调用。</p>
<p>Object.defineProperty 是 ES5 中一个无法 shim 的特性，这也就是 Vue 不支持 IE8 以及更低版本浏览器的原因。</p>
<p>但是这样做有以下问题：</p>
<ol>
<li>添加或删除对象的属性时，Vue 检测不到。因为添加或删除的对象没有在初始化进行响应式处理，只能通过<code>$set</code> 来调用<code>Object.defineProperty()</code>处理。</li>
<li>无法监控到数组下标和长度的变化。</li>
</ol>
<p>Vue3 使用 Proxy 来监控数据的变化。Proxy 是 ES6 中提供的功能，其作用为：用于定义基本操作的自定义行为（如属性查找，赋值，枚举，函数调用等）。相对于<code>Object.defineProperty()</code>，其有以下特点：</p>
<ol>
<li>Proxy 直接代理整个对象而非对象属性，这样只需做一层代理就可以监听同级结构下的所有属性变化，包括新增属性和删除属性。</li>
<li>Proxy 可以监听数组的变化。</li>
</ol>
<h3 id="3-Vue3-0-为什么要用-proxy？"><a href="#3-Vue3-0-为什么要用-proxy？" class="headerlink" title="3. Vue3.0 为什么要用 proxy？"></a>3. Vue3.0 为什么要用 proxy？</h3><p>在 Vue2 中， 0bject.defineProperty 会改变原始数据，而 Proxy 是创建对象的虚拟表示，并提供 set 、get 和 deleteProperty 等处理器，这些处理器可在访问或修改原始对象上的属性时进行拦截，有以下特点∶</p>
<ul>
<li>不需用使用 <code>Vue.$set</code> 或 <code>Vue.$delete</code> 触发响应式。</li>
<li>全方位的数组变化检测，消除了Vue2 无效的边界情况。</li>
<li>支持 Map，Set，WeakMap 和 WeakSet。</li>
</ul>
<p> Proxy 实现的响应式原理与 Vue2的实现原理相同，实现方式大同小异∶ </p>
<ul>
<li>get 收集依赖</li>
<li>Set、delete 等触发依赖</li>
<li>对于集合类型，就是对集合对象的方法做一层包装：原方法执行后执行依赖相关的收集或触发逻辑。</li>
</ul>
<h3 id="4-Vue-3-0-中的-Vue-Composition-API？"><a href="#4-Vue-3-0-中的-Vue-Composition-API？" class="headerlink" title="4.  Vue 3.0 中的 Vue Composition API？"></a>4.  Vue 3.0 中的 Vue Composition API？</h3><p>在 Vue2 中，代码是 Options API 风格的，也就是通过填充 (option) data、methods、computed 等属性来完成一个 Vue 组件。这种风格使得 Vue 相对于 React极为容易上手，同时也造成了几个问题：</p>
<ol>
<li>由于 Options API 不够灵活的开发方式，使得Vue开发缺乏优雅的方法来在组件间共用代码。</li>
<li>Vue 组件过于依赖<code>this</code>上下文，Vue 背后的一些小技巧使得 Vue 组件的开发看起来与 JavaScript 的开发原则相悖，比如在<code>methods</code> 中的<code>this</code>竟然指向组件实例来不指向<code>methods</code>所在的对象。这也使得 TypeScript 在Vue2 中很不好用。</li>
</ol>
<p>于是在 Vue3 中，舍弃了 Options API，转而投向 Composition API。Composition API本质上是将 Options API 背后的机制暴露给用户直接使用，这样用户就拥有了更多的灵活性，也使得 Vue3 更适合于 TypeScript 结合。</p>
<p>如下，是一个使用了 Vue Composition API 的 Vue3 组件：</p>
<figure class="highlight handlebars"><table><tr><td class="code"><pre><code class="hljs handlebars"><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml">  <span class="hljs-tag">&lt;<span class="hljs-name">button</span> @<span class="hljs-attr">click</span>=<span class="hljs-string">&quot;increment&quot;</span>&gt;</span></span><br><span class="language-xml">    Count: </span><span class="hljs-template-variable">&#123;&#123; <span class="hljs-name">count</span> &#125;&#125;</span><span class="language-xml"></span><br><span class="language-xml">  <span class="hljs-tag">&lt;/<span class="hljs-name">button</span>&gt;</span></span><br><span class="language-xml"><span class="hljs-tag">&lt;/<span class="hljs-name">template</span>&gt;</span></span><br><span class="language-xml"> </span><br><span class="language-xml"><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// Composition API 将组件属性暴露为函数，因此第一步是导入所需的函数</span></span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">import</span> &#123; ref, computed, onMounted &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;vue&#x27;</span></span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-keyword">export</span> <span class="hljs-keyword">default</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">  <span class="hljs-title function_">setup</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// 使用 ref 函数声明了称为 count 的响应属性，对应于Vue2中的data函数</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">const</span> count = <span class="hljs-title function_">ref</span>(<span class="hljs-number">0</span>)</span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml"><span class="hljs-comment">// Vue2中需要在methods option中声明的函数，现在直接声明</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">function</span> <span class="hljs-title function_">increment</span>(<span class="hljs-params"></span>) &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count.<span class="hljs-property">value</span>++</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml"> <span class="hljs-comment">// 对应于Vue2中的mounted声明周期</span></span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-title function_">onMounted</span>(<span class="hljs-function">() =&gt;</span> <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;component mounted!&#x27;</span>))</span></span><br><span class="language-javascript"><span class="language-xml"> </span></span><br><span class="language-javascript"><span class="language-xml">    <span class="hljs-keyword">return</span> &#123;</span></span><br><span class="language-javascript"><span class="language-xml">      count,</span></span><br><span class="language-javascript"><span class="language-xml">      increment</span></span><br><span class="language-javascript"><span class="language-xml">    &#125;</span></span><br><span class="language-javascript"><span class="language-xml">  &#125;</span></span><br><span class="language-javascript"><span class="language-xml">&#125;</span></span><br><span class="language-javascript"><span class="language-xml"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span></span><br></code></pre></td></tr></table></figure>

<p>显而易见，Vue Composition API 使得 Vue3 的开发风格更接近于原生 JavaScript，带给开发者更多地灵活性</p>
<h3 id="5-Composition-API与React-Hook很像，区别是什么"><a href="#5-Composition-API与React-Hook很像，区别是什么" class="headerlink" title="5. Composition API与React Hook很像，区别是什么"></a>5. Composition API与React Hook很像，区别是什么</h3><p>从React Hook的实现角度看，React Hook是根据useState调用的顺序来确定下一次重渲染时的state是来源于哪个useState，所以出现了以下限制</p>
<ul>
<li>不能在循环、条件、嵌套函数中调用Hook</li>
<li>必须确保总是在你的React函数的顶层调用Hook</li>
<li>useEffect、useMemo等函数必须手动确定依赖关系</li>
</ul>
<p>而Composition API是基于Vue的响应式系统实现的，与React Hook的相比</p>
<ul>
<li>声明在setup函数内，一次组件实例化只调用一次setup，而React Hook每次重渲染都需要调用Hook，使得React的GC比Vue更有压力，性能也相对于Vue来说也较慢</li>
<li>Compositon API的调用不需要顾虑调用顺序，也可以在循环、条件、嵌套函数中使用</li>
<li>响应式系统自动实现了依赖收集，进而组件的部分的性能优化由Vue内部自己完成，而React Hook需要手动传入依赖，而且必须必须保证依赖的顺序，让useEffect、useMemo等函数正确的捕获依赖变量，否则会由于依赖不正确使得组件性能下降。</li>
</ul>
<p>虽然Compositon API看起来比React Hook好用，但是其设计思想也是借鉴React Hook的。</p>
<h2 id="七、虚拟DOM"><a href="#七、虚拟DOM" class="headerlink" title="七、虚拟DOM"></a>七、虚拟DOM</h2><h3 id="1-对虚拟DOM的理解？"><a href="#1-对虚拟DOM的理解？" class="headerlink" title="1. 对虚拟DOM的理解？"></a>1. 对虚拟DOM的理解？</h3><p>从本质上来说，Virtual Dom是一个JavaScript对象，通过对象的方式来表示DOM结构。将页面的状态抽象为JS对象的形式，配合不同的渲染工具，使跨平台渲染成为可能。通过事务处理机制，将多次DOM修改的结果一次性的更新到页面上，从而有效的减少页面渲染的次数，减少修改DOM的重绘重排次数，提高渲染性能。</p>
<p>虚拟DOM是对DOM的抽象，这个对象是更加轻量级的对 DOM的描述。它设计的最初目的，就是更好的跨平台，比如Node.js就没有DOM，如果想实现SSR，那么一个方式就是借助虚拟DOM，因为虚拟DOM本身是js对象。 在代码渲染到页面之前，vue会把代码转换成一个对象（虚拟 DOM）。以对象的形式来描述真实DOM结构，最终渲染到页面。在每次数据发生变化前，虚拟DOM都会缓存一份，变化之时，现在的虚拟DOM会与缓存的虚拟DOM进行比较。在vue内部封装了diff算法，通过这个算法来进行比较，渲染时修改改变的变化，原先没有发生改变的通过原先的数据进行渲染。</p>
<p>另外现代前端框架的一个基本要求就是无须手动操作DOM，一方面是因为手动操作DOM无法保证程序性能，多人协作的项目中如果review不严格，可能会有开发者写出性能较低的代码，另一方面更重要的是省略手动DOM操作可以大大提高开发效率。</p>
<h3 id="2-虚拟DOM的解析过程"><a href="#2-虚拟DOM的解析过程" class="headerlink" title="2. 虚拟DOM的解析过程"></a>2. 虚拟DOM的解析过程</h3><p>虚拟DOM的解析过程：</p>
<ul>
<li>首先对将要插入到文档中的 DOM 树结构进行分析，使用 js 对象将其表示出来，比如一个元素对象，包含 TagName、props 和 Children 这些属性。然后将这个 js 对象树给保存下来，最后再将 DOM 片段插入到文档中。</li>
<li>当页面的状态发生改变，需要对页面的 DOM 的结构进行调整的时候，首先根据变更的状态，重新构建起一棵对象树，然后将这棵新的对象树和旧的对象树进行比较，记录下两棵树的的差异。</li>
<li>最后将记录的有差异的地方应用到真正的 DOM 树中去，这样视图就更新了。</li>
</ul>
<h3 id="3-为什么要用虚拟DOM"><a href="#3-为什么要用虚拟DOM" class="headerlink" title="3. 为什么要用虚拟DOM"></a>3. 为什么要用虚拟DOM</h3><p><strong>（1）保证性能下限，在不进行手动优化的情况下，提供过得去的性能</strong></p>
<p>看一下页面渲染的流程：<strong>解析HTML -&gt; 生成DOM</strong> <strong>-&gt;</strong> <strong>生成 CSSOM</strong> <strong>-&gt;</strong> <strong>Layout</strong> <strong>-&gt;</strong> <strong>Paint</strong> <strong>-&gt;</strong> <strong>Compiler</strong></p>
<p>下面对比一下修改DOM时真实DOM操作和Virtual DOM的过程，来看一下它们重排重绘的性能消耗∶</p>
<ul>
<li>真实DOM∶ 生成HTML字符串＋重建所有的DOM元素</li>
<li>虚拟DOM∶ 生成vNode+ DOMDiff＋必要的dom更新</li>
</ul>
<p>Virtual DOM的更新DOM的准备工作耗费更多的时间，也就是JS层面，相比于更多的DOM操作它的消费是极其便宜的。尤雨溪在社区论坛中说道∶ 框架给你的保证是，你不需要手动优化的情况下，依然可以给你提供过得去的性能。</p>
<p><strong>（2）跨平台</strong></p>
<p>Virtual DOM本质上是JavaScript的对象，它可以很方便的跨平台操作，比如服务端渲染、uniapp等。</p>
<h3 id="4-虚拟DOM真的比真实DOM性能好吗"><a href="#4-虚拟DOM真的比真实DOM性能好吗" class="headerlink" title="4. 虚拟DOM真的比真实DOM性能好吗"></a>4. 虚拟DOM真的比真实DOM性能好吗</h3><ul>
<li>首次渲染大量DOM时，由于多了一层虚拟DOM的计算，会比innerHTML插入慢。</li>
<li>正如它能保证性能下限，在真实DOM操作的时候进行针对性的优化时，还是更快的。</li>
</ul>
<h3 id="5-DIFF算法的原理"><a href="#5-DIFF算法的原理" class="headerlink" title="5. DIFF算法的原理"></a>5. DIFF算法的原理</h3><p>在新老虚拟DOM对比时：</p>
<ul>
<li>首先，对比节点本身，判断是否为同一节点，如果不为相同节点，则删除该节点重新创建节点进行替换</li>
<li>如果为相同节点，进行patchVnode，判断如何对该节点的子节点进行处理，先判断一方有子节点一方没有子节点的情况(如果新的children没有子节点，将旧的子节点移除)</li>
<li>比较如果都有子节点，则进行updateChildren，判断如何对这些新老节点的子节点进行操作（diff核心）。</li>
<li>匹配时，找到相同的子节点，递归比较子节点</li>
</ul>
<p>在diff中，只对同层的子节点进行比较，放弃跨级的节点比较，使得时间复杂从O(n3)降低值O(n)，也就是说，只有当新旧children都为多个子节点时才需要用核心的Diff算法进行同层级比较。</p>
<h3 id="6-Vue中key的作用"><a href="#6-Vue中key的作用" class="headerlink" title="6. Vue中key的作用"></a>6. Vue中key的作用</h3><p>vue 中 key 值的作用可以分为两种情况来考虑：</p>
<ul>
<li>第一种情况是 v-if 中使用 key。由于 Vue 会尽可能高效地渲染元素，通常会复用已有元素而不是从头开始渲染。因此当使用 v-if 来实现元素切换的时候，如果切换前后含有相同类型的元素，那么这个元素就会被复用。如果是相同的 input 元素，那么切换前后用户的输入不会被清除掉，这样是不符合需求的。因此可以通过使用 key 来唯一的标识一个元素，这个情况下，使用 key 的元素不会被复用。这个时候 key 的作用是用来标识一个独立的元素。</li>
<li>第二种情况是 v-for 中使用 key。用 v-for 更新已渲染过的元素列表时，它默认使用“就地复用”的策略。如果数据项的顺序发生了改变，Vue 不会移动 DOM 元素来匹配数据项的顺序，而是简单复用此处的每个元素。因此通过为每个列表项提供一个 key 值，来以便 Vue 跟踪元素的身份，从而高效的实现复用。这个时候 key 的作用是为了高效的更新渲染虚拟 DOM。</li>
</ul>
<p>key 是为 Vue 中 vnode 的唯一标记，通过这个 key，diff 操作可以更准确、更快速</p>
<ul>
<li>更准确：因为带 key 就不是就地复用了，在 sameNode 函数a.key &#x3D;&#x3D;&#x3D; b.key对比中可以避免就地复用的情况。所以会更加准确。</li>
<li>更快速：利用 key 的唯一性生成 map 对象来获取对应节点，比遍历方式更快</li>
</ul>
<h3 id="7-为什么不建议用index作为key"><a href="#7-为什么不建议用index作为key" class="headerlink" title="7. 为什么不建议用index作为key?"></a>7. 为什么不建议用index作为key?</h3><p>使用index 作为 key和没写基本上没区别，因为不管数组的顺序怎么颠倒，index 都是 0, 1, 2…这样排列，导致 Vue 会复用错误的旧子节点，做很多额外的工作。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>只能在18岁喝醉</title>
    <url>/2021/04/11/You%20can%20only%20get%20drunk%20at%2018/</url>
    <content><![CDATA[<h2 id="只能在18岁喝醉"><a href="#只能在18岁喝醉" class="headerlink" title="只能在18岁喝醉"></a>只能在18岁喝醉</h2><p><span style="border-top: 3px solid black; padding-top:10px">文／专三千</span></p>
<span id="more"></span>
<br>

<h2 id="第一场"><a href="#第一场" class="headerlink" title="第一场"></a><em>第一场</em></h2><br>

<p>第一次见到李乐时，我还不知道，她就是太奶奶说的“那个人”。</p>
<p>英语老师老王，眯着双眼指着李乐说：“这么好的姑娘，不知道会便宜哪位臭小子。”</p>
<p>我朝他指的方向看了看，白白净净一姑娘，扎着马尾，额前有几根杂乱的碎头发，被四十几道集中投来的目光炙烤得满脸通红，小声和同桌抱怨着。她扭头和我对视了一眼。留在我脑海里唯一的印象是清澈。</p>
<p>老王说这句话，是在文理分科后的第一节英语课，也是下午第一节课。这是我生平最讨厌的时刻。阳光穿过被风吹起的窗帘缝隙钻到课桌，午休的后劲还没散去，软绵绵的身体扛着昏昏沉沉的脑袋，黑板上的板书都变成旋转的不规则图案，像个催眠的万花筒。</p>
<p>可我还是小瞧了这个身高一米六的小个子。老王一进门，没有喊上课，而是激情澎湃地用英语开始演说。</p>
<p>他一口做作的英式腔调，每个需要与鼻腔共鸣的发音都像低音炮一样震动，试图唤起你胸腔与他澎湃内心的共振。</p>
<p>从仅能听懂的几个单词，我依稀分辨出，这是马丁·路德·金最著名的演讲，《I have a dream》。</p>
<p>我的“dream”就在这慷慨激昂的演讲中开始了。</p>
<p>一星期后，命运就把这位“不知道会便宜哪位臭小子”的姑娘，安排在了我前面。</p>
<p>我很有自知之明，我赌命运不会这样便宜我。</p>
<p>开明的阿飘（班主任，因为神出鬼没，走路悄无声息，经常忽然出现在同学身后得名。）在全班开放了“选座权”。每个人自由选择座位，最后由班长统一协调安排。</p>
<p>男生们发扬绅士精神，纷纷选择最后两排。当然，也有更加实际的考量：方便上课摸鱼，下课抢篮球场。</p>
<p>我的同桌叫王骏一，是一个每天都要被自己帅哭100次的男人。</p>
<p>他选我做同桌，我毫不意外。跑操时他站我旁边，一个星期里，他已经把除我之外的每个男生都吐槽了个遍。</p>
<p>我敢肯定他没有吐槽过我，因为他从没跟其它男生说过话。</p>
<p>他觉得王飞太高调，满身大牌logo；廖恺一身的娘炮气质，郑良栋一举一动都在装逼……</p>
<p>我理解他，从小镇来到赣州的我，也有相同的感受。当我们以自己的视角审视别人的行为时，常常会产生巨大的误解，会把别人的正常行为，曲解为炫耀或冒犯。</p>
<p>好在，我早已习惯接纳一切。作为全村唯一一个考上市重点高中的人，我靠的就是不断抛弃过去，接纳新的圈层。</p>
<p>王骏一比我双标。在吐槽其他人时，他也做着让人无语的事情：随身带着一面镜子，以每节课10次的频率，通过各个角度欣赏自己并不英俊偶尔还冒痘的容颜。</p>
<p>整个班，不穿名牌，不装逼，性格开朗，一身土气，还不嫌弃他的男生，只有我。</p>
<p>19班仅有的两只“乡村土狗”，就这样成了同桌。</p>
<p>李乐刚坐在我前面时，我并不赞同老王的说法。我觉得她和她的同桌周琪一样，都是那种上厕所要组队、每周追综艺、看到帅哥犯花痴的女孩。</p>
<p>她很喜欢喝奶，纯牛奶、养乐多、老酸奶，不管什么时候，她桌上一定放着一瓶奶。以至于，我一直觉得，我的青春有一股奶香，接近童年的味道。</p>
<p>我们的熟络，靠的是从《快乐大本营》流传出的一款桌游－－《谁是卧底》。</p>
<p>在教室里，做任何与读书无关的事情，都格外有趣。这款游戏规则简单，节奏快，参与人数不限，成了课间10分钟最佳的娱乐方式。</p>
<p>每个课间，教室里的人三五成群围成一圈，主持人把纸团往桌上一扔，其余人饿虎扑食一样抢，抢到纸团就等于抢到了参与游戏的资格。</p>
<p>这场景让我想起了村里的赌场。烟雾缭绕，汗臭夹杂着唾沫在空气中发酵，围在一起的人瞪着血红的双眼，等待着庄家发下的最后一张牌。</p>
<p>周琪最具牺牲精神，每次都做写纸条的主持人。她属于那种，看着别人开心就能开心起来的人。这是种难得的天赋。</p>
<p>李乐是玩这个游戏的高手，她擅长伪装，又擅长用隐晦的语言让所有人明白她的描述，所以她常常活到最后。</p>
<p>我和李乐相反，我每次都不受控制，用力过猛。当我知道我是平民时，描述完词语后，常常想立刻揪出卧底，便会说出自己的怀疑对象。当我知道自己是卧底，并且已经猜出平民词后，在描述词语时，我总会刻意解释一下。</p>
<p>这个游戏里，过于想证明自己的人，都活不长。</p>
<p>李乐很照顾人。每次游戏结束后，她都会帮我复盘，告诉我，那个时候，你不该那么做。</p>
<p>而我很不长记性，每次都犯同样的错。</p>
<p>王骏一从来不参与我们的游戏。我们在一旁描述、推理、投票，他拿着手机在虎扑看NBA图文直播。我们每周日晚上要上交手机，周六中午才能拿到，但王骏一有个模型机，每次交假的，留真的。</p>
<p>我担心他有些自闭，但是邀请多次被拒后，也就没再强求。他和我不一样。他似乎对于融入群体这件事毫不在乎。</p>
<p>我不止一次对他说：“我们从小地方出来不容易，很多时候，我们需要改变自己。”</p>
<p>每当我说这些，他总是照着镜子，挤挤脸上新长的痘痘摆摆手：“不用担心，没问题的。”</p>
<p>我意识到我和李乐真正成为了朋友，是因为她赠送了我一个外号。</p>
<p>2013年，第一季《爸爸去哪儿》爆火，全中国每一个有喇叭的地方都在放：老爸、老爸，我们去哪里呀，有我在就天不怕地不怕……</p>
<p>不老男神林志颖靠着可爱的kimi再度翻红，不知名导演王岳伦靠王诗龄软饭硬吃，超模张亮靠着天天成为了美食一哥，一只脚踏进娱乐圈的奥运冠军田亮靠着“森蝶”终于把另一只脚也迈进了娱乐圈。</p>
<p>节目里，软萌的Kimi叫林志颖“爸比”，一时间，单字后面加一个“比”，成为了流行的外号。就像广东那边取小名，就是在你名字的最后一个字前加“阿”：阿乐、阿千。</p>
<p>李乐按照Kimi的公式，给我起了个外号：你叫曾小千，就叫“千比”吧。叫着叫着，就成了“铅笔”。</p>
<p>而这次，王骏一这个对任何事情都不感兴趣的独狼，居然也认领了属于自己的外号。</p>
<p>在给王骏一想外号时，大家觉得“一比”有点怪，就改取中间字，叫“骏比”。这个外号把他高兴坏了，他说“骏（俊）”不就是“帅”的意思吗，以后大家都叫我“帅比”吧。</p>
<p>在我们村，如果一个人给你取外号，有两种可能：一是，这个人很讨厌你。二是，这个人挺喜欢你。</p>
<p>我在心里做了个排除法，不可能是一，但也不像二。也许城里人想法不一样。但四舍五入一下，起码她是把我当朋友的。</p>
<br>

<h2 id="第二场"><a href="#第二场" class="headerlink" title="第二场"></a><em>第二场</em></h2><br>
如果没有月考，高中一定会成为我生命中最美好的时光。

<p>快乐总是有代价的。我们在“谁是卧底”和《爸爸去哪儿》的欢乐中虚度，第一次月考悄然而至。我们班，惨败。</p>
<p>赣州中学一共分为3种班：宏志班，红色班，重点班。这几个命名有一定误导性，需要重点解释。</p>
<p>“宏志班”包揽了每个年级最牛逼的学神。在这个班，考倒数第一，也能上一本。</p>
<p>“红色班”包揽了除宏志班学神以外的其它学霸，在这种班，考倒数第一，也能妥妥上二本。</p>
<p>“重点班”，除了前两者，剩下的同学，都在重点班。</p>
<p>从班级的命名，就可窥见赣州中学的人文关怀——真正的“重点班”不叫重点班，要把“重点”放在人数最多的普通学生身上。</p>
<p>但学校似乎忘了，命名不重要，定义才重要，在课堂上，不少老师说起“重点班”三个字时，还是带着恨铁不成钢的无奈。</p>
<p>我们那一届，17到29班是文科班，17班是宏志班，18、19班是红色班，剩下的是重点班。</p>
<p>第二次月考后，用学校的定义来说，我们19班，成为了“红色班里的重点班”。</p>
<p>不用怀疑你的理解，这是阿飘看到第二次月考成绩后的原话。他说这话时，一脸的恨铁不成钢。</p>
<p>最不成钢的那块铁，是我。</p>
<p>我是班上的5号，这次月考，我班级排名第35。</p>
<p>学号是按分科时的分数排的，一共50人。也就是说，初始实力我排第5，努力学习1个月后排名退后了30 。</p>
<p>李乐学号32号，月考22名。王骏一学号50，月考42名。</p>
<p>开完班会后，阿飘找我去办公室谈话。</p>
<p>办公室里的老师都往外走，没有晚自习的老师收拾好东西准备下班，有晚自习的老师也拿起饭卡去食堂吃晚饭。</p>
<p>阿飘的办公桌在放手机的柜子旁边。那更像是一面巨大的储物墙，和超市门口的储物柜一样大，每个小柜门上贴着班级号码，放着全年级上千台手机。</p>
<p>阿飘喝了一口保温杯里泡的胖大海茶：“这次考试成绩不太理想啊。”</p>
<p>我：“是，退步很多。”</p>
<p>阿飘：“有去找原因吗？”</p>
<p>我：“这段时间没努力。”</p>
<p>阿飘：“你是宁都人吧？”</p>
<p>我：“是。”</p>
<p>阿飘：“我也是宁都的，你是宁都哪的？”</p>
<p>我：“东山坝。”</p>
<p>办公室里的老师都走了，几个来交作业的课代表也出去了，只剩下我和阿飘。我右手食指不断抠着大腿外侧的裤缝线，期待这场对话赶紧结束。</p>
<p>阿飘：“小地方考来赣州中学不容易，好好读书，考个好大学，给家里才有个交代。前几天你妈妈给我打电话了，说你太奶奶过世之后，你状态一直不好，让我多关照你。”</p>
<p>我忍不住翻了个白眼。我最不喜欢我妈的就是这点，总是把个人隐私当成社交的筹码，将两件毫无关联的事情强行扭在一起，就以为自己洞察了一切。</p>
<p>我：“那个事已经过去好几个月了，我会及时调整好。”</p>
<p>阿飘：“那就好。回去好好看书，下次月考争取回到正常水平。”</p>
<p>我：“好的，谢谢老师。”</p>
<p>快走到门口时，阿飘忽然又叫了我一句：“小千。”</p>
<p>我回头走到办公桌前：“怎么了，老师？”</p>
<p>阿飘：“王骏一最近怎么样？”</p>
<p>我：“挺好的，学习很认真。”</p>
<p>阿飘：“嗯，那就好，你们俩都要加把劲。”</p>
<p>走出办公室后，各个班都在扫教室。夕阳照着扬起的灰尘，丁达尔效应让走廊和来往的同学看起来像一幅动态的印象派油画。</p>
<p>肚子饿得打鼓，但我一点也不想去食堂。我坐在教室最后一排，看着风把窗帘吹得鼓起，又把窗帘吸出窗外。</p>
<p>也许我妈是对的。太奶奶去世后，我好像对读书提不起劲了。</p>
<p>太奶奶的死，让我觉得，运气比努力重要。你要去往何处，你能到达何地，可能早有定数。</p>
<p>晚自习前，李乐走进教室。她刚洗完澡，白T恤被没来得及吹干的头发沾湿，手腕上套着发圈，拿着一瓶红枣酸奶走到座位。</p>
<p>王骏一刚打完篮球，一身汗，拿着一瓶运动饮料走进教室。</p>
<p>我被两个湿漉漉的人包围，他们身上蒸发的水汽好像都跑到了我眼睛里。</p>
<p>王骏一拍拍我的肩膀：“今天下午阿飘找你说啥了？”</p>
<p>我：“他问我，你读书用不用功。”</p>
<p>王骏一：“那不可能，本帅比一向发挥稳定，从没出过班上倒数前10。”</p>
<p>李乐转过头盯着我：“铅笔，你是不是被阿飘批评了？”</p>
<p>我：“没有，我就是发挥失常了，阿飘说跟我是老乡，下课单独和我聊聊。”</p>
<p>李乐：“我也觉得你是发挥失常，下次一定会好起来的。”</p>
<p>那次月考后，我退出了课间“谁是卧底”的游戏，以一种自我麻痹的状态学习。每天早起背单词，晚归刷题。有没有效果不重要，自己感觉努力了，就心安了。</p>
<p>我突如其来的奋斗，把王骏一吓得够呛，他依旧看自己的球赛转播，鄙视别的男同学。</p>
<p>李乐见后面两位，一个埋头苦读，一个社交恐惧，转向和旁边的同学玩“谁是卧底”。</p>
<p>有天早上，李乐来得很早。我左手拿着馒头，右手捧着单词本，李乐从包里拿出一瓶纯牛奶：“出门多拿了一瓶，加油！”</p>
<p>我看着桌上的牛奶，不太敢接。太奶奶常说：出门在外，别乱拿人家东西，都要还的。</p>
<p>我摇摇头：“我不喝牛奶。”</p>
<p>李乐指着我脚下的牛奶盒：“你昨天刚喝。”</p>
<p>我：“我早上不喝，拉肚子。”</p>
<p>李乐：“那晚上喝，不然我就给王骏一。怎么那么多废话？”</p>
<p>如果一定要追溯我是从什么时候开始关注李乐的一言一行，那应该就是从此刻开始。</p>
<p>我发现，我再也无法把所有的注意力放在书上。就算我在解数学题，每写完一个步骤，我还是会看看李乐在干什么。</p>
<p>每个课间，我嘴里在背古诗词，眼睛却从没离开过正在玩“谁是卧底”的李乐。</p>
<p>第二天，我回了李乐一盒奥利奥饼干。</p>
<p>这是我认知范畴里最贵的饼干。而且广告里说，它和牛奶是绝配。</p>
<p>上午第二节课课间，跑完操，大家解散各自走回教室，她走到我身边竖个大拇指：“饼干好评。”</p>
<p>这句话让我开心了一天，也仅仅是一天。</p>
<p>第二次月考来了，我攒足了劲，准备一雪前耻。结果我还是输得彻底。</p>
<p>这次更加干脆，我直接进了王骏一的领地，全班倒数第10。</p>
<p>出成绩的那天，我把所有的书堆在桌子上，把自己围在里面，拿出那本黄色封面的笔记本。这是我从中学开始的写作本，自己的一些短篇、想法、抱怨、给别人的信都在里面。我提笔开始写：</p>
<p>太奶奶，我又考砸了。我知道，这主要是我自己的责任。但是对不起，我还是有点怪你。为什么你偏偏要在那时候离开？如果你晚一点走，我考得肯定会比现在好吧。你说的“那个人”也没有出现。如果我的成绩一直好不起来，我的人生还能好起来吗？</p>
<p>整整一节晚自习，我就写了这一段话。教室里窸窸窣窣，大家拿到试卷后开始订正。</p>
<p>王骏一越过书墙来看我：“铅笔，不就是一次考试吗？又不是高考，嗨起来。你看我排名比你还后，是不是就不活了？”</p>
<p>我搞不懂王骏一莫名的乐观，他似乎不在乎成绩，不在乎未来。我多次提醒他，我们小镇出来的要比别人上进一些，他总是一边玩手机一边摆手：“没问题的。”</p>
<p>我：“没事，我就是喜欢自己写点东西。”</p>
<p>第一节晚自习结束后，我去厕所抽了根烟。极品金圣。是我趁太奶奶葬礼时从家里面偷的。我不会抽烟，香烟吸进去时，尼古丁和焦油像一把钝刀插进我的气管。我蹲在男厕所的隔间里，一边咳嗽，一边继续虐待我的肺。</p>
<p>我刚抽完半根，隔壁蹲位忽然敲了敲隔板：“旁边的是老师还是学生，在厕所里吸烟？”</p>
<p>是老王的声音，后两节是英语晚自习。</p>
<p>我回了一句：“老师，不是抽烟，我膝盖疼，艾灸呢。”</p>
<p>老王：“挂白佬（赣州方言，指胡说八道的人），烟灰都弹我屁股上了。”</p>
<p>我把剩下的半截烟扔进蹲盆，踩下冲水开关，匆忙回到了教室。</p>
<p>到座位一看，我围好的书墙被整齐地码在课桌左边。李乐吐着舌头对我说：“刚刚去扔垃圾，不小心把你书碰倒了，不好意思。”</p>
<p>我：“没事。”</p>
<p>我看到黄色笔记本被压在最底下，安心了一些。</p>
<p>老王大摇大摆地走了进来，眯着眼朝我的方向看，我心虚地躲开，假装找书。老王举起右臂，由右往左晃了晃，握紧拳头做了个“收”的动作：“大家安静一下。今天我要特别表扬一下李乐同学，英语完形填空全班得分最高。”</p>
<p>我忍不住对王骏一吐槽：“欲加之赞，何患无辞。总分第一的不表扬，表扬完形填空得分最高的，那我还是第四组最后一排完形填空得分最高的呢。”</p>
<p>王骏一看了看我的英语答题卡：“不好意思，第四组最后一排完形填空最高的也不是你。”</p>
<p>我把左边的书全部堆到右边：“把你的书也堆上来吧，还有，明天跟班长说一下，我重新物色一个同桌。”</p>
<p>老王宣布完自己的表彰信息后，笑眯眯地走到李乐桌子旁，刚想跟李乐说点什么，又往我和王骏一的方向嗅了嗅，对王骏一说：“家妈滴，刚刚厕所里艾灸的是你吧？”</p>
<p>王骏一吓得紧紧按住藏在英语习题册下的手机：“啥？”</p>
<p>老王有些谄媚地搂着王骏一的肩膀说：“这玩意少碰，没好处，下不为例。”</p>
<p>王骏一满脸不解，但好像没啥大事，只好点头附和：“嗯嗯，老师说的对。”</p>
<p>老王在李乐座位前寒暄了几句，给她讲解了几个错题，就回讲台玩手机了。</p>
<p>我刚想拿出黄色封皮的笔记本继续写，李乐转过头来问我：“铅笔，是不是不开心？”</p>
<p>我：“没有，挺开心的。”</p>
<p>李乐：“我们出去溜溜？”</p>
<p>我：“现在？”</p>
<p>李乐：“老王的课，逃一节无所谓。”</p>
<p>我：“你无所谓，我要是被老王抓到，他会锤爆我的头。”</p>
<p>李乐：“你就说去不去。”</p>
<p>王骏一掏出镜子，用手整理了一下头发：“去。”</p>
<p>我：“去。”</p>
<p>我们三个人一前一后，从后门溜出教室。</p>
<p>李乐站在走廊尽头朝我们挥手：“过来。”</p>
<p>她带着我们一直上到五楼，我这才发现，教学楼四楼的楼顶，居然是一片宽阔的天台。</p>
<p>这是连接两栋教学楼的中间部分，旁边两栋都有5层，盖着红瓦，中间连接部分只有4层，留出了一片巨大的水泥空地。地上布满了各种管道，被月光涂成银色。</p>
<p>风从两栋楼之间穿过，把红色塑料袋卷到天上。李乐穿着人字拖，踩在一根电线杆粗细的管道上，当独木桥走：“铅笔，人生会好起来的。”</p>
<p>我：“你看了我的笔记本？”</p>
<p>李乐：“帮你捡书的时候，不小心看到的。”</p>
<p>我转身要走，李乐说：“你走吧，要不是王骏一拉我一起安慰你，我才不想来这楼顶吹风。”</p>
<p>我看着王骏一，他甩着头发朝我抛了个媚眼：“不用谢。”</p>
<p>我走到管道前踢了一脚：“你们都看了？”</p>
<p>王骏一：“你摊在桌子上，字写得那么老大，谁顶得住？”</p>
<p>李乐：“问题是要解决的，光难过有什么用，说说吧。”</p>
<p>我：“我不知道从哪开始说。”</p>
<p>李乐：“聊聊你太奶奶吧。”</p>
<p>王骏一：“对，你说你这个不孝子，考不好还要怪祖宗头上。我要是你太奶奶，都得爬起来揍你。”</p>
<p>我：“你们相信命运吗？”</p>
<p>李乐：“我信。”</p>
<p>王骏一：“咱奶整这么深奥？”</p>
<p>我掏出口袋里剩的烟，点上一根，说：“我太奶奶是在我们文理分科考试前2天去世的。我正在上自习，班长跑进来说班主任有事找我。我刚走到办公室门口，看到我的手机放在办公桌上，我就猜到，家里出事了，我要领手机先回家。班主任跟我说完后，我很淡定，简单收拾了行李，买车票，转四趟车回了老家。一路上，我都冷静得像个上帝视角的录像机，看着自己坐在班车里，看着路过的车，看着高速路上铺的金黄色的晚霞。直到看见太奶奶的棺椁，我才反应过来，我失去了一位亲人。那个永远护着我，每次回家都给我炖土鸡蛋、红枣汤的太奶奶，永远地离开了我。可对着遗体，我怎么也哭不出来。我妈一直掐我，她说，我太奶奶生前对我最好，别人可以不哭，我必须哭。我跟我妈说，太奶奶89了，是喜丧。我妈问我谁说的，我说，太奶奶自己说的。”</p>
<p>我轻咳了两下，刚刚强行吸的几口烟让我咽喉很不舒服：“我觉得，人是可以预感到自己死亡的。我最后一次见太奶奶，赶上村口一个老爷爷下葬。太奶奶说，88了，喜丧。我问她，人死了，哪来的喜。太奶奶说，你还不晓得。人老了，就要走。不然，累自己，也累后生。人呐，能在意的人数是有限的，我们老人家走，给你们年轻人心里腾出位置。你说，是不是喜事。等哪天我走了，你也可以当喜事看，说明老天爷告诉我，该给那个人腾位置了。”</p>
<p>李乐：“那个人是谁？”</p>
<p>我没想到李乐会问这么无解的问题，随口回答：“你。”</p>
<p>李乐：“我可不给你炖汤。”</p>
<p>王骏一：“我还是不明白，你太奶奶去世，跟你的成绩有什么关系。”</p>
<p>我：“因为要参加文理分科考试，我没能等到太奶奶下葬，就先回学校了。你还记得吗，我们分科考试数学试卷倒数第二题，很难，但是这个题型有模板。考完对答案的时候，我发现全宿舍只有我不会做。原来我回家的那两天，数学老师带其他同学着重复习了几个题型，其中就有这题。那题15分，如果我没有回去参加葬礼，就进宏志班了。”</p>
<p>李乐：“那你也遇不到我们了。”</p>
<p>我：“对，这就是命运。”</p>
<p>王骏一：“现在让你重新选一次，做对那道数学题进17班，和回去见太奶奶最后一面，二选一，你选哪一个？”</p>
<p>我：“回去见太奶奶最后一面。”</p>
<p>这时，王骏一的手机响了，他看了看号码：“你们先聊，我接个电话。”</p>
<p>李乐和我一起坐到管子上，脚从人字拖里伸出来，踩在管子上，手搭在膝盖上，指甲剪得很干净。这时的她像一碗透明的白凉粉，加了蜂蜜那种。</p>
<p>她问我：“你是不是觉得命运对你特别不公平？”</p>
<p>我点点头：“嗯。”</p>
<p>李乐：“你太贪心了。”</p>
<p>我：“我没有。”</p>
<p>李乐：“你就是既想进最好的班，也不想亲人离开。你有没有想过，如果你太奶奶晚一天走，想回去见太奶奶，你就要放弃整场考试？”</p>
<p>可能，就算我在教室里，老师讲那个题型时我也会走神。我和我妈一样，习惯在遇到问题时，找一个原因，把责任都往外推，以求得内心的自洽。</p>
<p>很不幸，我妈分析的可能是对的，她找到了源头，我现在才明白。</p>
<p>赣州亚热带季风的气候，让夏季显得漫长，入秋后，依旧有几波高温天气反复。好在蚊子不会随着气温反复，屋顶白日的余热被风慢慢搜刮，配上夜色凉的刚刚好。</p>
<p>李乐仰头看着月亮，眼睛清澈得像是覆了一层水，一束月光照进去，就会荡开涟漪。我想起第一次见她的场景，那种清澈的感觉，来自她的眼睛。</p>
<p>我看了看天空，远没有她眼中折射的那样美丽。学校建在章江新区，周围都是新楼盘。每当夜幕降临，工程车载着黄土和建筑废料围着学校绕圈，车斗里的土和车轮掀起的灰就罩住了整个学校。</p>
<p>月光下的李乐察觉到我盯着她看，转过头：“还有，你的认真，表演性太强了。课间背单词的时候，你根本不专心。”</p>
<p>我：“我很认真啊。”</p>
<p>李乐：“你不是一直看着我玩谁是卧底？”</p>
<p>我：“你玩游戏都不专心，还偷偷看我？”</p>
<p>李乐：“要脸吗？是你一直看，我偶尔瞥一眼就发现了。”</p>
<p>可能，她就是太奶奶说的“那个人”。</p>
<p>之前，我只看到了失去的15分，没有看到靠近的李乐。</p>
<p>我之前一直错了，因为有李乐，就算高中有月考，也依然是我生命中最美好的时光。<br><br></p>
<h2 id="第三场"><a href="#第三场" class="headerlink" title="第三场"></a><em>第三场</em></h2><br>
第二次月考过后，是家长会。

<p>我和我妈打了个电话，问她来不来。</p>
<p>她说，餐馆周末本来就忙，老板不给服务员假。我爸厂里最近订单多，要加班，抽不开身。另外，广州回赣州，坐火车要7个小时，太麻烦。最后说，我的成绩退步，希望我能尽快找到原因。</p>
<p>翻译一下就是：想来，但得给你挣学费。我和你爸都不容易，你最好心里有点数，努力学习，考好一点。</p>
<p>家长会那天，我吃完早餐就去操场跑步了。路过校门口时，看到一整条路都被私家车塞满。前几天我看到一个新闻，标题是《2013年，全国汽车保有量1.37亿辆，平均10个人拥有一辆车》。我们村人口200，却只有2辆车。</p>
<p>路上时不时有穿着赣州中学校服的学生，牵着家长的手，介绍学校。</p>
<p>红墙尖顶，钟塔绿坪。整齐的绿化，丰富的食堂。毗邻赣州最漂亮的中央公园，身后是现下最贵的楼盘中航。这样的学校很难让人不去炫耀，如果我父母来开家长会，我也会这样介绍一番。</p>
<p>跑完步回宿舍的路上，我碰见了王骏一，他低头玩着手机，手里提着可乐、酸笋、海白菜。</p>
<p>我问：“你怎么没去教室？”</p>
<p>王骏一：“我家长没来。”</p>
<p>果然，王骏一和我做同桌，就是因为我们相似。</p>
<p>我拍拍他的肩膀：“要不咱们打篮球去吧。”</p>
<p>王骏一对其它活动都没兴趣，唯独篮球，不吃饭也要多投几个篮。他打篮球的核心目的不是进球，而是帅气，所以练的招式实不实用不管，帅就完事了。</p>
<p>我们在教学楼旁的篮球场单挑，王骏一的动作轻飘飘的像个女生，我连续盖了他好几个帽。</p>
<p>打到接近12点，我看到李乐和她妈妈从教学楼出口走出来。她妈妈穿着一件淡蓝色的连衣裙，披着长发，隔得太远，没看清有没有化妆，但从身形举止依旧可以看出家庭条件不错，保养得当。</p>
<p>王骏一从我身侧绕过，一个上篮，进了，球砸在我头上。</p>
<p>他得意地朝我倒竖了一个大拇指。</p>
<p>我晃晃脑袋：“累了，吃饭去吧。”</p>
<p>王骏一抱着篮球，去1号超市买了几瓶饮料和一堆零食：“走吧，回宿舍吃，今天食堂肯定很挤。”</p>
<p>我说：“行，一共多少钱，AA吧。”</p>
<p>王骏一挥挥手：“不用了，我请。”</p>
<p>我：“不行，父母挣钱都不容易，一码归一码。”</p>
<p>王骏一：“那下次你请我。”</p>
<p>我：“也行。”</p>
<p>我抓起可乐喝一口气了半瓶。我一直觉得，打完篮球之后花3块钱买的那瓶可乐，第一口值3块5。剩下的，每多喝一口，嘴里的甜腻就倒扣1毛。</p>
<p>等周日晚上再回到教室时，教室里多了一台饮水机和一个书柜。</p>
<p>李乐和王骏一都还没到教室，我问周琪：“教室怎么多了台饮水机和书柜？”</p>
<p>周琪：“家长会上大家出钱买的呀，你不知道吗？”</p>
<p>原来，周末的家长会通过了两项重要决议。</p>
<blockquote>
<ul>
<li>1、鉴于19班是文科班，需要丰富阅读量，了解时事。由班主任提议，参会家长自愿出资，成立了“班级图书基金”。用于每月班级订购杂志、图书。</li>
<li>2、天气转寒，教室仅有的一台饮水机热水供应不足，由多位家长自愿出资，增购一台即热式饮水机。</li>
</ul>
</blockquote>
<p>我：“咱们班同学家里都这么有钱吗？”</p>
<p>周琪：“对啊，你不知道吗？我们班，除了考进来的，还有一些是花钱买进来的。”</p>
<p>这样的操作每个重点中学都有，有些地方叫“借读费”，有些地方叫“学位费”。</p>
<p>周琪为人热情，跟大家都熟络，消息自然灵通一些。在她的简略介绍中，我大概知道了班级部分同学的家庭状况。</p>
<p>班长的父亲是赣州南部某县的林业龙头企业董事长，坐在前排的某位女同学，父亲是某县卫生局局长，那位被王骏一吐槽天天穿名牌的男生，家里是开装修公司的。</p>
<p>周琪自己家做建材生意，李乐是双公务员家庭，父亲在税务局，母亲在出入境。</p>
<p>我：“我坦白，我是双农民工家庭，我爸在工厂，我妈在餐馆。”</p>
<p>周琪：“学校也看成绩的，跟这些没关系。”</p>
<p>我：“我成绩也垫底。”</p>
<p>周琪：“你底子好，努努力就起飞了。”</p>
<p>我忽然觉得在这个集体中有些格格不入。或许我应该让我妈来参加家长会，再从我的生活费中扣100，放入班级图书基金。</p>
<p>我讨厌这种被动的施舍，尽管周琪说整个筹款流程是保密的，会后各位家长直接交到班长手里，不记名，由班长统计总数。</p>
<p>图书基金成立后，班上定了很多杂志……</p>
<p>最受欢迎的那些杂志，常常还在上一个人手里，后面就已经有三四个人预定了。我都是等到最后一批再看，我总觉得，自己没出钱看杂志已经是占便宜，再抢别人前面就是耍流氓了。</p>
<p>杂志中有两个栏目最受同学们欢迎，一个是开头的编辑部神回复，另一个是结尾的“in生活”，两个栏目都带有段子性质。在手机上交，信息闭塞的高中，这两个栏目承包了19班大部分的快乐。</p>
<p>我最喜欢的是封底的专栏。专栏的内容从日常琐事到最近读到的好书，甚至作者自己的育儿经，谈天说地，毫无章法，却异常吸引我。</p>
<p>无知时总是自大。我总觉得，这些东西，我也能写。但真正刺激我写作欲望的，是另一本杂志。</p>
<p>某个百无聊赖的晚自习，我拿起一本杂志回到座位，李乐问我：“你要参加新概念吗？”</p>
<p>我：“不是啊。”</p>
<p>李乐指了指我手上的杂志：“那你拿这个干啥？”</p>
<p>那是我第一次知道，下半年的杂志里，每本都有一张“新概念作文大赛”的报名表。</p>
<p>我问：“是韩寒参加过的那个新概念吗？”</p>
<p>李乐点点头：“对，他是第一届一等奖。”</p>
<p>我：“初中时候，我把他所有书都看完了。”</p>
<p>李乐：“厉害啊，买书得花不少钱吧。”</p>
<p>我：“特便宜，有一次我去网吧，路上看到一本书，封面有张谢霆锋的照片，一时好奇停下看了看。摆摊的大叔说是韩寒，特别火的一个作家。9块钱，字典那么厚。书名叫《韩寒全集》，我看了一年。”</p>
<p>李乐：“如果你真的喜欢他，应该买正版。”</p>
<p>在我们镇，连新华字典都买不到正版。我正在努力，成为一个能买到正版书的人。</p>
<p>我指着报名表想换个话题：“你看，这里说，学生如果通过了初赛去上海参加复赛，可以报销交通费。那不就等于公费旅游吗？”</p>
<p>李乐：“这么好，那你赶紧参加。“</p>
<p>我：“如果我过了初试，带你去上海旅游。”</p>
<p>李乐：“你肯定能过。”</p>
<p>我：“作家都有个笔名，我要不要也想个笔名？”</p>
<p>李乐：“行啊。”</p>
<p>我：“要不就叫‘专一’吧，提醒自己，专心致志把写作这件事坚持下去。”</p>
<p>李乐：“专一？我看你是专三千吧，指不定哪天就变卦了。”</p>
<p>我：“专三千，还挺顺口的，就用这个吧。”</p>
<p>说完，我把杂志塞进课桌，掏出黄色封面的笔记本，准备写稿。</p>
<p>天台那晚后，我总是控制不住地观察李乐。</p>
<p>她指甲那么干净，是因为她想问题时喜欢咬指甲，数学晚自习，她把左手大拇指咬干净了；她今天早上穿的是一双棕色的小牛皮鞋，跑操的时候换成了一双紫色的运动鞋；最近她和同桌周琪不那么亲密了，晚自习改和另外两个女生一起走了；她喝的牛奶从纯牛奶变成早餐奶了；昨天下午她在饮水机前等了很久的热水，估计是来姨妈了。</p>
<p>晚自习，她找王骏一借手机，聊了一节晚自习的QQ。还给王骏一时，我借口说想给我妈打个电话，拿到了王骏一的手机。</p>
<p>我走到操场上，打开QQ，还好，只退出了登录，但自动记住了密码。我登上她的QQ，看到一个热血风的动漫头像，信息框显示发来的最后一句是：“宝贝，下次聊。”</p>
<p>我没有点进对话框，直接退出登录，把密码删了，给我妈打了个电话：“妈，最近怎么样。”</p>
<p>妈：“我这边没什么问题，就是你爸，总上夜班。”</p>
<p>我：“你让他别上夜班，伤身体。”</p>
<p>妈：“上夜班每天多10块钱。他那个脾气，谁劝得动。”</p>
<p>我：“……。”</p>
<p>妈：“赣州马上降温了，注意保暖。”</p>
<p>我：“好。”</p>
<p>妈：“秋衣秋裤记得穿上，不要逞能耍帅。”</p>
<p>我：“知道了。”</p>
<p>妈：“还有，在学校，有集体活动多参与，要交钱的及时说，不能占别人便宜，也别拖人家后腿。”</p>
<p>我：“好，我知道，钱够用。”</p>
<p>妈：“那先这样，我这边来了两桌客人。”</p>
<p>电话那头传来桌椅挪动的声音，我挂断了。</p>
<p>回到教室，把手机还给王骏一后，我魂不守舍，在黄色封面笔记本上乱涂。</p>
<p>我戳了戳王骏一：“你有喜欢的人吗？”</p>
<p>王骏一：“有啊。”</p>
<p>我：“如果你知道，你喜欢的人有男朋友怎么办？”</p>
<p>王骏一：“她有没有男朋友，跟我喜不喜欢她有什么关系？”</p>
<p>我：“王大师，我悟了。”</p>
<p>王骏一：“滚去读书，别影响我刷贴。”</p>
<p>事实上，除了武侠小说和禅宗故事，现实中从来不存在顿悟。当天晚上，我还是因为这件事，失眠了。</p>
<p>我在上铺辗转反侧，下铺的同学受不了：“哥，都晃两个小时了，还没结束？”</p>
<p>我立刻躺平，盯着漆黑的天花板。他是个怎样的男生？是我们学校的吗？我有没有见过？以我的身高，打架我是肯定打不过的。成绩，大概率也比我好吧。他们在一起多久了？那个天台会不会就是他们约会的秘密基地？李乐是不是每天早上都给他带牛奶？</p>
<p>入睡的前一秒，我想起了老王第一节课上说的那句话：“这么美好的姑娘，不知道便宜了哪位臭小子。”</p>
<br>

<h2 id="第四场"><a href="#第四场" class="headerlink" title="第四场"></a><em>第四场</em></h2><br>
自从知道李乐有男朋友后，我再怎么假装正常，都有些不自然。

<p>我想接近，但所有的行为都在逃避。</p>
<p>我试图通过写作转移自己的注意力，决定参加新概念作文大赛。</p>
<p>在我的想象中，当我通过初试的那一刻，我就有勇气对李乐说：你能便宜便宜我吗？</p>
<p>周六拿回手机后，我自己去学校书店买了那本杂志，翻到报名表那一页拍照发了一条说说：我要去上海公费旅行。</p>
<p>一分钟后，同村的小辉给我评论了：我去年过初赛了。</p>
<p>小辉是我发小，住我屋下头。他爸是个有些理想主义的文艺青年，一屋子的旧书，还有一个古老的录音机，挂式空调那么大，里面可以放磁带，全都是BEYOND的歌。</p>
<p>我和小辉离得近，夏天暑假晒谷子时就窝在一起，一边听BEYOND，一边看《故事会》，每看完一篇，就去翻一遍稻谷。小学加初中的暑假，我俩把一屋子的书都翻烂了。5年级，我们一起参加过学校举办的作文比赛，他拿了二等奖，我拿了三等奖。</p>
<p>不过他除语文外的科目都不行，中考勉强过了普通高中录取分数线，考进县城4中。我去赣州读高中后，我爸用所有的积蓄在镇上买了套房子，离开村里，和我妈去广东打工了。搬家去镇上后，我和小辉就没再联系。</p>
<p>我立刻给他打电话：“小辉，去年你去复赛了吗？”</p>
<p>小辉：“没去。”</p>
<p>我：“为什么不去？”</p>
<p>小辉：“没钱买车票。”</p>
<p>我：“学生不是可以报销交通费吗？”</p>
<p>小辉：“我没读书了。”</p>
<p>我：“什么情况。”</p>
<p>小辉：“我们村二癞子搞传销那事你知道吧。”</p>
<p>我：“听我妈提过，听说也拉我们家入过股。我爸说我读书钱不够，就没入。”</p>
<p>小辉：“我爸入了，攒的钱都投进去，跟他去了广西。去了才知道是传销，一个人逃出来，流浪到湖南报警，才回的家。”</p>
<p>我：“人没事就好。”</p>
<p>小辉：“人是回来了，精神状况不太好，干不了活。我想着反正继续读下去也就考个大专，干脆就出来打工了。”</p>
<p>我：“你现在在哪里？”</p>
<p>小辉：“在汕头，一个电子厂。”</p>
<p>我：“那你还写东西吗？”</p>
<p>小辉：“偶尔写，你现在怎么样，怎么突然想参加这个了？”</p>
<p>我：“感觉自己能写点东西，想试试。”</p>
<p>小辉：“加油，我这有个写手群，我拉你进。大家都挺热情，写东西有什么问题可以发里面。”</p>
<p>我：“好。”</p>
<p>在创作中，很快进入了11月。截稿日期快要到了，我虔诚地用自己都看不下去的字，重新誊写了一遍，买了张邮票，把文稿寄往上海。</p>
<p>11月是脐橙采摘的时候，作为赣南唯一拿得出手的特产，脐橙在我们班上泛滥成灾。</p>
<p>原因有2个，根本原因是阿飘关注大家成绩的同时也关注大家的身体，强调课间可以适当补充营养，比如牛奶和水果。有了班主任的允许，大家都把水果和牛奶往教室带，有些女同学，嫌每天带太麻烦，直接在周日返校时，让老爸一箱一箱往教室搬。</p>
<p>其次，班上很多同学的父母自己开公司，年底需要送礼给客户，会买比较多的脐橙。很多政府部门、事业单位，为了支持本地农业，这个阶段发福利也都是发脐橙。</p>
<p>于是，在这个时候进入19班，你会觉得自己进了赣南脐橙展销会。</p>
<p>吃脐橙很快就取代“谁是卧底”，成为了课间最主流的活动。下课铃一响，就有同学从桌子里抽出一张A4纸垫上，拿出水果刀，熟练地把脐橙切成8瓣，再分给大家。</p>
<p>我们这一块，负责分发脐橙工作的是周琪。过于热心的她，常常切了10分钟，自己一块也没吃。</p>
<p>那天，我去周琪桌上取脐橙，我看上的那块，李乐恰好也看上了，我们同时出手，两只手尴尬地碰在一起。</p>
<p>我把手缩回来，说了句对不起，马上拿另一块走了。</p>
<p>跑操解散后，李乐和我一起上楼梯，她喊我：“曾小千。”</p>
<p>她很少叫我全名。</p>
<p>我转头：“怎么了？”</p>
<p>她：“我怎么感觉你刻意躲着我？”</p>
<p>我：“有吗？”</p>
<p>她：“有。”</p>
<p>我：“可能我最近写东西写懵了。”</p>
<p>她：“神经。”</p>
<p>通过我的观察，李乐在学校没有和任何男生有亲密接触，所以她男朋友肯定不是本校的，我松了一口气。可转念一想，不在一个学校还能坚持，那不就更说明情感稳定？</p>
<p>也许是李乐那天在天台把我说透了。摆脱太奶奶的影响后，我后面几次月考的成绩都回到了20名左右的水平。虽然离学号还有一定距离，但比前两次好了不少。</p>
<p>班主任和身边的同学，对我也有了新的评估，我的水平，就是中游水平。</p>
<p>高二的第一个学期结束了，我回镇上过了一个并不快乐的寒假。</p>
<p>跟别人谈恋爱的李乐，遥遥无期的新概念初赛结果，乏善可陈的成绩排名。</p>
<p>王骏一整个假期都没有发动态。李乐发了条和朋友一起吃炒酸奶的说说，不知道是不是和那个叫她宝贝的人一起吃的。</p>
<p>小辉来镇上赶了几次集，我问他：“你有喜欢的人吗？”</p>
<p>小辉说：“有，原来的高中同学。”</p>
<p>我：“你追她了吗？”</p>
<p>小辉：“辍学后就没联系了。”</p>
<p>我：“那说明你不够喜欢。”</p>
<p>小辉：“怎么，有喜欢的姑娘了？”</p>
<p>我：“嗯，坐我前面一个姑娘。”</p>
<p>小辉：“趁着在学校，认真追一下。”</p>
<p>提起李乐，我就想起她QQ上的男友，我不想再继续聊这个话题：“我寄给新概念的那篇稿子你看了吗？”</p>
<p>小辉：“看了。”</p>
<p>我：“实话实话，你觉得怎么样。”</p>
<p>小辉：“很不错，你是怎么寄过去的？”</p>
<p>我：“抄写一遍寄过去的。”</p>
<p>小辉或许是想起了我的字，沉默了一会儿：“嗯，等结果吧。”</p>
<p>新年过后，进入了高二下学期。寒假的长度刚刚好，可以在跟父母翻脸前离开，又可以在思念成疾前见到想见的人。</p>
<p>李乐一身新衣，添了条红色围巾，周琪带来了一个热水袋，王骏一换了个新眼镜，只有我一成不变。</p>
<p>我妈说要给我买过年衣服，我听着家里卫生间和厨房两个为了省水费正在滴水的水龙头，说：“不用了，这衣服还是新的。”</p>
<p>上午在教室走完报名手续后，大家就各自回宿舍收拾床铺了。</p>
<p>我刚从蛇皮袋里把棉花抱出来，QQ班级群冒出一条通知，周琪问，有谁去唱K。李乐在后面跟了个：我。</p>
<p>我问王骏一：“唱K你去吗？”</p>
<p>王骏一看了眼群：“你想去就一起呗。”</p>
<p>我把棉花扔到床上，拿起手机在群里回复：我。</p>
<p>一行人十几个，在校门口集合。下午送学生返校的私家车散了不少，我们在公交车亭等车。</p>
<p>建在新区的学校就是这么扯淡，上万名师生，全靠一条28路公交通往市区和火车站。可学校交通不便却是无数家长心中的优点——因为这样学生就只能呆学校认真读书。</p>
<p>开学第一天，返校的28路基本是满的，我们坐的反方向，空空荡荡。</p>
<p>上车时，李乐先上坐在后排外侧，我路过时想坐里面那个位置，李乐的腿往外移了点。</p>
<p>我正要进去，王骏一坐在最后一排朝我招手。我径直走到最后一排，坐在了王骏一旁边。</p>
<p>唱K要去南门口老城区。国光超市对面有一排老旧的KTV，麦克风常常失灵，沙发边缘已经被坐的包浆，一水的霓虹灯招牌，好些灯管已经坏了，一到晚上没有一家店名全亮的。门口标配几个磕瓜子聊闲天的大妈，见到成群结队的小年轻就问一嘴：“唱歌吗？小包只要60。”</p>
<p>这些KTV的名字都很有年代感：月亮湾、喜洋洋、好莱坞……</p>
<p>28路公交车的站台就在这排KTV的前面，所以，尽管我没去过，但每次等公交车都要在门口站上几十分钟，对那块地方也算熟悉。</p>
<p>周琪带我们进了其中一家，通过大厅亮色的马赛克瓷砖，还依稀可以窥见这里昔日的繁华。</p>
<p>一进包房，我和王骏一就找了个角落坐下。</p>
<p>其他人从苏打绿的《小情歌》唱到五月天的《恋爱ing》，从陈奕迅的《十年》唱到周杰伦的《稻香》。</p>
<p>很快，周琪发现王骏一和我一直躲在角落摸鱼，就带头起哄，要求我们必须一人来一首。</p>
<p>我用胳膊肘推了推王骏一：“我没唱过K，我们东山坝没这玩意，你点一首吧。”</p>
<p>王骏一收起手机，接过周琪手里的话筒。</p>
<p>我松了口气，朝王骏一竖了个大拇指：”兄弟，牛……”</p>
<p>话还没说完，王骏一说：“曾小千说他一个人唱两首，把我那首也包了，大家掌声鼓励。”</p>
<p>包厢里所有的人开始鼓掌起哄。</p>
<p>我脑袋一片空白，初中时期非主流肆虐各大乡镇，我常听的那些洗剪吹歌曲，在这种场合，实在开不了口。更糟糕的是，这是我第一次进KTV，一嗓子出去是什么效果，我心里没数。</p>
<p>如果李乐不在现场，我硬着头皮唱一首也就应付过去了，但是李乐正在鼓掌看着我。没有一个17岁的少年可以接受自己在心上人面前出丑，还是当众出丑。这等同于接受宫刑。</p>
<p>王骏一把话筒塞到我手里，周琪把我带到点歌台旁边。我心一横，咬咬牙，大不了就唱一首《心痛2009》，从此与在座各位同学相忘于江湖。</p>
<p>点歌台屏幕有延迟，我按手写输入，点歌机把歌星按字母排序了，我看到B开头的歌手，忽然想到了BEYOND。</p>
<p>那些和小辉在村里晒稻谷的夏天，像波浪一样盖过初中的非主流岁月，黄家驹熟悉的嗓音在我耳边响起：今天我寒夜里看雪飘过，怀着冷却了的心窝飘远方……</p>
<p>我唱了两首，一首《海阔天空》，一首《真的爱你》。</p>
<p>那天，我借着BEYOND对李乐用粤语说了四句：请准我说声真的爱你。</p>
<p>这是首唱给母亲的歌，但我想说的只有这一句。</p>
<p>因为没人听得懂粤语，麦克风又美化了嗓音，两首的效果居然都还不错。</p>
<p>总算蒙混过关，我拉着王骏一，借口宿舍搞卫生提前退场了。再待下去，就是心痛2014了。</p>
<p>王骏一：“看不出来，高手啊。”</p>
<p>我：“你他妈的差点搞死我。”</p>
<p>王骏一：“唱这么好，虚什么。”</p>
<p>我：“我就会这两首。”</p>
<p>第二天早读，李乐对我说：“昨天唱的粤语歌不错，你以前在广东读过书吗？”</p>
<p>我：“没有，跟一个在广东打工的朋友学的。”</p>
<p>她：“寒假作业写完了吗？”</p>
<p>我：“除了英语，都写完了。”</p>
<p>她：“老王没骂你？”</p>
<p>我：“我跟他说被我侄子丢火盆里了。”</p>
<p>她：“这理由他能信？”</p>
<p>我把手机里那张英语寒假作业在火盆里烧了一半的照片给她看：“事实就是这样。”</p>
<p>她拿着我手机，左右滑动了一下，看到了我拍的老家房子：炊烟袅袅，门口家人晒着太阳烤火，几只鸡在地上叨散落的谷粒。</p>
<p>她眼里闪着光，问：“这是你家吗，世外桃源的感觉，好想去住。”</p>
<p>我感觉有些被冒犯，可能就像王骏一看其他很多男生不爽一样。对方只是很正常地表达自己的感受，但我依旧会多想。</p>
<p>那地方不是世外桃源。因为夏天需要通风，所以窗户只能用塑料薄膜覆盖，冬天风大，一整晚都是风吹塑料薄膜的声音。没有洗手间，房间里放个尿桶，满屋子都是辣眼睛的氨味。没有热水器，刚炒完菜的大锅，涮涮就用来烧洗澡水，烧开后还能看见表面浮着一层五彩的油膜。</p>
<p>我爸花了半辈子的时间，才走出这个“世外桃源”。</p>
<p>我笑着点点头：“高考完，带你去体验一下。”</p>
<p>她：“一言为定。”</p>
<p>不知道是不是我的错觉，KTV事件后，班上很多同学都对我更热情了些。我好像也更加完全地融入了这个集体。</p>
<p>开学后不久，新概念作文大赛初赛结果出来了，我在A组找了5遍，确定没有入围后，决定假装一切都没发生。</p>
<p>拿回手机后，我给小辉发了个信息：“没入围。”</p>
<p>两分钟后小辉回了一句：“建议你下次投稿，打印出来投。你那个字，确实有点影响阅读。”</p>
<p>一个坏消息通常伴随着一个好消息，高二下学期的第一次月考，我考了全班第15名。虽然还是没追上我的学号，但已经是分科后历史最佳了。</p>
<p>为了庆祝进步，当天晚上我奖励了自己一瓶酸奶，和一包海白菜。</p>
<p>我和李乐的关系，也越来越近，似乎从朋友，变成了好朋友。</p>
<p>这一切，都要感谢命运。</p>
<br>

<h2 id="第五场"><a href="#第五场" class="headerlink" title="第五场"></a><em>第五场</em></h2><br>
本来，在那次“世外桃源”后，我清醒了不少。我跟她可能不是一个世界的人，这样的误解和芥蒂在未来只会越来越多。

<p>可不久后的一场雨，让爱意冲破了所有的阻碍，让我这个小镇青年彻底放下了城乡偏见，一头扎进了爱情的苦海。</p>
<p>李乐是个大大咧咧的女生，倡导极简，拒绝一切麻烦的事情，比如说带伞。</p>
<p>而我因为从小生存环境恶劣，只能处处谨慎，未雨绸缪，比如说每天都在书包侧面放一把伞。</p>
<p>那个学期的第一场雨下得很突然，下晚自习前还好好的，一打下课铃，就开始下雨。</p>
<p>班上一大半的人都没有带伞，当然也包括李乐。</p>
<p>男生宿舍就在教学路对面，不少男生顶着书包就跑回去了。但女生宿舍穿过男生宿舍还要往左边走一段路，很多女生只能在教室里干等着。</p>
<p>李乐问周琪：“你带伞了吗？”</p>
<p>周琪：“我也没带。”</p>
<p>李乐看到了我书包侧边的伞，但她没说话。</p>
<p>我在座位上纠结了2分钟，鼓起勇气说：“李乐，我送你回宿舍吧。”</p>
<p>李乐背起书包：“走吧。”</p>
<p>回女生宿舍有2条路，一条是刚才说的穿过男生宿舍左转，另一条是从教学楼右边绕过男生宿舍，走食堂门口的马路回。</p>
<p>后一条路比前一条路远了大概几百米，我选了后一条。</p>
<p>李乐：“这么冷，怎么不走男生宿舍那边？”</p>
<p>我就是想路远一点，多走一会儿。</p>
<p>我：“没反应过来，我平时都走这条路。”</p>
<p>李乐：“你这次考得还不错。”</p>
<p>我：“瞎猫碰上死耗子。以前英语阅读理解能对一半就不错了，这回英语阅读理解全对。”</p>
<p>李乐：“你英语确实得好好补补了，还有字得练练，不然文综扣分很多。”</p>
<p>我：“要不我们一起练字吧。”</p>
<p>李乐：“我的字又不丑。”</p>
<p>我：“那我练字和做英语阅读理解，你和我一起练英语阅读理解，每天互相打卡。”</p>
<p>李乐：“可以啊，谁缺卡就给对方买一瓶酸奶。”</p>
<p>我：“没问题。”</p>
<p>走到食堂门口时，风变大了，我把伞往她的方向倾斜，手肘不小心碰到了她的胸。我发誓，除防止她淋雨之外的，我没有一点别的想法。但它发生的那一刻，所有龌龊的场景都涌进了我的大脑。我赶忙换了只手撑伞，她红着脸往外挪了挪。</p>
<p>我才发现，李乐算是身材不错那一种，宽大的校服也盖不住正在发育的线条。少年们都顾着看脸，饱经风霜的老王早已看透了本质。</p>
<p>一路上我们没有再说话，在女生宿舍门口，几对情侣在拥抱分别。男生宠溺地说：“晚安，宝贝。”</p>
<p>女孩小跑进女生宿舍，回头说：“晚安，亲爱的，明天见。”</p>
<p>我腻得像一口气喝了一瓶1.25L的泄气可乐，转头对李乐说：“早点休息。”</p>
<p>李乐：“你也是。”</p>
<p>第二天，我买了练字的字帖，对李乐说：“我开始了，你小心今天欠我一瓶奶。”</p>
<p>下午我看到李乐桌上也多了一本一样的字帖。</p>
<p>我问她：“你不是说你不用练字吗？”</p>
<p>李乐：“我喜欢，你管我？”</p>
<p>共同话题是促进关系的良药。我们每天多了一个共同的话题，关系也亲密起来。</p>
<p>更巧的是，那次下雨后不久，赣州进入了梅雨天气，常常一下就是一周，我们就养成了一起下课的习惯。</p>
<p>我们约定，中午下课后，推迟20分钟走，用来练字。晚自习下课后推迟15分钟走，用来对英语答案。</p>
<p>中午刚下课是学校食堂最挤的时候，推迟20分钟去，刚好可以不用排队。</p>
<p>自从每天中午推迟下课后，我才发现，学校里很多小情侣都这么干。我和李乐每天都能遇到一对女生，一个假小子类型，一个小家碧玉，牵着手路上打打闹闹，在食堂打一份饭两个人吃。</p>
<p>我们最常去的是2楼左边的食堂，种类比较多，除了统一的饭菜，还有很多单独的小铺。有一个赣县阿姨开的瓦罐汤窗口，和一个瑞金大叔开的盖浇饭窗口。</p>
<p>我们每天中午，都点一份瓦罐汤。她最喜欢的汤是香芋排骨，我最常点的是生地排骨。</p>
<p>我并不喜欢生地，点它是因为招牌上写着，生地排骨汤的功效是清热解毒。那阵子我一直长痘，对一切标榜清热解毒的东西着迷，尽管它们每次都让我失望。</p>
<p>我很喜欢跟她一起吃饭。她吃任何东西，都会给你一种很好吃的错觉。</p>
<p>我是个吃饭很慢的人，每次她吃完都要等我。而别桌都是男生一脸宠溺地看着女生细嚼慢咽。</p>
<p>那阵子，我的成绩还不错，起码我自己这么觉得，稳定在10到20名之间。</p>
<p>一切看似在往看起来美好的方向发展，但一个问题依旧时不时跳出来困扰我——李乐的男朋友到底是谁？</p>
<p>我弄清楚这个问题那天，是语文老师的生日。</p>
<p>语文老师是一位温柔的中年女性，讲话轻声细语，做事润物无声。在她的课上，我常常打瞌睡，但她的解决办法是，走到你身旁，提高音调讲几句话。当然，她能成为我最喜欢的老师，也不仅仅因为这些。我一直认为，整个高中生涯，只有语文老师真正能体会到我的纠结与踌躇。因为，年过30的她，和17岁的我一样，还在长青春痘。</p>
<p>对于一个三十多岁还在长青春痘的人，每个人应该给予她无限的温柔。我可能在30岁面临同样的境况，希望别人能善待我。</p>
<p>那天语文课前，班长在讲台上让大家安静，并宣布：“今天是语文课，等下我喊‘起立’，大家一起说，祝老师生日快乐。”</p>
<p>语文老师穿了一件新的驼色外套，微笑着走上讲台，插好U盘准备打开PPT上课。</p>
<p>因为我们班老师都很随和，除了看到大家无精打采，想让大家起立醒醒神以外，基本不喊上课，大家也不用起立回“老师好”。</p>
<p>今天也一样，语文老师略过了这个流程。</p>
<p>班长眼见PPT就要打开，计划要落空，自己站起来强行喊了句：“起立。”</p>
<p>所有人站起来：“祝老师生日快乐。”</p>
<p>语文老师抬起头，眼眶红了：“谢谢各位同学，这是我收到最好的礼物。”</p>
<p>大家稀稀拉拉坐下，等着语文老师撑着讲台缓和情绪。我眼见气氛有点怪异，喊了句：“要不我们给老师唱个生日歌吧。”</p>
<p>这时身边的周琪和王骏一起劲了：“老师，曾小千要给你唱首歌做礼物。”</p>
<p>我当场石化了，一切又回到了在KTV里被王骏一支配的恐惧。</p>
<p>接着，那天在KTV的同学开始起哄，最后全班人开始起哄。</p>
<p>语文老师见群情激愤，平时与我关系也不差，就点名：“曾小千，那你唱一首吧。”</p>
<p>我扭捏地站起身，班上所有的目光投向我，李乐侧身，捧着一张笑脸看着我。</p>
<p>小丑终究是我自己。</p>
<p>没办法，故技重施，BEYOND救场，我说：“一首《真的爱你》，代表19班，献给我们最爱的语文老师。”</p>
<p>无法可修饰的一对手</p>
<p>带出温暖永远在背后</p>
<p>纵使啰嗦始终关注 </p>
<p>不懂珍惜太内疚</p>
<p>……</p>
<p>是你多么温馨的目光</p>
<p>教我坚毅望着前路</p>
<p>叮嘱我跌倒不应放弃</p>
<p>没法解释怎可报尽亲恩</p>
<p>爱意宽大是无限 </p>
<p>请准我说声真的爱你</p>
<p>唱最后一句时，我看着李乐的眼睛。她没有回避，我也没有从里面找到答案。</p>
<p>那天晚自习下课后没有下雨，但我还是送她回了宿舍。</p>
<p>李乐：“你唱BEYOND的歌真的挺好听的。”</p>
<p>我：“最后一句是给你唱的。”</p>
<p>李乐：“切。”</p>
<p>我抽出书包侧面的雨伞，当麦克风，唱了最后一句：“请准我说声真的爱你。”</p>
<p>李乐：“说爱还需要被允许吗？”</p>
<p>我：“万一人家有男朋友呢？”</p>
<p>李乐：“那就憋着。”</p>
<p>我：“你有男朋友吧。”</p>
<p>我们走到食堂门口，往前是女生宿舍，往左是男生宿舍。</p>
<p>李乐：“怎么突然问这个？”</p>
<p>我：“上次瞥见你跟一个男生聊了一晚的QQ。”</p>
<p>李乐：“哪次？”</p>
<p>我：“你借王骏一手机那次。”</p>
<p>李乐笑了：“你有病啊，那是我表姐。”</p>
<p>我：“那明明是个男生头像。”</p>
<p>李乐：“你没看过《火影》吗？那是宇智波鼬，我表姐的男神，她不仅用他做头像，她还用他做抱枕呢。”</p>
<p>我：“好吧。”</p>
<p>李乐：“这个问题你是不是憋很久了？”</p>
<p>我：“没有，就刚好想起来顺口一问。”</p>
<p>李乐：“吃醋了就直说。”</p>
<p>我：“我就是怕挨打，想确认一下，自己是不是每天和别人的女朋友一起下课。”</p>
<p>李乐：“现在确认了？可以肆无忌惮了？”</p>
<p>我：“肆无忌惮倒不至于，可以早点休息了。”</p>
<p>快到女生宿舍门口时，阿飘迎面走来，我赶紧低头想扭头跑，李乐大方地喊了一声：“老师好。”</p>
<p>我硬着头皮喊了句：“老师好。”</p>
<p>阿飘：“你怎么跑这边来。”</p>
<p>我指了指食堂侧门：“我来买点宵夜。”</p>
<p>阿飘：“晚上饿了，喝点热牛奶或者吃个苹果，别吃那些太难消化的。”</p>
<p>我：“谢谢老师。”</p>
<p>第二天，我和李乐去吃午饭。</p>
<p>她美滋滋地喝着自己的香芋排骨汤，我看着实在忍不住：“李乐同学，我可以喝一口你的香芋排骨汤吗？”</p>
<p>李乐：“不行。”</p>
<p>我失落地低下头。</p>
<p>李乐把嘴里的骨头吐出来：“除非你也让我喝一口你的。”</p>
<p>我把漆黑的生地排骨汤推到她面前：“随便喝。”</p>
<br>

<h2 id="第六场"><a href="#第六场" class="headerlink" title="第六场"></a><em>第六场</em></h2><br>
可能是因为太过美好，高二下学期过得很快。随着我和李乐的关系越来越好，我才感觉我真正爱上了这个集体，这个校园。

<p>教学楼的天台、小操场的单杠、食堂门口的花架、足球场的草皮，每个留下我们足迹的地方都变得可爱。</p>
<p>唯一感觉有些不对劲的，是王骏一。他好像与我越来越疏远。也许是我的错觉，他本来就是一个不怎么合群的人。</p>
<p>高二的暑假很短，马上进入高三，学校顶着被教育局查的压力也要补课。</p>
<p>2014年7月，韩寒拍的第一部电影《后会无期》即将上映，前期的宣发铺天盖地。朴树的一首《平凡之路》甚至要盖过电影的风头。</p>
<p>我单曲循环了一星期，终于得以保证下次去KTV时还有一首能拿得出手的歌。</p>
<p>电影首映日是7月24日，星期四，刚好那天下午第一节课是自习。我决定，为了韩寒逃课。</p>
<p>我跟李乐说了我的计划：我们12点下课，午休时间到2点，下午第一节课逃课，下午第二节课上课前，也就是2：50之前回来就行。买12：30的场，2：14散场，前后各留半小时左右打车来回。</p>
<p>计划很精准，就是时间太紧。</p>
<p>李乐说：“行，我们一起去吧。’</p>
<p>我：“被抓了怎么办？”</p>
<p>李乐：“就说身体不舒服，去校医室了。”</p>
<p>我：“走。”</p>
<p>我问王骏一：“你去吗？”</p>
<p>王骏一：“去。”</p>
<p>这让我很意外，他平时对文学和电影丝毫不感兴趣，居然愿意跟我一起去。</p>
<p>上午最后一节课结束，我们三个人立刻冲出教室。在学校门口拦了一辆的士，直奔电影院。</p>
<p>万盛是一个神奇的商场，除了顶上的电影院和负一层的商场，其它地方都冷冷清清。三个人饿着肚子，本来想先吃点东西，结果发现只有一个超市。王骏一跑去超市买了一大包零食，几个人急匆匆跑到检票处。</p>
<p>电影的情节很简单：三个人一起出发，送其中一个朋友去远方任教，然后一路相遇，一路走丢。</p>
<p>人生无非两个选择，告别或者告白。</p>
<p>电影我看得很不认真，中间很长一段我都在看李乐。</p>
<p>唯一记住的是，韩寒把王珞丹拍得好美，和李乐一样美。</p>
<p>电影刚结束，我们跑步下楼，王骏一拦下一辆出租车，冲上副驾，把零食丢到后排：“师傅，赣州中学，麻烦开快一点。”</p>
<p>在车上我问李乐：“你觉得怎么样？”</p>
<p>李乐：“很好啊，幽默又有深度。”</p>
<p>我：“你最喜欢哪句台词？”</p>
<p>李乐：“有时候，你想证明给一万个人看，但最后你发现只要有一个人懂就够了。”</p>
<p>我：“我最喜欢那句，喜欢就会放肆，但爱就是克制。”</p>
<p>李乐：“那你是放肆还是克制？”</p>
<p>我没回答，戳戳副驾驶王骏一的肩膀：“你呢，最喜欢哪句？”</p>
<p>王骏一说：“告别的时候还是要用力一点，多说一句可能就是最后一句。多看一眼，可能就是最后一眼。”</p>
<p>我们赶上了第二节课，逃课也没有被发现。</p>
<p>看完《后会无期》后，我们就彻底进入了高三的状态。新课都已经学完，剩下的就是重复多轮的复习。考试从月考变成周练。语文、数学、英语、历史、地理、政治，6门课，刚好周一到周六每天下午考一门。</p>
<p>高强度的学习容易让人暴躁，而我也一直在纠结，面对李乐，我是该放肆还是该克制。</p>
<p>高三学业为重，我们不再一起吃饭，只剩每天晚上下课后一起回宿舍走一段路。</p>
<p>小情侣们都一起走到女生宿舍门口再分开，我每次都在食堂门口就和李乐分开。</p>
<p>有天晚上我问李乐：“你有想过未来想过怎样的生活吗？”</p>
<p>李乐：“和喜欢的人，在喜欢的城市，买一套自己的房子，养一条金毛。下完班两个人一起遛狗，周末带狗去郊游。”</p>
<p>我：“听起来就很幸福。”</p>
<p>李乐：“你呢？”</p>
<p>我：“我还不知道，我爸从村里走到镇里，我先从镇里走到县里吧。”</p>
<p>李乐：“你现在已经在市里了。”</p>
<p>我：“也对。”</p>
<p>可能是我不够用功，也可能是其他人太过用功。进入高三后，我的排名又掉出30名开外。我感觉脑子就像断了根弦，再也续不上了。</p>
<p>在雪花一样的试卷里，我们进入了11月。</p>
<p>教室又到了切脐橙的季节，只不过，大家更讲究效率，不再有专人切好给你吃，要吃的自己剥。</p>
<p>周琪边剥脐橙边问李乐：“我们两个生日接近，要不然一起过吧。”</p>
<p>李乐咬着牛奶吸管：“可以啊。“</p>
<p>我问李乐：“你生日啥时候？”</p>
<p>她说：“12月12日。”</p>
<p>我决定送她一份特别的生日礼物。</p>
<p>进入高三后，《看天下》变得更加抢手，压抑的生活需要新鲜的段子续命。</p>
<p>其中一期杂志介绍了一款装着星河的棒棒糖。班上的女生奔走相告，大有谁送我这片星河，立马就以身相许的趋势。李乐和周琪也翻到那页，讨论了好几次。</p>
<p>我记下了棒棒糖的品牌，决定在她生日那天送她一篇文章和一盒星河棒棒糖。</p>
<p>周日拿回手机后，我查了一下那个棒棒糖，是个美国品牌，只能代购，500多一盒，基本上是我一个月的伙食费。</p>
<p>我带上银行卡，去超市旁的自动取款机查询余额，还剩1000块，下个月我爸还会给我打600，这么一算，也够。</p>
<p>我挑了一家靠谱的店铺，加入了购物车，正要付款，小辉拉我进的那个写手群冒出一个消息通知：靠，这也太浪漫了。</p>
<p>我点进去一看，原来是一个作者写了篇以自己和女朋友为原型的短篇，发在一本杂志上，在女朋友生日那天，这个作者把那本杂志送给了女朋友。</p>
<p>这是比单纯送一篇文章更好的方案。</p>
<p>我在群里询问：各位有杂志的投稿渠道吗？我女朋友12月过生日，我也想这么来一个惊喜。</p>
<p>大家纷纷把自己知道的杂志投稿邮箱发在群里。</p>
<p>几分钟后，我收到一个好友申请，备注是，某某杂志编辑。</p>
<p>他热情地跟我科普，一般大点的杂志，都提前很久安排版面。现在投稿，想在12月份拿到刊物基本不可能。</p>
<p>不过我运气好，发消息时正好他看见了。他是一家小杂志社的编辑，正好有个小说作者拖稿，可以安排我的稿子。</p>
<p>我连发了3个抱拳表示感谢。</p>
<p>他说，现在由于要走紧急审稿通道，需要交600元的费用，这个钱主要用于编辑帮忙润色稿件，保证上版。</p>
<p>我有些犹豫。</p>
<p>他又发，之后的正常投稿，都是有稿费的。而且你有了发表案例后，再去别的地方投稿也是不一样的。</p>
<p>经过半小时的考虑，我决定放弃星河棒棒糖，花600块钱把写的短篇发表在杂志社，在生日那天送给李乐。</p>
<p>我把稿子发给他后，就把手机上交了。</p>
<p>之后的每一天，我都借王骏一的手机登QQ跟编辑联系。编辑给我提了几个修改意见，我改完一版后，又给他发过去了。</p>
<p>我每天等着杂志寄过来，可一直到12月10日也没等到快递。</p>
<p>12月11号，我再发消息过去时，发现自己被拉黑了。</p>
<p>我知道，我遇到骗子了。</p>
<p>棒棒糖和杂志都泡汤了，只剩下一篇文稿。我去超市花1块钱买了一叠信纸，用我丑陋的笔记重新抄了一遍这个故事，放在了信封里。</p>
<p>故事写的是：</p>
<p>年轻的男孩和年轻的女孩相爱了，他们在城市租了个小房子，白天各自上班，晚上一起做饭看剧。</p>
<p>女孩说，等过几年，一定要换个大房子，养一条金毛，名字叫“乐多”，然后我们就天天下班之后就一起吃饭饭、睡觉觉、养乐多。</p>
<p>女孩把男孩带回家，女孩的爸爸要求要26岁之前，要在那座城市买一套100平以上的房子，否则就分手。</p>
<p>男孩努力攒钱，26岁时终于倾其所有，买了一套52平的公寓。女孩的父亲看完后一句话没说，把女孩带走了。</p>
<p>男孩很伤心，继续在这个城市奋斗。可命运并没有眷顾他，他因为状态不好，犯了不少错，被公司开除。</p>
<p>2年后，男孩不得不离开这座城市，他决定把公寓卖掉回老家。</p>
<p>在和买家签合同的时候，他在公寓门口遇到了一只金毛，他鬼使神差地叫了一句“乐多”。金毛居然摇着尾巴过来了。</p>
<p>他蹲下来摸了摸金毛，这时候从隔壁走出一个熟悉的身影，是她日思夜想的女孩。</p>
<p>原来，女孩用所有的积蓄，在他隔壁买了一间公寓。</p>
<p>最后男孩没有卖掉公寓，他们把房子打通，拥有了一套104平米的房子。</p>
<p>他们结婚，过上了下班后吃饭饭、睡觉觉、养乐多的生活。</p>
<p>12月12日，王骏一请了一天的假，没人知道为什么。</p>
<p>第一节晚自习是老王的，我把李乐带到天台，把文章给了她。</p>
<p>她看完后说：“吓死我了，我还以为他们要分开。”</p>
<p>我：“送你的，当然是温暖的结局。”</p>
<p>她：“谢谢，这个生日礼物我很喜欢。”</p>
<p>我：“还有一个礼物，本来是准备送棒棒糖的，但是出了点意外，只能寒酸点了。”</p>
<p>我从口袋里拿出一个小口琴，断断续续地吹。</p>
<p>她边听边笑：“哈哈哈哈，依稀能分辨出旋律是《同桌的你》。”</p>
<p>我：“我花一天时间练成这样不错了。”</p>
<p>她拍拍手鼓掌：“不错不错。”</p>
<p>我：“生日快乐。”</p>
<p>她：“谢谢，非常快乐。你什么时候生日？”</p>
<p>我：“我不过生日。”</p>
<p>快乐，就在此刻结束。</p>
<p>我们回到教室后，发现王骏一连人带座位消失了，而我、李乐、周琪桌上，都多了一盒星河棒棒糖。</p>
<p>我问周琪：“王骏一的桌子呢？”</p>
<p>周琪：“上节课，王骏一和他爸爸，还有年级组长，把他的桌子搬到17班去了。”</p>
<p>原来，王骏一的爸爸是市里某国企老总。因为身份特殊，平时工作忙，不常来学校。对王骏一的要求也是，务必要低调。</p>
<p>高三后，王骏一成绩一直没有起色，他爸有些着急，最后阶段，想送去宏志班17班搏一搏。</p>
<p>我想起他和我们一起看《后会无期》时，说的印象最深刻的台词：“告别的时候还是要用力一点，多说一句可能就是最后一句。多看一眼，可能就是最后一眼。”</p>
<p>可能他早就知道了他爸的打算，只是一直拖到现在才执行。</p>
<p>我坐在座位上，感觉自己被抛弃了。他欺骗了我，一直以来，我以为他和我一样，来自小镇，不理解这些城里孩子的举动。我还傻呵呵地劝他好好努力，我还总教育他父母不易。我以为他把我当班上最好的朋友，原来他只是把我当班上最好骗的傻子。我们同样沉默，我们同样躲在角落；他是源自自信的不屑，我是源自无知的自卑。</p>
<p>他跟我根本不一样。阔绰的出手，对学习无所谓的态度，对未来有恃无恐的自信。还有阿飘的特别关心，英语老师的谄媚。</p>
<p>我早该注意到，他的学号50，最后一位，这种学号基本就是周琪说的，花钱买进来的类型。</p>
<p>其实王骏一根本没有骗我，只是我太需要这个班有一个和我一样，从小镇考出来，自卑、内向、成绩一般的朋友。</p>
<p>教室里的人忽然集体抬头看着白板上的投影，我抬头一看，原来老王用教师权限提前查到了这次月考的成绩排名，在几位学霸的怂恿下把成绩投在了大屏幕上。</p>
<p>随着滑块越滑越低，20名，还没看到我的名字，30名还是没看到，40名，还是没有，一直拉到最后，倒数第一。</p>
<p>大多数人可以接受自己不优秀，但决不能接受自己是最后一名。</p>
<p>我还没从刚刚朋友背叛的情绪中缓和，立刻又陷入了新的绝望。</p>
<p>我走出教室，路过17班教室时看到王骏一在最后一排的角落，趴在桌子上一动不动。</p>
<p>我来到办公室，阿飘在座位上改作业，察觉到有人进来，抬头看见了我：“小千，这次成绩看到了吗？”</p>
<p>我：“刚刚看到。”</p>
<p>阿飘：“还有半年，一切都还来得及。”</p>
<p>我：“老师，我想换座位。”</p>
<p>阿飘：“没问题，你跟同学商量好，跟班长报备就行。”</p>
<p>我：“王骏一去17班了，我再跟谁换都要让其他人一个人坐，我想申请坐讲台旁边。”</p>
<p>阿飘：“没问题，你等下就搬过去吧。”</p>
<p>我：“好的。”</p>
<p>回到教室后，大家已经从看排名的混乱中恢复。第二节晚自习课间，我从教室侧面，把桌子搬到讲台旁边。</p>
<p>李乐问我：“你干嘛？”</p>
<p>我：“换座位。”</p>
<p>李乐：“为什么？”</p>
<p>我：“我觉得这里视角好。”</p>
<p>李乐：“随你便吧，我和周琪准备去17班看看王骏一，你跟我们一起去吧。”</p>
<p>我：“我不去，我跟他没什么好说的。”</p>
<p>李乐牵着周琪：“我们走吧，别理他。”</p>
<p>我不知道李乐对王骏一说了什么，总之，第三节晚自习，王骏一自己又把桌子搬了回来，再也没有离开19班。</p>
<p>12号那天晚上，我刚打下课铃就走了，李乐跟在我身后，我故意加快脚步，她小跑着到我前面：“考差一次有那么可怕吗”</p>
<p>我：“我不是因为这个？”</p>
<p>李乐：“那我喊你一起去找王骏一你为什么不去，他把你当最好的朋友，这种时候你却一句话都不说。”</p>
<p>我：“是他先骗我的。”</p>
<p>李乐：“他骗了你什么？”</p>
<p>我：“他……男生之间的事，跟你说不清。”</p>
<p>李乐：“你能不能不要跟个小姑娘一样？这个不能说，那个说不清。只有想不想说，没有说不清。”</p>
<p>我低头想了很久：“就是说不清。”</p>
<p>李乐：“你今晚好好休息下吧，明天周六，晚上我们去大操场聊聊。”</p>
<p>周六一整天我都没听课，虽然坐在讲台边，但却感觉离课堂很远。我满脑子都是晚上和李乐该怎么说。</p>
<p>下午吃完晚饭，我就先去大操场跑步。</p>
<p>我在QQ上问李乐：“你什么时候来。”</p>
<p>李乐：“在洗头，等会儿。”</p>
<p>周边工地的吊塔已经不再转动，只有顶上的灯泡还在一闪一闪。中航已经有人入住了，据说我们班有好几个人就住那里。</p>
<p>一个想法从心底跃上脑袋，像吊塔顶端的灯泡，越闪越亮，最后变成一轮明月：是不是到了该说我爱你的时刻。</p>
<p>反正一切都已经最糟糕，成绩已经触底，最好的朋友已经破裂，只剩下最美好的李乐。</p>
<p>如果她接受，就带着美好奋起直追；如果拒绝，就埋头苦读。</p>
<p>我去超市买了一朵红色的纸玫瑰，插在外套内衬的袋子里。</p>
<p>我给李乐发QQ消息：“我在大操场铁门旁等你。”</p>
<p>李乐：“吹头发了，3分钟下来。”</p>
<br>

<h2 id="第七场"><a href="#第七场" class="headerlink" title="第七场"></a><em>第七场</em></h2><br>
刚准备把手机收起来，我妈来电话了。

<p>我：“喂，妈。”</p>
<p>我妈：“小千，最近考试了吗？”</p>
<p>我妈总是这样，已经知道的事情非要装作不知道，让你自己说出来。</p>
<p>我：“考了，班上倒数第一。”</p>
<p>我妈：“有分析原因吗？”</p>
<p>我：“题不会做。”</p>
<p>我妈沉默了一会儿：“本来不想告诉你的。”</p>
<p>她每次以这句话开头，都说明接下来的事她蓄谋已久要讲给我听。</p>
<p>我：“没事，说吧。”</p>
<p>我妈：“你爸，因为年纪大，上夜班出工慢，被厂里开除了。最近在找新工作，这个时节吧，工作也难找。你爸不让我跟你说，可是我一听你这成绩，想想还是告诉你。你底子不差，得好好读书，不要将来和我们一样四五十岁在外面找工作被人嫌弃。”</p>
<p>我：“你跟班主任打过电话了吧。”</p>
<p>我妈：“昨天晚上打的。”</p>
<p>我：“嗯，我昨天晚上找班主任调位置了，一个人换到讲台边上了。”</p>
<p>我妈：“那也好，一个人好好用心。钱还够吗？”</p>
<p>我想起被骗的600，一阵心疼：“钱够用，不够我打电话说。”</p>
<p>我妈：“你从小就懂事。这个阶段我还是要提醒你一句，除了读书，其它的事情都放一放。我之前就说过，咱们尽量把自己做好，别拖人家后腿。你把书读好了，未来自己有能力了，其它的事情都是水到渠成。现在着急着做以后的事，现在的东西抓不住，未来的也会跑。”</p>
<p>阿飘看见过好几次我和李乐一起下晚自习，我妈说这段话也不奇怪。</p>
<p>我：“好，我知道了。”</p>
<p>我挂完电话，抬头看见李乐披着长头发站在铁门另一侧。</p>
<p>李乐：“打完了？”</p>
<p>我：“嗯。”</p>
<p>李乐：“怎么样，今天能和我说清了吗？”</p>
<p>我：“我觉得没必要说了。”</p>
<p>李乐：“为什么？”</p>
<p>我：“我想去教室看书了，你回宿舍吧。”</p>
<p>李乐：“你怎么了？”</p>
<p>我：“我想读书。”</p>
<p>李乐：“为什么？”</p>
<p>我：“因为我是个小镇出身，不自量力自作多情的倒数第一！”</p>
<p>我转身往教室走，把胸口的玫瑰扔进了食堂旁边的垃圾桶。</p>
<p>我在讲台旁度过了剩下的高三，跟李乐和王骏一再也没有交集。我常常看到李乐、王骏一、周琪三个人一起，我都故意绕远。</p>
<p>独自奋斗的时间会被无限拉长，我终于熬到了高考。</p>
<p>我被分到赣一中高考，李乐也是。恰巧赣一中由我们班主任阿飘带队，也让我们这批人格外安心。</p>
<p>早上，我们统一在校门口坐上专线公交，下车后在赣一中门口的大树下集合。</p>
<p>阿飘提着两个红袋子，里面装满了德芙巧克力。阿飘说怕有同学低血糖影响发挥，每人领一粒。</p>
<p>那年的作文题是：一位父亲在高速公路开车打电话，旁边的孩子一再提醒父亲不要拨打电话。可父亲不听劝阻，最终孩子选择报警。警察赶来后对父亲进行批评教育，引起社会争议。请以此为内容，写一封800字的信。可选择给违章当事人、女儿、警察写。</p>
<p>我在那场语文考试中举行了人生最盛大的一场文学行为艺术，我没有选当事人，也没有选女儿，更没有选警察。</p>
<p>我给争议群众写了一封信，中心思想就是劝说他们多关心关心自己的孩子和自己的行为，不要天天在网络上当喷子。</p>
<p>当最后一门英语考试结束，学校安排了一辆加长版的公交来接我们。</p>
<p>车子中间有一个衔接的圆盘，转弯的时候它也会跟着转动。我和李乐站在圆盘上，她在前半截车厢，我在后半截。一路上，我都害怕它会忽然断裂，我和李乐再也无法站在同一个圆盘上。</p>
<p>当天晚上，班长在市区星级酒店订好了宴会厅。</p>
<p>我再次被城市的排场震惊，舞台、音响、灯光、红毯……我以前以为，电视里拍的青春都是夸张，现在才知道人家都是写实派。</p>
<p>离开饭还有一段时间，班长在酒店旁开了两个KTV房。</p>
<p>我和李乐在同一个房间，她唱了什么我忘了，我只记得我没有唱《真的爱你》，我唱了《平凡之路》。</p>
<p>两小时后，晚餐开始。</p>
<p>分别可以消除所有芥蒂，我甚至跟老王喝了2杯交杯酒。</p>
<p>我和班上每一个同学干杯，从啤酒喝到红酒再到白酒。</p>
<p>我不知道我那晚到底喝了多少，我只记得，最后我坐在门口拉着一个服务员的手，对他说：“你相信命运吗？如果我太奶奶晚一点走，我可能就不会爱上李乐……”</p>
<p>服务员怕我吐他身上，边往后退边喊：“信、信、信。”</p>
<p>投影和音响打开后，不断有人站上去表白。</p>
<p>我把啤酒瓶握在手里，我决定，谁敢对李乐表白，我TM就上去跟他吹瓶干杯，因为太有眼光。</p>
<p>可我没想到，上去对李乐表白的是王骏一。</p>
<p>他喝得满脸通红，却不像之前那些人那样浮夸。他抓着话筒，咽了几口口水，只说了一句：“李乐，我喜欢你。”</p>
<p>手里的啤酒瓶掉在地毯上，像中毒身亡的我，撒了一地的白沫。</p>
<p>原来他去唱K不是陪我，而是看到李乐会去；</p>
<p>原来我和李乐关系越来越好，他跟我却越来越疏远不是错觉；</p>
<p>原来一起去看《后会无期》，他是想陪李乐去看；</p>
<p>原来他课间照镜子，不是在看自己，而是看在旁边玩谁是卧底的李乐；</p>
<p>原来他在李乐生日那天给我们3个人送星河棒棒糖，只是想送给李乐一个人。</p>
<p>原来那天在他从17班搬回19班，不需要李乐说任何话，只需要李乐去就足够让他回来了。</p>
<p>晚饭结束，大家围在酒店门口商量怎么回。</p>
<p>王骏一的父亲怕他喝多出事，早早开着宝马在楼下等他。</p>
<p>他对李乐说：“我送你回学校吧。”</p>
<p>李乐红着脸抬起头：“额……”</p>
<p>我站在李乐旁边，还保持着一丝理智，立刻打断他们的对话，“我们一起打车回吧。”</p>
<p>李乐对王骏一说：“我已经答应铅笔跟他一起打车回了。”</p>
<p>我在酒店门口拦下一辆出租车，李乐扶着我坐上后排。从市区回学校要经过一座斜拉桥，我地理很差，不知道流在桥下的水是章江还是贡江。李乐望着窗外，我喝得迷迷糊糊，两边穿梭而过的汽车在眼中带着延迟摄影的效果，变成一条条光束。</p>
<p>脑海里有一个声音，不停地怂恿我：牵起她的手。</p>
<p>无数根钢绳汇聚在那根高大的柱子上，出租车驶上桥的那一刻，我牵起了她的手。</p>
<p>先是两手紧握，接着是十指相扣。她手指张开的瞬间，我已经知道了答案。</p>
<p>她问我：“曾小千，你的梦想是什么？”</p>
<p>我：“我的梦想就是现在这样。”</p>
<p>她：“不是这种，这个梦想太微不足道了。”</p>
<p>我：“那我的梦想就是，这座桥永远没有尽头。”</p>
<p>她：“算了，你喝多了。”</p>
<p>我：“你呢，你的梦想是什么？”</p>
<p>她：“我的梦想就是，和自己爱的人有一套自己的房子，养一条叫乐多的金毛，每年两个人带着狗去一个地方旅行。”</p>
<p>我点点头：“不错的梦想，你最想去哪旅行？”</p>
<p>李乐：“想去加拿大。”</p>
<p>我：“为什么？”</p>
<p>李乐：“我看杂志上说，加拿大的黄刀是世界上最适合看极光的地方。”</p>
<p>我：“祝你梦想成真。”</p>
<p>下车后，天上开始飘小雨点。我没有带伞，只好小跑着把她送到宿舍楼下。</p>
<p>我：“你什么时候回。”</p>
<p>她：“现在就回，我爸开车来了，在门口等我。”</p>
<p>我：“好的，一路顺风，再见。”</p>
<p>她：“你是不是忘了什么话没说？”</p>
<p>我被雨淋得清醒了不少。</p>
<p>我：“哦对。”</p>
<p>她站着：“你说。”</p>
<p>我：“你快去收拾东西，别让你爸等太久。”</p>
<p>李乐：“哦。”</p>
<p>她转身走了，没有回头。</p>
<p>告别还是告白，我们选了告别。</p>
<p>第二天，我收拾好行李，把热水壶、衣架、复习资料全扔了，留了一些必需品。</p>
<p>临走前我又去了一趟教室，乱糟糟的，都是大家遗弃的书本，书架上还有几本杂志，我随手拿了几本塞在包里。</p>
<p>整理好一切，我扛着被子和衣物去校门口等28路公交。</p>
<p>我转了4趟车，终于回到小镇。去找婶婶拿了家里钥匙，把行李放好。</p>
<p>我给小辉打了个电话：“小辉，你们厂还要人吗？”</p>
<p>小辉：“正招暑期工呢。”</p>
<p>我：“我想来挣点钱。”</p>
<p>小辉：“行，你买好车票过来。”</p>
<p>在家躺了2天后，我提着一个行李箱去了汕头。</p>
<p>我很适合电子厂。那里都是小镇青年，张口他妈的，闭口“扑街仔”。这里没有放眼全球的杂志专栏，也没有青春文艺的情感故事，只有“今天我多干了100件，要买包好烟”。</p>
<p>我回到了我属于的群体，不再对周遭的一切陌生，不再拘谨，不再困惑。</p>
<p>我每天在流水线上边打螺丝边环游世界。今天这个同学去海南潜水，明天那个同学去青海徒步，李乐去了厦门海边踏浪，周琪去了西湖看断桥，王骏一去了加拿大开游艇。</p>
<p>我想，我选择直接告别是对的。王骏一可以带她去加拿大看极光，而我只能带她来流水线看夜班时的饥荒。</p>
<p>上完夜班，工友们都喜欢小酌两杯。我从来都以茶代酒。</p>
<p>他们都嘲讽我：“文化人是不一样哈，斯文。”</p>
<p>小辉搂着我的肩：“不对啊，你们家从你爷爷辈开始可都是老酒鬼，你怎么不喝？”</p>
<p>我：“喝醉一次的代价太大了。”</p>
<p>高考结束后，我再也没喝过酒，也再没醉过。</p>
<p>高中发生的一切像一场烂醉。热情、绚丽、不真实。我侥幸拿着别人的入场券进入一场宴会，当宴会散去，又回到自己的世界，从此与其它宾客再无交集。</p>
<p>我想，如果我没有喝醉那一次，对她来说会更好。</p>
<p>会更好吗？</p>
<p>会的。</p>
<p>打完最后一颗螺丝后，我看着自己黑漆漆的手指，自言自语道。</p>
<br>

<h2 id="第八场"><a href="#第八场" class="headerlink" title="第八场"></a><em>第八场</em></h2><br>
不久后，高考成绩出来了，如我所料，高出二本不少，离一本还有差距。

<p>我妈问我要不要复读，我说算了，我想清楚了，我决定走写作这条路。大学里只要有自习室和桌子就行，哪个大学都一样。</p>
<p>我去工厂旁边的网吧填好志愿，我没有按热门专业、学校好坏来排志愿顺序，都按学费高低来排。</p>
<p>工厂一位广西的小姑娘，每天都来找我聊天。</p>
<p>一个月后，我们在一起了。</p>
<p>女孩送了我一个蓝牙耳机，这样我打螺丝的时候听有声小说，就不会有一根线在胸前晃来晃去。</p>
<p>我给她回了一个纯银的戒指，她很喜欢。</p>
<p>小辉问：“你喜欢了李乐那么久都不敢在一起。这个才认识1个月，怎么就在一起了。”</p>
<p>我想了很久，说：“这姑娘，跟我们一样。我觉得，她给我的，我都能负担。但是李乐，她比我高太多了，我怕她突然给出的东西，我还不起。”</p>
<p>比如说爱，比如说，未来。</p>
<p>我18岁的“dream”，在工厂流水线的轰鸣声中结束了。</p>
<p>我18岁的dream里都是李乐，无法拭去。</p>
<p>如果李乐18岁的dream里有我，也没关系，因为我是铅笔。</p>
<p>太奶奶，她是那个人，但我不是。 </p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>文章</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>推荐一下适合假期的片单 or 书单？</title>
    <url>/2022/10/02/book%20movie/</url>
    <content><![CDATA[<h2 id="推荐一下适合假期的片单-or-书单？"><a href="#推荐一下适合假期的片单-or-书单？" class="headerlink" title="推荐一下适合假期的片单 or 书单？"></a>推荐一下适合假期的片单 or 书单？</h2><span id="more"></span>
<hr>
<br>

<blockquote>
<p>1.《<strong>肖申克的救赎</strong>》。每一次，无论是看书还是看电影，《肖申克的救赎》都能让我流泪。真的好棒。好真诚，没有主角光环，不刻意，但能让你感受希望的力量。</p>
</blockquote>
<br>
<br>


<blockquote>
<p>2.刘擎教授的《<strong>现代西方思想讲义</strong>》因为我很喜欢刘擎教授的表达的方式，内容可以理解，每章结束后面还有思考小问题，真的很喜欢这本书，打开思维</p>
</blockquote>
<br>
<br>
 

<blockquote>
<p>3.《<strong>漫长的余生——一个北魏宫女和她的时代</strong>》历史也可以是普通人视角下的，她的命运，被能写进诗书的人和事所改变着，书写着。但只有她的碑文在告诉后世的人，她是谁，她经历过什么。通过她，我们也能感知到历史中没有碑文的芸芸众生的鲜活，她们都曾来过这个世界，亦如你我！</p>
</blockquote>
<br>
<br>

<blockquote>
<p>4.《<strong>我不是完美小孩</strong>》<br>一位被现实撞得伤痕累累的“小孩”身份，看到的“大人”再也不是大人，我这个小孩也再也不是以前的“小孩”。我依旧不完美，依旧没那么阳光，那么勃勃生机。一幅幅画既是大人的也是小孩的倒影，我们何尝不是被要求“完美”地成长。但是最后的我成了一个普普通通的人，面对很多问题还是有很多不解，我也逐渐失去毫不犹豫的孤勇。可我依旧热爱着这本绘本，来源于最深处的勇气。来源于每个不完美，爱与被爱，期待与被期待，依旧伴随自己生活。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>5.推荐适合假期的片单：刚看完美剧《<strong>闪亮女孩</strong>》，本是奔着科幻去的，看完发现是心理创伤治愈片（女主视角），但一点不妨碍前五集悬疑+科幻的品质，这个和电影《妈的多重宇宙》类似，在科幻的框架中去创作，想起莫言曾经说：“文学艺术，永远不是唱赞歌的工具”，真心佩服小说作者的脑洞，另外影视化水准也极佳，真心强烈推荐！</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>6.《<strong>鄙视</strong>》把男性的情感和心理动态描写得很到位，激烈的暴力和性仿佛翻手覆手。一出完美的心理剧，和奥德修斯的呼应既是弗洛伊德式的，爱情是人的支撑，也放大了人的世俗、自大、自欺与妒忌。</p>
</blockquote>
<br>
<br>
 

<blockquote>
<p>7.推荐刘瑜的《<strong>送你一颗子弹</strong>》。因为这是轻松幽默又有点小哲理思考的日常合集。适合在轻松休闲的假期里，放手边随时看一篇，放下后出去玩，回头再拿起看下一篇也不会吃力。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>8.李娟《<strong>冬牧场</strong>》，用写实的笔触记录了新疆游牧民族在零下几十度寒冬里的放牧生活，有寒冷，也有人文的温情。通过李娟细腻的笔触，读起来让人心神荡漾。这本书，让我看到了，新疆这片广袤的土地上，另一种我从未了解过的牧民的生活，同时，也从中感受到了生生不息的生命的力量。有时我们一再追问生命的意义，这本书给我们提供了一个视角，每天艰辛地劳作放牧，辛苦枯燥，但却又让人感受到一种蓬勃生命力，一种质朴坚实的力量。也向读者诠释了，活着，本身就是意义。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>9.读辛波斯卡的诗吧《<strong>我曾这样寂寞生活</strong>》最开始因为电台知道辛波斯卡，去查了一下百度百科，感觉她应该是一个很帅气的诗人，在她的诗歌中能看到很多情绪，坚韧？勇敢？自由？难受？失落……虽不是个喜欢凄美文学的人，但是诗歌有时候或多或少有些“忧郁”成分，而且因为电台的滤镜加持，即便有些诗歌的情绪感觉有些down但是还是很喜欢！对辛波斯卡的爱一发不可收拾！如果你也喜欢诗，邀请你读辛波斯卡呀，一个很帅气的女人。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>10.我认为在假期主要是放松平和地享受快乐，《<strong>有熊谷守一的地方</strong>》，《<strong>日日是好日</strong>》，《<strong>人生果实</strong>》，《<strong>小花的味噌汤</strong>》都是我非常喜欢n刷的片子。</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>11.真的特别特别爱蔡崇达，推荐假期看的话，就是蔡崇达的《<strong>皮囊</strong>》吧<br>理由：这本书是由各个小故事构成的，每天都可以看一个，读起来不会觉得很累，从一些和阿婆，跟着自己长大的朋友，从外面回来开KTV的妹妹，从他们的故事里都可以或多或少找到自己的影子，然后再收拾好心情出发，是真的读起来很有趣味！</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>12.书最近在看：《<strong>十三邀3：我们都在给大问题做注脚</strong>》，有些深刻的话语值得用文字记录下来，反复咀嚼。<br>电影推荐《<strong>普罗旺斯的夏天</strong>》，在夏天的尾巴回顾一下夏日美好吧！每一帧都像画一样~</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>13.阿伦森的《<strong>绝非偶然</strong>》，这本书真是改变了我对自我的认知，让我从一个胆小很自卑的人，开始想去尝试自己想要又不敢做的事情。虽然不能说一步跨越，但是潜移默化中心里多了很多积极乐观的东西。它从心理学的角度剖析了每个人的认知心理和自我行为的关联性，告诉人们只要你想改变，并付出行动，就有可能改变。</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>14.最近读了余华的《<strong>文城</strong>》，这是一部“道路小说”，讲了北方男人林祥福，为了寻找不辞而别的妻子，只身一人来到南方小镇的故事。读余华的小说，更像是寓言，他把时代的遭遇，压缩在符号化的人物身上，从而让我们记住历史，记住那些容易被遗忘被忽略的小人物。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>15.推荐影片：《<strong>落叶归根</strong>》<br>理由：虽然是比较老的电影，而且讲的内容也很简单，是一个在外打工的中年男子，带着自己的工友回家的故事（此时的工友已经因病去世了），所以他带上的只是一具尸体，但是，一路上的颠沛他都没有抛下工友，打劫没有，没车坐也没有，全片简单没有杂冗的剧情，虽然故事简单但是看完真的会让人情触之深，原来时间也有温情，原来人与人之间也会温存这样的故事，串联着你和我……</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>16.假期片单推荐：《<strong>托斯卡纳艳阳下</strong>》<br>因为一次旅行，婚姻不顺的女作家定居在了意大利托斯卡尼，人生开始有了转变，在这里拥有一座自己的别墅，一个爱的人，然后过着面朝大海春暖花开的生活，内心也开始变得丰盈，这个假期跟着电影一起去感受一下阳光下的爱情，令人向往而感动。</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>17.《<strong>唐顿庄园</strong>》创作者不约而同聚焦于人性之恶时，还有人愿意思考善良、伟大、优雅，是这个时代难得的品质（ps节奏缓慢的英剧就是消磨时间的利器）。</p>
</blockquote>
<br>
<br>


<blockquote>
<p>18.推荐《<strong>亚历山大和他最糟糕的一天</strong>》！不用被电影名字误导，是一部非常轻松的喜剧电影，围绕一大家人展开的荒诞搞笑故事，结局也非常温馨～适合一个人看，也适合和家人朋友一起看，假期当然要无脑笑！</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>19.《<strong>纯真博物馆</strong>》吧，每次看了都有新感受，让人思考究竟什么是爱和欲望，故事有时候并没有一个完美的结局，人生也是一样，但是永远不要丢失对美好的幻想。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>20.推荐简媜的《<strong>谁在银光闪闪的地方，等你</strong>》这本书用幽默戏谑的语言谈论“老病死”话题，年轻的朋友阅读，既可以预见自己未来的变化，又能增加在生活中对父母的了解，学会多一份体谅。</p>
</blockquote>
<br>
<br>
 

<blockquote>
<p>21.《<strong>你长大了就会懂</strong>》<br>虽然嘴上经常说老了以后去养老院，但是从来也没有了解过养老院到底是什么情况，也从来没有好好想一想死亡到底意味着什么，我们所追求的意义究竟有没有意义…… 跟着书中的人物感受他们在养老院的生活日常，慢慢领悟来人世这一趟的不易。</p>
</blockquote>
<br>
<br>
 

<blockquote>
<p>22.《<strong>纽约的一个雨天</strong>》。成都入秋了，雨每天下个不停。我在教室的窗边复习考研，昨天学累了索性休息一下。翻了好久没用的迅雷，想着纽约的雨天还没看，姑且看着换换脑。结果片中的甜茶那么文艺，范宁那么灵动，还有同样下着雨的纽约的傍晚，有钢琴，有爵士。我在最合适的时间看了这部电影。</p>
</blockquote>
<br>
<br>

 

<blockquote>
<p>23.书单：<br>《<strong>不安之书</strong>》费尔南多·佩索阿：我们是两个深渊，是举目凝视天空的深井。<br>《<strong>安德鲁不想孤独终老</strong>》理查德·罗珀：独居且从不请人到家里来至少有一个好处——没人能够对他的生活方式评头论足。<br>《<strong>蝲蛄吟唱的地方</strong>》迪莉娅·欧文斯：她知道自己难过的并不是蔡斯，而是被定义为抛弃的一生。头顶的天空和云层互相搏斗着，她大声说：“我只能一个人生活。我知道这点。我早就知道没有人会为我停留。”<br>《<strong>母爱的羁绊</strong>》卡瑞尔·麦克布莱恩：<br>康复来自理解和爱，而非指责。一旦我们理解了母亲所面对的那些导致她们无力爱我们的困难，接下来就能开始改善我们自己的生活，最终目标是了解自己、对自己负责，进而获得康复。</p>
</blockquote>
<br>
<br>


<figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>


<blockquote>
<p>24.《<strong>如果我们的语言是威士忌</strong>》，村上春树的游记在假期旅途中就可以看完，读着惬意舒服，就像喝着一杯冰威士忌。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>25.推荐一个导演：伍迪·艾伦。当你不想看沉闷深刻的艺术电影（没有说伯格曼不好的意思），也不想看爆米花式的商业大片的时候，他是最好的选择！他的几部作品：《<strong>安妮·霍尔</strong>》《<strong>曼哈顿</strong>》《<strong>开罗紫玫瑰</strong>》。</p>
</blockquote>
<br>
<br>



<blockquote>
<p>26.书本推荐《<strong>香水</strong>》，在悠闲的假期里一起感受格雷诺耶的嗅觉艺术吧！还有是枝裕和的电影也非常治愈系，《<strong>海街日记</strong>》也是个不错的选择！</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>27.很久没有静下心来认真看一部电影了，今天看了《<strong>秋天的故事</strong>》，影片的风格画面色调看着都很舒服，把秋天拍得太好了。<br>恋爱都不容易，哪有什么偶遇一见钟情啊，等不再年轻的时候，两个人能聊得来就已经很好了。<br>其实欧嘉莉还是很幸运的，虽然不再年轻了，但是有很好的朋友，有自己的葡萄园，不爱热闹不愿交友最后还遇见了爱情。真好。</p>
</blockquote>
<br>
<br>


 

<blockquote>
<p>28.我建议读一下四大名著，从最基础的开始，加强自身文化涵养和家国情怀。<br>现代网络，最不缺乏的就是推荐，只要想找，比比皆是，很多人在纷杂的网络信息里逐渐迷失了自己的根，总习惯去追求那些看似很高大上但实则并不适用的文学艺术。<br>四大名著看似很普通，但很多人未必完整地读过一遍，而且很多都是在自己学生时代阅读的，理解浅显或片面，拿到现在来看，我们也许更加能够看清楚那些妖魔鬼怪、世事人情背后所隐藏的意义。</p>
</blockquote>
<br>
<br>



 

<blockquote>
<p>29.那我推荐一下片单吧：<br>日剧《<strong>凪的新生活</strong>》：是一个女性蜕变和成长，有自己的主见选择正确的、有尊严的感情的故事。这部剧还蛮适合正处于感情成长期的女孩子们看的。<br>日剧《<strong>短剧开始了</strong>》：每一集的侧重点都不一样，但又像一个圆圈一样星星点点地串在一起，让人感叹编剧情节巧妙。是当代青年的真实写照，没有夸张的表演，但像五谷杂粮，越嚼越有味道。*<br>日剧神剧《<strong>legal high</strong>》：这部剧出了一个神角色古美门，每一集不仅与新垣结衣饰演的律师助理斗嘴拌嘴外，还以超强嘴炮“战无不胜”，其中的博弈也很精彩，十分推荐。<br>日剧《<strong>追忆潸然</strong>》：这是一部对我而言很奇妙的剧。平常也就匆匆略过，但每到冬天就会自动打开这部剧。也许是金句王坂元裕二，也许是那句“没关系，我会跑着穿过雨和雨之间的缝隙。”<br>美剧《<strong>怪奇物语</strong>》：这部剧一共有四部，剧情是相互串联的。我本来是不爱看连续季的，可是打开了第一部后就一集一集停不下来了，下饭好剧。</p>
</blockquote>
<br>
<br>
 

<blockquote>
<p>30.国庆片单day1到day7《<strong>筋疲力尽</strong>》《<strong>四百击</strong>》《<strong>祖与占</strong>》《<strong>法外之徒</strong>》《<strong>慕德家一夜</strong>》《<strong>漂亮的塞尔日</strong>》《<strong>巴黎属于我们</strong>》美好的七天长假，何不用心去了解一个电影时代呢？法国新浪潮是朦胧的，在这个好莱坞工业化电影挟风俱雨地侵入每个人关于电影的印象时，那一套奉为模板的视听语言在法国新浪潮面前全部黯然失色。开始看时也许会觉得无聊，我为何浪费时间好似我邻居日常的鸡毛蒜皮上？但是相信在这每天的一部片之后，在搜索百科，影评的途中，它会像一剂晨雾在心中氤氲开来，耳目一新。</p>
</blockquote>
<br>

<h3 id="好的推荐，欢迎下方留言，好的作品，应让更多人看见"><a href="#好的推荐，欢迎下方留言，好的作品，应让更多人看见" class="headerlink" title="好的推荐，欢迎下方留言，好的作品，应让更多人看见 "></a><center>好的推荐，欢迎下方留言，好的作品，应让更多人看见 </center></h3>]]></content>
      <categories>
        <category>问答</category>
      </categories>
      <tags>
        <tag>问答</tag>
        <tag>转载</tag>
        <tag>书籍</tag>
        <tag>电影</tag>
        <tag>交流</tag>
      </tags>
  </entry>
  <entry>
    <title>代码输出</title>
    <url>/2022/08/22/code%20output/</url>
    <content><![CDATA[<h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2><span id="more"></span>


<h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><strong>代码输出结果</strong>也是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：<strong>异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承</strong>等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行讨论。这里不会系统的阐述基础知识，而是通过面试例题的形式，来讲述每个题目的知识点以及代码的执行过程。如果会了这些例题，在前端面试中多数代码输出问题就可以轻而易举的解决了。</p>
<p><strong>注：</strong>本文中所有例题收集自牛客网面经、网络博文等，如果侵权，请联系删除！</p>
<h2 id="一、异步-amp-事件循环"><a href="#一、异步-amp-事件循环" class="headerlink" title="一、异步&amp;事件循环"></a>一、异步&amp;事件循环</h2><h3 id="1-代码输出结果"><a href="#1-代码输出结果" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const promise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">2 </span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。</p>
<h3 id="2-代码输出结果"><a href="#2-代码输出结果" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const promise1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve(<span class="hljs-string">&#x27;resolve1&#x27;</span>)<br>&#125;)<br>const promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>, promise1);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>, promise2);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml">promise1<br>1 Promise&#123;<span class="hljs-tag">&lt;<span class="hljs-name">resolved</span>&gt;</span>: resolve1&#125;<br>2 Promise&#123;<span class="hljs-tag">&lt;<span class="hljs-name">pending</span>&gt;</span>&#125;<br>resolve1<br></code></pre></td></tr></table></figure>

<p>需要注意的是，直接打印promise1，会打印出它的状态值和参数。</p>
<p>代码执行过程如下：</p>
<ol>
<li>script是一个宏任务，按照顺序执行这些代码；</li>
<li>首先进入Promise，执行该构造函数中的代码，打印<code>promise1</code>；</li>
<li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来；</li>
<li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列；</li>
<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code>；</li>
<li>执行同步代码1， 同时打印出<code>promise1</code>的状态是<code>resolved</code>；</li>
<li>执行同步代码2，同时打印出<code>promise2</code>的状态是<code>pending</code>；</li>
<li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>
</ol>
<h3 id="3-代码输出结果"><a href="#3-代码输出结果" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const promise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;timerStart&quot;</span>);<br>    resolve(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;timerEnd&quot;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1<br>2<br>4<br>timerStart<br>timerEnd<br>success<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ul>
<li>首先遇到Promise构造函数，会先执行里面的内容，打印<code>1</code>；</li>
<li>遇到定时器<code>steTimeout</code>，它是一个宏任务，放入宏任务队列；</li>
<li>继续向下执行，打印出2；</li>
<li>由于<code>Promise</code>的状态此时还是<code>pending</code>，所以<code>promise.then</code>先不执行；</li>
<li>继续执行下面的同步任务，打印出4；</li>
<li>此时微任务队列没有任务，继续执行下一轮宏任务，执行<code>steTimeout</code>；</li>
<li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列，再执行<code>timerEnd</code>；</li>
<li>执行完这个宏任务，就去执行微任务<code>promise.then</code>，打印出<code>resolve</code>的结果。</li>
</ul>
<h3 id="4-代码输出结果"><a href="#4-代码输出结果" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>  const timer2 = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;);<br>const timer1 = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>  &#125;)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span><br>promise1<br>timer1<br>promise2<br>timer2<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先，<code>Promise.resolve().then</code>是一个微任务，加入微任务队列</li>
<li>执行timer1，它是一个宏任务，加入宏任务队列</li>
<li>继续执行下面的同步代码，打印出<code>start</code></li>
<li>这样第一轮宏任务就执行完了，开始执行微任务<code>Promise.resolve().then</code>，打印出<code>promise1</code></li>
<li>遇到<code>timer2</code>，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是<code>timer1</code>、<code>timer2</code>；</li>
<li>这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器<code>timer1</code>，打印<code>timer1</code>；</li>
<li>遇到<code>Promise.resolve().then</code>，它是一个微任务，加入微任务队列</li>
<li>开始执行微任务队列中的任务，打印<code>promise2</code>；</li>
<li>最后执行宏任务<code>timer2</code>定时器，打印出<code>timer2</code>；</li>
</ol>
<h3 id="5-代码输出结果"><a href="#5-代码输出结果" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success1&#x27;</span>);<br>    reject(<span class="hljs-string">&#x27;error&#x27;</span>);<br>    resolve(<span class="hljs-string">&#x27;success2&#x27;</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;then:&#x27;</span>, res);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;catch:&#x27;</span>, err);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">then：success1<br></code></pre></td></tr></table></figure>

<p>这个题目考察的就是<strong>Promise的状态在发生变化之后，就不会再发生变化</strong>。开始状态由<code>pending</code>变为<code>resolve</code>，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。</p>
<h3 id="6-代码输出结果"><a href="#6-代码输出结果" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>(1)<br>  .the<span class="hljs-meta">n</span>(2)<br>  .the<span class="hljs-meta">n</span>(Promise.<span class="hljs-meta">resolve</span>(3))<br>  .the<span class="hljs-meta">n</span>(console.log)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1</span><br><span class="hljs-built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="hljs-literal">undefined</span>&#125;<br></code></pre></td></tr></table></figure>

<p>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。</p>
<p>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p>
<h3 id="7-代码输出结果"><a href="#7-代码输出结果" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>const promise2 = promise1.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>&#125;)<br>console.log(<span class="hljs-string">&#x27;promise1&#x27;</span>, promise1)<br>console.log(<span class="hljs-string">&#x27;promise2&#x27;</span>, promise2)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  console.log(<span class="hljs-string">&#x27;promise1&#x27;</span>, promise1)<br>  console.log(<span class="hljs-string">&#x27;promise2&#x27;</span>, promise2)<br>&#125;, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">promise1 <span class="hljs-title class_">Promise</span> &#123;&lt;pending&gt;&#125;<br>promise2 <span class="hljs-title class_">Promise</span> &#123;&lt;pending&gt;&#125;<br><br><span class="hljs-title class_">Uncaught</span> (<span class="hljs-keyword">in</span> promise) <span class="hljs-title class_">Error</span>: error!!!<br>promise1 <span class="hljs-title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="hljs-string">&quot;success&quot;</span>&#125;<br>promise2 <span class="hljs-title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="hljs-title class_">Error</span>: error!!&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-代码输出结果"><a href="#8-代码输出结果" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.resolve(<span class="hljs-number">1</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>  <br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>Promise是可以链式调用的，由于每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。</p>
<p>上面的输出结果之所以依次打印出1和2，是因为<code>resolve(1)</code>之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成<code>resolve(2)</code>，被最后的then打印输出2。</p>
<h3 id="9-代码输出结果"><a href="#9-代码输出结果" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;then: &quot;</span>, res)<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;catch: &quot;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight 1c"><table><tr><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;then: &quot;</span> <span class="hljs-string">&quot;Error: error!!!&quot;</span><br></code></pre></td></tr></table></figure>

<p>返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>，因此它会被then捕获而不是catch。</p>
<h3 id="10-代码输出结果"><a href="#10-代码输出结果" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;)<br>promise.<span class="hljs-keyword">catch</span>(console.err)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Uncaught</span> (in promise) TypeError: Chaining cycle detected <span class="hljs-keyword">for</span> promise #&lt;Promise&gt;<br></code></pre></td></tr></table></figure>

<p>这里其实是一个坑，<code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>
<h3 id="11-代码输出结果"><a href="#11-代码输出结果" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight sas"><table><tr><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>(1)<br>  .the<span class="hljs-meta">n</span>(2)<br>  .the<span class="hljs-meta">n</span>(Promise.<span class="hljs-meta">resolve</span>(3))<br>  .the<span class="hljs-meta">n</span>(console.log)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure>

<p>看到这个题目，好多的then，实际上只需要记住一个原则：<code>.then</code> 或<code>.catch</code> 的参数期望是函数，传入非函数则会发生<strong>值透传</strong>。</p>
<p>第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个then里，直接打印出1。</p>
<h3 id="12-代码输出结果"><a href="#12-代码输出结果" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.reject(<span class="hljs-string">&#x27;err!!!&#x27;</span>)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>, res)<br>  &#125;, (err) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)<br>  &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;catch&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>err!!!<br></code></pre></td></tr></table></figure>

<p>我们知道，<code>.then</code>函数中的两个参数：</p>
<ul>
<li>第一个参数是用来处理Promise成功的函数</li>
<li>第二个则是处理失败的函数</li>
</ul>
<p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p>
<p>在这道题中，错误直接被<code>then</code>的第二个参数捕获了，所以就不会被<code>catch</code>捕获了，输出结果为：<code>error err!!!&#39;</code></p>
<p>但是，如果是像下面这样：</p>
<figure class="highlight qml"><table><tr><td class="code"><pre><code class="hljs qml"><span class="hljs-built_in">Promise</span>.resolve()<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">success</span> (<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fail1</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fail1&#x27;</span>, err)<br>  &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fail2</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fail2&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>在<code>then</code>的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的<code>catch</code>捕获到。</p>
<h3 id="13-代码输出结果"><a href="#13-代码输出结果" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.resolve(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>)<br>  &#125;)<br>Promise.resolve(<span class="hljs-string">&#x27;2&#x27;</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally2&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是finally2返回的值&#x27;</span><br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally2后面的then函数&#x27;</span>, res)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><code class="hljs ceylon"><span class="hljs-number">1</span><br><span class="hljs-keyword">finally</span><span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span><br><span class="hljs-keyword">finally</span><span class="hljs-number">2</span>后面的<span class="hljs-keyword">then</span>函数 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p><code>.finally()</code>一般用的很少，只要记住以下几点就可以了：</p>
<ul>
<li><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</li>
<li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是无法知道Promise最终的状态是<code>resolved</code>还是<code>rejected</code>的</li>
<li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li>
<li>finally本质上是then方法的特例</li>
</ul>
<p><code>.finally()</code>的错误捕获：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.resolve(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally1&#x27;</span>)<br>    throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;我是finally中抛出的异常&#x27;</span>)<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally后面的then函数&#x27;</span>, res)<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;捕获错误&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;finally1&#x27;</span><br><span class="hljs-string">&#x27;捕获错误&#x27;</span> <span class="hljs-title class_">Error</span>: 我是<span class="hljs-keyword">finally</span>中抛出的异常<br></code></pre></td></tr></table></figure>

<h3 id="14-代码输出结果"><a href="#14-代码输出结果" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (<span class="hljs-params">x</span>) &#123;<br>    const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>))<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br>Promise.<span class="hljs-built_in">all</span>([runAsync(<span class="hljs-number">1</span>), runAsync(<span class="hljs-number">2</span>), runAsync(<span class="hljs-number">3</span>)]).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-string">[1, 2, 3]</span><br></code></pre></td></tr></table></figure>

<p>首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。</p>
<p>之后再使用<code>Promise.all</code>来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。</p>
<h3 id="15-代码输出结果"><a href="#15-代码输出结果" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">runReject</span> (<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> rej(<span class="hljs-string">`Error: <span class="hljs-subst">$&#123;x&#125;</span>`</span>, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span> * x))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br>Promise.<span class="hljs-built_in">all</span>([runAsync(<span class="hljs-number">1</span>), runReject(<span class="hljs-number">4</span>), runAsync(<span class="hljs-number">3</span>), runReject(<span class="hljs-number">2</span>)])<br>       .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br>       .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">// 1s后输出<br>1<br>3<br>// 2s后输出<br>2<br><span class="hljs-keyword">Error: </span>2<br>// 4s后输出<br>4<br></code></pre></td></tr></table></figure>

<p>可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是<code>runReject(2)</code>的结果。如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。会被<code>.then()</code>的第二个回调函数捕获。</p>
<h3 id="16-代码输出结果"><a href="#16-代码输出结果" class="headerlink" title="16. 代码输出结果"></a>16. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br>Promise.race([runAsync(<span class="hljs-number">1</span>), runAsync(<span class="hljs-number">2</span>), runAsync(<span class="hljs-number">3</span>)])<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;result: &#x27;</span>, res))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight scheme"><table><tr><td class="code"><pre><code class="hljs scheme"><span class="hljs-number">1</span><br><span class="hljs-symbol">&#x27;result:</span> &#x27; <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。</p>
<h3 id="17-代码输出结果"><a href="#17-代码输出结果" class="headerlink" title="17. 代码输出结果"></a>17. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span>(<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span><br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>)<br>  );<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">runReject</span>(<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span><br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> rej(<span class="hljs-string">`Error: <span class="hljs-subst">$&#123;x&#125;</span>`</span>, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span> * x)<br>  );<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br>Promise.race([runReject(<span class="hljs-number">0</span>), runAsync(<span class="hljs-number">1</span>), runAsync(<span class="hljs-number">2</span>), runAsync(<span class="hljs-number">3</span>)])<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;result: &quot;</span>, res))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err));<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight subunit"><table><tr><td class="code"><pre><code class="hljs subunit">0<br><span class="hljs-keyword">Error: </span>0<br>1<br>2<br>3<br></code></pre></td></tr></table></figure>

<p>可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。</p>
<p>注意：<code>all</code>和<code>race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</p>
<h3 id="18-代码输出结果"><a href="#18-代码输出结果" class="headerlink" title="18. 代码输出结果"></a>18. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br>async1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight gcode"><table><tr><td class="code"><pre><code class="hljs gcode">asy<span class="hljs-symbol">nc1</span> start<br>asy<span class="hljs-symbol">nc2</span><br>start<br>asy<span class="hljs-symbol">nc1</span> e<span class="hljs-symbol">nd</span><br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行函数中的同步代码<code>async1 start</code>，之后遇到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code>；</li>
<li>跳出<code>async1</code>函数后，执行同步代码<code>start</code>；</li>
<li>在一轮宏任务全部执行完之后，再来执行<code>await</code>后面的内容<code>async1 end</code>。</li>
</ol>
<p>这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。</p>
<h3 id="19-代码输出结果"><a href="#19-代码输出结果" class="headerlink" title="19. 代码输出结果"></a>19. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br>async1();<br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer3&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;start&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="code"><pre><code class="hljs livecodeserver">async1 <span class="hljs-built_in">start</span><br>async2<br><span class="hljs-built_in">start</span><br>async1 <span class="hljs-function"><span class="hljs-keyword">end</span></span><br><span class="hljs-function"><span class="hljs-title">timer2</span></span><br>timer3<br>timer1<br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先进入<code>async1</code>，打印出<code>async1 start</code>；</li>
<li>之后遇到<code>async2</code>，进入<code>async2</code>，遇到定时器<code>timer2</code>，加入宏任务队列，之后打印<code>async2</code>；</li>
<li>由于<code>async2</code>阻塞了后面代码的执行，所以执行后面的定时器<code>timer3</code>，将其加入宏任务队列，之后打印<code>start</code>；</li>
<li>然后执行async2后面的代码，打印出<code>async1 end</code>，遇到定时器timer1，将其加入宏任务队列；</li>
<li>最后，宏任务队列有三个任务，先后顺序为<code>timer2</code>，<code>timer3</code>，<code>timer1</code>，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。</li>
</ol>
<h3 id="20-代码输出结果"><a href="#20-代码输出结果" class="headerlink" title="20. 代码输出结果"></a>20. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  await <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 success&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 end&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt start&#x27;</span>)<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1 start<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>这里需要注意的是在<code>async1</code>中<code>await</code>后面的Promise是没有返回值的，也就是它的状态始终是<code>pending</code>状态，所以在<code>await</code>之后的内容是不会执行的，包括<code>async1</code>后面的 <code>.then</code>。</p>
<h3 id="21-代码输出结果"><a href="#21-代码输出结果" class="headerlink" title="21. 代码输出结果"></a>21. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  await <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    resolve(<span class="hljs-string">&#x27;promise1 resolve&#x27;</span>)<br>  &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 success&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 end&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt start&#x27;</span>)<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这里是对上面一题进行了改造，加上了resolve。</p>
<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1 start<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br>promise1 resolve<br>async1 success<br>async1 <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h3 id="22-代码输出结果"><a href="#22-代码输出结果" class="headerlink" title="22. 代码输出结果"></a>22. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br><br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br><br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>async1();<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);<br>  resolve();<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise2&quot;</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1 start<br>async2<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br>async1 <span class="hljs-keyword">end</span><br>promise2<br>setTimeout<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下： </p>
<ol>
<li>开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；</li>
<li>遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；</li>
<li>之后执行函数async1，首先打印出async1 start；</li>
<li>遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；</li>
<li>然后跳出async1和async2，遇到Promise，打印出promise1；</li>
<li>遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；</li>
<li>之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；</li>
<li>执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</li>
</ol>
<h3 id="23-代码输出结果"><a href="#23-代码输出结果" class="headerlink" title="23. 代码输出结果"></a>23. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 success&#x27;</span><br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>    reject(<span class="hljs-string">&#x27;error&#x27;</span>)<br>  &#125;)<br>&#125;<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight nginx"><table><tr><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">async2</span><br>Uncaught (in promise) <span class="hljs-literal">error</span><br></code></pre></td></tr></table></figure>

<p>可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。</p>
<p>如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  await Promise.reject(<span class="hljs-string">&#x27;error!!!&#x27;</span>).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(e))<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> Promise.resolve(<span class="hljs-string">&#x27;async1 success&#x27;</span>)<br>&#125;<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这样的输出结果就是：</p>
<figure class="highlight erlang-repl"><table><tr><td class="code"><pre><code class="hljs erlang-repl">script start<br>error!!!<br>async1<br>async1 success<br></code></pre></td></tr></table></figure>

<h3 id="24-代码输出结果"><a href="#24-代码输出结果" class="headerlink" title="24. 代码输出结果"></a>24. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">first</span> = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>    let p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>);<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>            resolve(<span class="hljs-number">6</span>);<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(p)<br>        &#125;, <span class="hljs-number">0</span>)<br>        resolve(<span class="hljs-number">1</span>);<br>    &#125;);<br>    resolve(<span class="hljs-number">2</span>);<br>    p.then(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arg);<br>    &#125;);<br>&#125;));<br><span class="hljs-built_in">first</span>().then(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arg);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">7</span><br><span class="hljs-attribute">4</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；</li>
<li>遇到了定时器，将其加入宏任务队列；</li>
<li>执行Promise  p中的resolve，状态变为resolved，返回值为1；</li>
<li>执行Promise first中的resolve，状态变为resolved，返回值为2；</li>
<li>遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；</li>
<li>执行外面的代码，打印出4；</li>
<li>这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；</li>
<li>这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以<code>resolve(6)</code>不会再执行；</li>
<li>最后<code>console.log(p)</code>打印出<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>；</li>
</ol>
<h3 id="25-代码输出结果"><a href="#25-代码输出结果" class="headerlink" title="25. 代码输出结果"></a>25. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const async1 = async () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">2000</span>)<br>  await <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 success&#x27;</span><br>&#125; <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br>Promise.resolve(<span class="hljs-number">1</span>)<br>  .then(<span class="hljs-number">2</span>)<br>  .then(Promise.resolve(<span class="hljs-number">3</span>))<br>  .catch(<span class="hljs-number">4</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br><span class="hljs-number">1</span><br>timer2<br>timer1<br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行同步带吗，打印出script start；</li>
<li>遇到定时器timer1将其加入宏任务队列；</li>
<li>之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；</li>
<li>然后执行同步代码，打印出script end；</li>
<li>继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；</li>
<li>遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。</li>
</ol>
<h3 id="26-代码输出结果"><a href="#26-代码输出结果" class="headerlink" title="26. 代码输出结果"></a>26. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const p1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;resolve3&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  resolve(<span class="hljs-string">&#x27;resovle1&#x27;</span>);<br>  resolve(<span class="hljs-string">&#x27;resolve2&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)  <span class="hljs-comment">// resolve1</span><br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(p1)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;).finally(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>, res)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>执行结果为如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">resolve1<br><span class="hljs-keyword">finally</span>  <span class="hljs-literal">undefined</span><br>timer1<br><span class="hljs-built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-literal">undefined</span>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="27-代码输出结果"><a href="#27-代码输出结果" class="headerlink" title="27. 代码输出结果"></a>27. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>)<br>    &#125;)<br>&#125;)<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;9&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;10&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1<br>7<br>6<br>8<br>2<br>4<br>3<br>5<br>9<br>11<br>10<br>12<br></code></pre></td></tr></table></figure>

<p><strong>（1）第一轮事件循环流程分析如下：</strong></p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li>
<li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。暂且记为<code>setTimeout1</code>。</li>
<li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。记为<code>process1</code>。</li>
<li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。记为<code>then1</code>。</li>
<li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td>process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then1</td>
</tr>
</tbody></table>
<p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了<code>process1</code>和<code>then1</code>两个微任务：</p>
<ul>
<li>执行<code>process1</code>，输出6。</li>
<li>执行<code>then1</code>，输出8。</li>
</ul>
<p>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</p>
<p><strong>（2）第二轮时间循环从</strong><code>**setTimeout1**</code><strong>宏任务开始：</strong></p>
<ul>
<li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。</li>
<li><code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td>process2</td>
</tr>
<tr>
<td></td>
<td>then2</td>
</tr>
</tbody></table>
<p>第二轮事件循环宏任务结束，发现有<code>process2</code>和<code>then2</code>两个微任务可以执行：</p>
<ul>
<li>输出3。</li>
<li>输出5。</li>
</ul>
<p>第二轮事件循环结束，第二轮输出2，4，3，5。</p>
<p><strong>（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。</strong></p>
<ul>
<li>直接输出9。</li>
<li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li>
<li>直接执行<code>new Promise</code>，输出11。</li>
<li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>process3</td>
</tr>
<tr>
<td></td>
<td>then3</td>
</tr>
</tbody></table>
<p>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>：</p>
<ul>
<li>输出10。</li>
<li>输出12。</li>
</ul>
<p>第三轮事件循环结束，第三轮输出9，11，10，12。</p>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p>
<h3 id="28-代码输出结果"><a href="#28-代码输出结果" class="headerlink" title="28. 代码输出结果"></a>28. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>  &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>  resolve(<span class="hljs-number">4</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(d))<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)<br>  <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>  &#123;<br>    resolve(<span class="hljs-number">6</span>)<br>  &#125;).then(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(d))<br>&#125;)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1<br>3<br>8<br>4<br>2<br>5<br>6<br>7<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行script代码，打印出1；</li>
<li>遇到第一个定时器，加入到宏任务队列；</li>
<li>遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器，加入到宏任务队列；</li>
<li>遇到第三个定时器，加入到宏任务队列；</li>
<li>继续执行script代码，打印出8，第一轮执行结束；</li>
<li>执行微任务队列，打印出第一个Promise的resolve结果：4；</li>
<li>开始执行宏任务队列，执行第一个定时器，打印出2；</li>
<li>此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；</li>
<li>执行微任务队列，打印出6；</li>
<li>执行宏任务队列中的最后一个定时器，打印出7。</li>
</ol>
<h3 id="29-代码输出结果"><a href="#29-代码输出结果" class="headerlink" title="29. 代码输出结果"></a>29. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>    <br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>  Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)<br>  resolve(<span class="hljs-number">5</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>&#125;)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure>

<p>代码输出结果如下：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">1<br>4<br>7<br>5<br>2<br>3<br>6<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行scrip代码，打印出1；</li>
<li>遇到第一个定时器setTimeout，将其加入到宏任务队列；</li>
<li>遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器setTimeout，将其加入到红任务队列；</li>
<li>执行script代码，打印出7，至此第一轮执行完成；</li>
<li>指定微任务队列中的代码，打印出resolve的结果：5；</li>
<li>执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；</li>
<li>执行完这个宏任务，就开始执行微任务队列，打印出3；</li>
<li>继续执行宏任务队列中的第二个定时器，打印出6。</li>
</ol>
<h3 id="30-代码输出结果"><a href="#30-代码输出结果" class="headerlink" title="30. 代码输出结果"></a>30. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    throw <span class="hljs-string">&#x27;Error&#x27;</span>;<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    throw <span class="hljs-string">&#x27;Error&#x27;</span>;<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight basic"><table><tr><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">5 </span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。</p>
<h3 id="31-代码输出结果"><a href="#31-代码输出结果" class="headerlink" title="31. 代码输出结果"></a>31. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>  resolve();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;).then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>    &#125;, <span class="hljs-number">10</span>);<br>  &#125;)<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight"><table><tr><td class="code"><pre><code class="hljs">2<br>3<br>7<br>8<br>4<br>5<br>6<br>1<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先遇到定时器，将其加入到宏任务队列；</li>
<li>遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；</li>
<li>继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；</li>
<li>执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；</li>
<li>执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；</li>
<li>此时微任务队列为空，继续执行宏任务队列，打印出1。</li>
</ol>
<p>做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。</p>
<h2 id="二、this"><a href="#二、this" class="headerlink" title="二、this"></a>二、this</h2><h3 id="1-代码输出结果-1"><a href="#1-代码输出结果-1" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( this.a );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params"></span>) &#123;<br>  foo();<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">doFoo</span>: doFoo<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>obj.doFoo()<br></code></pre></td></tr></table></figure>

<p>输出结果：2 </p>
<p>在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。</p>
<h3 id="2-代码输出结果-1"><a href="#2-代码输出结果-1" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span><br><span class="hljs-selector-tag">var</span> obj = &#123;<br>  <span class="hljs-selector-tag">a</span>: <span class="hljs-number">20</span>,<br>  say: () =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)<br>  &#125;<br>&#125;<br>obj<span class="hljs-selector-class">.say</span>() <br><br><span class="hljs-selector-tag">var</span> anotherObj = &#123; <span class="hljs-selector-tag">a</span>: <span class="hljs-number">30</span> &#125; <br>obj<span class="hljs-selector-class">.say</span><span class="hljs-selector-class">.apply</span>(anotherObj) <br></code></pre></td></tr></table></figure>

<p>输出结果：10  10</p>
<p>我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。</p>
<p>但是，如果是普通函数，那么就会有完全不一样的结果：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span>  <br><span class="hljs-selector-tag">var</span> obj = &#123;  <br>  <span class="hljs-selector-tag">a</span>: <span class="hljs-number">20</span>,  <br>  <span class="hljs-built_in">say</span>()&#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)  <br>  &#125;  <br>&#125;  <br>obj<span class="hljs-selector-class">.say</span>()   <br><span class="hljs-selector-tag">var</span> anotherObj=&#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">30</span>&#125;   <br>obj<span class="hljs-selector-class">.say</span><span class="hljs-selector-class">.apply</span>(anotherObj)<br></code></pre></td></tr></table></figure>

<p>输出结果：20 30</p>
<p>这时，say方法中的this就会指向他所在的对象，输出其中的a的值。</p>
<h3 id="3-代码输出结果-1"><a href="#3-代码输出结果-1" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>&#125;<br>a.call(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p>打印结果：window对象</p>
<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>
<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br>a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// null</span><br>a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h3 id="4-代码输出结果-1"><a href="#4-代码输出结果-1" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> obj = &#123; <br>  name: <span class="hljs-string">&#x27;cuggz&#x27;</span>, <br>  <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-title">function</span><span class="hljs-params">()</span></span>&#123; <br>     console.log(<span class="hljs-keyword">this</span>.name); <br>  &#125; <br>&#125; <br>obj.<span class="hljs-keyword">fun</span>()     <span class="hljs-comment">// cuggz</span><br>new obj.<span class="hljs-keyword">fun</span>() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h3 id="6-代码输出结果-1"><a href="#6-代码输出结果-1" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = &#123;<br>   <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1111&quot;</span>, this);<br>     &#125;<br>     f1();<br>   &#125;,<br>   <span class="hljs-attr">pro</span>: &#123;<br>     <span class="hljs-attr">getPro</span>:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>     &#125;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o = obj.say;<br>o();<br>obj.say();<br>obj.pro.getPro();<br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = &#123;<br>   <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1111&quot;</span>, this);<br>     &#125;<br>     f1();<br>   &#125;,<br>   <span class="hljs-attr">pro</span>: &#123;<br>     <span class="hljs-attr">getPro</span>:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>     &#125;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o = obj.say;<br>o();<br>obj.say();<br>obj.pro.getPro();<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight dart"><table><tr><td class="code"><pre><code class="hljs dart"><span class="hljs-number">1111</span> <span class="hljs-built_in">window</span>对象<br><span class="hljs-number">1111</span> obj对象<br><span class="hljs-built_in">window</span>对象<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；</li>
<li>obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；</li>
<li>obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。</li>
</ol>
<h3 id="7-代码输出结果-1"><a href="#7-代码输出结果-1" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> myObject = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>    <span class="hljs-attr">func</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> self = this;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.foo);  <br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(self.foo);  <br>        (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.foo);  <br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(self.foo);  <br>        &#125;());<br>    &#125;<br>&#125;;<br>myObject.func();<br></code></pre></td></tr></table></figure>

<p>输出结果：bar bar undefined bar</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先func是由myObject调用的，this指向myObject。又因为var self &#x3D; this;所以self指向myObject。</li>
<li>这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。</li>
</ol>
<h3 id="8-代码输出问题"><a href="#8-代码输出问题" class="headerlink" title="8. 代码输出问题"></a>8. 代码输出问题</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">window.<span class="hljs-built_in">number</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br> <span class="hljs-attr">number</span>: <span class="hljs-number">3</span>,<br> <span class="hljs-attr">db1</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>   this.<span class="hljs-built_in">number</span> *= <span class="hljs-number">4</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>     this.<span class="hljs-built_in">number</span> *= <span class="hljs-number">5</span>;<br>   &#125;<br> &#125;)()<br>&#125;<br><span class="hljs-keyword">var</span> db1 = obj.db1;<br>db1();<br>obj.db1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.<span class="hljs-built_in">number</span>);     <span class="hljs-comment">// 15</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(window.<span class="hljs-built_in">number</span>);  <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure>

<p>这道题目看清起来有点乱，但是实际上是考察this指向的:</p>
<ol>
<li>执行db1()时，this指向全局作用域，所以window.number * 4 &#x3D; 8，然后执行匿名函数， 所以window.number * 5 &#x3D; 40；</li>
<li>执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 &#x3D; 15。</li>
</ol>
<h3 id="9-代码输出结果-1"><a href="#9-代码输出结果-1" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">length</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.<span class="hljs-built_in">length</span>);<br>&#125;<br> <br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    fn();<br>    arguments[<span class="hljs-number">0</span>]();<br>  &#125;<br>&#125;;<br> <br>obj.method(fn, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果： 10 2 </p>
<p><strong>解析：</strong></p>
<ol>
<li>第一次执行fn()，this指向window对象，输出10。</li>
<li>第二次执行arguments<a href="">0</a>，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。</li>
</ol>
<h3 id="10-代码输出结果-1"><a href="#10-代码输出结果-1" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printA</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><span class="hljs-keyword">var</span> obj=&#123;<br>  <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>:printA,<br>  <span class="hljs-attr">bar</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    printA();<br>  &#125;<br>&#125;<br><br>obj.foo(); <span class="hljs-comment">// 2</span><br>obj.bar(); <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">var</span> foo = obj.foo;<br>foo(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 2 1 1 </p>
<p><strong>解析：</strong></p>
<ol>
<li>obj.foo()，foo 的this指向obj对象，所以a会输出2；</li>
<li>obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；</li>
<li>foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；</li>
</ol>
<h3 id="11-代码输出结果-1"><a href="#11-代码输出结果-1" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">getX</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> this.x;<br>        &#125;();<br>    &#125;,<br>    <span class="hljs-attr">getY</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> y = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">return</span> this.y;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.getX()) <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.getY()) <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p>输出结果：3  6</p>
<p><strong>解析：</strong></p>
<ol>
<li>我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；</li>
<li>getY是由obj调用的，所以其this指向的是obj对象，会打印出6。</li>
</ol>
<h3 id="12-代码输出结果-1"><a href="#12-代码输出结果-1" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">var</span> obt = &#123; <br>  <span class="hljs-attr">a</span>: <span class="hljs-number">20</span>, <br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span>; <br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a)<br>  &#125; <br>&#125;<br>obt.fn();  <span class="hljs-comment">// 20</span><br>obt.fn.call(); <span class="hljs-comment">// 10</span><br>(obt.fn)(); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 20  10  20 </p>
<p><strong>解析：</strong></p>
<ol>
<li>obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；</li>
<li>obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；</li>
<li>(obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于  obt.fn()，所以会打印出 20；</li>
</ol>
<h3 id="13-代码输出结果-1"><a href="#13-代码输出结果-1" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">xx</span>)&#123;<br>  this.x = xx;<br>  <span class="hljs-keyword">return</span> this<br>&#125;;<br><span class="hljs-keyword">var</span> x = a(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> y = a(<span class="hljs-number">6</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x.x)  <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(y.x)  <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p>输出结果： undefined  6</p>
<p><strong>解析：</strong></p>
<ol>
<li>最关键的就是var x &#x3D; a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。<strong>所以 this.x &#x3D; 5 就相当于：window.x &#x3D; 5。</strong>之后 return this，也就是说 var x &#x3D; a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。</li>
<li>当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。</li>
</ol>
<h3 id="14-代码输出结果-1"><a href="#14-代码输出结果-1" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>)&#123;<br>    this.a = something<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br><br>obj1.foo(<span class="hljs-number">2</span>); <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><br>obj1.foo.call(obj2, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj2.a); <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.foo(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bar.a); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 2  3  2  4</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；</li>
<li>执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；</li>
<li>obj1.a会打印出2；</li>
<li>最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。</li>
</ol>
<h3 id="15-代码输出结果-1"><a href="#15-代码输出结果-1" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>)&#123;<br>    this.a = something<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><br><span class="hljs-keyword">var</span> bar = foo.bind(obj1);<br>bar(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> bar(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(baz.a); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 2  2  3</p>
<p>这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：<strong>this绑定的优先级：****new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</strong></p>
<h2 id="三、作用域-amp-变量提升-amp-闭包"><a href="#三、作用域-amp-变量提升-amp-闭包" class="headerlink" title="三、作用域&amp;变量提升&amp;闭包"></a>三、作用域&amp;变量提升&amp;闭包</h2><h3 id="1-代码输出结果-2"><a href="#1-代码输出结果-2" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> x = y = <span class="hljs-number">1</span>;<br>&#125;)();<br><span class="hljs-keyword">var</span> z;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(y); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(z); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x); <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure>

<p>这段代码的关键在于：var x &#x3D; y &#x3D; 1; 实际上这里是从右往左执行的，首先执行y &#x3D; 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。</p>
<h3 id="2-代码输出结果-2"><a href="#2-代码输出结果-2" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a, b<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);<br>   <span class="hljs-keyword">var</span> a = (b = <span class="hljs-number">3</span>);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);   <br>&#125;)()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">undefined</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span> <br><span class="hljs-number">3</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">undefined</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span> <br><span class="hljs-number">3</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。</p>
<h3 id="3-代码输出结果-2"><a href="#3-代码输出结果-2" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> friendName = <span class="hljs-string">&#x27;World&#x27;</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> friendName === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">var</span> friendName = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Goodbye &#x27;</span> + friendName);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + friendName);<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p>输出结果：Goodbye Jack</p>
<p>我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;World!&#x27;</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> name === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        name = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Goodbye &#x27;</span> + name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + name);<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p>这样，答案就一目了然了。</p>
<h3 id="4-代码输出结果-2"><a href="#4-代码输出结果-2" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">fn1</span>()&#123;<br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;fn1&#x27;</span>)<br>&#125;<br><span class="hljs-selector-tag">var</span> fn2<br> <br><span class="hljs-function"><span class="hljs-title">fn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br> <br>fn2 = <span class="hljs-built_in">function</span>() &#123;<br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;fn2&#x27;</span>)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>输出结果： </p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">fn1<br>Uncaught TypeError: fn2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a <span class="hljs-keyword">function</span><br><span class="hljs-title">fn2</span><br></code></pre></td></tr></table></figure>

<p>这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。</p>
<h3 id="5-代码输出结果-1"><a href="#5-代码输出结果-1" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(temp); <span class="hljs-comment">// 10</span><br>    &#125;<br>    b();<br>&#125;<br>a();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-number">10</span>;<br>    b();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(temp); <span class="hljs-comment">// 报错 Uncaught ReferenceError: temp is not defined</span><br>&#125;<br>a();<br></code></pre></td></tr></table></figure>

<p>在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。</p>
<h3 id="6-代码输出结果-2"><a href="#6-代码输出结果-2" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight abnf"><table><tr><td class="code"><pre><code class="hljs abnf">var a<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-comment">;</span><br>function c()&#123;<br>   alert(a)<span class="hljs-comment">;</span><br>&#125;<br>(function()&#123;<br> var a<span class="hljs-operator">=</span><span class="hljs-number">4</span><span class="hljs-comment">;</span><br> c()<span class="hljs-comment">;</span><br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等</p>
<h3 id="7-代码输出问题"><a href="#7-代码输出问题" class="headerlink" title="7.  代码输出问题"></a>7.  代码输出问题</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n, o)</span></span> &#123;<br>  console.log(o)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-title">function</span><span class="hljs-params">(m)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m, n)</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> c = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br><span class="hljs-attribute">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 <code>console.log(o);</code> 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。</p>
<h3 id="8-代码输出结果-1"><a href="#8-代码输出结果-1" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">f = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;   <br>g = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;   <br>   <span class="hljs-keyword">if</span> (g() &amp;&amp; [] == ![]) &#123;   <br>      f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;   <br>   &#125;   <br>&#125;)();   <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(f());<br></code></pre></td></tr></table></figure>

<p>输出结果： false</p>
<p>这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。</p>
<p>第二个条件是[] &#x3D;&#x3D; ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] &#x3D;&#x3D; 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。</p>
<p>两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。</p>
<h2 id="四、原型-amp-继承"><a href="#四、原型-amp-继承" class="headerlink" title="四、原型&amp;继承"></a>四、原型&amp;继承</h2><h3 id="1-代码输出结果-3"><a href="#1-代码输出结果-3" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight sqf"><table><tr><td class="code"><pre><code class="hljs sqf">function Person(<span class="hljs-built_in">name</span>) &#123;<br>    this.<span class="hljs-built_in">name</span> = <span class="hljs-built_in">name</span><br>&#125;<br>var p2 = new Person(<span class="hljs-string">&#x27;king&#x27;</span>);<br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">//Person.prototype</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">//Object.prototype</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">// null</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//null后面没有了，报错</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//null后面没有了，报错</span><br>console.<span class="hljs-built_in">log</span>(p2.constructor)<span class="hljs-comment">//Person</span><br>console.<span class="hljs-built_in">log</span>(p2.prototype)<span class="hljs-comment">//undefined p2是实例，没有prototype属性</span><br>console.<span class="hljs-built_in">log</span>(Person.constructor)<span class="hljs-comment">//Function 一个空函数</span><br>console.<span class="hljs-built_in">log</span>(Person.prototype)<span class="hljs-comment">//打印出Person.prototype这个对象里所有的方法和属性</span><br>console.<span class="hljs-built_in">log</span>(Person.prototype.constructor)<span class="hljs-comment">//Person</span><br>console.<span class="hljs-built_in">log</span>(Person.prototype.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">// Object.prototype</span><br>console.<span class="hljs-built_in">log</span>(Person.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">//Function.prototype</span><br>console.<span class="hljs-built_in">log</span>(Function.prototype.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//Object.prototype</span><br>console.<span class="hljs-built_in">log</span>(Function.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//Function.prototype</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Object</span>.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//Function.prototype</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Object</span>.prototype.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure>

<p>这道义题目考察原型、原型链的基础，记住就可以了。</p>
<h3 id="2-代码输出结果-3"><a href="#2-代码输出结果-3" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// a</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span> (<span class="hljs-params"></span>) &#123;<br> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-keyword">return</span> this;<br>&#125;<br><span class="hljs-comment">// b</span><br>Foo.getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">// c</span><br>Foo.prototype.getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><span class="hljs-comment">// d</span><br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">// e</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br>Foo.getName();           <span class="hljs-comment">// 2</span><br>getName();               <span class="hljs-comment">// 4</span><br>Foo().getName();         <span class="hljs-comment">// 1</span><br>getName();               <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">new</span> Foo.getName();       <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">new</span> Foo().getName();     <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Foo().getName(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>输出结果：2  4  1  1  2  3  3</p>
<p><strong>解析：</strong></p>
<ol>
<li><strong>Foo.getName()，</strong>Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；</li>
<li><strong>getName()，</strong>这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；</li>
<li><strong>Foo().getName()，</strong>这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；</li>
<li><strong>getName()，</strong>上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；</li>
<li><strong>new Foo.getName()，</strong>这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；</li>
<li><strong>new Foo().getName()，</strong>这里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.<strong>protot</strong> &#x3D;&#x3D;&#x3D; Foo.prototype，所以输出 3；</li>
<li><strong>new new Foo().getName()，</strong>这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。</li>
</ol>
<h3 id="3-代码输出结果-3"><a href="#3-代码输出结果-3" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">b</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>f.<span class="hljs-title function_">a</span>();<br>f.<span class="hljs-title function_">b</span>();<br>F.<span class="hljs-title function_">a</span>();<br>F.<span class="hljs-title function_">b</span>()<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight less"><table><tr><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">Uncaught</span> <span class="hljs-selector-tag">TypeError</span>: <span class="hljs-selector-tag">f</span><span class="hljs-selector-class">.b</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">function</span><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a  ，而 f.b() 就报错了。</li>
<li>F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof  Object &#x3D;&#x3D;&#x3D; true，F instanceof Function &#x3D;&#x3D;&#x3D; true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。</li>
</ol>
<h3 id="4-代码输出结果-3"><a href="#4-代码输出结果-3" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>)&#123;<br>    Foo.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    this.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br><br>Foo.prototype.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br>Foo.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br>Foo.a();<br>let obj = <span class="hljs-keyword">new</span> Foo();<br>obj.a();<br>Foo.a();<br></code></pre></td></tr></table></figure>

<p>输出结果：4 2 1</p>
<p><strong>解析：</strong></p>
<ol>
<li>Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4</li>
<li>let obj &#x3D; new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。</li>
<li>obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2</li>
<li>Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1</li>
</ol>
<h3 id="5-代码输出结果-2"><a href="#5-代码输出结果-2" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;puppy&#x27;</span><br>&#125;<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;woof!woof!&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Dog</span> &amp;&amp; dog.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Dog</span> &amp;&amp; dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果：true</p>
<p><strong>解析：</strong></p>
<p>因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。</p>
<p>constructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。</p>
<h3 id="6-代码输出结果-3"><a href="#6-代码输出结果-3" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">4399</span>&#125;;<br><span class="hljs-keyword">var</span> B =  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> = <span class="hljs-number">9999</span>&#125;;<br><span class="hljs-keyword">var</span> C =  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">var</span> n = <span class="hljs-number">8888</span>&#125;;<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = A;<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = A;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br>A.<span class="hljs-property">n</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">n</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">n</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果：9999  4400</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b &#x3D; new B()时，函数内部this.n&#x3D;9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。</li>
<li>console.log(c.n)，同理，当执行var c &#x3D; new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。</li>
</ol>
<h3 id="7-代码输出问题-1"><a href="#7-代码输出问题-1" class="headerlink" title="7. 代码输出问题"></a>7. 代码输出问题</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params">a</span>)&#123;<br>　　<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params">a</span>)&#123;<br>　　<span class="hljs-keyword">if</span>(a)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>　　&#125;<br>&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>().<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>().<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(<span class="hljs-number">2</span>).<span class="hljs-property">a</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果：1  undefined  2</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；</li>
<li>console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;</li>
<li>console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a &#x3D; 2,故属性a的值为2。</li>
</ol>
<h3 id="8-代码输出问题-1"><a href="#8-代码输出问题-1" class="headerlink" title="8 代码输出问题"></a>8 代码输出问题</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin">function Parent() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">this</span>.b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>.a];<br>    <span class="hljs-keyword">this</span>.c = &#123; demo: <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">this</span>.show = function () &#123;<br>        console.log(<span class="hljs-keyword">this</span>.a , <span class="hljs-keyword">this</span>.b , <span class="hljs-keyword">this</span>.c.demo );<br>    &#125;<br>&#125;<br><br>function Child() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.change = function () &#123;<br>        <span class="hljs-keyword">this</span>.b.push(<span class="hljs-keyword">this</span>.a);<br>        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">this</span>.b.length;<br>        <span class="hljs-keyword">this</span>.c.demo = <span class="hljs-keyword">this</span>.a++;<br>    &#125;<br>&#125;<br><br>Child.prototype = new Parent();<br><span class="hljs-keyword">var</span> parent = new Parent();<br><span class="hljs-keyword">var</span> child1 = new Child();<br><span class="hljs-keyword">var</span> child2 = new Child();<br>child1.a = <span class="hljs-number">11</span>;<br>child2.a = <span class="hljs-number">12</span>;<br>parent.show();<br>child1.show();<br>child2.show();<br>child1.change();<br>child2.change();<br>parent.show();<br>child1.show();<br>child2.show();<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">parent.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br><br>child1.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">11</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br>child2.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">12</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br><br>parent.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">1</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br><br>child1.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">5</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>] <span class="hljs-number">5</span><br><br>child2.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">6</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>] <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>这道题目值得神帝，他涉及到的知识点很多，例如<strong>this的指向、原型、原型链、类的继承、数据类型</strong>等。</p>
<p><strong>解析****：</strong></p>
<ol>
<li>parent.show()，可以直接获得所需的值，没啥好说的；</li>
<li>child1.show()，<code>Child</code>的构造函数原本是指向<code>Child</code>的，题目显式将<code>Child</code>类的原型对象指向了<code>Parent</code>类的一个实例，需要注意<code>Child.prototype</code>指向的是<code>Parent</code>的实例<code>parent</code>，而不是指向<code>Parent</code>这个类。</li>
<li>child2.show()，这个也没啥好说的；</li>
<li>parent.show()，<code>parent</code>是一个<code>Parent</code>类的实例，<code>Child.prorotype</code>指向的是<code>Parent</code>类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响<code>parent</code>实例，所以输出结果不变；</li>
<li>child1.show()，<code>child1</code>执行了<code>change()</code>方法后，发生了怎样的变化呢?</li>
</ol>
<ul>
<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child1</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11]**;</li>
<li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child1.a</code>变为<strong>4</strong>;</li>
<li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child1</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，<code>this.a</code>值为<strong>4</strong>，为原始类型，故赋值操作时会直接赋值，<code>Child.prototype.c.demo</code>的结果为<strong>4</strong>，而<code>this.a</code>随后自增为<strong>5(4 + 1 &#x3D; 5)。</strong></li>
</ul>
<ol>
<li><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果。</li>
</ol>
<ul>
<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child2</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11,12]**;</li>
<li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child2.a</code>变为<strong>5</strong>;</li>
<li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child2</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，故执行结果为<code>Child.prototype.c.demo</code>的值变为<code>child2.a</code>的值<strong>5</strong>，而<code>child2.a</code>最终自增为<strong>6(5 + 1 &#x3D; 6)。</strong></li>
</ul>
<h3 id="9-代码输出结果-2"><a href="#9-代码输出结果-2" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());<br></code></pre></td></tr></table></figure>

<p>输出结果：true</p>
<p>实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1620043144097-44798602-b916-406d-bc50-e003f27dece2.png"  ><span class="image-caption">image.png</span></p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>Hello World</title>
    <url>/2022/08/22/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span> <br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>Hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>面试题</title>
    <url>/2022/09/25/interview%20questions/</url>
    <content><![CDATA[<p> 面试指南</p>
<span id="more"></span>
<h1 id="CSS-x2F-HTML部分"><a href="#CSS-x2F-HTML部分" class="headerlink" title="CSS&#x2F;HTML部分"></a>CSS&#x2F;HTML部分</h1><h2 id="1-css布局方式"><a href="#1-css布局方式" class="headerlink" title="1.css布局方式"></a>1.css布局方式</h2><pre><code>1.table布局(不常用)
2.flex布局
3.float布局
4.响应式布局
</code></pre>
<h2 id="2-盒子模型"><a href="#2-盒子模型" class="headerlink" title="2.盒子模型"></a>2.盒子模型</h2><blockquote>
<p>标准盒子模型和IE盒子模型</p>
</blockquote>
<pre><code>    IE盒子模型的宽度包括content和padding还有border，标准盒子不包括
</code></pre>
<blockquote>
<p>这两个的区别主要是什么</p>
</blockquote>
<pre><code>    box-sizing:content-box 标准盒子模型
    box-sizing:border-box IE盒子模型
</code></pre>
<h2 id="3-html5新标签"><a href="#3-html5新标签" class="headerlink" title="3.html5新标签"></a>3.html5新标签</h2><blockquote>
<p>canvas 新元素</p>
</blockquote>
<pre><code>    &lt;canvas&gt;标签定义图形，比如图表和其他图像。该标签基于js的绘图API
</code></pre>
<blockquote>
<p>新多媒体元素</p>
</blockquote>
<pre><code>     &lt;audio&gt; 定义音频内容
     &lt;video&gt; 定义视频
</code></pre>
<h2 id="4-BFC"><a href="#4-BFC" class="headerlink" title="4.BFC"></a>4.BFC</h2><blockquote>
<p>BFC，块级格式化上下文，它是页面中一个独立的容器，容器中的元素不会影响到外面的元素。</p>
</blockquote>
<blockquote>
<p>触发条件 (包括但不限于)</p>
</blockquote>
<ul>
<li>根元素，及HTML元素</li>
<li>浮动元素:float值为left、right</li>
<li>overflow值不为visible，为auto、scroll、 hidden</li>
<li>display的值为inline—block，inltable-cell、table-caption、table、inline-table、<br> flex、inline-flex、grid、inline-grid</li>
<li>position的值为absolute或fixed</li>
</ul>
<h2 id="5-浏览器运行机制"><a href="#5-浏览器运行机制" class="headerlink" title="5.浏览器运行机制"></a>5.浏览器运行机制</h2><pre><code>    1.创建DOM树
    2.构建渲染树，css渲染
    3.布局渲染，每个元素的大小位置
    4.绘制渲染树，画出来
    重绘 : 改变元素的外观属性例如div的color、background-color等属性发生改变时

    重排(回流) ：元素的规模尺寸、布局、隐藏改变时

    代价 : 耗时，导致浏览器卡慢
</code></pre>
<h2 id="6-居中的方式"><a href="#6-居中的方式" class="headerlink" title="6.居中的方式"></a>6.居中的方式</h2><p>  <strong>垂直居中的方式</strong></p>
<p>  行高&#x3D;高</p>
<p>  绝对定位top50%,自身宽度的50%的负值<br>  flex布局 align—center</p>
<p>  <strong>水平居中的方式</strong><br>  绝对定位</p>
<p>  flex布局juest—center</p>
<p>  text-align center</p>
<h2 id="7-rem-em-vh-px各自代表的含义"><a href="#7-rem-em-vh-px各自代表的含义" class="headerlink" title="7.rem,em,vh,px各自代表的含义"></a>7.rem,em,vh,px各自代表的含义</h2><p> <strong>px</strong>:绝对单位，页面按照精确像素展示<br> <strong>em</strong>:相对单位，基准点为父节点字体的大小，如果自身定义了font-size按照自身来计算，整个页面内 <strong>1em</strong> 不是一个固定的值<br> <strong>rem</strong>：相对单位,理解为 <strong>root em</strong>,相对根节点<strong>html</strong>的字体大小来计算<br> <strong>vh、vw</strong>:主要用于视口大小布局，在页面布局上更加方便简单</p>
<h2 id="8-有哪些方式可以隐藏页面元素以及区别"><a href="#8-有哪些方式可以隐藏页面元素以及区别" class="headerlink" title="8.有哪些方式可以隐藏页面元素以及区别"></a>8.有哪些方式可以隐藏页面元素以及区别</h2><ul>
<li>display:none</li>
<li>visibility:hidden</li>
<li>opacity:0</li>
<li>设置height、widht模型属性为0</li>
<li>position:absolute</li>
<li>clip-path</li>
</ul>
<p><strong>区别</strong><br>  <img src="隐藏元素.jpg"></p>
<h2 id="9-什么是响应式设计？响应式设计的基本原理是什么？如何做？"><a href="#9-什么是响应式设计？响应式设计的基本原理是什么？如何做？" class="headerlink" title="9.什么是响应式设计？响应式设计的基本原理是什么？如何做？"></a>9.什么是响应式设计？响应式设计的基本原理是什么？如何做？</h2><pre><code>    响应式网站设计是一种网络页面设计布局，页面的设计与开发应当根据用户行为以及设备环境进行相应的响应和调整
</code></pre>
<p>  <strong>响应式网站常见特点</strong></p>
<ul>
<li>同时适配PC+平板+手机等</li>
<li>标签导航在接近手持设备时改变为经典的抽屉式导航</li>
<li>网站的布局会根据视口来调整模块的大小和位置</li>
</ul>
<p><strong>实现响应式布局的方式如下</strong></p>
<ul>
<li>媒体查询（我们可以设置不同类型的媒体条件，并根据对应的条件，给相应符合条件的媒体调用相对应的样式表）</li>
<li>百分比</li>
<li>vm&#x2F;vh</li>
<li>rem</li>
</ul>
<p>响应式设计实现通常会从以下几个方面思考</p>
<ul>
<li>弹性盒子(包括图片、表格、视频)和媒体查询等技术</li>
<li>使用百分比布局创建流式布局的弹性UI，同时使用媒体查询限制元素的尺寸和内容变更范围</li>
<li>使用相对单位使得内容自适应调节</li>
<li>选择断点，针对不同断点实现不同布局和内容展示</li>
</ul>
<h2 id="10-css选择器有哪些以及优先级"><a href="#10-css选择器有哪些以及优先级" class="headerlink" title="10.css选择器有哪些以及优先级"></a>10.css选择器有哪些以及优先级</h2><p><strong>关于css属性选择器常用的有:</strong></p>
<ul>
<li>id选择器</li>
<li>类(class)选择器</li>
<li>标签选择器</li>
<li>后代选择器</li>
<li>子选择器</li>
<li>相邻同胞选择器</li>
<li>群组选择器</li>
</ul>
<p><strong>还有一些使用频率没那么多的选择器</strong></p>
<ul>
<li><p>伪类选择器</p>
<pre><code>  :link 选择未被访问的链接
  :visited 选择已被访问的链接
  :active 选择活动链接
  :hover 鼠标指针浮动在上面的元素
  :focus 选择具有焦点的
  :first-child 父元素的首个子元素
</code></pre>
</li>
<li><p>伪元素选择器</p>
<pre><code>  :first-letter ：用于选取指定选择器的首字母
  :first-line ：选取指定选择器的首行
  :before : 选择器在被选元素的内容前面插入内容
  :after : 选择器在被选元素的内容后面插入内容
</code></pre>
</li>
<li><p>属性选择器</p>
<pre><code>  [attribute] 选择带有attribute属性的元素
  [attribute=value] 选择所有使用attribute=value的元素
  [attribute~=value] 选择attribute属性包含value的元素
  [attribute|=value]：选择attribute属性以value开头的元素
</code></pre>
</li>
</ul>
<p><strong>在css3中新增的选择器</strong></p>
<ul>
<li><p>层次选择器（p~ul），选择前面有p元素的每个ul元素</p>
</li>
<li><p>伪类选择器</p>
<pre><code>  :first-of-type 父元素的首个元素
  :last-of-type 父元素的最后一个元素
  :only-of-type 父元素的特定类型的唯一子元素
  :only-child 父元素中唯一子元素
  :nth-child(n) 选择父元素中第N个子元素
  :nth-last-of-type(n) 选择父元素中第N个子元素，从后往前
  :last-child 父元素的最后一个元素
  :root 设置HTML文档
  :empty 指定空的元素
  :enabled 选择被禁用元素
  :disabled 选择被禁用元素
  :checked 选择选中的元素
  :not(selector) 选择非 &lt;selector&gt; 元素的所有元素
</code></pre>
</li>
<li><p>属性选择器</p>
<pre><code>  [attribute*=value]：选择attribute属性值包含value的所有元素
  [attribute^=value]：选择attribute属性开头为value的所有元素
  [attribute$=value]：选择attribute属性结尾为value的所有元素
</code></pre>
</li>
</ul>
<p><strong>优先级</strong></p>
<pre><code>    内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器
</code></pre>
<h2 id="清楚浮动的方法"><a href="#清楚浮动的方法" class="headerlink" title="清楚浮动的方法"></a>清楚浮动的方法</h2><p><strong>方法一：使用带 clear 属性的空元素</strong></p>
<p>在浮动元素后使用一个空元素,并在 CSS 中赋 予.clear{clear:both;}属性即可清理浮动。</p>
<p><strong>方法二：使用 CSS 的 overflow 属性</strong></p>
<p>给浮动元素的容器添加 overflow:hidden;或 overflow:auto;可以清除浮动，另外在 IE6 中还 需要触发 hasLayout ，例如为父元素设置容器宽高或设置 zoom:1。 在添加 overflow 属性后，浮动元素又回到了容器层，把容器高度撑起，达到了清理浮动 的效果。</p>
<p><strong>方法三：给浮动的元素的容器添加浮动</strong></p>
<p>给浮动元素的容器也添加上浮动属性即可清除内部浮动，但是这样会使其整体浮动，影 响布局，不推荐使用。</p>
<p><strong>方法四：使用 CSS 的:after 伪元素</strong>    </p>
<p>结合:after 伪元素（注意这不是伪类，而是伪元素，代表一个元素之后最近的元素）和 IEhack ，可以完美兼容当前主流的各大浏览器，这里的 IEhack 指的是触发 hasLayout。 给浮动元素的容器添加一个 clearfix 的 class，然后给这个 class 添加一个:after 伪元素实 现元素末尾添加一个看不见的块元素清除浮动</p>
]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>面试</tag>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title>前端准备</title>
    <url>/2022/08/22/interview/</url>
    <content><![CDATA[<h2 id="前端准备"><a href="#前端准备" class="headerlink" title="前端准备"></a>前端准备</h2><span id="more"></span>

<h2 id="一、面试准备"><a href="#一、面试准备" class="headerlink" title="一、面试准备"></a>一、面试准备</h2><h3 id="1-利用脑图来梳理知识点"><a href="#1-利用脑图来梳理知识点" class="headerlink" title="1. 利用脑图来梳理知识点"></a>1. 利用脑图来梳理知识点</h3><p>对于统一校招类的面试，要重点梳理前端的所有知识点，校招面试一般是为了做人才储备，所以看的是候选人的可塑性和学习能力；对于社招类面试，则看重的是业务能力和 JD 匹配程度，所以要针对性地整理前端知识点，针对性的内容包括：项目用到的技术细节、个人技能部分需要加强或提升的常考知识点。</p>
<p>所以，不仅仅简历要针对性地来写，知识点也要根据自己的经历、准备的简历、公司和职位描述来针对性地梳理。</p>
<p>基础知识来自于自己平时的储备，一般对着一本系统的书籍或者自己平时的笔记过一遍即可，但是提到自己做到的项目是没有固定的复习套路的，而且围绕项目可以衍生出来各种问题，都需要了解，项目讲清楚对于候选人也特别重要。基础是固定的，任何人经过一段时间都可以学完的，但是项目经历是实打实的经验。</p>
<p>对于项目的复习和准备，建议<strong>列思维导图（脑图）</strong>，针对自己重点需要讲的项目，列出用到的技术点（知识点），介绍背景、项目上线后的收益以及后续优化点。这是第一层，第二层就是针对技术点（知识点）做各种发散的问题。</p>
<p>注：JD（job description），是指职位描述，是其缩写。一般在招聘中，最常用到的意思就是岗位介绍和工作职责描述的意思。</p>
<h3 id="2-程序员应该具备哪些软技能？"><a href="#2-程序员应该具备哪些软技能？" class="headerlink" title="2. 程序员应该具备哪些软技能？"></a>2. 程序员应该具备哪些软技能？</h3><p>程序员除了业务技能外，应该具有下面的软技能：</p>
<ul>
<li>韧性：抗压能力，在一定项目压力下能够迎难而上，比如勇于主动承担和解决技术难题</li>
<li>责任心：对于自己做过的项目，能够出现 bug 之类主动解决</li>
<li>持续学习能力：IT 行业是个需要不断充电的行业，尤其 Web 前端这些年一直在巨变，所以持续学习能力很重要</li>
<li>团队合作能力：做项目不能个人英雄主义，应该融入团队，跟团队一起打仗</li>
<li>交流沟通能力：经常会遇见沟通需求和交互设计的工作，应该乐于沟通分享</li>
</ul>
<h3 id="3-准备合适的技术型简历"><a href="#3-准备合适的技术型简历" class="headerlink" title="3. 准备合适的技术型简历"></a>3. 准备合适的技术型简历</h3><p><strong>（1）技术型简历的重要组成部分</strong></p>
<p>一份合适的技术型简历最重要的三部分是：</p>
<ul>
<li>个人掌握的技能，是否有岗位需要用到的技能，及其技能掌握的熟练程度：熟悉、了解还是精通</li>
<li>项目经历，项目经历是否对现在岗位有用或者有重叠，是否能够驾驭大型项目</li>
<li>实习经历，对于没有经验的应届生来说，实习经历是很重要的部分，是否有大公司或者具体项目的实习经历是筛选简历的重要参考</li>
</ul>
<p>技术型简历一般不要太花俏，关键要语言表达通顺清楚，让语言准确和容易理解，在 HR 筛选简历的时候，可以瞬间抓住他的眼球。另外如果有一些特殊奖项，也可以在简历中突出出来，比如：季度之星、最佳个人之类的奖项，应届生会有优秀毕业生、全额奖学金等。</p>
<p><strong>（2）推荐使用 PDF 版本的简历</strong></p>
<p>一般来说简历会有 Word、Markdown、PDF 等版本，这里推荐使用 PDF 版本的简历，主要原因如下：</p>
<ul>
<li>内容丰富，布局调整方便</li>
<li>字体等格式有保障，你不知道收到你简历的人用的是什么环境，PDF 版本不会因为不同操作系统等原因而受限</li>
<li>便于携带和传播，始终存一份简历在手机或者邮箱内，随时发送</li>
<li>不容易被涂改</li>
</ul>
<p>一般 Windows 系统的 Word、Mac 系统的 Pages 都支持导出 PDF 格式的文件，原稿可以保存到云端或者 iCloud，方便以后修改。</p>
<p>虽然我们是 Web 前端工程师，但是不推荐使用 HTML 格式的简历，HTML 版本的简历容易受浏览器等环境因素影响，而且接收方不一定是技术人员，炫酷的效果对方不一定能被看到。</p>
<p><strong>（3）简历最好要有针对性地来写</strong></p>
<p>简历是「<strong>敲门砖</strong>」，建议根据想要找的公司、岗位和职位描述来有针对性地写简历。尤其是个人技能和项目（实习）经验部分，要根据岗位要求来写，这样才能增加受邀面试的机会。</p>
<blockquote>
<p>举个例子：好友给你推荐了百度地图部门的一个 Web 前端工程师工作，并且把职位描述（JD）发给你了，里面有要求哪些技能，用到哪些技术，还有加分项。那么你写简历就应该思考自己有没有这些技能。如果没有 JD，那么至少你应该知道：地图部门肯定做一些跟地图相关的工作，如果恰巧你之前研究过地图定位，了解 HTML5 Geolocation 定位接口，那么你可以在简历里提一下。</p>
</blockquote>
<p>很多时候我们并不知道简历会被谁看到，也不知道简历会被朋友&#x2F;猎头投递到什么公司或者职位，那么这样的简历应该是一种「通用简历」。所谓通用简历，应该是与我们找的职位和期望的级别相匹配的简历，比如想找大概 T4 水平的 Web 前端工作，那么就应该在简历体现出来自己的技能能够达到 T4 的水平。不要拿着一两年前的简历去找工作，前端这两年发展速度很快，只靠一两年前简历上面「精通、熟悉」的库和框架，可能已经找不到工作了。</p>
<p>所以，写简历也是个技术活，而且是一个辛苦活！不要用千篇一律的模板！</p>
<p><strong>（4）简历是面试时「点菜」用的菜单</strong></p>
<p>简历除了是「敲门砖」之外，还是供面试官提问用的「菜单」。面试官会从简历上面写的技能、项目进行提问。所以简历是候选人「反客为主」的重要工具，这也是我们一直提到的：<strong>不要造假或者描述太出格</strong>，而应该实事求是地写简历。简历中的技能和项目都要做好知识点梳理，尽量多地梳理出面试官可能问到的问题，并且想出怎么回答应对，<strong>千万不要在简历上自己给自己挖坑</strong>。</p>
<p>另外简历中不要出现错误的单词拼写，注意单词的大小写，比如<code>jQuery</code>之类。并且，作为一个前端工程师，简历的布局一定要合理，美观。</p>
<h3 id="4-收到面试邀请之后的准备"><a href="#4-收到面试邀请之后的准备" class="headerlink" title="4. 收到面试邀请之后的准备"></a>4. 收到面试邀请之后的准备</h3><p>当有公司邀请我们去面试的时候，应该针对性地做一些功课。</p>
<p><strong>（1）了解部门和团队</strong></p>
<p>了解部门做的事情，团队用的技术栈，前文提到这部分信息一般从 JD 当中就可以看到，如果 JD 并没有这些信息，那么可以根据面试的部门搜索下，总会找到一些零星的信息，如果实在没有任何信息，就准备岗位需要的通用技术。</p>
<p><strong>（2）了解面试官</strong></p>
<p>通过邀请电话或者面试邀请邮件，可以找到面试官信息。通过这些信息查找面试官技术博客、GitHub 等，了解面试官最近关注的技术和擅长的技术，因为面试官往往会在面试的过程中问自己擅长的技术。</p>
<h2 id="二、面试过程："><a href="#二、面试过程：" class="headerlink" title="二、面试过程："></a>二、面试过程：</h2><h3 id="1-面试过程中要注意社交礼仪"><a href="#1-面试过程中要注意社交礼仪" class="headerlink" title="1. 面试过程中要注意社交礼仪"></a>1. 面试过程中要注意社交礼仪</h3><ul>
<li><strong>注意社交礼仪：</strong>虽然说 IT 行业不怎么注重工作环境，上下级也没有繁文缛节，但是在面试中还是应该注意一些社交礼仪的。像进门敲门、出门关门、站着迎人这类基本礼仪还是要做的。</li>
<li><strong>舒适但不随意的着装：</strong>首先着装方面，不要太随意，也不要太正式，太正式的衣服可能会使人紧张，所以建议穿自己平时喜欢的衣服，关键是干净整洁。</li>
<li><strong>约个双方都舒服的面试时间：</strong>如果 HR 打电话预约面试时间，记得一定要约个双方都舒服的时间，宁愿请假也要安排好面试时间。面试时间很重要，<strong>提前十分钟到面试地点</strong>，熟悉下环境，做个登记之类的，留下个守时的好印象。如果因为堵车之类的原因不能按时到达，则要在约定时间之前电话通知对方。</li>
</ul>
<h3 id="2-面试中出现的常规问题"><a href="#2-面试中出现的常规问题" class="headerlink" title="2 面试中出现的常规问题"></a>2 面试中出现的常规问题</h3><p>对于面试中出现的常规问题要做好准备，比如：介绍下自己，为什么跳槽，面试最后一般会问有什么要问的。</p>
<p><strong>（1）介绍自己</strong></p>
<p>介绍自己时，切忌从自己大学实习一直到最新公司全部毫无侧重地介绍，这些在简历当中都有，最好的方式是在介绍中铺垫自己的技术特长、做的项目，引导面试官问自己准备好的问题。</p>
<p><strong>（2） 为什么跳槽</strong></p>
<p>这个问题一定要慎重和认真思考，诚实回答。一般这个问题是想评估你入职能够待多长时间，是否能够融入团队。每个人跳槽前肯定想了很多原因，最终才走出这一步，不管现在工作怎样，<strong>切忌抱怨，不要吐槽，更不要说和现在领导不和睦之类的话</strong>。 多从自身发展找原因，可以表达寻找自己心目中的好的技术团队氛围和平台机会，比如：个人遇见了天花板，希望找个更好的发展机会。</p>
<h3 id="3-如何介绍自己的项目经历"><a href="#3-如何介绍自己的项目经历" class="headerlink" title="3. 如何介绍自己的项目经历"></a>3. 如何介绍自己的项目经历</h3><p><strong>（1）介绍项目背景</strong></p>
<p>这个项目为什么做，当初大的环境背景是什么？还是为了解决一个什么问题而设立的项目？背景是很重要的，如果不了解背景，一上来就听一个结论性的项目，面试官可能对于项目的技术选型、技术难度会有理解偏差，甚至怀疑是否真的有过这样的项目。</p>
<blockquote>
<p>比如一上来就说：我们的项目采用了「backbone」来做框架，然后。。。而「backbone」已经是三四年前比较新鲜的技术，现在会有更好的选择方案，如果不介绍项目的时间背景，面试官肯定一脸懵逼。</p>
</blockquote>
<p><strong>（2） 承担角色</strong></p>
<p>项目涉及的人员角色有哪些，自己在其中扮演的角色是什么？</p>
<p>这里候选往往人会自己给自己挖坑，比如把自己在项目中起到的作用夸大等。一般来说，面试官细节追问的时候，如果候选人能够把细节或者技术方案等讲明白、讲清楚，不管他是真的做过还是跟别人做过，或者自己认真思考过，都能体现候选人的技术水平和技术视野。前提还是在你能够兜得住的可控范围之内做适当的「美化」。</p>
<p><strong>（3）最终的结果和收益</strong></p>
<p>项目介绍过程中，应该介绍项目最终的结果和收益，比如项目最后经过多久的开发上线了，上线后的数据是怎样的，是否达到预期，还是带来了新的问题，遇见了问题自己后续又是怎样补救的。</p>
<p><strong>（4）有始有终：项目总结和反思</strong></p>
<p>有总结和反思，才会有进步。 项目做完了往往会有一些心得和体会，这时候应该跟面试官说出来。在梳理项目的总结和反思时，可以按照下面的列表来梳理：</p>
<ul>
<li>收获有哪些？</li>
<li>是否有做得不足的地方，怎么改进？</li>
<li>是否具有可迁移性？</li>
</ul>
<p>比如，之前详细介绍了某个项目，这个项目当时看来没有什么问题，但是现在有更好的解决方案了，候选人就应该在这里提出来：现在看来，这个项目还有 xx 的问题，我可以通过 xx 的方式来解决。再比如：做这个项目的时候，你做得比较出彩的地方，可以迁移到其他项目中直接使用，小到代码片段，大到解决方案，总会有你值得总结和梳理的地方。</p>
<p>介绍完项目总结这部分，也可以引导面试官往自己擅长的领域思考。比如上面提到项目中的问题，可以往你擅长的方面引导，即使面试官没有问到，你也介绍到了。</p>
<p>按照上面的四段体介绍项目，会让面试官感觉候选人有清晰的思路，对整个项目也有理解和想法，还能够总结反思项目的收益和问题，可谓「一箭三雕」。</p>
<h3 id="4-项目细节和技术点的追问"><a href="#4-项目细节和技术点的追问" class="headerlink" title="4. 项目细节和技术点的追问"></a>4. 项目细节和技术点的追问</h3><p>介绍项目的过程中，面试官可能会追问技术细节，所以在准备面试的时候，应该尽量把技术细节梳理清楚，技术细节包括：</p>
<ul>
<li>技术选型方案：当时做技术选型所面临的状况</li>
<li>技术解决方案：最终确定某种技术方案的原因，比如：选择用 Vue 而没有用 React 是为什么？</li>
<li>项目数据和收益</li>
<li>项目中最难的地方</li>
<li>遇见的坑：如使用某种框架遇见哪些坑</li>
</ul>
<p>一般来说，做技术选型的时候需要考虑下面几个因素：</p>
<ul>
<li>时代：现在比较火的技术是什么，为什么火起来，解决了什么问题，能否用到我的项目中？</li>
<li>团队：个人或者团队对某种技术的熟悉程度是怎样的，学习成本又是怎样的？</li>
<li>业务需求：需求是怎样的，能否套用现在的成熟解决方案&#x2F;库来快速解决？</li>
<li>维护成本：一个解决方案的是否再能够 cover 住的范围之内？</li>
</ul>
<p>在项目中遇见的数据和收益应该做好跟踪，保证数据的真实性和可信性。另外，遇见的坑可能是面试官问得比较多的，尤其现在比较火的一些技术（Vue、React、webpack），一般团队都在使用，所以一定要提前准备</p>
<p>下。</p>
<h3 id="5-没有做过大型项目怎么办"><a href="#5-没有做过大型项目怎么办" class="headerlink" title="5. 没有做过大型项目怎么办"></a>5. 没有做过大型项目怎么办</h3><p>对于刚刚找工作的应届生，或者面试官让你进行一个大型项目的设计，候选人可能没有类似的经验。这时候不要用「我不会、没做过」一句话就带过。如果是实在没有项目可以说，那么可以提自己日常做的练手项目，或者看到一个解决方案的文章&#x2F;书，提到的某个项目，抒发下自己的想法。</p>
<p>如果是对于面试官提出来需要你设计的项目&#x2F;系统，可以按照下面几步思考：</p>
<ol>
<li>有没有遇见过类似的项目</li>
<li>有没有读过类似解决方案的文章</li>
<li>项目能不能拆解，拆解过程中能不能发现自己做过的项目可以用</li>
<li>项目解决的问题是什么，这类问题有没有更好的解决方案</li>
</ol>
<p>总之，切记不要一句「不知道、没做过」就放弃，每一次提问都是自己表现的机会。</p>
<h3 id="6-当被分配一个几乎不可能完成的任务时，会怎么做"><a href="#6-当被分配一个几乎不可能完成的任务时，会怎么做" class="headerlink" title="6. 当被分配一个几乎不可能完成的任务时，会怎么做"></a>6. 当被分配一个几乎不可能完成的任务时，会怎么做</h3><p>这种情况下，一般通过下面方式来解决：</p>
<ol>
<li>自己先查找资料，寻找解决方案，评估自己需要怎样的资源来完成，需要多长时间</li>
<li>能不能借助周围同事来解决问题</li>
<li>拿着分析结果跟上级反馈，寻求帮助或者资源</li>
</ol>
<p>突出的软技能：分析和解决问题，沟通寻求帮助。</p>
<h3 id="7-提问环节"><a href="#7-提问环节" class="headerlink" title="7. 提问环节"></a>7. 提问环节</h3><p>面试是一个双向选择的事情，所以面试后一般会有提问环节。在提问环节，候选人最好不要什么都不问，更不要只问薪水待遇、是否加班之类的问题。</p>
<p>其实这个时候可以反问面试官了解团队情况、团队做的业务、本职位具体做的工作、工作的规划，甚至一些数据（可能有些问题不会直面回答）。</p>
<p>还可以问一些关于公司培训机会和晋升机会之类的问题。如果是一些高端职位，则可以问一下：自己的 leader 想把这个职位安排给什么样的人，希望多久的时间内可以达到怎样的水平。</p>
<h2 id="三、HR面试："><a href="#三、HR面试：" class="headerlink" title="三、HR面试："></a>三、HR面试：</h2><h3 id="1-谈薪资——准确定位和自我估值"><a href="#1-谈薪资——准确定位和自我估值" class="headerlink" title="1. 谈薪资——准确定位和自我估值"></a>1. 谈薪资——准确定位和自我估值</h3><p>在准备跳槽时，每个人肯定会对自己有一个预估，做好足够的心理准备。下面谈下怎么对自己的薪酬做个评估。一般来说跳槽的薪水是根据现在薪酬的基础上浮 15~30%，具体看个人面试的情况。对于应届毕业生，大公司基本都有标准薪水，同期的应届生差别不会特别大。</p>
<p>除了上面的方法，还应该按照公司的技术职级进行估值。每个公司都有对应的技术职级，不同的技术职级薪酬范围是固定的，如果是小公司，则可以参考大公司的职级范围来确定薪资范围。根据职级薪资范围和自己现在薪酬基础上浮后的薪酬，做个比较，取其较高的结果。</p>
<p>除此之外，我们可以在<strong>微信小程序<strong><strong>offershow</strong></strong>、牛客网</strong>等平台看看网友分享的各个公司的薪酬体系。</p>
<p>当然如果面试结果很好，可以适当地提高下薪酬预期。除了这种情况，应该针对不同的性质来对 offer先做好不同的估值。这里的预期估值只是心理预期，也就是自己的「底牌」。</p>
<p>所谓不同性质的 offer 指的是：</p>
<ul>
<li>是否是自己真心喜欢的工作岗位： 如果是自己真心喜欢的工作岗位，比如对于个人成长有利，或者希望进入某个公司部门，从事某个专业方向的工作，而你自己对于薪酬又不是特别在意，这时候可以适当调低薪酬预期，以拿到这个工作机会为主。</li>
<li>是否只是做 backup 的岗位：面试可能不止面试一家，对于不是特别喜欢的公司部门，那么可以把这个 offer 做为 backup，后面遇见喜欢的公司可以以此基础来谈薪水。</li>
</ul>
<p>这时候分两种情况：如果面试结果不是很好，这种情况应该优先拿到 offer，所以可以适当降低期望薪酬；如果面试结果很好，这种情况应该多要一些薪酬，增加的薪酬可以让你加入这家公司也心里很舒服。</p>
<p>对于自己真正的目标职位，面试之前应该先找 backup 岗位练练手，一是为了找出面试的感觉，二是为了拿到几个 offer 做好 backup。</p>
<h3 id="2-跟-HR-沟通的技巧"><a href="#2-跟-HR-沟通的技巧" class="headerlink" title="2. 跟 HR 沟通的技巧"></a>2. 跟 HR 沟通的技巧</h3><p>跟 HR 沟通的时候，不要夸大现在的薪酬，HR 知道的信息往往会超出你的认知，尤其大公司还会有背景调查，所以不要撒谎，实事求是。跟 HR 沟通的技巧有以下几点：</p>
<ul>
<li><strong>不要急于出价</strong></li>
</ul>
<p>不要急于亮出自己的底牌，一旦你说出一个薪酬范围，自己就不能增加薪酬了，还给了对方砍价的空间。而且一个不合理的价格反而会让对方直接放弃。所以不要着急出价，先让对方出价。</p>
<p>同时，对于公司级别也是，不要一开始就奔着某个目标去面试，这样会加大面试的难度，比如：</p>
<blockquote>
<p>目标是拿到阿里 P7 的职位，不要说不给 P7 我就不去面试之类的，这样的要求会让对方一开始就拿 P7 的标准来面试，可能会找 P8+ 的面试官来面试你，这样会大大提升面试难度。</p>
</blockquote>
<ul>
<li><strong>要有底气足够自信</strong></li>
</ul>
<p>要有底气，自信，自己按照上面的估值盘算好了想要的薪酬，那么应该有底气地说出来，并且给出具体的原因，比如：</p>
<blockquote>
<ol>
<li>我已经对贵公司的薪酬范围和级别有了大概的了解，我现在的水平大概范围是多少</li>
<li>现在公司很快就有调薪机会，自己已经很久没有调薪，年前跳槽会损失年终奖等情况</li>
<li>现在我已经有某个公司多少 K 的 offer</li>
</ol>
</blockquote>
<p>如果 HR 表示你想要的薪酬不能满足，这时候你应该给出自己评估的依据，是根据行业职级标准还是自己现有薪酬范围，这样做到有理有据。</p>
<ul>
<li><strong>谈好 offer 就要尽快落实</strong></li>
</ul>
<p>对于已经谈拢的薪酬待遇，一定要 HR 以发邮件 offer 的形式来确认。</p>
<h2 id="四、其他"><a href="#四、其他" class="headerlink" title="四、其他"></a>四、其他</h2><h3 id="1-总结和思考"><a href="#1-总结和思考" class="headerlink" title="1. 总结和思考"></a>1. 总结和思考</h3><ul>
<li>面试完了多总结自己哪里做得不好，哪里做得好，都记录下来，后续扬长避短</li>
<li>通过面试肯定亲身体会到了公司团队文化、面试官体现出来的技术能力、专业性以及职位将来所做的事情，跟自己预期是否有差距，多个 offer 的话多做对比</li>
</ul>
<p>每次面试应该都有所收获，毕竟花费了时间和精力。即使面不上也可以知道自己哪方面做得不好，继续加强。</p>
<h3 id="2-面试注意点"><a href="#2-面试注意点" class="headerlink" title="2. 面试注意点"></a>2. 面试注意点</h3><p>在面试过程中，我们经常会被问及各种问题，在回答的过程中，这里简单列举了一些“坑”。</p>
<ul>
<li>“对不起，我真的很紧张”，即使紧张也不要说出来；</li>
<li>“我想知道这个职位的具体收入有多少”一开始就谈钱，你的理想、价值观、使命、目标呢？</li>
<li>“我的缺点是斤斤计较，不能加班，承受不了工作压力太大”不要主动告诉别人你的缺点，你来是展示你的优势的；</li>
<li>“我真的很想要这份工作”不要太过于表现你的欲望或绝望，这是你软弱的表现；</li>
<li>“我现在（之前）的老板太不好了……”向 HR 说你老板的话会变成对方对你的看法；</li>
<li>“我需要……能实现工作目标”招聘是为了满足公司需求，不是为你搭建舞台；</li>
<li>“请问面试什么时候结束”不要表现赶时间，你不尊重公司，自然不会录用你；</li>
<li>“我喜欢贵公司的福利待遇”你是来工作的，不是因为福利待遇才来的；“无可奉告”不违法不涉及隐私，如实告知，有准备的话不会“无可奉告”；</li>
<li>“工作第一年的福利待遇及带薪年假和病假等情况是什么样的”这是入职时才可以问的规定，先问只会被误会；</li>
<li>“我在离婚或者怀孕期间经历了非常艰难的时期”不要主动告诉对方隐私情况，你个人的事情处理不好会容易联想到工作表现；</li>
<li>“我没有什么问题要问”最后被问到时这样回答等同于“再也不见”。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>手写信会从这个世界上消失么？</title>
    <url>/2022/10/05/letter/</url>
    <content><![CDATA[<h2 id="手写信会从这个世界上消失么？"><a href="#手写信会从这个世界上消失么？" class="headerlink" title="手写信会从这个世界上消失么？"></a>手写信会从这个世界上消失么？</h2><span id="more"></span>
<hr>
<p>我驱车前往临镇时，经过一个红色的邮筒，突然想到——会吧。当我们这代人老去时，写信这种形式会从世界上消失吧。</p>
<p>现在的年轻人几乎不依赖书信交流，邮局基本成为了老年人寄存养老金和社交的场所。</p>
<p>微信让沟通变得快捷、方便。</p>
<p>属于时代的工具不停更迭，大胆一点想，也许待我们老去，微信可能都不存在了。</p>
<p>也许在未来，人体内植入了义体，只要愿意，想法便可直接通过大脑，传递给对方，连“码字”、“发语音”都省下了。</p>
<p>也许还能搭配回忆场景特效，话语能配上记忆中的场景和细节。</p>
<p>不仅快速，而且绝佳隐秘。</p>
<p>但转念一想，真的隐秘么？</p>
<p>这样的脑内沟通，被黑客高手破解后更容易窥探到，连最后一层人心隔肚皮都没有了。</p>
<p>相比之下，书信反而更安全，当二进制代码组成的程序甜美地品鉴着你的生物信息，反倒不会在意那一份份白色的信笺。阅读完毕，烧掉，于是你完成了一次大逆不道的隐秘传播。</p>
<p>沟通变得复古，却又安全了起来。那我相信信不会消失。</p>
<p>当然，我觉得信件最终还是会陈列在博物馆，变成某种人类存在的证明。</p>
<p>最初的智人因为沟通，相互传递信息，发展成为群落，发明了火，进而孕育出文明。未来的我们，哪一天走到了尽头，也许不是科技导致的肉身毁灭，而是我们再也不会交流了，亦或是说人类再也没有了交流的欲望了。一切都可通过科技完成供应，不论是食物，金钱，抑或是情感。</p>
<p>如果我们连沟通的欲望都消失了，那么信也会消失的吧。</p>
<p>车子驶过红色邮筒，后视镜中的它端庄、肃穆，却又有一丝美感，它好像在对我说，这一切都看我们人类自己的选择。</p>
]]></content>
      <categories>
        <category>问答</category>
      </categories>
      <tags>
        <tag>问答</tag>
        <tag>阅读</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>成年人应掌握哪些必要的生活技能？</title>
    <url>/2022/09/23/life%20skill/</url>
    <content><![CDATA[<h2 id="为什么现在的年轻人活得那么累？"><a href="#为什么现在的年轻人活得那么累？" class="headerlink" title="为什么现在的年轻人活得那么累？"></a>为什么现在的年轻人活得那么累？</h2><p><span style="border-top: 3px solid black; padding-top:10px">无证上岗谢青年问</span></p>
<span id="more"></span>
<br>

<p><strong>成年人应掌握哪些必要的生活技能？</strong></p>
<hr>
<br>

<p>年纪小点的时候，总觉得做一些宏大事情才算得上美丽人生，比如：要去知名公司工作，要吃高级餐厅，要去大家心目中都觉得好玩的地方去玩，要去采访最当红的明星，还要跟他们合照，要写出一部好作品，要红，要有很多粉丝，要通过写作被很多人认识，要把别人眼中觉得很难做成的事情做好等等。</p>
<p>后来，以上事情差不多都被我做到了，当面采访过当红明星，也给不少人写过人物采访稿，去过一些不错的地方玩过，好吃的、不好吃的高级东西也吃过不少，作品也有，通过写作也赚了些钱，也有些喜欢我的读者，习惯性地时不时挑战一下自己，逼自己走出舒适圈，完成一两件看起来很难完成的事。</p>
<p><strong>但，有段时间还是过得很不开心。</strong></p>
<p>反倒经常被朋友圈看到的朋友自己做的，一顿没那么精致，但充满温度的饭治愈；被学姐那张堆满繁杂难懂专业书，还堆满一摞摞论文的书桌感动；被学长说的那句听起来一点不文艺，但充满生活哲学的“骨头难啃，那就先喝口汤”打动。</p>
<p>后来，用了很长时间才明白，我们虽都在追求更好更美的人生，但真正能让我们发自内心快乐的并不是什么高级、绚烂的东西。<strong>生活中的小确幸，才是我们持久快乐的源泉。</strong></p>
<p>年少时，往往最不喜“平淡”二字，得等，等到都吃过一遍，看过一遍，玩过一遍，才会明白有时平平淡淡，用心去生活带来的快乐也很多。</p>
<p>掌握一些生活技能，生活本身也可以是很好玩的。</p>
<br>

<h2 id="1-学会做菜，能帮你打开新世界大门"><a href="#1-学会做菜，能帮你打开新世界大门" class="headerlink" title="1.学会做菜，能帮你打开新世界大门"></a>1.学会做菜，能帮你打开新世界大门</h2><br>

<p>我深圳姐姐和姐夫一家特别爱自己动手捣鼓一些吃的，哪怕家中有保姆阿姨做饭，但偶尔周六周末会在家做好看的馒头、花卷、包子，会做蔬菜彩虹面条，会做豆浆，做豆腐脑，会烤披萨，烤面包。</p>
<p>最开始时，我只以为他们是擅长做饭，所以有空就捣鼓不停。</p>
<p>后来，去深圳跟姐姐生活一段时间，看着姐姐早上六点多起床，收拾孩子上学，然后自己上瑜伽课，上完课再去公司上班，晚上六点半左右下班回到家，吃饭，陪孩子玩，哄完孩子睡觉，忙完自己的事就是十一点了，每天很辛苦。周六周末有时间，肯定还是想休息的。时不时动手做点新花样，肯定不只是出于擅长。</p>
<p>期间，参与过几次包包子、包饺子的活动，花上一下午，一家人和着面，用着擀面杖压着面块，再撕出一小块，用手戳一个窝窝，塞进自己调好的馅儿，再放在锅上蒸熟，一家人再一起等面熟。这期间，大家说说话，唠唠家常，哥哥（读小学的小侄）有时会过来帮忙包几个奇怪形状的包子，妹妹（三岁多的小侄女）则坐在客厅垫子上，看着动画片，等包子熟了，大家又很认真地尝一口，说着热包子真好吃，说着这次调的馅儿真好吃。</p>
<p><strong>一家人热热闹闹一起吃饭，是一件很温馨的事。也是一个很好的家庭团日活动。</strong></p>
<p>那一两年我过得很焦虑，每年都会去深圳姐姐那呆上一段日子，美其名曰散心。偶尔在外面吃饭，偶尔也会在家自己做饭吃。姐姐教我包菜怎么炒最好吃，牛肉芹菜豆干怎么做味道最香，还要清蒸鱼时要记得往鱼肚子里塞几根大葱和姜块。</p>
<p>看着生食材，在时间的作用下，在我们的努力下，在火候的烹饪下，变得好吃，会觉得很治愈。做菜是这样，生活也是，写作也是如此，凡事从稚嫩到美味，都需时间，都需等待，都需付出自己的劳动力。不要怕辛苦，不要怕程序繁琐。耐心等待，总会变美味的。</p>
<p><strong>这是从做菜中，感悟到的生活哲学。</strong></p>
<p>社会便捷度提高，我们能随时随地在生活中偷懒，我们不需做饭，可以吃外卖，我们不必要再去看那么艰辛难懂的电视剧和书籍，算法会根据我们的喜好，给我们推荐我们所喜欢的短视频，甚至我们连洗头都可以不需要自己动手。</p>
<p>很多事做起来都容易了，都不需要我们自己动手，所收获的快乐更少，而且也容易滋生我们的懒惰，稍微工作辛苦些，就觉得压力大，就觉得生活无趣。</p>
<p>生活越方便，越需要我们坚持自己动手做一些东西，就像做菜，喂饱自己，让自己吃得健康、营养的同时，也能让自己明白人生是繁杂的，切勿投机取巧。</p>
 <br>

<h2 id="2-把房间布置成想要的样子，拥有在家的快乐"><a href="#2-把房间布置成想要的样子，拥有在家的快乐" class="headerlink" title="2.把房间布置成想要的样子，拥有在家的快乐"></a>2.把房间布置成想要的样子，拥有在家的快乐</h2><br>

<p>我最近的生活原则是：<strong>接受不能改变的，在最大限度上改变可改变的，把可改变那部分尽量变成我喜欢的那部分。</strong></p>
<p>比如房间长度、宽度，窗户的位置改变不了，那就改变能改变的。我每天花在书桌上的时间最久，那就给自己买个喜欢的书桌，就算没喜欢的书桌，那就买张喜欢的桌布，买个书架，把自己喜欢的书圆圆满满都架起来，再在书桌上放个简约风小闹钟，放个笔筒，放点小装饰品。把桌子装饰成自己喜欢的样子，那么每天写东西、看书时心情就会很好。</p>
<p>比如，想要电视上看到的那种很好舒适柔软的床，也很容易做到，挑一套质量好点，且是你喜欢风格的床上四件套，经常性把被子拿出去晒晒，躺在自己喜欢的床上睡觉心情也会很好。</p>
<p>再比如，想要日式那种围着小桌子席地而坐的感觉，那就淘个小圆桌，买几个可爱的坐蒲或者坐垫，像很ins风的花瓣垫、还要吐司垫、能坐，放那装饰也好看，再买个小毯子铺在地上，买几个好看的杯子，家里也能开辟出一个很美好很文艺的小角落。</p>
<p>这些都是我自己收拾房间的小tips，在已有条件下，稍微买点小东西，都能把房间弄成自己喜欢的样子。</p>
<p>坦白说，收拾房间、装扮房间这种东西，我一开始也不会，甚至我压根对收拾房间这件事没兴趣。虽期间羡慕过别人房间温馨，生活美好，但总觉得自己不擅长干这件事，而且也麻烦。</p>
<p>过了很久，看到认识很久的学姐，把自己小家置办成自己想要样子，给自己小家买喜欢的小物件，买想要的沙拉碗、水果碟，买各种可爱的碗具，才慢慢明白：<strong>我们想要的生活，是有能力让自己过上的，我们想要的房间，也是可以拥有的，只要再勤快点，再热爱生活一点。</strong></p>
<p>把房间布置成想要的样子，看起来只是一件很微不足道的小事，但真的会给生活增加满满的幸福感。</p>
<p>当然，不仅在家，在宿舍也可以拥有想要的宿舍环境。比如前不久，我的博士师姐说，她买了个2000块的书架，寄到宿舍楼下，咬牙搬上宿舍，终于过上有大书架的生活了。再比如，我们宿舍书桌都贴上自己喜欢颜色的桌纸，买些小挂件，把小书架架起来，装上自己喜欢的书，买个喜欢的小台灯，桌边放有我们去花鸟市场淘的玫瑰花，平时在桌上放平板、放电脑、放书，看看论文，写写作业，虽然看论文的时候很辛苦，但生活也是充满温度的。</p>
<br>

<h2 id="3-把生活折腾成想要样子的能力"><a href="#3-把生活折腾成想要样子的能力" class="headerlink" title="3. 把生活折腾成想要样子的能力"></a>3. 把生活折腾成想要样子的能力</h2><br>

<p>这一两年，学会最重要的一件事就是：<strong>想要什么样的生活，那就让自己去过什么样的生活。</strong></p>
<p>想继续回学校读书，那就买书参考书、备考，重新回到学校读研；想要打hpv疫苗，但武汉抢不到，那就想想办法去预约周边城市的疫苗，虽路途辛苦些，来回颠簸几次，多花些车旅费，但最后一样能和朋友们打上疫苗；希望过一个热闹的生日，那就买零食、订蛋糕，和朋友们一起快乐庆祝。</p>
<p>三月八号那天也想要花，那就泡完一天图书馆，傍晚十分和室友一起去学校周边的花鸟市场买花，根据自己的喜好搭一束自己喜欢的花，而后几个女孩手上拿着各自喜欢的花，回到宿舍剪花、插花，放在书桌旁，到如今过了差不多十多天，那束花依旧开得漂亮，每天看到桌旁花瓶的那束花，都觉开心。</p>
<p>想成为那种“学得好，但玩得也开心”的女生，于是平时除了上课，在学校的时间基本都在图书馆，看书、写字、看论文、做老师的项目。但也不能只知道学习，学习任务完成得差不多了，每周基本都会抽出一天时间，跟室友或朋友一起看森林公园看向日葵，去东湖看樱花顺带吃藏着东湖深处的冰烤红薯，去看博物馆，去看音乐节，去春游，偶尔也逛街，也买排很长队的奶茶和糕点。</p>
<p>以前不懂生活，遇到很小一点变故都觉难过，想做的事也有很多，但自己疲懒，大多不愿去做，还总觉生活对我不好，要不然别人生活怎么如此丰富多彩，自己生活那般单调。</p>
<p>现在长大了，也成熟了，慢慢懂得想要的生活，谁都给不了我，只能自己给自己创造。想要出去玩，那就自己筹备，约朋友，定时间；想要工作、学习、生活都如意，那就该学时好好学，该玩时再认真玩；想要玩得开心，吃得开心，那平时就好好干活，好好赚点钱，好好写东西，让自己快乐。</p>
<p><strong>想要过怎样的生活，就让自己去做怎样的努力。这就是人生。</strong></p>
<p>前几天博士师兄跟我们开会，聊完课题，师兄突然跟我们说：“虽然学业很紧张，但大家也不能压力太大，我之前读研究生可是到处去玩的。你们也一样，每周七天，五天在学校学习，剩下两天该出去玩，就去出去玩。学习和生活做不到五五开，最起码得做到六四开。”</p>
<p>导师每次跟我们师门开会，都要夸师兄一遍，说师兄有搞学术的天赋。师兄在研究生期间就发了几篇C刊，拿过国奖，这些都是花费精力、付出时间才能做成的。但之前翻他朋友圈，看到的也是他到处去玩，国内各个城市玩一遍后，就去英国，去冰岛，去国外玩。</p>
<p>当然，读博的压力肯定大，但工作归工作，生活归生活。学习得认认真真学，玩的时候也要好好玩。松弛有度才最长久。</p>
<p>我很喜欢我身边的这种环境。身边一些人，无论是师兄师姐们，还是师长、朋友，他们每个人都有自己的压力，都有自己的人生难关，但那些压力也并不会真的影响大家的生活，大家都很沉得住气，心态极好。</p>
<p>可能也是跟学术氛围有关，大家都知道有些东西急不得，书得一页页看，论文得一个字一个字写，问题得一个个解决，急不得。<strong>更重要的是，也不用着急，问题在那就在那呗，踏踏实实一步步走，冷静沉着一点点解决问题，好好努力，好好看书，自己争点气，也总会有解决问题的那一天。关键是沉住气，熬住了。</strong></p>
<p>既然打的是长远战，那就调整好心态，千万不要还没熬到大结局，就先把人给熬垮了。该工作的时候认真工作，该学习的时候好好学习，之余也要好好生活，好好吃每一顿饭，充实且愉快地度过每一天。</p>
<p>不悲不喜，接受月有阴晴也有圆缺的事实，也接受人生有阳光明媚，也有阴雨绵绵的真相，别再为阴雨难过，阳光明媚就开开心心出门遛弯、赏个花，阴雨时分撑把伞也可以不让自己淋湿。<strong>无论得，或失，一切都是人生，一切都可以是最好的安排。</strong></p>
<p>总有乐在其中的本领，是我们这一生必须学会的一项很重要的生活技能。</p>
]]></content>
      <categories>
        <category>问答</category>
      </categories>
      <tags>
        <tag>问答</tag>
        <tag>阅读</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>喜欢我十九年的男孩结婚了</title>
    <url>/2022/10/07/marry/</url>
    <content><![CDATA[<h2 id="喜欢我十九年的男孩结婚了"><a href="#喜欢我十九年的男孩结婚了" class="headerlink" title="喜欢我十九年的男孩结婚了"></a>喜欢我十九年的男孩结婚了</h2><p><span style="border-top: 3px solid black; padding-top:10px">文／卫好唯</span></p>
<span id="more"></span>
<br>


<p>夏季，周末，有晚风，有暑气。</p>
<p>大学室友萍子从外地回来，特地给我打电话点名要吃烤全鱼，扬言要榨干我本月的工资，我在电话里调侃：只要你能吃得下，我请你吃光整个松花江。</p>
<p>许久没见，萍子竟丰腴了不少，我俩坐在雾气缭绕的鱼锅旁从当年大学生活聊到如今工作，从大热韩剧来自星星的你聊到谢霆锋王菲分分合合，聊至起兴，萍子要了两瓶茅台，说这样才算是意境。</p>
<p>我为了她的意境，先干了一杯。</p>
<p>萍子夹了一块鱼肉说：好好，网上有一个特火的文章来着，叫什么，我喜欢了十年的姑娘今天结婚了，哎，多可惜。</p>
<p>我呦了一声说：这么巧。</p>
<p>她不明所以：什么这么巧？你喜欢的姑娘也在今天结婚了？</p>
<p>我说：哪能呢，我是说喜欢了我…</p>
<p>我扳了下手指头数了数接着说：喜欢了我十九年的那小子啊，今天也结婚了。</p>
<p>萍子瞪圆眼睛问：你说谁啊，我怎么不知道。</p>
<p>我说你哪能知道，谁都不知道。</p>
<p>萍子嘿嘿傻乐：小伙子长什么样啊，让我见识见识。</p>
<p>我掏出手机，翻至一张照片，照片里是某年冬天我和一个男孩在广场上看冰灯时的合照，他穿着黑白色的羽绒服，耳垂被冻得通红，由于身高很高，他将手臂搭在我的肩上，侧头看着我，表情似乎是微微的不悦，因为那两条极是浓密的眉毛是皱着的，在斑驳的冰灯下溢彩流光。</p>
<p>照片上，映在我脸上的光线有些暗了，看不清表情，只是大概觉得，神情是在瞪他的。远远看去，两个人竟神奇的有些“深情对视”的味道。</p>
<p>萍子接过去，醉眼朦胧的看了半天，我估计她是在对焦。</p>
<p>过会，她咿咿呀呀地叫：哎呦，这不是你大学时候么，这小伙是哪院的草啊，我怎么没见过。</p>
<p>我说：哪院也不是。</p>
<p>萍子撇撇嘴：你不说他今天结婚么，新娘长什么样啊，比你漂亮吗，有多好看？</p>
<p>有多好看？</p>
<p>我在想该如何回答。</p>
<p>隔着缭绕见薄的雾气和几乎见底的茅台白酒，我低下头，酒气上涌烧红两颊，烫得我几乎睁不开眼睛。</p>
<p>过了一会儿，我说：应该是比月亮还好看吧。</p>
<p>一</p>
<p>2008年冬，摄于哈尔滨。</p>
<p>肖丛和我随着闪光灯定格在08年冰灯夜的二十几个小时前，他还远在大不列颠潮湿的阳光下装绅士，或者拿着课本攻读他学得比死还难受的金融。</p>
<p>而他出现在我面前的时候，只有一句话。</p>
<p>他说，何好，我回来了。</p>
<p>若不是他上下满身的风尘仆仆，我几乎以为自己是站在老楼的阴凉处，在等他和一群朋友在足球场挥汗如雨道别后，余兴未尽地跑回来，气喘吁吁地对我说：何好，我回来了！</p>
<p>接着，胡乱应付了我絮絮叨叨告诉他剧烈运动不能马上喝水的嘱咐后，兴致盎然地讲着他今天踢了多么好的球，哪个哪个胖子长得比球门还宽却总是守不住球，哪个哪个小子运球还算厉害。</p>
<p>好似寻常往时。</p>
<p>我已经不记得是怎么记住肖丛这个名字，也不记得我和他说的第一句话。</p>
<p>就像我不记得生命中是如何叫出第一声妈妈。</p>
<p>妈妈就是妈妈。</p>
<p>肖丛就是肖丛。</p>
<p>直到我在2011年看了一部叫做《怦然心动》的电影，看到美得像画一样的金发碧眼小萝莉与第一次见面的心仪男孩牵手的时候，忽然鼻头一酸。</p>
<p>我万分肯定肖丛跟我一样什么都记不住，因为我俩的“初次会面”比电影里的小男女主角还小，见面不打得你哭我嚎的就不错了，一定不会和气美满地牵个手。</p>
<p>我和肖丛从小住对门，常是我回家上楼，掏钥匙，插门锁，还没等开门，对面的门就能循着声音慢慢悠悠地打开，然后是肖丛趿拉着拖鞋，穿着四方大短裤和半袖，懒洋洋地倚在门框，往往细长的眼睛半梦半醒地看着我说：我有点饿。</p>
<p>然后等我打开门，说“过来吧”，他便直接轻跳着大迈一步，从那一头的门槛上跨到这一头的门槛内。</p>
<p>因为肖丛，我从只会煮方便面到最后能熟练地做一盘上好的糖醋排骨。</p>
<p>但肖丛始终都说我妈的手艺比我好，在这一点上，我认为他绝对是在奉承我妈，我好几次逼他说实话，但他一直坚持撒谎。</p>
<p>肖丛的蹭吃蹭喝皆源自于他常年空荡荡的家，或许那已并不能称之为家，父母外地经商，常年不曾见面，从小便将他托付给五十多岁的奶奶。小时候好些，肖奶奶贴心照料，待肖丛长大一点，能跑能跳会自己吃饭的时候，便天天随着一群友人在麻将桌上赤膊大战，乃老当益壮。</p>
<p>所以每当饭点，我妈都会把我从电视机里拎出来，让我去叫肖丛过来吃饭，她常常嘱咐我：好好你要多照顾肖丛，他比你小，是你弟弟。</p>
<p>我说妈你看，他就比我小一岁，但是长得比我高那么多，全是你喂出来的，你怎么不把你亲生闺女养那么壮实呢。</p>
<p>我爸说：女孩瘦点好看。</p>
<p>从小到大，我和肖丛仿若从来没有分开过一般，我们同一所小学，同一所初中，甚至同一所高中。</p>
<p>小学时，下课回家的铃声一响，他就会准时出现在我们班级的门口等我一起回家。</p>
<p>有一天早晨起来，我的两边脸肿得像巨型馒头，早晨刚进教室就被班主任叫过去，他仔仔细细地盯着我的脸看了半天，然后跟我说：何好，你今天先回家吧，你这是腮腺炎，会传染的，等好了再来上学。</p>
<p>然后我在班级小朋友唯恐避之不及的惊恐目光中被班主任不容置疑地遣回了家。</p>
<p>当天黄昏，本是放学的点，肖丛却迟迟不归，急得肖奶奶麻将也不打了，一直在楼底下踱步转悠，直到一个小时后，肖丛才慢慢悠悠地从远处走回来。肖奶奶上去刚要劈头盖脸一顿教训却看到他那张小脸上青一块紫一块的挂了彩。顿时又惊又心疼，问他怎么回事，是不是在外面打架了。</p>
<p>肖丛的小脸上在那时候还是愤愤的样子，他理直气壮地说：没事，就是跟何好她班的一个男生打起来了。</p>
<p>肖奶奶问他：你这孩子，跟小何好的同学打什么架啊，人家同学都比你大一两岁的，你打得过人家吗！</p>
<p>他扬起脸：打得过！我都把他打哭了！谁让他说何好快死了！</p>
<p>那气势汹汹硬声硬气的小男孩的声音说到这竟软了，眼圈也开始泛红，他问：奶奶，何好真快要死了吗？</p>
<p>那天晚上，我印象很深。</p>
<p>不光是因为得了腮腺炎疼得我只能捧着奶瓶子喝奶，而是因为，正当我捧着奶瓶子在沙发上边看电视边喝奶的时候，肖奶奶领着肖丛直接冲到我们家验证我是不是快要死了。</p>
<p>后来不论是肖奶奶还是我妈，每当需要笑料的时候都会把这件事重新翻出来讲讲，讲小肖丛那勇敢无畏的小英雄形象，谈小英雄落泪只为我这小红颜，而每当她俩谈得起兴，肖丛就会冷着脸从旁边默默走开。</p>
<p>那是肖丛第一次和人打架，还把人家打哭了。</p>
<p>等到我痊愈回到学校的时候，才知道被打哭的是我们班的一个小胖子，小胖子也怪可怜的，他一直纯真地以为传染病就是绝症，但是我觉得他以后再也不会这么以为了。</p>
<p>此后肖丛在我们班一战成名，这个名是“何好的好弟弟”。</p>
<p>班里的几个小女生开始羡慕我，说我弟弟对我真好，天天等着我放学回家，有时候还帮着拎书包，还能为了我和小胖子打架，小胖子多厉害呀，长那么高，肉还那么多，没几个能打过的。</p>
<p>我说你们别羡慕，他给我拎书包完全是因为我俩石头剪子布他输了，愿赌服输的。</p>
<p>小女生说真好，我也要和你弟弟玩石头剪子布。</p>
<p>我说不行，我弟弟只能和我玩石头剪子布。</p>
<p>后来不知怎么的，肖丛竟然和小胖子握手言欢，一直到小学毕业，肖丛在我们班混得比我都好，和我们班里的男生称兄道弟。甚至夏天一到，后面那一排男生分西瓜，都让我给肖丛带一块过去，然后顺带的，沾光的，我也能得一块。</p>
<p>小学升初中后，我去了算不错的五中，报到那天远远看见一个男生很眼熟。走过去一看，正是我的小学同学董野，顿时有一种“他乡遇故知”的激动。</p>
<p>我上去打招呼，我说：董野真巧，我都不知道你也来五中。</p>
<p>董野说：真巧，我早就知道你也在五中。</p>
<p>我问：你怎么知道的？</p>
<p>董野答：肖丛告诉我的呀，暑假我们出去玩来着，庆祝毕业，把肖丛也带上了。肖丛就问我们有没有谁去了五中，我说我去了。肖丛就说你也在五中，还让我先照顾你一年呢。</p>
<p>我发了个长长的哦音说：我们互帮互助，互帮互助。</p>
<p>站在正午大好的阳光下，其实心底在偷笑。</p>
<p>那一年正是2001年，懵懂的尾巴，青春的开幕。</p>
<p>我一直没有深究董野说的那一句“先照顾一年”，或说我把侧重点放在了照顾上，而忽略了“先”和“一年”。</p>
<p>也自然未曾想过，也许早在得知我会去五中这个消息之时，肖丛就已经决定一年后，自己也要去那个听说叫做五中的，也不知好坏的，陌生学校。</p>
<p>上了初中后，我回家的时间开始比肖丛晚，也不再有人陪我一起回家，不再有人在回家的路上输掉了石头剪子布帮我拎书包。</p>
<p>每当我看到肖丛那小子在外面玩得跟野马似的跑回来，我这个过来人就会深沉幽怨地告诉他：等你到了姐姐这个年纪，你就天天做作业去吧。</p>
<p>被我啰嗦的次数多了，后来肖丛用一句话凌迟了我，他说：你做一个小时的作业我只用十分钟，因为你笨。</p>
<p>这句话对我来说打击很大，所以我顶着巨大的打击学会了西红柿炒蛋，端到他面前要求他给我道歉。</p>
<p>他接过我手里香喷喷的一盘西红柿炒蛋，说了句“谢谢，回见”。</p>
<p>结合天时地利人和，我和董野的关系越来越好，我在三班，他在七班，不同于小学见面嗨一下，现在是见面聊一会。</p>
<p>这样往来的次数多了，有一次班里一个八卦的女同学拉住我小声问：何好，你和七班的那个，叫什么野的男生，是不是在一起了呀？</p>
<p>我愣住，脑袋里一遍一遍重复着那三个字。</p>
<p>在一起。</p>
<p>13岁的年纪，第一次将“在一起”这个暧昧模糊的词安放到了自己身上，将这三个字从远处拿到近处，从模糊的看到了清晰的实体。</p>
<p>我知道我的脸颊肯定红了，我说：没有，他是我小学同学，我俩就是老同学好朋友。</p>
<p>她点点头，将信将疑地走了。</p>
<p>不管她信不信，我是有点不信了，我从这段时间的开头想到结尾，开始觉得如果我和董野真的“在一起”，那么也是情理之中，水到渠成。</p>
<p>一天放学后董野来找我，说今天去他姑姑家，正好和我顺路，能送我回家。</p>
<p>我说好啊，那走吧。</p>
<p>我俩一路走得比往常慢，坐车也比往常晚，下车也比往常晚，我们一直在聊，聊的内容已经记不清了，就是总有话在聊，聊不尽的样子。聊着聊着便已经到了家门口。</p>
<p>我说：董野拜拜，谢谢你送我回家。</p>
<p>董野就看着我呵呵地笑，然后说：何好，明个见。</p>
<p>接着一路跑远。</p>
<p>我的心情，用琼瑶阿姨的话来说就是开心得不得了，也不知道为什么开心，反正就是开心。</p>
<p>等到我上楼迈到最后一个台阶，就被一声巨大的开门声吓得一抖，差点没从楼梯上滚下去。</p>
<p>我抬头就看到肖丛站在门里，小小年纪却开始学会抱肩质问我：你怎么回来这么晚？</p>
<p>我说：没有很晚，天还大亮着呢。</p>
<p>他说：你回来这么晚还这么开心。</p>
<p>我说：你哪看到我开心了？</p>
<p>他说：在楼上。</p>
<p>我开始明白他是在楼上看到我和董野。我说：他去他姑姑家，顺路送我回来。</p>
<p>他居高临下地对我嗯了一声，然后砰的一声把门关上了。</p>
<p>肖丛一直像个孩子，对我笑对我闹对我毒舌大吼，却从来没有像这样过，只是冷冷的嗯了一声，再留下一个冷暴力。</p>
<p>那天我是笑脸进楼黑脸进门的，我妈敲我房门让我出去吃饭，我说妈我不吃，我减肥。</p>
<p>我妈说那你去叫肖丛来吃饭。</p>
<p>我说他也不吃，他也减肥。</p>
<p>我和肖丛开始冷战，那是我俩第一次冷战，原因竟有些莫名其妙。</p>
<p>冷战一直持续到周末中午，那是我起床的时间，朦朦胧胧睁开眼睛，视线还没等清晰就看到肖丛坐在我书桌旁的椅子上，手里拿着一个魔方在转。</p>
<p>我打了个哈欠说：你干嘛呢。</p>
<p>说完我就后悔了，因为我想起来我们还在冷战。</p>
<p>肖丛说：我饿了。</p>
<p>我抱着“饿了还敢跟我耍脾气”的心态穿着睡衣去刷牙洗脸，然后去厨房煮了两人份的面。</p>
<p>我俩吃得安安静静，谁都没有开口说话，我吃完就坐到沙发上看电视。</p>
<p>肖丛吃完也走过来，坐在我边上，我不和他说话，眼睛直盯着电视机，过了一会儿，他叫我的名字：何好。</p>
<p>我仍是不看他，只说：干嘛。</p>
<p>他说：何好。</p>
<p>我说：有事就说。</p>
<p>他还是叫：何好。</p>
<p>我终于怒气冲冲地转过来看他：都告诉你有事就说。</p>
<p>他看了我半天，说：我说我要跟你和好。</p>
<p>本来我凶巴巴的一张脸瞬间就被他破功了，我忍不住咳嗽了一下说：那就和好呗。</p>
<p>那时候小，从此就以为无论什么事情只要他叫一叫我的名字，我们就能像从前一样好。</p>
<p>可是长大了之后，很多事情都变得很难很复杂和很多无可奈何，无论他叫多少次我的名字，我都再也不能说一句，那就和好，那样简单。</p>
<p>我升初二的那年，肖丛光荣地成为了初中生，并且光荣地跟着大客车被送去了部队，参加人生中第一次军训。</p>
<p>等到再被大客车送回来的时候，黑了不止一个色度，我安慰他：姐当年缓了一年才白回来，你别怕，一年很快就过去。</p>
<p>可肖丛满不在乎：黑就黑了。</p>
<p>后来的生活又按照从前的老套路来了一遍，他在放学的点等在我的班级门口，我俩在路上石头剪子布，他又开始经常输，开始帮我拎书包。</p>
<p>都说沉重的书包压弯了孩子们的腰，压矮了孩子们的身高，可是肖丛帮我拎好几年书包了，我沉重的书包并没能降住他，尤其初三开始，架势就像孙悟空的定海神针，我很是担心他会长天上去。</p>
<p>以前我俩并排，我侧头是他的眼睛，后来我侧头，是他的下巴，最后我侧头，是他的锁骨。</p>
<p>肖丛所在低年级的教学楼，我常在大课间或者午休去找他，顺便给他带点吃的。</p>
<p>去了两三次之后便总觉得路上总有小姑娘对我指指点点，开始我还有点恐慌，后来我直接一个眼神杀过去，她们就看天看地反正不是看我了。</p>
<p>有一天我拿着两个苹果去找肖丛，刚上楼就迎面碰见一个男生，那男生看我一眼就马上转身往回跑，我想我长得不能像他班主任，毕竟我还穿着校服呢。</p>
<p>那男生跑到我的目标班级门口，兴奋地大喊：肖丛肖丛，来找你了。</p>
<p>一边说还一边挤眉弄眼。</p>
<p>然后跑过来冲我嘿嘿一笑说：马上就出来了。</p>
<p>我点头：谢谢学弟。</p>
<p>男生说完不谢不谢就跑了。</p>
<p>肖丛出来拿了我手里其中一个苹果，咬了一口。</p>
<p>我说：肖丛你从小到大吃的所有水果好像都是我喂的，我不提醒你你就不吃水果，我妈说多吃水果对身体好。</p>
<p>肖丛说：你喂的就够多了。</p>
<p>我拍拍他的肩膀：知道姐对你好就行，以后别娶了媳妇忘了姐。</p>
<p>肖丛瞪了我一眼。</p>
<p>吃完一个苹果，我说你回去吧，我走了。</p>
<p>他嗯了一声，把苹果核给我就转身走了。</p>
<p>等到我狰狞地拎着苹果核再转身的时候，就看到三个小姑娘看着我，和我手上的苹果核。</p>
<p>再等我走几步，就听到身后小声的窃窃私语：他对他女朋友也太不好了，你说能不能是倒贴？</p>
<p>我想我毕竟比她们老一岁，她们说的那点事我直接就能明白，我又转过身看她们，我说：不是倒贴，我是他姐。</p>
<p>说完我就拎着苹果核走了。</p>
<p>那是我第一次朦朦胧胧地从陌生人的眼中看到我们的关系。</p>
<p>2003年春末夏，危乱恐慌的氛围开始在全国各地的每一个角落蔓延，学校开始封闭，严查每一个进出校园的人员，而每一个体温超过38度的学生老师，都要求强制隔离。</p>
<p>那场重大的病害灾难叫非典。</p>
<p>那一年我们都还不懂什么叫生命，以为死去很遥远，它不在我们身上，不在父母身上，不在同学身上，不在老师身上。它只在电视机里，在新闻报道里，在别人的言语唏嘘里。</p>
<p>03年的非典将它混合着恐慌和眼泪注入到每个人的身上。</p>
<p>那段时间我们每个人早晨都要测体温，填单子，数据整齐不能缺漏。记得班上有个学习很好的女生因为高烧到38.1，直接被隔离在家。</p>
<p>第二天哭着给老师打电话，她说：老师，快要中考了，你让我回去吧。</p>
<p>老师说：这不是我让你回来你就能回来的，你先好好打针吃药，等烧退了你再来，你学习没问题，不差这几天。</p>
<p>女同学哽咽地嗯了一声。</p>
<p>后来她退了烧，健健康康的回到学校里，跟我们说，其实她在电话里还想说一句，她想说：老师，如果我真的要死了，那我也想坚持到走进考场。</p>
<p>她说完，我们哈哈大笑，笑她真是死认学死认学的。</p>
<p>她说：我就是觉得学习这么努力，还没收获点什么，不甘心。</p>
<p>我们又笑了。</p>
<p>那段时间，学校要求每个班级之间的学生不能随便走动，肖丛便很长时间没有吃过水果。</p>
<p>后来我经历中考，考上了前四所中排名第三的实验高中，实验高中实行住校制，也是因为离家远，我过了上了人生中第一次的寝室生活。</p>
<p>住校不到一周，我妈就给我配了个手机，每天晚上都会给我打电话，对话也永远都是一个模式。</p>
<p>我妈：今天晚上吃饭了吗？</p>
<p>我：吃了。</p>
<p>我妈：学习怎么样？累不累？</p>
<p>我：不累。</p>
<p>我妈：身上的钱够不够？</p>
<p>我：够了。</p>
<p>肖丛也会给我打电话，相比于我妈的每天，他是每周的周三，一周的中间日。</p>
<p>这时候的对话就是,我：吃饭了吗？</p>
<p>肖丛：吃了。</p>
<p>我：学习怎么样？</p>
<p>肖丛：比你好。</p>
<p>我：想不想姐姐我？</p>
<p>肖丛：不想。</p>
<p>我：那我周末不回去了。</p>
<p>肖丛：阿姨说周末吃火锅。</p>
<p>15岁的男孩，我每周回去见他，他都是一个新样子，个头高了些，肩膀宽了些，轮廓清朗了些，某一天，我甚至发现他的唇角开始生出细软的绒毛。</p>
<p>第二年，他正式升入高一，报到那天我老早的就等在男生宿舍楼门口，看他在远处的报到队伍里填完单子，再拉着行李箱走过来。</p>
<p>那天的天气很好，阳光很好，周围的景致好，高中生洋溢的朝气好，他走过来的样子也好。</p>
<p>明明是他常穿的运动鞋，常穿的休闲裤，常穿的体恤衫，我却看到了不一样的肖丛。</p>
<p>听说长大是一瞬间的，我想，我的男孩长大了。</p>
<p>而我，只堪堪到他的肩膀了。</p>
<p>我看着他笑，我说：学弟别怕，学姐照顾你。</p>
<p>他也看着我笑，他说：学姐，你越来越矮了，还是我照顾你吧。</p>
<p>我帮他把新发的被褥铺好，然后带他去食堂吃饭，转转校园，那一路引来的侧目，是每个17岁女孩都无法拒绝的虚荣心。</p>
<p>高中的军训是在本校的大体育场上。</p>
<p>烈日炎炎，体育场内是整片整片穿着绿色迷彩服的新生，体育场外是一圈一圈体育课上跑出来偷闲的学长学姐。</p>
<p>男生看哪个新学妹漂亮，女生看哪个新学弟帅气。而我在人群里找到肖丛的队伍，再找到他，给他送水送吃的。</p>
<p>送的次数一多，我便发现他同寝的几个小子看着我的眼神带着可怜兮兮的乞求。后来我买东西都带出他们一个寝室的份，从此这帮小子就开始一口一个姐，叫得特别亲。</p>
<p>我跟肖丛说：你看我给他们送了就几天吃的喝的，就叫我叫得这么甜。</p>
<p>我给你送这么多年了，你一次都没叫我姐。</p>
<p>肖丛说：我岂能为五斗米折腰。</p>
<p>新生军训结束后，每天回寝室的路上从室友又变回了肖丛，每到放学的点，室友们便会把我往外一推：去吧去吧，你帅弟弟来了，用不着我们陪了。</p>
<p>她们也常说：何好！我看上你弟弟了，从此你就是我姐夫！</p>
<p>通常我也会爱抚她们的肩膀说：先把男女辈分称呼弄明白了再来提亲。</p>
<p>她们也会在我帮肖丛洗校服的时候说：何好，等到我成为你小姑子的时候，你会不会也把我的衣服也洗了。</p>
<p>通常这个时候我也会说：会，我会把你洗了。</p>
<p>这是好时光。</p>
<p>好时光里，有无数封情书在男孩女孩的手里穿梭，有无数的小字在墙壁书桌角留下，有很多喜欢你，对不起在拥抱和转身之间辗转，有很多暗恋和眼泪，很多哽咽和表白，和，很多陪伴。</p>
<p>好时光里，我们吵闹，我们大笑，我们坐在课堂上奋笔疾书，站在塑胶跑道边大喊加油快跑。</p>
<p>好时光太好。</p>
<p>而好时光最会的就是，一晃而过。</p>
<p>06年九月，我脱去了青春里最后一套校服，和五十多个男孩女孩在一个夜晚碰杯流泪，然后，踏上了通往哈尔滨的火车。</p>
<p>我说：肖丛，以后校服自己洗吧，记得多吃水果。</p>
<p>他说：我看见你们班的男生抱你了。</p>
<p>我说：那是我们告别呢。</p>
<p>他说：我也要告别。</p>
<p>然后他张开双臂，一寸一寸，是舒展的姿势。</p>
<p>那是我和肖丛从小到大的第一次拥抱，第一次听到那样在他胸腔里的，有力的，飞快的心跳。</p>
<p>大一的下学期，有个男生把我拦截在图书馆的阅览室的门口，他说：何好是吧，我叫杜飞。</p>
<p>我说：你是不是还有个兄弟叫何书桓。</p>
<p>他一下子笑出声，然后把一张学生证亮在我面前说：你刚才借完书没拿学生证就走了。</p>
<p>我看着我学生证上像素残酷的照片，接过来说了声谢谢。</p>
<p>他看着我笑：谢就不用了，要不你请我吃个饭吧，正好中午没吃饭。</p>
<p>我说：你要吃什么。</p>
<p>他说：就食堂的一荤两素吧。</p>
<p>我说：行。</p>
<p>六块钱的一荤两素，我认识了比我大两届的杜飞。</p>
<p>他和电视剧里的杜飞一点都不一样，他办事高效完美，为人成熟慷慨，学长应有的魅力他全有。</p>
<p>和我妈通电话的时候我提起杜飞，我妈说：这次你可以早恋了。</p>
<p>我说：妈，我现在是晚恋，而且还没恋呢。</p>
<p>这通电话的第二天晚上，肖丛给我打电话，我正在KTV和室友们抱着麦克风嘶吼。</p>
<p>萍子趴到我耳边大喊：好好！你来电话了！来电显示叫肖丛！</p>
<p>我拿着手机走出包间接听，我说：喂。</p>
<p>那边过了几秒才回应我：你在哪？</p>
<p>我说：我和室友在KTV玩。</p>
<p>他说：你什么时候回来？</p>
<p>我说：等到放暑假的呀，怎么了？</p>
<p>那边又是安静，我以为是这边的吵闹声太大让我没有听清，我想可能是快要高考了，他压力很大。</p>
<p>我安慰：肖丛你马上要高考了，早点睡觉，你那么聪明不用熬夜学习，放松就好。</p>
<p>他说：不用你管。</p>
<p>然后挂掉电话。</p>
<p>萍子出来问我怎么了，我说没事，我弟弟要高考了，心情不好，找我发泄呢。</p>
<p>其实有些事情，我们一点也不懂，或者我们以为自己懂了。</p>
<p>然后在以后，在短发变成长发以后，在牛仔裤变成长裙以后。</p>
<p>那时我们或许正围着围裙在厨房里炒菜。</p>
<p>或许正拿着玩偶在逗婴儿床里的宝宝笑。</p>
<p>也或许正推着购物车在超市的调料架子边挑挑选选。</p>
<p>却猛然间想到那些陈年旧事。</p>
<p>想到那个男孩的电话，电光火石的就突然懂了。</p>
<p>其实他想说：你在哪，你不要和别的男人在一起。</p>
<p>你什么时候回来，你快点回来。</p>
<p>和，我想你。</p>
<p>我暑假回家下火车的那一天正值很热的天气，30度左右的高温下看到肖丛在站口的身影。</p>
<p>他从远处走过来，身姿容颜一点一点变得清晰，最后接过我手里的行李箱。</p>
<p>我说：肖丛你刮胡子了。</p>
<p>他说：早就刮了。</p>
<p>我说：肖丛你长喉结了。</p>
<p>他说：早就长了。</p>
<p>我说：肖丛你想我了。</p>
<p>他说：一点都不。</p>
<p>我说：你怎么不按套路来呀。</p>
<p>然后两个人就开始笑。</p>
<p>那个夏天正是肖丛结束了高考开始填录取通知书的时候。</p>
<p>我有时候就问他，想好去哪所大学了吗？有没有什么感兴趣的专业？</p>
<p>却不知为什么，每次问到这样的问题，他便一脸的不耐烦，一句都不愿意和我谈，后来我也就不再问了。</p>
<p>一个大长假的聚会是少不了的，在我参加完初中的同学聚会后，又参加了高中的同学聚会，接着是肖丛，去参加了他高考后的毕业宴。</p>
<p>他去参加毕业宴那晚我在家穿着睡衣吃着葡萄，坐在沙发上和我爸妈看黄金八点档。</p>
<p>接到电话的时候，一盘葡萄已经下半。</p>
<p>电话那头告诉我：姐，我是肖丛的室友，肖丛喝多了，你能不能过来接他。</p>
<p>我说你把地址短信给我，我马上过去。</p>
<p>我刚下车就看到酒店门口歪歪倒倒林立着的二十多号男孩女孩，有清醒的，有不清醒的，有清醒的扶着不清醒的，有不清醒的和不清醒的缠成一块的。</p>
<p>然后就看到肖丛背靠着酒店的墙，低着头，周围围着他的那几个因为当年受我滴水之恩就叫了我三年姐的室友。</p>
<p>我走过上下看了一眼肖丛，我说：这也没喝多呀，也没耍酒疯。</p>
<p>旁边的男孩说：姐你不知道，肖丛喝多了就这样，一句话也不说，站得很直溜，但是你让他走道，他肯定走不出直线。</p>
<p>我说：那好吧，我先把他带走了。</p>
<p>跟一帮小朋友告别之后，我扶着肖丛去路边打车，走了几步我才知道肖丛室友说的是真的。</p>
<p>你看他眼睛是睁着的，嘴里也是安静的，就是走路不走直线。再加上他那么高一个大个，我简直使出了吃奶的劲，最后我俩走出好几个不同字母，最没有难度的是S。</p>
<p>正是晚上九点多快十点的时间，路上的出租车少得可怜，我看着肖丛的眼睛马上就要合上了。</p>
<p>我停下来拍拍他的脸，我说：肖丛你别睡啊，你睡了我可抬不动你。</p>
<p>他睁开眼睛稍微有了些反应，我看他的样子竟有些想笑。</p>
<p>我调侃他：肖丛你抬头，你看天上的月亮多好看，又大又漂亮，你想不想要，你想要就不能睡。</p>
<p>他的眼睛清亮了好多，顺着我指尖向上看去，而后又顺着指尖看下来，目光停在我的脸上。</p>
<p>下一秒，他俯下身，捧起我的脸，在唇上蜻蜓点水的一个触碰，鼻息间是他放大的酒气。</p>
<p>然后他抬起头，看着我的眼睛说：想要。</p>
<p>很久以后，我听见有一个人跟我讲了一个故事，是猴子和月亮的故事。</p>
<p>就在前一晚，他和我说：何好，我18岁了。</p>
<p>我想起几天前初中同学聚会时，遇到董野，他也是喝醉了，不过他喝醉了并不沉默。</p>
<p>他喝醉了就爱提起从前，他和我说：何好，我初中那会喜欢你来着，我想和你在一起来着，可是后来肖丛找我，他说，何好不能和别人在一起。</p>
<p>我把肖丛抬回去的时候已经十一点多，肖奶奶在家等得着急，看到我俩进门终于放了心。</p>
<p>肖丛在房间里睡着后，肖奶奶把房间门关上，跟我说：好好，你过来，我跟你说点话。</p>
<p>我俩坐在沙发上，消耗着外面的深夜，看着墙上的指针。</p>
<p>她开口说：好好，肖丛爸妈想把他接到国外读大学去，我听说去国外读大学发展特别好，回来不论去哪都好找工作的。但是肖丛就是不愿意去，每次他妈打电话来他都倔得很。你是上了大学的，你肯定知道现在正时兴出国呢，你帮我劝劝肖丛。</p>
<p>我在消化着她的话，忽然想到我好几次问他要去哪个大学，他都不愿和我谈。原来是这个原因。</p>
<p>她接着说：我知道你俩感情好，从小玩到大的，说不定肖丛就是舍不得你呢。</p>
<p>一句话恰好击中了我的尴尬处。</p>
<p>这句若是放在今晚之前，我一定不会这样。</p>
<p>我急切地接过她的话，我说：奶奶，我肯定帮您劝他，我明天就和他说。</p>
<p>我知道我在心虚。</p>
<p>第二天我看到肖丛的状态，我就知道他喝断片了，对我性骚扰的事也忘得一干二净了，还指使我去给他倒水。</p>
<p>他在一边喝水，我一边背我准备了一晚上的腹稿，等我觉得时机差不多的时候，我说：肖丛，你爸妈想让你出国读书是吧，我觉得这件事非常好，很多大学生现在都想出国，挤破了脑袋也想争取做交换生。但是你看你都不用争取，你爸妈就能帮你争取，好多人都羡慕不来，而且你将来凭着一个海归的身份，找工作肯定不成问题，发展大大的好，所以你就别和你妈犟了，你就出国吧，反正也就是几年的时间，不长。</p>
<p>说这话的时候，我还没意识到往后会有成片成片的海归。</p>
<p>肖丛听我说完，放下水杯，问我：你是说你希望我出国？</p>
<p>我点头：希望。</p>
<p>他说：那你一年都不能见我一次了。</p>
<p>我说：没事，我更喜欢你变成小海龟再回来见我。</p>
<p>与此相似的对话，在那个暑假结束之前我们谈过很多次，但他的态度总是不明不白，我不知道他是答应还是不答应。</p>
<p>日子离我返校的时间越来越近，离他父母定好的出国日期越来越近。</p>
<p>我踏上火车返校的那天，肖丛死也不和我说一声再见。</p>
<p>后来我和杜飞在图书馆，中途我去了趟厕所，回来看见杜飞拿着我的手机对我晃，说有人给你打电话，是个男孩，我告诉他等你回来让你回他。</p>
<p>我接过手机，看了下，我说是我弟弟。</p>
<p>我回拨给肖丛，对方立马就接起来，我说：我刚才去厕所了，没接到。</p>
<p>他说：有人帮你接到了。</p>
<p>我说：嗯，有什么事？</p>
<p>他说：没事就不能给你打电话吗？我现在给你打电话都需要有事才行。</p>
<p>我说：肖丛你别小孩脾气。</p>
<p>他说：你总觉得我小孩，你就喜欢比你大的对吧。</p>
<p>我说：你现在就像个小孩。</p>
<p>几秒的寂静，他没有再和我吵，而是挂了电话。</p>
<p>杜飞笑着说：你弟弟挺凶的，我刚接起来喂了一声，他就直接问我是谁，好像要吃了我。</p>
<p>我说：你别在意，他不懂事。</p>
<p>后来肖奶奶给我打电话，她说：好好啊，谢谢你帮我劝肖丛，他真听话了，跟着她妈出国去了。</p>
<p>我说：嗯，不谢。</p>
<p>那天我在寝室捧着电脑看了一天韩剧，名字叫《对不起我爱你》，看着林秀晶和苏志燮那两张催泪的脸哭得稀里哗啦。</p>
<p>肖丛出国以后从来没有给我打过电话，室友说：好好，你和弟弟好久没通过电话了，我记得以前你俩总打电话的，感情特别好。</p>
<p>我说：他出国了，嫌跨洋电话费贵。</p>
<p>2008年冬天，我在晚上刚下了实验课，回寝室的时候，鞋面上全是一路带回来的，白色的还没来得及化开的雪。</p>
<p>就在那天晚上，我接到了一个陌生的号码。</p>
<p>我接起来：喂。</p>
<p>没有回应，我以为是诈骗电话，刚要挂掉，电话里便有了声音，只是短短的两个字：何好。</p>
<p>我的心跳停了一个拍子，突然就想哭。</p>
<p>我说：肖丛你简直没人性。</p>
<p>他没有回应我这句话。</p>
<p>他用无比平淡，没有任何感情起伏的声音说：何好，你想不想我。</p>
<p>没有等我的回应，他又问了一遍：想不想。</p>
<p>我说：想。</p>
<p>他说：嗯。</p>
<p>然后挂了电话。</p>
<p>只留我在这一边，一边气一边哭，我想肖丛你他妈真不是人，这么久才给我打电话，给我打电话就打了13秒，13秒就是为了证明我想你，然后什么也不说再把电话挂了，你他妈是多缺电话费。</p>
<p>记得第二天我醒来的时候已经是下午三点左右，两只眼睛的眼皮肿得像上下两个寿桃。</p>
<p>室友约会的约会，上课的上课，练车的练车，我饿得头晕眼花，最后实在受不了，终于从床上爬起来，穿着拖鞋披着羽绒服下楼去食堂。</p>
<p>刚出寝室楼，就在台阶下的雪地里看到一个高高瘦瘦的雪人，穿着黑底白杠的羽绒服，皮肤几乎冻得透明，身后是被白雪覆盖的花坛和几棵翠色和白色契合的覆了雪的松树。</p>
<p>他的表情有些冻僵了，每一个呼吸都是很快消失的雾气，他对着我笑，他说：何好，我回来了。</p>
<p>我不记得我在台阶上愣了多久，等到我回神的时候，我说：你在这等了多久，你怎么不给我打电话。</p>
<p>他有些委屈：你手机关机了。</p>
<p>我心里一阵抽搐的心疼，我说：你先在这等着，我上楼换个鞋。</p>
<p>我用最快的速度跑上楼换了里面的睡衣和脚下的拖鞋，拿着暖手宝下了楼。</p>
<p>我把暖手宝塞给肖丛让他抱着，然后带他去离学校最近的火锅店。</p>
<p>肖丛饿坏了，他几乎二十个小时没有吃饭没有睡觉。</p>
<p>我说：飞机上乘务小姐饿到你了吗？</p>
<p>他说：我那时候什么也吃不下。</p>
<p>我说：你回来你妈知道吗？</p>
<p>他说：我瞒着她回来的。</p>
<p>我问：那你今晚住哪？</p>
<p>他说：你陪我去看冰灯。</p>
<p>那晚我们去看了冰灯，那是一座童话冰城，色彩斑驳，子民繁盛，我和肖丛都是它小小的子民。</p>
<p>通往城堡的路要爬五个长长的阶梯，肖丛说要爬，我说不要爬。我俩就在城堡的下面吵。</p>
<p>他可能嫌我矮了，吵得累了，便把手搭在我的肩膀上继续和我吵。</p>
<p>等到我俩都停下来大眼瞪小眼的时候，一个棕色头发的外国女生走过来和我们打招呼，拿着手里的单反给我们看，画面里，是我和肖丛互相对视的样子。</p>
<p>若不是这个外国女生，我都没有意识到，肖丛的英语已经能说得这么好。</p>
<p>记得当初，他的英语我还曾帮着辅导。</p>
<p>那个女生是个驴友，经常拿着单反记录她走过的风景，她留下了自己的Facebook，说会上传到网上，争取我们的意见。</p>
<p>当然，我们没有意见。</p>
<p>看完冰灯，我们在附近宾馆订了房间。</p>
<p>小时候，我和肖丛常常在我家玩到很晚，然后一起倒在床上呼呼大睡。</p>
<p>睡梦中他踹过我的腰，我蹬过他的脸，可这一个晚上，我们都好像长大了懂事了，安安静静地将自己的身体摆成最正确笔直的姿态，听着对方在黑夜里莫名放大的呼吸声。</p>
<p>我睁着眼睛，看一片漆黑的天花板，我说：你明天就回去吧。</p>
<p>他嗯了一声。</p>
<p>我说：你怎么突然就回来了。</p>
<p>他说：因为你说你想我。</p>
<p>我说：我相信。</p>
<p>他说：那我能跟你告别吗。</p>
<p>我说：能。</p>
<p>然后另一半的床陷下去，他翻身抱住我，将我的头抵在他的胸腔，手掌覆在我的头顶。</p>
<p>我说：姐姐被你憋得喘不过气来了。</p>
<p>他说：我有分寸，憋不死你。</p>
<p>我们都不再说话，过了好久，我渐渐有了睡意，他在我头顶叫我，声音的震动顺着喉结传至胸腔，最后是我的耳膜。</p>
<p>他说：何好。</p>
<p>我：嗯。</p>
<p>他说：因为我想你。</p>
<p>从懂事到二十几岁的最好年华，我所有的平凡和浪漫，感动和伤心，眼泪和欢笑都是肖丛给的。他混合着琐碎的时光融到我的生命里，成为我生命的一部分。</p>
<p>此后，也再没有哪个人能像这个男孩一样，用一个13秒的电话证明想念，再用二十几个小时的不眠不休跨过大洋彼岸来见我。</p>
<p>第二天肖丛飞机刚刚起飞的一个多小时左右，我在从飞机场返回到学校的车上接到了肖丛母亲的电话。</p>
<p>她说：何好是吧。</p>
<p>我说：我是，阿姨。</p>
<p>她说：肖丛是不是回国找你去了。</p>
<p>我顿了下，实话实说：是，但是他现在已经上飞机回去了。</p>
<p>她说：我不知道你和他说什么了，让他大老远跑回去找你，但是我觉得你应该知道肖丛以后发展会很好，他聪明上进，我也会推波助澜地帮他，你懂吗？</p>
<p>我说：懂。</p>
<p>她说：我和他爸辛苦打拼大半辈子，为的就是他，也希望他将来能找个门当户对，而且能帮助他的女孩。而不是在他学业为重的时候把他从学校里拉出去约会的人，懂吗？</p>
<p>我说：阿姨，你误会了。</p>
<p>她说：你也别解释了，我听说了，你俩从小关系好，也难免出现感情，但那都是小时候的事了，以后成家立业了，再想想那就是小孩子玩家家酒。</p>
<p>我说：阿姨，你放心，我俩从来也就没在一起过，而且我现在有男朋友了，过得也挺好的，我也祝福你能给你儿子找个门当户对的大家闺秀，贤妻良母。阿姨，我还有事，就先不说了，再见。</p>
<p>我挂了电话，眼泪刷的流下来，在二十岁的青春里，我们没钱没阅历，穷得只剩自尊，所以为了维护那点自尊，我们可以抛弃所有。</p>
<p>在后视镜里，看到四十多岁的司机师傅一脸过来人的样子看着我。</p>
<p>他说：小姑娘，我年轻的时候有个女朋友，我特别喜欢她，她也特别喜欢我，但是她妈就不喜欢我，但是我不怕，我觉得喜欢就是两个人的事，我又不娶她妈。</p>
<p>我说：后来呢。</p>
<p>他说：分了。</p>
<p>我说：为啥。</p>
<p>他说：因为她妈。</p>
<p>我想到肖丛登机前，他突然转过身来问我，他说：何好，你能不能先不要和别人在一起？</p>
<p>我说：你管得还挺宽。</p>
<p>他瞪着我，生气了似的。</p>
<p>过了会，泄了气，很认真地问我：你能等我吗？</p>
<p>后来，我和肖丛只通两个电话。</p>
<p>电话里我说：肖丛，我有男朋友了。</p>
<p>他说：你再说一遍。</p>
<p>我说：我有男朋友了。</p>
<p>他说：何好，你骗我。</p>
<p>我说：我没骗你，他叫杜飞，我妈肯定跟你提过。</p>
<p>他说：我不信。</p>
<p>我说：他就在旁边呢，你要不要和他通个话。</p>
<p>他说：何好，我恨不得杀了你。</p>
<p>电话被他狠狠地挂断，杜飞在一旁普度众生地笑：看来我也没派上用场啊。</p>
<p>我说：派上了，我了解他，他不会和你通话的，你站在旁边就是给我壮士气的，谢谢学长。</p>
<p>第二次是在凌晨四点多，我正在睡觉，刺耳的电话铃声把我叫醒，我看到来电显示，已经清醒了大半。</p>
<p>我接起来，对方一直不说话，而是浓重不规律的呼吸声，我直觉他是喝醉了。</p>
<p>我说：肖丛。</p>
<p>他说：何好我想你。</p>
<p>我说：嗯，你在哪呢？</p>
<p>他说：我不敢想你和别人在一起。</p>
<p>我说：肖丛，你喝多了。</p>
<p>他说：何好，我看不见你，我在英国熬不下去。</p>
<p>那天的凌晨四点，天没有大亮，我拿着手机抽哽得一句话都无法说出来。</p>
<p>后来牙齿都有了麻意，我说：你安心读书。</p>
<p>他说：我可以努力比他成熟，我可以对你更好。</p>
<p>我说：肖丛，你一直是我弟弟。</p>
<p>好久，都没有回应，后来他说：何好，你怎么这么狠。</p>
<p>从那以后，肖丛就没有再打过电话。</p>
<p>所有人都以为肖丛喝醉之后不说话，其实他喝醉之后只说真话，只说最想说的话。</p>
<p>不论是他还是我，我们都以为从小在一起长大的人后半辈子也不会分开。</p>
<p>所以我们都不着急，吵架不着急，我们以为总有一天会和好。</p>
<p>分开不着急，以为总有一天会相聚。</p>
<p>喜欢也不着急，以为会一直这样，一辈子在一起。</p>
<p>等到我们吵架再也无法和好，分开再也不能相聚，我们突然知道来不及。</p>
<p>喜欢来不及。</p>
<p>在一起也来不及。</p>
<p>我的男孩，我陪着你长大，却不能陪着你到老。</p>
<p>大学毕业后，我成为一名杂志编辑。</p>
<p>大学同学和朋友合资开了一间婚纱店，要我帮忙当模特给她拍几组照片。</p>
<p>我说：我得有出场费吧。</p>
<p>同学说：一碗麻辣烫。</p>
<p>我说：我就值一碗麻辣烫。</p>
<p>她说：那我再给你找个新郎。</p>
<p>我说：这个出场费还行。</p>
<p>本是开玩笑的话，去了才知道，新娘是我，新郎是杜飞，我当下就明白是同学的有意撮合。</p>
<p>同学对我眨眼睛：怎么样，这新郎怎么样。</p>
<p>我说：你别闹，要在一起，我们早就在一起了。</p>
<p>那组婚纱照拍得很美，我看着电脑屏幕上的图片还真的很像一对新婚夫妇。</p>
<p>杜飞笑着说：现在就缺一个证了。</p>
<p>我看他，他拍拍我：你不当真，我就不会当真。</p>
<p>那组婚纱照后不久，董野约我出去喝茶，我笑他：搞什么文艺，还喝茶。</p>
<p>他说：你不懂，这是艺术。</p>
<p>我俩一边体会着艺术，一边东扯西扯的聊。</p>
<p>最后我终于明白，他绕了一个大弯，最主要的问题就是想问我：何好，你是不是要结婚了？</p>
<p>我说：你听谁说的。</p>
<p>他说：有的同学都看到你婚纱照了，然后传到网上，我们都看到了。</p>
<p>我说：那是我帮我同学做模特呢。</p>
<p>他说哦，然后犹豫着开口：肖丛还问过我，你是不是结婚了。</p>
<p>我的心提了一下，然后说：你就说我结婚了。</p>
<p>13年年尾，我回家过春节。</p>
<p>爸妈在厨房包饺子，我以前从没发觉，爸妈都已早早有了白头发。</p>
<p>我妈一边擀饺子皮一边唏嘘：我记得你和肖丛小时候，过春节就是两家一起过，你肖奶奶做的饺子馅特别好吃。</p>
<p>肖奶奶在肖丛出国后的一年也搬去了儿女那，对门住进了新的一家，年轻的父母，七八岁的小女儿。</p>
<p>小女儿经常跑过来让我给她编辫子，涂口红。</p>
<p>物是人非。</p>
<p>我妈说：好好，你肖奶奶说肖丛有女朋友了，也是留学英国的，家境好，长得也漂亮，说六月份左右就准备结婚，真好，肖丛都长大了。</p>
<p>那个新年，我在一片喧嚣热闹的炮竹声中清晰地意识到，他再也不是我的。</p>
<p>从此肖丛是肖丛，何好是何好。</p>
<p>何好和肖丛是泛旧老照片里的，是从前故事里的。</p>
<p>从一月到六月，日子从来没有如此快过。</p>
<p>肖丛结婚的那天，我和萍子坐在鱼锅店里，肚子里装的全是酒水，我们喝走了店里所有的客人，喝到夜深人静，我趴在桌子上一直哭一直哭，萍子就陪着我哭。</p>
<p>我没告诉她，肖丛在这半年里联系过我，他说：何好，你只要像当年一样，说一句想我，我就不要国外的一切回去找你。</p>
<p>我脱口欲出的话已经到了嘴边，我想说我想你，很想你，二十多年来，这一次最想你。</p>
<p>可我一定不能说，咬紧牙关的不能说。</p>
<p>我也没告诉她，就在前一晚，我收到一封没有署名的邮件。</p>
<p>邮件里说：</p>
<p>小时候，猴子想要月亮，也知道月亮不在水里在天上，所以猴子想做齐天大圣，有一朵一个跟头十万八千里的筋斗云乘着他去摘月亮。可后来才知道，猴子有很多，齐天大圣却只有一个。</p>
<p>猴子想和月亮说对不起，因为他没有成为她的齐天大圣。</p>
]]></content>
      <categories>
        <category>阅读</category>
      </categories>
      <tags>
        <tag>阅读</tag>
        <tag>文章</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机网络</title>
    <url>/2022/08/22/network/</url>
    <content><![CDATA[<h2 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a>计算机网络</h2><span id="more"></span>
<p><img  src="/images/image/network.png"  ><span class="image-caption">计算机网络面试题.png</span></p>
<h2 id="一、HTTP协议"><a href="#一、HTTP协议" class="headerlink" title="一、HTTP协议"></a>一、HTTP协议</h2><h3 id="1-GET和POST的请求的区别"><a href="#1-GET和POST的请求的区别" class="headerlink" title="1. GET和POST的请求的区别"></a>1. GET和POST的请求的区别</h3><p>Post 和 Get 是 HTTP 请求的两种方法，其区别如下：</p>
<ul>
<li><strong>应用场景：</strong>GET 请求是一个幂等的请求，一般 Get 请求用于对服务器资源不会产生影响的场景，比如说请求一个网页的资源。而 Post 不是一个幂等的请求，一般用于对服务器资源会产生影响的情景，比如注册用户这一类的操作。</li>
<li><strong>是否缓存：</strong>因为两者应用场景不同，浏览器一般会对 Get 请求缓存，但很少对 Post 请求缓存。</li>
<li><strong>发送的报文格式：</strong>Get 请求的报文中实体部分为空，Post 请求的报文中实体部分一般为向服务器发送的数据。</li>
<li><strong>安全性：</strong>Get 请求可以将请求的参数放入 url 中向服务器发送，这样的做法相对于 Post 请求来说是不太安全的，因为请求的 url 会被保留在历史记录中。</li>
<li><strong>请求长度：</strong>浏览器由于对 url 长度的限制，所以会影响 get 请求发送数据时的长度。这个限制是浏览器规定的，并不是 RFC 规定的。</li>
<li><strong>参数类型：</strong>post 的参数传递支持更多的数据类型。</li>
</ul>
<h3 id="2-POST和PUT请求的区别"><a href="#2-POST和PUT请求的区别" class="headerlink" title="2. POST和PUT请求的区别"></a>2. POST和PUT请求的区别</h3><ul>
<li>PUT请求是向服务器端发送数据，从而修改数据的内容，但是不会增加数据的种类等，也就是说无论进行多少次PUT操作，其结果并没有不同。（可以理解为时<strong>更新数据</strong>）</li>
<li>POST请求是向服务器端发送数据，该请求会改变数据的种类等资源，它会创建新的内容。（可以理解为是<strong>创建数据</strong>）</li>
</ul>
<h3 id="3-常见的HTTP请求头和响应头"><a href="#3-常见的HTTP请求头和响应头" class="headerlink" title="3. 常见的HTTP请求头和响应头"></a>3. 常见的HTTP请求头和响应头</h3><p><strong>HTTP Request Header 常见的请求头：</strong></p>
<ul>
<li>Accept:浏览器能够处理的内容类型</li>
<li>Accept-Charset:浏览器能够显示的字符集</li>
<li>Accept-Encoding：浏览器能够处理的压缩编码</li>
<li>Accept-Language：浏览器当前设置的语言</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cookie：当前页面设置的任何Cookie</li>
<li>Host：发出请求的页面所在的域</li>
<li>Referer：发出请求的页面的URL</li>
<li>User-Agent：浏览器的用户代理字符串</li>
</ul>
<p><strong>HTTP Responses Header 常见的响应头：</strong></p>
<ul>
<li>Date：表示消息发送的时间，时间的描述格式由rfc822定义</li>
<li>server:服务器名称</li>
<li>Connection：浏览器与服务器之间连接的类型</li>
<li>Cache-Control：控制HTTP缓存</li>
<li>content-type:表示后面的文档属于什么MIME类型</li>
</ul>
<p>常见的 Content-Type 属性值有以下四种：</p>
<p>（1）application&#x2F;x-www-form-urlencoded：浏览器的原生 form 表单，如果不设置 enctype 属性，那么最终就会以 application&#x2F;x-www-form-urlencoded 方式提交数据。该种方式提交的数据放在 body 里面，数据按照 key1&#x3D;val1&amp;key2&#x3D;val2 的方式进行编码，key 和 val 都进行了 URL转码。</p>
<p>（2）multipart&#x2F;form-data：该种方式也是一个常见的 POST 提交方式，通常表单上传文件时使用该种方式。</p>
<p>（3）application&#x2F;json：服务器消息主体是序列化后的 JSON 字符串。</p>
<p>（4）text&#x2F;xml：该种方式主要用来提交 XML 格式的数据。</p>
<h3 id="4-HTTP状态码304是多好还是少好"><a href="#4-HTTP状态码304是多好还是少好" class="headerlink" title="4. HTTP状态码304是多好还是少好"></a>4. HTTP状态码304是多好还是少好</h3><p>服务器为了提高网站访问速度，对之前访问的部分页面指定缓存机制，当客户端在此对这些页面进行请求，服务器会根据缓存内容判断页面与之前是否相同，若相同便直接返回304，此时客户端调用缓存内容，不必进行二次下载。</p>
<p>状态码304不应该认为是一种错误，而是对客户端<strong>有缓存情况下</strong>服务端的一种响应。</p>
<p>搜索引擎蜘蛛会更加青睐内容源更新频繁的网站。通过特定时间内对网站抓取返回的状态码来调节对该网站的抓取频次。若网站在一定时间内一直处于304的状态，那么蜘蛛可能会降低对网站的抓取次数。相反，若网站变化的频率非常之快，每次抓取都能获取新内容，那么日积月累，的回访率也会提高。</p>
<p><strong>产生较多304状态码的原因：</strong></p>
<ul>
<li>页面更新周期长或不更新</li>
<li>纯静态页面或强制生成静态html</li>
</ul>
<p><strong>304状态码出现过多会造成以下问题：</strong></p>
<ul>
<li>网站快照停止；</li>
<li>收录减少；</li>
<li>权重下降。</li>
</ul>
<h3 id="5-常见的HTTP请求方法"><a href="#5-常见的HTTP请求方法" class="headerlink" title="5. 常见的HTTP请求方法"></a>5. 常见的HTTP请求方法</h3><ul>
<li>GET: 向服务器获取数据；</li>
<li>POST：将实体提交到指定的资源，通常会造成服务器资源的修改；</li>
<li>PUT：上传文件，更新数据；</li>
<li>DELETE：删除服务器上的对象；</li>
<li>HEAD：获取报文首部，与GET相比，不返回报文主体部分；</li>
<li>OPTIONS：询问支持的请求方法，用来跨域请求；</li>
<li>CONNECT：要求在与代理服务器通信时建立隧道，使用隧道进行TCP通信；</li>
<li>TRACE: 回显服务器收到的请求，主要⽤于测试或诊断。</li>
</ul>
<h3 id="6-OPTIONS请求方法及使用场景"><a href="#6-OPTIONS请求方法及使用场景" class="headerlink" title="6. OPTIONS请求方法及使用场景"></a>6. OPTIONS请求方法及使用场景</h3><p>OPTIONS是除了GET和POST之外的其中一种 HTTP请求方法。</p>
<p>OPTIONS方法是用于请求获得由<code>Request-URI</code>标识的资源在请求&#x2F;响应的通信过程中可以使用的功能选项。通过这个方法，客户端可以<strong>在采取具体资源请求之前，决定对该资源采取何种必要措施，或者了解服务器的性能</strong>。该请求方法的响应不能缓存。</p>
<p>OPTIONS请求方法的<strong>主要用途</strong>有两个：</p>
<ul>
<li>获取服务器支持的所有HTTP请求方法；</li>
<li>用来检查访问权限。例如：在进行 CORS 跨域资源共享时，对于复杂请求，就是使用 OPTIONS 方法发送嗅探请求，以判断是否有对指定资源的访问权限。</li>
</ul>
<h3 id="7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？"><a href="#7-HTTP-1-0-和-HTTP-1-1-之间有哪些区别？" class="headerlink" title="7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？"></a>7. HTTP 1.0 和 HTTP 1.1 之间有哪些区别？</h3><p><strong>HTTP 1.0和 HTTP 1.1</strong> <strong>有以下区别</strong>：</p>
<ul>
<li><strong>连接方面</strong>，http1.0 默认使用非持久连接，而 http1.1 默认使用持久连接。http1.1 通过使用持久连接来使多个 http 请求复用同一个 TCP 连接，以此来避免使用非持久连接时每次需要建立连接的时延。</li>
<li><strong>资源请求方面</strong>，在 http1.0 中，存在一些浪费带宽的现象，例如客户端只是需要某个对象的一部分，而服务器却将整个对象送过来了，并且不支持断点续传功能，http1.1 则在请求头引入了 range 头域，它允许只请求资源的某个部分，即返回码是 206（Partial Content），这样就方便了开发者自由的选择以便于充分利用带宽和连接。</li>
<li><strong>缓存方面</strong>，在 http1.0 中主要使用 header 里的 If-Modified-Since、Expires 来做为缓存判断的标准，http1.1 则引入了更多的缓存控制策略，例如 Etag、If-Unmodified-Since、If-Match、If-None-Match 等更多可供选择的缓存头来控制缓存策略。</li>
<li>http1.1 中<strong>新增了 host 字段</strong>，用来指定服务器的域名。http1.0 中认为每台服务器都绑定一个唯一的 IP 地址，因此，请求消息中的 URL 并没有传递主机名（hostname）。但随着虚拟主机技术的发展，在一台物理服务器上可以存在多个虚拟主机，并且它们共享一个IP地址。因此有了 host 字段，这样就可以将请求发往到同一台服务器上的不同网站。</li>
<li>http1.1 相对于 http1.0 还新增了很多<strong>请求方法</strong>，如 PUT、HEAD、OPTIONS 等。</li>
</ul>
<h3 id="8-HTTP-1-1-和-HTTP-2-0-的区别"><a href="#8-HTTP-1-1-和-HTTP-2-0-的区别" class="headerlink" title="8. HTTP 1.1 和 HTTP 2.0 的区别"></a>8. HTTP 1.1 和 HTTP 2.0 的区别</h3><ul>
<li><strong>二进制协议</strong>：HTTP&#x2F;2 是一个二进制协议。在 HTTP&#x2F;1.1 版中，报文的头信息必须是文本（ASCII 编码），数据体可以是文本，也可以是二进制。HTTP&#x2F;2 则是一个彻底的二进制协议，头信息和数据体都是二进制，并且统称为”帧”，可以分为头信息帧和数据帧。 帧的概念是它实现多路复用的基础。</li>
<li><strong>多路复用：</strong>HTTP&#x2F;2 实现了多路复用，HTTP&#x2F;2 仍然复用 TCP 连接，但是在一个连接里，客户端和服务器都可以同时发送多个请求或回应，而且不用按照顺序一一发送，这样就避免了”队头堵塞”【1】的问题。</li>
<li><strong>数据流：</strong>HTTP&#x2F;2 使用了数据流的概念，因为 HTTP&#x2F;2 的数据包是不按顺序发送的，同一个连接里面连续的数据包，可能属于不同的请求。因此，必须要对数据包做标记，指出它属于哪个请求。HTTP&#x2F;2 将每个请求或回应的所有数据包，称为一个数据流。每个数据流都有一个独一无二的编号。数据包发送时，都必须标记数据流 ID ，用来区分它属于哪个数据流。</li>
<li><strong>头信息压缩：</strong>HTTP&#x2F;2 实现了头信息压缩，由于 HTTP 1.1 协议不带状态，每次请求都必须附上所有信息。所以，请求的很多字段都是重复的，比如 Cookie 和 User Agent ，一模一样的内容，每次请求都必须附带，这会浪费很多带宽，也影响速度。HTTP&#x2F;2 对这一点做了优化，引入了头信息压缩机制。一方面，头信息使用 gzip 或 compress 压缩后再发送；另一方面，客户端和服务器同时维护一张头信息表，所有字段都会存入这个表，生成一个索引号，以后就不发送同样字段了，只发送索引号，这样就能提高速度了。</li>
<li><strong>服务器推送：</strong>HTTP&#x2F;2 允许服务器未经请求，主动向客户端发送资源，这叫做服务器推送。使用服务器推送提前给客户端推送必要的资源，这样就可以相对减少一些延迟时间。这里需要注意的是 http2 下服务器主动推送的是静态资源，和 WebSocket 以及使用 SSE 等方式向客户端发送即时数据的推送是不同的。</li>
</ul>
<p><strong>【1】队头堵塞：</strong></p>
<blockquote>
<p>队头阻塞是由 HTTP 基本的“请求 - 应答”模型所导致的。HTTP 规定报文必须是“一发一收”，这就形成了一个先进先出的“串行”队列。队列里的请求是没有优先级的，只有入队的先后顺序，排在最前面的请求会被最优先处理。如果队首的请求因为处理的太慢耽误了时间，那么队列里后面的所有请求也不得不跟着一起等待，结果就是其他的请求承担了不应有的时间成本，造成了队头堵塞的现象。</p>
</blockquote>
<h3 id="9-HTTP和HTTPS协议的区别"><a href="#9-HTTP和HTTPS协议的区别" class="headerlink" title="9. HTTP和HTTPS协议的区别"></a>9. HTTP和HTTPS协议的区别</h3><p>HTTP和HTTPS协议的主要区别如下：</p>
<ul>
<li>HTTPS协议需要CA证书，费用较高；而HTTP协议不需要；</li>
<li>HTTP协议是超文本传输协议，信息是明文传输的，HTTPS则是具有安全性的SSL加密传输协议；</li>
<li>使用不同的连接方式，端口也不同，HTTP协议端口是80，HTTPS协议端口是443；</li>
<li>HTTP协议连接很简单，是无状态的；HTTPS协议是有SSL和HTTP协议构建的可进行加密传输、身份认证的网络协议，比HTTP更加安全。</li>
</ul>
<h3 id="10-GET方法URL长度限制的原因"><a href="#10-GET方法URL长度限制的原因" class="headerlink" title="10. GET方法URL长度限制的原因"></a>10. GET方法URL长度限制的原因</h3><p>实际上HTTP协议规范并没有对get方法请求的url长度进行限制，这个限制是特定的浏览器及服务器对它的限制。</p>
<p>IE对URL长度的限制是2083字节(2K+35)。由于IE浏览器对URL长度的允许值是最小的，所以开发过程中，只要URL不超过2083字节，那么在所有浏览器中工作都不会有问题。</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">GET</span>的长度值 = URL（<span class="hljs-number">2083</span>）- （你的<span class="hljs-keyword">Domain</span>+<span class="hljs-type">Path</span>）<span class="hljs-number">-2</span>（<span class="hljs-number">2</span>是<span class="hljs-keyword">get</span>请求中?=两个字符的长度）<br></code></pre></td></tr></table></figure>

<p>下面看一下主流浏览器对get方法中url的长度限制范围：</p>
<ul>
<li>Microsoft Internet Explorer (Browser)：IE浏览器对URL的最大限制为2083个字符，如果超过这个数字，提交按钮没有任何反应。</li>
<li>Firefox (Browser)：对于Firefox浏览器URL的长度限制为 65,536 个字符。</li>
<li>Safari (Browser)：URL最大长度限制为 80,000 个字符。</li>
<li>Opera (Browser)：URL最大长度限制为 190,000 个字符。</li>
<li>Google (chrome)：URL最大长度限制为 8182 个字符。</li>
</ul>
<p>主流的服务器对get方法中url的长度限制范围：</p>
<ul>
<li>Apache (Server)：能接受最大url长度为8192个字符。</li>
<li>Microsoft Internet Information Server(IIS)：能接受最大url的长度为16384个字符。</li>
</ul>
<p>根据上面的数据，可以知道，get方法中的URL长度最长不超过2083个字符，这样所有的浏览器和服务器都可能正常工作。</p>
<h3 id="11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？"><a href="#11-当在浏览器中输入-Google-com-并且按下回车之后发生了什么？" class="headerlink" title="11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？"></a>11. 当在浏览器中输入 Google.com 并且按下回车之后发生了什么？</h3><p>（1）<strong>解析URL：</strong>首先会对 URL 进行解析，分析所需要使用的传输协议和请求的资源的路径。如果输入的 URL 中的协议或者主机名不合法，将会把地址栏中输入的内容传递给搜索引擎。如果没有问题，浏览器会检查 URL 中是否出现了非法字符，如果存在非法字符，则对非法字符进行转义后再进行下一过程。</p>
<p>（2）<strong>缓存判断：</strong>浏览器会判断所请求的资源是否在缓存里，如果请求的资源在缓存里并且没有失效，那么就直接使用，否则向服务器发起新的请求。</p>
<p>（3）<strong>DNS解析：</strong>下一步首先需要获取的是输入的 URL 中的域名的 IP 地址，首先会判断本地是否有该域名的 IP 地址的缓存，如果有则使用，如果没有则向本地 DNS 服务器发起请求。本地 DNS 服务器也会先检查是否存在缓存，如果没有就会先向根域名服务器发起请求，获得负责的顶级域名服务器的地址后，再向顶级域名服务器请求，然后获得负责的权威域名服务器的地址后，再向权威域名服务器发起请求，最终获得域名的 IP 地址后，本地 DNS 服务器再将这个 IP 地址返回给请求的用户。用户向本地 DNS 服务器发起请求属于递归请求，本地 DNS 服务器向各级域名服务器发起请求属于迭代请求。</p>
<p>（4）<strong>获取MAC地址：</strong>当浏览器得到 IP 地址后，数据传输还需要知道目的主机 MAC 地址，因为应用层下发数据给传输层，TCP 协议会指定源端口号和目的端口号，然后下发给网络层。网络层会将本机地址作为源地址，获取的 IP 地址作为目的地址。然后将下发给数据链路层，数据链路层的发送需要加入通信双方的 MAC 地址，本机的 MAC 地址作为源 MAC 地址，目的 MAC 地址需要分情况处理。通过将 IP 地址与本机的子网掩码相与，可以判断是否与请求主机在同一个子网里，如果在同一个子网里，可以使用 APR 协议获取到目的主机的 MAC 地址，如果不在一个子网里，那么请求应该转发给网关，由它代为转发，此时同样可以通过 ARP 协议来获取网关的 MAC 地址，此时目的主机的 MAC 地址应该为网关的地址。</p>
<p>（5）<strong>TCP三次握手：</strong>下面是 TCP 建立连接的三次握手的过程，首先客户端向服务器发送一个 SYN 连接请求报文段和一个随机序号，服务端接收到请求后向服务器端发送一个 SYN ACK报文段，确认连接请求，并且也向客户端发送一个随机序号。客户端接收服务器的确认应答后，进入连接建立的状态，同时向服务器也发送一个ACK 确认报文段，服务器端接收到确认后，也进入连接建立状态，此时双方的连接就建立起来了。</p>
<p>（6）<strong>HTTPS握手：</strong>如果使用的是 HTTPS 协议，在通信前还存在 TLS 的一个四次握手的过程。首先由客户端向服务器端发送使用的协议的版本号、一个随机数和可以使用的加密方法。服务器端收到后，确认加密的方法，也向客户端发送一个随机数和自己的数字证书。客户端收到后，首先检查数字证书是否有效，如果有效，则再生成一个随机数，并使用证书中的公钥对随机数加密，然后发送给服务器端，并且还会提供一个前面所有内容的 hash 值供服务器端检验。服务器端接收后，使用自己的私钥对数据解密，同时向客户端发送一个前面所有内容的 hash 值供客户端检验。这个时候双方都有了三个随机数，按照之前所约定的加密方法，使用这三个随机数生成一把秘钥，以后双方通信前，就使用这个秘钥对数据进行加密后再传输。</p>
<p>（7）<strong>返回数据：</strong>当页面请求发送到服务器端后，服务器端会返回一个 html 文件作为响应，浏览器接收到响应后，开始对 html 文件进行解析，开始页面的渲染过程。</p>
<p>（8）<strong>页面渲染：</strong>浏览器首先会根据 html 文件构建 DOM 树，根据解析到的 css 文件构建 CSSOM 树，如果遇到 script 标签，则判端是否含有 defer 或者 async 属性，要不然 script 的加载和执行会造成页面的渲染的阻塞。当 DOM 树和 CSSOM 树建立好后，根据它们来构建渲染树。渲染树构建好后，会根据渲染树来进行布局。布局完成后，最后使用浏览器的 UI 接口对页面进行绘制。这个时候整个页面就显示出来了。</p>
<p>（9）<strong>TCP四次挥手：</strong>最后一步是 TCP 断开连接的四次挥手过程。若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</p>
<h3 id="12-对keep-alive的理解"><a href="#12-对keep-alive的理解" class="headerlink" title="12. 对keep-alive的理解"></a>12. 对keep-alive的理解</h3><p>HTTP1.0 中默认是在每次请求&#x2F;应答，客户端和服务器都要新建一个连接，完成之后立即断开连接，这就是<strong>短连接</strong>。当使用Keep-Alive模式时，Keep-Alive功能使客户端到服务器端的连接持续有效，当出现对服务器的后继请求时，Keep-Alive功能避免了建立或者重新建立连接，这就是<strong>长连接</strong>。其使用方法如下：</p>
<ul>
<li>HTTP1.0版本是默认没有Keep-alive的（也就是默认会发送keep-alive），所以要想连接得到保持，必须手动配置发送<code>Connection: keep-alive</code>字段。若想断开keep-alive连接，需发送<code>Connection:close</code>字段；</li>
<li>HTTP1.1规定了默认保持长连接，数据传输完成了保持TCP连接不断开，等待在同域名下继续用这个通道传输数据。如果需要关闭，需要客户端发送<code>Connection：close</code>首部字段。</li>
</ul>
<p>Keep-Alive的<strong>建立过程</strong>：</p>
<ul>
<li>客户端向服务器在发送请求报文同时在首部添加发送Connection字段</li>
<li>服务器收到请求并处理 Connection字段</li>
<li>服务器回送Connection:Keep-Alive字段给客户端</li>
<li>客户端接收到Connection字段</li>
<li>Keep-Alive连接建立成功</li>
</ul>
<p><strong>服务端自动断开过程（也就是没有keep-alive）</strong>：</p>
<ul>
<li>客户端向服务器只是发送内容报文（不包含Connection字段）</li>
<li>服务器收到请求并处理</li>
<li>服务器返回客户端请求的资源并关闭连接</li>
<li>客户端接收资源，发现没有Connection字段，断开连接</li>
</ul>
<p><strong>客户端请求断开连接过程</strong>：</p>
<ul>
<li>客户端向服务器发送Connection:close字段</li>
<li>服务器收到请求并处理connection字段</li>
<li>服务器回送响应资源并断开连接</li>
<li>客户端接收资源并断开连接</li>
</ul>
<p>开启Keep-Alive的<strong>优点：</strong></p>
<ul>
<li>较少的CPU和内存的使⽤（由于同时打开的连接的减少了）；</li>
<li>允许请求和应答的HTTP管线化； </li>
<li>降低拥塞控制 （TCP连接减少了）； </li>
<li>减少了后续请求的延迟（⽆需再进⾏握⼿）； </li>
<li>报告错误⽆需关闭TCP连；</li>
</ul>
<p>开启Keep-Alive的<strong>缺点</strong>：</p>
<ul>
<li>长时间的Tcp连接容易导致系统资源无效占用，浪费系统资源。</li>
</ul>
<h3 id="13-页面有多张图片，HTTP是怎样的加载表现？"><a href="#13-页面有多张图片，HTTP是怎样的加载表现？" class="headerlink" title="13. 页面有多张图片，HTTP是怎样的加载表现？"></a>13. 页面有多张图片，HTTP是怎样的加载表现？</h3><ul>
<li>在<code>HTTP 1</code>下，浏览器对一个域名下最大TCP连接数为6，所以会请求多次。可以用<strong>多域名部署</strong>解决。这样可以提高同时请求的数目，加快页面图片的获取速度。</li>
<li>在<code>HTTP 2</code>下，可以一瞬间加载出来很多资源，因为，HTTP2支持多路复用，可以在一个TCP连接中发送多个HTTP请求。</li>
</ul>
<h3 id="14-HTTP2的头部压缩算法是怎样的？"><a href="#14-HTTP2的头部压缩算法是怎样的？" class="headerlink" title="14. HTTP2的头部压缩算法是怎样的？"></a>14. HTTP2的头部压缩算法是怎样的？</h3><p>HTTP2的头部压缩是HPACK算法。在客户端和服务器两端建立“字典”，用索引号表示重复的字符串，采用哈夫曼编码来压缩整数和字符串，可以达到50%~90%的高压缩率。</p>
<p>具体来说:</p>
<ul>
<li>在客户端和服务器端使用“首部表”来跟踪和存储之前发送的键值对，对于相同的数据，不再通过每次请求和响应发送；</li>
<li>首部表在HTTP&#x2F;2的连接存续期内始终存在，由客户端和服务器共同渐进地更新；</li>
<li>每个新的首部键值对要么被追加到当前表的末尾，要么替换表中之前的值。</li>
</ul>
<p>例如下图中的两个请求， 请求一发送了所有的头部字段，第二个请求则只需要发送差异数据，这样可以减少冗余数据，降低开销。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604070508591-32d79893-7e98-40c8-b779-ffb6da42cd1b.png"  ><span class="image-caption">image</span></p>
<h3 id="15-HTTP请求报文的是什么样的？"><a href="#15-HTTP请求报文的是什么样的？" class="headerlink" title="15. HTTP请求报文的是什么样的？"></a>15. HTTP请求报文的是什么样的？</h3><p>请求报⽂有4部分组成: </p>
<ul>
<li>请求⾏ </li>
<li>请求头部 </li>
<li>空⾏</li>
<li>请求体</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907508156-a82d09e4-00bf-4dc7-a3a3-1ae75481754e.png"  ><span class="image-caption">image.png</span></p>
<p><strong>其中：</strong></p>
<p>（1）请求⾏包括：请求⽅法字段、URL字段、HTTP协议版本字段。它们⽤空格分隔。例如，GET &#x2F;index.html HTTP&#x2F;1.1。 </p>
<p>（2）请求头部:请求头部由关键字&#x2F;值对组成，每⾏⼀对，关键字和值⽤英⽂冒号“:”分隔  </p>
<ul>
<li>User-Agent：产⽣请求的浏览器类型。 </li>
<li>Accept：客户端可识别的内容类型列表。 </li>
<li>Host：请求的主机名，允许多个域名同处⼀个IP地址，即虚拟主机。</li>
</ul>
<p>（3）请求体: post put等请求携带的数据 </p>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907573585-6651540d-9dee-4b33-a97f-dee1b31f231c.png"  ><span class="image-caption">image.png</span></p>
<h3 id="16-HTTP响应报文的是什么样的？"><a href="#16-HTTP响应报文的是什么样的？" class="headerlink" title="16. HTTP响应报文的是什么样的？"></a>16. HTTP响应报文的是什么样的？</h3><p>请求报⽂有4部分组成: </p>
<ul>
<li>响应⾏ </li>
<li>响应头 </li>
<li>空⾏</li>
<li>响应体</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2021/png/1500604/1615907658281-b3a51c98-db27-45be-9b0c-fb2c7665b015.png"  ><span class="image-caption">image.png</span></p>
<ul>
<li>响应⾏：由网络协议版本，状态码和状态码的原因短语组成，例如 HTTP&#x2F;1.1 200 OK 。 </li>
<li>响应头：响应部⾸组成 </li>
<li>响应体：服务器响应的数据</li>
</ul>
<h3 id="17-HTTP协议的优点和缺点"><a href="#17-HTTP协议的优点和缺点" class="headerlink" title="17. HTTP协议的优点和缺点"></a>17. HTTP协议的优点和缺点</h3><p>HTTP 是超文本传输协议，它定义了客户端和服务器之间交换报文的格式和方式，默认使用 80 端口。它使用 TCP 作为传输层协议，保证了数据传输的可靠性。</p>
<p>HTTP协议具有以下<strong>优点</strong>：</p>
<ul>
<li>支持客户端&#x2F;服务器模式</li>
<li><strong>简单快速</strong>：客户向服务器请求服务时，只需传送请求方法和路径。由于 HTTP 协议简单，使得 HTTP 服务器的程序规模小，因而通信速度很快。</li>
<li><strong>无连接</strong>：无连接就是限制每次连接只处理一个请求。服务器处理完客户的请求，并收到客户的应答后，即断开连接，采用这种方式可以节省传输时间。</li>
<li><strong>无状态</strong>：HTTP 协议是无状态协议，这里的状态是指通信过程的上下文信息。缺少状态意味着如果后续处理需要前面的信息，则它必须重传，这样可能会导致每次连接传送的数据量增大。另一方面，在服务器不需要先前信息时它的应答就比较快。</li>
<li><strong>灵活</strong>：HTTP 允许传输任意类型的数据对象。正在传输的类型由 Content-Type 加以标记。</li>
</ul>
<p>HTTP协议具有以下<strong>缺点</strong>：</p>
<ul>
<li><strong>无状态：</strong>HTTP 是一个无状态的协议，HTTP 服务器不会保存关于客户的任何信息。</li>
<li><strong>明文传输：</strong>协议中的报文使用的是文本形式，这就直接暴露给外界，不安全。</li>
<li><strong>不安全</strong></li>
</ul>
<p>（1）通信使用明文（不加密），内容可能会被窃听；</p>
<p>（2）不验证通信方的身份，因此有可能遭遇伪装；</p>
<p>（3）无法证明报文的完整性，所以有可能已遭篡改；</p>
<h3 id="18-说一下HTTP-3-0"><a href="#18-说一下HTTP-3-0" class="headerlink" title="18. 说一下HTTP 3.0"></a>18. 说一下HTTP 3.0</h3><p>HTTP&#x2F;3基于UDP协议实现了类似于TCP的多路复用数据流、传输可靠性等功能，这套功能被称为QUIC协议。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-9b0f553d-3c6e-43a3-8185-8565f9fa1fb4.webp"  ><span class="image-caption">image</span></p>
<ol>
<li>流量控制、传输可靠性功能：QUIC在UDP的基础上增加了一层来保证数据传输可靠性，它提供了数据包重传、拥塞控制、以及其他一些TCP中的特性。</li>
<li>集成TLS加密功能：目前QUIC使用TLS1.3，减少了握手所花费的RTT数。</li>
<li>多路复用：同一物理连接上可以有多个独立的逻辑数据流，实现了数据流的单独传输，解决了TCP的队头阻塞问题。</li>
</ol>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604068246276-5d0a5de2-00db-425e-8b21-0cc4bbb54b24.webp"  ><span class="image-caption">image</span></p>
<ol>
<li>快速握手：由于基于UDP，可以实现使用0 ~ 1个RTT来建立连接。</li>
</ol>
<h3 id="19-HTTP协议的性能怎么样"><a href="#19-HTTP协议的性能怎么样" class="headerlink" title="19. HTTP协议的性能怎么样"></a>19. HTTP协议的性能怎么样</h3><p>HTTP 协议是基于 TCP&#x2F;IP，并且使用了<strong>请求-应答</strong>的通信模式，所以性能的关键就在这两点里。</p>
<ul>
<li><strong>长连接</strong></li>
</ul>
<p>HTTP协议有两种连接模式，一种是持续连接，一种非持续连接。</p>
<p>（1）非持续连接指的是服务器必须为每一个请求的对象建立和维护一个全新的连接。</p>
<p>（2）持续连接下，TCP 连接默认不关闭，可以被多个请求复用。采用持续连接的好处是可以避免每次建立 TCP 连接三次握手时所花费的时间。</p>
<p>对于不同版本的采用不同的连接方式：</p>
<ul>
<li>在HTTP&#x2F;1.0 每发起一个请求，都要新建一次 TCP 连接（三次握手），而且是串行请求，做了无畏的 TCP 连接建立和断开，增加了通信开销。该版本使用的非持续的连接，但是可以在请求时，加上 Connection: keep-a live 来要求服务器不要关闭 TCP 连接。</li>
<li>在HTTP&#x2F;1.1 提出了<strong>长连接</strong>的通信方式，也叫持久连接。这种方式的好处在于减少了 TCP 连接的重复建立和断开所造成的额外开销，减轻了服务器端的负载。该版本及以后版本默认采用的是持续的连接。目前对于同一个域，大多数浏览器支持同时建立 6 个持久连接。</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604065902281-b98a486c-5442-4d0b-b58d-00aab296ce1a.png"  ><span class="image-caption">image</span></p>
<ul>
<li><strong>管道网络传输</strong></li>
</ul>
<p>HTTP&#x2F;1.1 采用了长连接的方式，这使得管道（pipeline）网络传输成为了可能。</p>
<p>管道（pipeline）网络传输是指：可以在同一个 TCP 连接里面，客户端可以发起多个请求，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，可以减少整体的响应时间。但是服务器还是按照顺序回应请求。如果前面的回应特别慢，后面就会有许多请求排队等着。这称为队头堵塞。</p>
<ul>
<li><strong>队头堵塞</strong></li>
</ul>
<p>HTTP 传输的报文必须是一发一收，但是，里面的任务被放在一个任务队列中串行执行，一旦队首的请求处理太慢，就会阻塞后面请求的处理。这就是HTTP队头阻塞问题。</p>
<p><strong>队头阻塞的解决方案：</strong></p>
<p>（1）并发连接：对于一个域名允许分配多个长连接，那么相当于增加了任务队列，不至于一个队伍的任务阻塞其它所有任务。</p>
<p>（2）域名分片：将域名分出很多二级域名，它们都指向同样的一台服务器，能够并发的长连接数变多，解决了队头阻塞的问题。</p>
<h3 id="20-URL有哪些组成部分"><a href="#20-URL有哪些组成部分" class="headerlink" title="20. URL有哪些组成部分"></a>20. URL有哪些组成部分</h3><p>以下面的URL为例：<strong><a href="http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name">http://www.aspxfans.com:8080/news/index.asp?boardID=5&amp;ID=24618&amp;page=1#name</a></strong></p>
<p>从上面的URL可以看出，一个完整的URL包括以下几部分：</p>
<ul>
<li><strong>协议部分</strong>：该URL的协议部分为“http：”，这代表网页使用的是HTTP协议。在Internet中可以使用多种协议，如HTTP，FTP等等本例中使用的是HTTP协议。在”HTTP”后面的“&#x2F;&#x2F;”为分隔符；</li>
<li><strong>域名部分</strong>：该URL的域名部分为“<a href="http://www.aspxfans.com”.一个url中,也可以使用ip地址作为域名使用/">www.aspxfans.com”。一个URL中，也可以使用IP地址作为域名使用</a></li>
<li><strong>端口部分</strong>：跟在域名后面的是端口，域名和端口之间使用“:”作为分隔符。端口不是一个URL必须的部分，如果省略端口部分，将采用默认端口（HTTP协议默认端口是80，HTTPS协议默认端口是443）；</li>
<li><strong>虚拟目录部分</strong>：从域名后的第一个“&#x2F;”开始到最后一个“&#x2F;”为止，是虚拟目录部分。虚拟目录也不是一个URL必须的部分。本例中的虚拟目录是“&#x2F;news&#x2F;”；</li>
<li><strong>文件名部分</strong>：从域名后的最后一个“&#x2F;”开始到“？”为止，是文件名部分，如果没有“?”,则是从域名后的最后一个“&#x2F;”开始到“#”为止，是文件部分，如果没有“？”和“#”，那么从域名后的最后一个“&#x2F;”开始到结束，都是文件名部分。本例中的文件名是“index.asp”。文件名部分也不是一个URL必须的部分，如果省略该部分，则使用默认的文件名；</li>
<li><strong>锚部分</strong>：从“#”开始到最后，都是锚部分。本例中的锚部分是“name”。锚部分也不是一个URL必须的部分；</li>
<li><strong>参数部分</strong>：从“？”开始到“#”为止之间的部分为参数部分，又称搜索部分、查询部分。本例中的参数部分为“boardID&#x3D;5&amp;ID&#x3D;24618&amp;page&#x3D;1”。参数可以允许有多个参数，参数与参数之间用“&amp;”作为分隔符。</li>
</ul>
<h3 id="21-与缓存相关的HTTP请求头有哪些"><a href="#21-与缓存相关的HTTP请求头有哪些" class="headerlink" title="21. 与缓存相关的HTTP请求头有哪些"></a>21. 与缓存相关的HTTP请求头有哪些</h3><p>强缓存：</p>
<ul>
<li>Expires</li>
<li>Cache-Control</li>
</ul>
<p>协商缓存：</p>
<ul>
<li>Etag、If-None-Match</li>
<li>Last-Modified、If-Modified-Since</li>
</ul>
<h2 id="二、HTTPS协议"><a href="#二、HTTPS协议" class="headerlink" title="二、HTTPS协议"></a>二、HTTPS协议</h2><h3 id="1-什么是HTTPS协议？"><a href="#1-什么是HTTPS协议？" class="headerlink" title="1. 什么是HTTPS协议？"></a>1. 什么是HTTPS协议？</h3><p>超文本传输安全协议（Hypertext Transfer Protocol Secure，简称：HTTPS）是一种通过计算机网络进行安全通信的传输协议。HTTPS经由HTTP进行通信，利用SSL&#x2F;TLS来加密数据包。HTTPS的主要目的是提供对网站服务器的身份认证，保护交换数据的隐私与完整性。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685749-8cc21a1b-4277-42b1-aeed-18978c1cdb95.png?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image</span></p>
<p>HTTP协议采用<strong>明文传输</strong>信息，存在<strong>信息窃听</strong>、<strong>信息篡改</strong>和<strong>信息劫持</strong>的风险，而协议TLS&#x2F;SSL具有<strong>身份验证</strong>、<strong>信息加密</strong>和<strong>完整性校验</strong>的功能，可以避免此类问题发生。</p>
<p>安全层的主要职责就是<strong>对发起的HTTP请求的数据进行加密操作</strong> 和 <strong>对接收到的HTTP的内容进行解密操作</strong>。</p>
<h3 id="2-TLS-x2F-SSL的工作原理"><a href="#2-TLS-x2F-SSL的工作原理" class="headerlink" title="2. TLS&#x2F;SSL的工作原理"></a>2. TLS&#x2F;SSL的工作原理</h3><p><strong>TLS&#x2F;SSL</strong>全称<strong>安全传输层协议</strong>（Transport Layer Security）, 是介于TCP和HTTP之间的一层安全协议，不影响原有的TCP协议和HTTP协议，所以使用HTTPS基本上不需要对HTTP页面进行太多的改造。</p>
<p>TLS&#x2F;SSL的功能实现主要依赖三类基本算法：<strong>散列函数hash</strong>、<strong>对称加密</strong>、<strong>非对称加密</strong>。这三类算法的作用如下：</p>
<ul>
<li>基于散列函数验证信息的完整性</li>
<li>对称加密算法采用协商的秘钥对数据加密</li>
<li>非对称加密实现身份认证和秘钥协商</li>
</ul>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685769-63a91dae-936d-42d3-8571-577cefa11e33.png"  ><span class="image-caption">image</span></p>
<h4 id="（1）散列函数hash"><a href="#（1）散列函数hash" class="headerlink" title="（1）散列函数hash"></a>（1）散列函数hash</h4><p>常见的散列函数有MD5、SHA1、SHA256。该函数的特点是单向不可逆，对输入数据非常敏感，输出的长度固定，任何数据的修改都会改变散列函数的结果，可以用于防止信息篡改并验证数据的完整性。</p>
<p><strong>特点：</strong>在信息传输过程中，散列函数不能三都实现信息防篡改，由于传输是明文传输，中间人可以修改信息后重新计算信息的摘要，所以需要对传输的信息和信息摘要进行加密。</p>
<h4 id="（2）对称加密"><a href="#（2）对称加密" class="headerlink" title="（2）对称加密"></a>（2）对称加密</h4><p>对称加密的方法是，双方使用同一个秘钥对数据进行加密和解密。但是对称加密的存在一个问题，就是如何保证秘钥传输的安全性，因为秘钥还是会通过网络传输的，一旦秘钥被其他人获取到，那么整个加密过程就毫无作用了。 这就要用到非对称加密的方法。</p>
<p>常见的对称加密算法有AES-CBC、DES、3DES、AES-GCM等。相同的秘钥可以用于信息的加密和解密。掌握秘钥才能获取信息，防止信息窃听，其通讯方式是一对一。</p>
<p><strong>特点：</strong>对称加密的优势就是信息传输使用一对一，需要共享相同的密码，密码的安全是保证信息安全的基础，服务器和N个客户端通信，需要维持N个密码记录且不能修改密码。</p>
<h4 id="（3）非对称加密"><a href="#（3）非对称加密" class="headerlink" title="（3）非对称加密"></a>（3）非对称加密</h4><p>非对称加密的方法是，我们拥有两个秘钥，一个是公钥，一个是私钥。公钥是公开的，私钥是保密的。用私钥加密的数据，只有对应的公钥才能解密，用公钥加密的数据，只有对应的私钥才能解密。我们可以将公钥公布出去，任何想和我们通信的客户， 都可以使用我们提供的公钥对数据进行加密，这样我们就可以使用私钥进行解密，这样就能保证数据的安全了。但是非对称加密有一个缺点就是加密的过程很慢，因此如果每次通信都使用非对称加密的方式的话，反而会造成等待时间过长的问题。</p>
<p>常见的非对称加密算法有RSA、ECC、DH等。秘钥成对出现，一般称为公钥（公开）和私钥（保密）。公钥加密的信息只有私钥可以解开，私钥加密的信息只能公钥解开，因此掌握公钥的不同客户端之间不能相互解密信息，只能和服务器进行加密通信，服务器可以实现一对多的的通信，客户端也可以用来验证掌握私钥的服务器的身份。</p>
<p><strong>特点：</strong>非对称加密的特点就是信息一对多，服务器只需要维持一个私钥就可以和多个客户端进行通信，但服务器发出的信息能够被所有的客户端解密，且该算法的计算复杂，加密的速度慢。</p>
<p>综合上述算法特点，TLS&#x2F;SSL的工作方式就是客户端使用非对称加密与服务器进行通信，实现身份的验证并协商对称加密使用的秘钥。对称加密算法采用协商秘钥对信息以及信息摘要进行加密通信，不同节点之间采用的对称秘钥不同，从而保证信息只能通信双方获取。这样就解决了两个方法各自存在的问题。</p>
<h3 id="3-数字证书是什么？"><a href="#3-数字证书是什么？" class="headerlink" title="3. 数字证书是什么？"></a>3. 数字证书是什么？</h3><p>现在的方法也不一定是安全的，因为没有办法确定得到的公钥就一定是安全的公钥。可能存在一个中间人，截取了对方发给我们的公钥，然后将他自己的公钥发送给我们，当我们使用他的公钥加密后发送的信息，就可以被他用自己的私钥解密。然后他伪装成我们以同样的方法向对方发送信息，这样我们的信息就被窃取了，然而自己还不知道。为了解决这样的问题，可以使用数字证书。</p>
<p>首先使用一种 Hash 算法来对公钥和其他信息进行加密，生成一个信息摘要，然后让有公信力的认证中心（简称 CA ）用它的私钥对消息摘要加密，形成签名。最后将原始的信息和签名合在一起，称为数字证书。当接收方收到数字证书的时候，先根据原始信息使用同样的 Hash 算法生成一个摘要，然后使用公证处的公钥来对数字证书中的摘要进行解密，最后将解密的摘要和生成的摘要进行对比，就能发现得到的信息是否被更改了。</p>
<p>这个方法最要的是认证中心的可靠性，一般浏览器里会内置一些顶层的认证中心的证书，相当于我们自动信任了他们，只有这样才能保证数据的安全。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603965685765-ffc9a525-ccad-43f0-bb25-8e17281d68fe.png"  ><span class="image-caption">image</span></p>
<h3 id="4-HTTPS通信（握手）过程"><a href="#4-HTTPS通信（握手）过程" class="headerlink" title="4. HTTPS通信（握手）过程"></a>4. HTTPS通信（握手）过程</h3><p>HTTPS的通信过程如下：</p>
<ol>
<li>客户端向服务器发起请求，请求中包含使用的协议版本号、生成的一个随机数、以及客户端支持的加密方法。</li>
<li>服务器端接收到请求后，确认双方使用的加密方法、并给出服务器的证书、以及一个服务器生成的随机数。</li>
<li>客户端确认服务器证书有效后，生成一个新的随机数，并使用数字证书中的公钥，加密这个随机数，然后发给服 务器。并且还会提供一个前面所有内容的 hash 的值，用来供服务器检验。</li>
<li>服务器使用自己的私钥，来解密客户端发送过来的随机数。并提供前面所有内容的 hash 值来供客户端检验。</li>
<li>客户端和服务器端根据约定的加密方法使用前面的三个随机数，生成对话秘钥，以后的对话过程都使用这个秘钥来加密信息。</li>
</ol>
<h3 id="5-HTTPS的特点"><a href="#5-HTTPS的特点" class="headerlink" title="5. HTTPS的特点"></a>5. HTTPS的特点</h3><p>HTTPS的<strong>优点</strong>如下：</p>
<ul>
<li>使用HTTPS协议可以认证用户和服务器，确保数据发送到正确的客户端和服务器；</li>
<li>使用HTTPS协议可以进行加密传输、身份认证，通信更加安全，防止数据在传输过程中被窃取、修改，确保数据安全性；</li>
<li>HTTPS是现行架构下最安全的解决方案，虽然不是绝对的安全，但是大幅增加了中间人攻击的成本；</li>
</ul>
<p>HTTPS的<strong>缺点</strong>如下：</p>
<ul>
<li>HTTPS需要做服务器和客户端双方的加密个解密处理，耗费更多服务器资源，过程复杂；</li>
<li>HTTPS协议握手阶段比较费时，增加页面的加载时间；</li>
<li>SSL证书是收费的，功能越强大的证书费用越高；</li>
<li>HTTPS连接服务器端资源占用高很多，支持访客稍多的网站需要投入更大的成本；</li>
<li>SSL证书需要绑定IP，不能再同一个IP上绑定多个域名。</li>
</ul>
<h3 id="6-HTTPS是如何保证安全的？"><a href="#6-HTTPS是如何保证安全的？" class="headerlink" title="6. HTTPS是如何保证安全的？"></a>6. <strong>HTTPS</strong>是如何保证安全的？</h3><p>先理解两个概念：</p>
<ul>
<li>对称加密：即通信的双⽅都使⽤同⼀个秘钥进⾏加解密，对称加密虽然很简单性能也好，但是⽆法解决⾸次把秘钥发给对⽅的问题，很容易被⿊客拦截秘钥。 </li>
<li>⾮对称加密：</li>
</ul>
<p>\1. 私钥 + 公钥&#x3D; 密钥对 </p>
<p>\2. 即⽤私钥加密的数据,只有对应的公钥才能解密,⽤公钥加密的数据,只有对应的私钥才能解密 </p>
<p>\3. 因为通信双⽅的⼿⾥都有⼀套⾃⼰的密钥对,通信之前双⽅会先把⾃⼰的公钥都先发给对⽅ </p>
<p>\4. 然后对⽅再拿着这个公钥来加密数据响应给对⽅,等到到了对⽅那⾥,对⽅再⽤⾃⼰的私钥进⾏解密 </p>
<p>⾮对称加密虽然安全性更⾼，但是带来的问题就是速度很慢，影响性能。 </p>
<p><strong>解决⽅案：</strong> </p>
<p>结合两种加密⽅式，将对称加密的密钥使⽤⾮对称加密的公钥进⾏加密，然后发送出去，接收⽅使⽤私钥进⾏解密得到对称加密的密钥，然后双⽅可以使⽤对称加密来进⾏沟通。 </p>
<p>此时⼜带来⼀个问题，中间⼈问题： </p>
<p>如果此时在客户端和服务器之间存在⼀个中间⼈,这个中间⼈只需要把原本双⽅通信互发的公钥,换成⾃⼰的公钥,这样中间⼈就可以轻松解密通信双⽅所发送的所有数据。 </p>
<p>所以这个时候需要⼀个安全的第三⽅颁发证书（CA），证明身份的身份，防⽌被中间⼈攻击。 证书中包括：签发者、证书⽤途、使⽤者公钥、使⽤者私钥、使⽤者的HASH算法、证书到期时间等。</p>
<p>但是问题来了，如果中间⼈篡改了证书，那么身份证明是不是就⽆效了？这个证明就⽩买了，这个时候需要⼀个新的技术，数字签名。 </p>
<p>数字签名就是⽤CA⾃带的HASH算法对证书的内容进⾏HASH得到⼀个摘要，再⽤CA的私钥加密，最终组成数字签名。当别⼈把他的证书发过来的时候,我再⽤同样的Hash算法,再次⽣成消息摘要，然后⽤CA的公钥对数字签名解密,得到CA创建的消息摘要,两者⼀⽐,就知道中间有没有被⼈篡改了。这个时候就能最⼤程度保证通信的安全了。 </p>
<h2 id="三、HTTP状态码"><a href="#三、HTTP状态码" class="headerlink" title="三、HTTP状态码"></a>三、HTTP状态码</h2><p>状态码的类别：</p>
<table>
<thead>
<tr>
<th><strong>类别</strong></th>
<th><strong>原因</strong></th>
<th><strong>描述</strong></th>
</tr>
</thead>
<tbody><tr>
<td>1xx</td>
<td>Informational(信息性状态码)</td>
<td>接受的请求正在处理</td>
</tr>
<tr>
<td>2xx</td>
<td>Success(成功状态码)</td>
<td>请求正常处理完毕</td>
</tr>
<tr>
<td>3xx</td>
<td>Redirection(重定向状态码)</td>
<td>需要进行附加操作一完成请求</td>
</tr>
<tr>
<td>4xx</td>
<td>Client Error (客户端错误状态码)</td>
<td>服务器无法处理请求</td>
</tr>
<tr>
<td>5xx</td>
<td>Server Error(服务器错误状态码)</td>
<td>服务器处理请求出错</td>
</tr>
</tbody></table>
<h3 id="1-2XX-Success-成功状态码"><a href="#1-2XX-Success-成功状态码" class="headerlink" title="1. 2XX (Success 成功状态码)"></a>1. 2XX (Success 成功状态码)</h3><p>状态码2XX表示请求被正常处理了。</p>
<h4 id="（1）200-OK"><a href="#（1）200-OK" class="headerlink" title="（1）200 OK"></a>（1）200 OK</h4><p>200 OK表示客户端发来的请求被服务器端正常处理了。</p>
<h4 id="（2）204-No-Content"><a href="#（2）204-No-Content" class="headerlink" title="（2）204 No Content"></a>（2）204 No Content</h4><p>该状态码表示客户端发送的请求已经在服务器端正常处理了，但是没有返回的内容，响应报文中不包含实体的主体部分。一般在只需要从客户端往服务器端发送信息，而服务器端不需要往客户端发送内容时使用。</p>
<h4 id="（3）206-Partial-Content"><a href="#（3）206-Partial-Content" class="headerlink" title="（3）206 Partial Content"></a>（3）206 Partial Content</h4><p>该状态码表示客户端进行了范围请求，而服务器端执行了这部分的 GET 请求。响应报文中包含由 Content-Range 指定范围的实体内容。</p>
<h3 id="2-3XX-Redirection-重定向状态码"><a href="#2-3XX-Redirection-重定向状态码" class="headerlink" title="2. 3XX (Redirection 重定向状态码)"></a>2. 3XX (Redirection 重定向状态码)</h3><p>3XX 响应结果表明浏览器需要执行某些特殊的处理以正确处理请求。</p>
<h4 id="（1）301-Moved-Permanently"><a href="#（1）301-Moved-Permanently" class="headerlink" title="（1）301 Moved Permanently"></a>（1）301 Moved Permanently</h4><p><strong>永久重定向。</strong></p>
<p>该状态码表示请求的资源已经被分配了新的 URI，以后应使用资源指定的 URI。新的 URI 会在 HTTP 响应头中的 Location 首部字段指定。若用户已经把原来的URI保存为书签，此时会按照 Location 中新的URI重新保存该书签。同时，搜索引擎在抓取新内容的同时也将旧的网址替换为重定向之后的网址。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们想换个域名，旧的域名不再使用时，用户访问旧域名时用301就重定向到新的域名。其实也是告诉搜索引擎收录的域名需要对新的域名进行收录。</li>
<li>在搜索引擎的搜索结果中出现了不带www的域名，而带www的域名却没有收录，这个时候可以用301重定向来告诉搜索引擎我们目标的域名是哪一个。</li>
</ul>
<h4 id="（2）302-Found"><a href="#（2）302-Found" class="headerlink" title="（2）302 Found"></a>（2）302 Found</h4><p><strong>临时重定向。</strong></p>
<p>该状态码表示请求的资源被分配到了新的 URI，希望用户（本次）能使用新的 URI 访问资源。和 301 Moved Permanently 状态码相似，但是 302 代表的资源不是被永久重定向，只是临时性质的。也就是说已移动的资源对应的 URI 将来还有可能发生改变。若用户把 URI 保存成书签，但不会像 301 状态码出现时那样去更新书签，而是仍旧保留返回 302 状态码的页面对应的 URI。同时，搜索引擎会抓取新的内容而保留旧的网址。因为服务器返回302代码，搜索引擎认为新的网址只是暂时的。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>当我们在做活动时，登录到首页自动重定向，进入活动页面。</li>
<li>未登陆的用户访问用户中心重定向到登录页面。</li>
<li>访问404页面重新定向到首页。</li>
</ul>
<h4 id="（3）303-See-Other"><a href="#（3）303-See-Other" class="headerlink" title="（3）303 See Other"></a>（3）303 See Other</h4><p>该状态码表示由于请求对应的资源存在着另一个 URI，应使用 GET 方法定向获取请求的资源。</p>
<p>303 状态码和 302 Found 状态码有着相似的功能，但是 303 状态码明确表示客户端应当采用 GET 方法获取资源。</p>
<p>303 状态码通常作为 PUT 或 POST 操作的返回结果，它表示重定向链接指向的不是新上传的资源，而是另外一个页面，比如消息确认页面或上传进度页面。而请求重定向页面的方法要总是使用 GET。</p>
<p>注意：</p>
<ul>
<li>当 301、302、303 响应状态码返回时，几乎所有的浏览器都会把 POST 改成GET，并删除请求报文内的主体，之后请求会再次自动发送。</li>
<li>301、302 标准是禁止将 POST 方法变成 GET方法的，但实际大家都会这么做。</li>
</ul>
<h4 id="（4）304-Not-Modified"><a href="#（4）304-Not-Modified" class="headerlink" title="（4）304 Not Modified"></a>（4）304 Not Modified</h4><p><strong>浏览器缓存相关。</strong></p>
<p>该状态码表示客户端发送附带条件的请求时，服务器端允许请求访问资源，但未满足条件的情况。304 状态码返回时，不包含任何响应的主体部分。304 虽然被划分在 3XX 类别中，但是和重定向没有关系。</p>
<p>带条件的请求（Http 条件请求）：使用 Get方法 请求，请求报文中包含（<code>if-match</code>、<code>if-none-match</code>、<code>if-modified-since</code>、<code>if-unmodified-since</code>、<code>if-range</code>）中任意首部。</p>
<p>状态码304并不是一种错误，而是告诉客户端有缓存，直接使用缓存中的数据。返回页面的只有头部信息，是没有内容部分的，这样在一定程度上提高了网页的性能。</p>
<h4 id="（5）307-Temporary-Redirect"><a href="#（5）307-Temporary-Redirect" class="headerlink" title="（5）307 Temporary Redirect"></a>（5）307 Temporary Redirect</h4><p><strong>307表示临时重定向。</strong>该状态码与 302 Found 有着相同含义，尽管 302 标准禁止 POST 变成 GET，但是实际使用时还是这样做了。</p>
<p>307 会遵守浏览器标准，<strong>不会从 POST 变成 GET</strong>。但是对于处理请求的行为时，不同浏览器还是会出现不同的情况。规范要求浏览器继续向 Location 的地址 POST 内容。规范要求浏览器继续向 Location 的地址 POST 内容。</p>
<h3 id="3-4XX-Client-Error-客户端错误状态码"><a href="#3-4XX-Client-Error-客户端错误状态码" class="headerlink" title="3. 4XX (Client Error 客户端错误状态码)"></a>3. 4XX (Client Error 客户端错误状态码)</h3><p>4XX 的响应结果表明客户端是发生错误的原因所在。</p>
<h4 id="（1）400-Bad-Request"><a href="#（1）400-Bad-Request" class="headerlink" title="（1）400 Bad Request"></a>（1）400 Bad Request</h4><p>该状态码表示请求报文中存在语法错误。当错误发生时，需修改请求的内容后再次发送请求。另外，浏览器会像 200 OK 一样对待该状态码。</p>
<h4 id="（2）401-Unauthorized"><a href="#（2）401-Unauthorized" class="headerlink" title="（2）401 Unauthorized"></a>（2）401 Unauthorized</h4><p>该状态码表示发送的请求需要有通过 HTTP 认证(BASIC 认证、DIGEST 认证)的认证信息。若之前已进行过一次请求，则表示用户认证失败</p>
<p>返回含有 401 的响应必须包含一个适用于被请求资源的 WWW-Authenticate 首部用以质询(challenge)用户信息。当浏览器初次接收到 401 响应，会弹出认证用的对话窗口。</p>
<p>以下情况会出现401：</p>
<ul>
<li>401.1 - 登录失败。</li>
<li>401.2 - 服务器配置导致登录失败。</li>
<li>401.3 - 由于 ACL 对资源的限制而未获得授权。</li>
<li>401.4 - 筛选器授权失败。</li>
<li>401.5 - ISAPI&#x2F;CGI 应用程序授权失败。</li>
<li>401.7 - 访问被 Web 服务器上的 URL 授权策略拒绝。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（3）403-Forbidden"><a href="#（3）403-Forbidden" class="headerlink" title="（3）403 Forbidden"></a>（3）403 Forbidden</h4><p>该状态码表明请求资源的访问被服务器拒绝了，服务器端没有必要给出详细理由，但是可以在响应报文实体的主体中进行说明。进入该状态后，不能再继续进行验证。该访问是永久禁止的，并且与应用逻辑密切相关。</p>
<p>IIS 定义了许多不同的 403 错误，它们指明更为具体的错误原因：</p>
<ul>
<li>403.1 - 执行访问被禁止。</li>
<li>403.2 - 读访问被禁止。</li>
<li>403.3 - 写访问被禁止。</li>
<li>403.4 - 要求 SSL。</li>
<li>403.5 - 要求 SSL 128。</li>
<li>403.6 - IP 地址被拒绝。</li>
<li>403.7 - 要求客户端证书。</li>
<li>403.8 - 站点访问被拒绝。</li>
<li>403.9 - 用户数过多。</li>
<li>403.10 - 配置无效。</li>
<li>403.11 - 密码更改。</li>
<li>403.12 - 拒绝访问映射表。</li>
<li>403.13 - 客户端证书被吊销。</li>
<li>403.14 - 拒绝目录列表。</li>
<li>403.15 - 超出客户端访问许可。</li>
<li>403.16 - 客户端证书不受信任或无效。</li>
<li>403.17 - 客户端证书已过期或尚未生效</li>
<li>403.18 - 在当前的应用程序池中不能执行所请求的 URL。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.19 - 不能为这个应用程序池中的客户端执行 CGI。这个错误代码为 IIS 6.0 所专用。</li>
<li>403.20 - Passport 登录失败。这个错误代码为 IIS 6.0 所专用。</li>
</ul>
<h4 id="（4）404-Not-Found"><a href="#（4）404-Not-Found" class="headerlink" title="（4）404 Not Found"></a>（4）404 Not Found</h4><p>该状态码表明服务器上无法找到请求的资源。除此之外，也可以在服务器端拒绝请求且不想说明理由时使用。</p>
<p>以下情况会出现404：</p>
<ul>
<li>404.0 -（无） – 没有找到文件或目录。</li>
<li>404.1 - 无法在所请求的端口上访问 Web 站点。</li>
<li>404.2 - Web 服务扩展锁定策略阻止本请求。</li>
<li>404.3 - MIME 映射策略阻止本请求。</li>
</ul>
<h4 id="（5）405-Method-Not-Allowed"><a href="#（5）405-Method-Not-Allowed" class="headerlink" title="（5）405 Method Not Allowed"></a>（5）405 Method Not Allowed</h4><p>该状态码表示客户端请求的方法虽然能被服务器识别，但是服务器禁止使用该方法。GET 和 HEAD 方法，服务器应该总是允许客户端进行访问。客户端可以通过 OPTIONS 方法（预检）来查看服务器允许的访问方法, 如下</p>
<figure class="highlight pgsql"><table><tr><td class="code"><pre><code class="hljs pgsql"><span class="hljs-keyword">Access</span>-Control-Allow-Methods: <span class="hljs-keyword">GET</span>,HEAD,PUT,PATCH,POST,<span class="hljs-keyword">DELETE</span><br></code></pre></td></tr></table></figure>

<h3 id="4-5XX-Server-Error-服务器错误状态码"><a href="#4-5XX-Server-Error-服务器错误状态码" class="headerlink" title="4. 5XX (Server Error 服务器错误状态码)"></a>4. 5XX (Server Error 服务器错误状态码)</h3><p>5XX 的响应结果表明服务器本身发生错误.</p>
<h4 id="（1）500-Internal-Server-Error"><a href="#（1）500-Internal-Server-Error" class="headerlink" title="（1）500 Internal Server Error"></a>（1）500 Internal Server Error</h4><p>该状态码表明服务器端在执行请求时发生了错误。也有可能是 Web 应用存在的 bug 或某些临时的故障。</p>
<h4 id="（2）502-Bad-Gateway"><a href="#（2）502-Bad-Gateway" class="headerlink" title="（2）502 Bad Gateway"></a>（2）502 Bad Gateway</h4><p>该状态码表明扮演网关或代理角色的服务器，从上游服务器中接收到的响应是无效的。注意，502 错误通常不是客户端能够修复的，而是需要由途经的 Web 服务器或者代理服务器对其进行修复。以下情况会出现502：</p>
<ul>
<li>502.1 - CGI （通用网关接口）应用程序超时。</li>
<li>502.2 - CGI （通用网关接口）应用程序出错。</li>
</ul>
<h4 id="（3）503-Service-Unavailable"><a href="#（3）503-Service-Unavailable" class="headerlink" title="（3）503 Service Unavailable"></a>（3）503 Service Unavailable</h4><p>该状态码表明服务器暂时处于超负载或正在进行停机维护，现在无法处理请求。如果事先得知解除以上状况需要的时间，最好写入 RetryAfter 首部字段再返回给客户端。</p>
<p><strong>使用场景：</strong></p>
<ul>
<li>服务器停机维护时，主动用503响应请求；</li>
<li>nginx 设置限速，超过限速，会返回503。</li>
</ul>
<h4 id="（4）504-Gateway-Timeout"><a href="#（4）504-Gateway-Timeout" class="headerlink" title="（4）504 Gateway Timeout"></a>（4）504 Gateway Timeout</h4><p>该状态码表示网关或者代理的服务器无法在规定的时间内获得想要的响应。他是HTTP 1.1中新加入的。</p>
<p>使用场景：代码执行时间超时，或者发生了死循环。</p>
<h3 id="5-总结"><a href="#5-总结" class="headerlink" title="5. 总结"></a>5. 总结</h3><p><strong>（1）2XX 成功</strong></p>
<ul>
<li>200 OK，表示从客户端发来的请求在服务器端被正确处理</li>
<li>204 No content，表示请求成功，但响应报文不含实体的主体部分</li>
<li>205 Reset Content，表示请求成功，但响应报文不含实体的主体部分，但是与 204 响应不同在于要求请求方重置内容</li>
<li>206 Partial Content，进行范围请求</li>
</ul>
<p><strong>（2）3XX 重定向</strong></p>
<ul>
<li>301 moved permanently，永久性重定向，表示资源已被分配了新的 URL</li>
<li>302 found，临时性重定向，表示资源临时被分配了新的 URL</li>
<li>303 see other，表示资源存在着另一个 URL，应使用 GET 方法获取资源</li>
<li>304 not modified，表示服务器允许访问资源，但因发生请求未满足条件的情况</li>
<li>307 temporary redirect，临时重定向，和302含义类似，但是期望客户端保持请求方法不变向新的地址发出请求</li>
</ul>
<p><strong>（3）4XX 客户端错误</strong></p>
<ul>
<li>400 bad request，请求报文存在语法错误</li>
<li>401 unauthorized，表示发送的请求需要有通过 HTTP 认证的认证信息</li>
<li>403 forbidden，表示对请求资源的访问被服务器拒绝</li>
<li>404 not found，表示在服务器上没有找到请求的资源</li>
</ul>
<p><strong>（4）5XX 服务器错误</strong></p>
<ul>
<li>500 internal sever error，表示服务器端在执行请求时发生了错误</li>
<li>501 Not Implemented，表示服务器不支持当前请求所需要的某个功能</li>
<li>503 service unavailable，表明服务器暂时处于超负载或正在停机维护，无法处理请求</li>
</ul>
<h3 id="6-同样是重定向，307，303，302的区别？"><a href="#6-同样是重定向，307，303，302的区别？" class="headerlink" title="6. 同样是重定向，307，303，302的区别？"></a>6. 同样是重定向，<strong>307</strong>，<strong>303</strong>，<strong>302</strong>的区别？</h3><p>302是http1.0的协议状态码，在http1.1版本的时候为了细化302状态码⼜出来了两个303和307。 303明确表示客户端应当采⽤get⽅法获取资源，他会把POST请求变为GET请求进⾏重定向。 307会遵照浏览器标准，不会从post变为get。 </p>
<h2 id="四、DNS协议介绍"><a href="#四、DNS协议介绍" class="headerlink" title="四、DNS协议介绍"></a>四、DNS协议介绍</h2><h3 id="1-DNS-协议是什么"><a href="#1-DNS-协议是什么" class="headerlink" title="1. DNS 协议是什么"></a>1. DNS 协议是什么</h3><p><strong>概念</strong>： DNS 是域名系统 (Domain Name System) 的缩写，提供的是一种主机名到 IP 地址的转换服务，就是我们常说的域名系统。它是一个由分层的 DNS 服务器组成的分布式数据库，是定义了主机如何查询这个分布式数据库的方式的应用层协议。能够使人更方便的访问互联网，而不用去记住能够被机器直接读取的IP数串。</p>
<p><strong>作用</strong>： 将域名解析为IP地址，客户端向DNS服务器（DNS服务器有自己的IP地址）发送域名查询请求，DNS服务器告知客户机Web服务器的 IP 地址。</p>
<h3 id="2-DNS同时使用TCP和UDP协议？"><a href="#2-DNS同时使用TCP和UDP协议？" class="headerlink" title="2. DNS同时使用TCP和UDP协议？"></a>2. DNS同时使用TCP和UDP协议？</h3><p><strong>DNS占用53号端口，同时使用TCP和UDP协议。</strong></p>
<p>（1）在区域传输的时候使用TCP协议</p>
<ul>
<li>辅域名服务器会定时（一般3小时）向主域名服务器进行查询以便了解数据是否有变动。如有变动，会执行一次区域传送，进行数据同步。区域传送使用TCP而不是UDP，因为数据同步传送的数据量比一个请求应答的数据量要多得多。</li>
<li>TCP是一种可靠连接，保证了数据的准确性。</li>
</ul>
<p>（2）在域名解析的时候使用UDP协议</p>
<ul>
<li>客户端向DNS服务器查询域名，一般返回的内容都不超过512字节，用UDP传输即可。不用经过三次握手，这样DNS服务器负载更低，响应更快。理论上说，客户端也可以指定向DNS服务器查询时用TCP，但事实上，很多DNS服务器进行配置的时候，仅支持UDP查询包。</li>
</ul>
<h3 id="3-DNS完整的查询过程"><a href="#3-DNS完整的查询过程" class="headerlink" title="3. DNS完整的查询过程"></a>3. DNS完整的查询过程</h3><p>DNS服务器解析域名的过程：</p>
<ul>
<li>首先会在<strong>浏览器的缓存</strong>中查找对应的IP地址，如果查找到直接返回，若找不到继续下一步</li>
<li>将请求发送给<strong>本地DNS服务器</strong>，在本地域名服务器缓存中查询，如果查找到，就直接将查找结果返回，若找不到继续下一步</li>
<li>本地DNS服务器向<strong>根域名服务器</strong>发送请求，根域名服务器会返回一个所查询域的顶级域名服务器地址</li>
<li>本地DNS服务器向<strong>顶级域名服务器</strong>发送请求，接受请求的服务器查询自己的缓存，如果有记录，就返回查询结果，如果没有就返回相关的下一级的权威域名服务器的地址</li>
<li>本地DNS服务器向<strong>权威域名服务器</strong>发送请求，域名服务器返回对应的结果</li>
<li>本地DNS服务器将返回结果保存在缓存中，便于下次使用</li>
<li>本地DNS服务器将返回结果返回给浏览器</li>
</ul>
<p>比如要查询 <a href="http://www.baidu.com/">www.baidu.com</a> 的 IP 地址，首先会在浏览器的缓存中查找是否有该域名的缓存，如果不存在就将请求发送到本地的 DNS 服务器中，本地DNS服务器会判断是否存在该域名的缓存，如果不存在，则向根域名服务器发送一个请求，根域名服务器返回负责 .com 的顶级域名服务器的 IP 地址的列表。然后本地 DNS 服务器再向其中一个负责 .com 的顶级域名服务器发送一个请求，负责 .com 的顶级域名服务器返回负责 .baidu 的权威域名服务器的 IP 地址列表。然后本地 DNS 服务器再向其中一个权威域名服务器发送一个请求，最后权威域名服务器返回一个对应的主机名的 IP 地址列表。</p>
<h3 id="4-迭代查询与递归查询"><a href="#4-迭代查询与递归查询" class="headerlink" title="4. 迭代查询与递归查询"></a>4. 迭代查询与递归查询</h3><p>实际上，DNS解析是一个包含迭代查询和递归查询的过程。</p>
<ul>
<li><strong>递归查询</strong>指的是查询请求发出后，域名服务器代为向下一级域名服务器发出请求，最后向用户返回查询的最终结果。使用递归 查询，用户只需要发出一次查询请求。</li>
<li><strong>迭代查询</strong>指的是查询请求后，域名服务器返回单次查询的结果。下一级的查询由用户自己请求。使用迭代查询，用户需要发出 多次的查询请求。</li>
</ul>
<p>一般我们向本地 DNS 服务器发送请求的方式就是递归查询，因为我们只需要发出一次请求，然后本地 DNS 服务器返回给我 们最终的请求结果。而本地 DNS 服务器向其他域名服务器请求的过程是迭代查询的过程，因为每一次域名服务器只返回单次 查询的结果，下一级的查询由本地 DNS 服务器自己进行。</p>
<h3 id="5-DNS-记录和报文"><a href="#5-DNS-记录和报文" class="headerlink" title="5. DNS 记录和报文"></a>5. DNS 记录和报文</h3><p>DNS 服务器中以资源记录的形式存储信息，每一个 DNS 响应报文一般包含多条资源记录。一条资源记录的具体的格式为</p>
<figure class="highlight delphi"><table><tr><td class="code"><pre><code class="hljs delphi">（<span class="hljs-keyword">Name</span>，Value，<span class="hljs-keyword">Type</span>，TTL）<br></code></pre></td></tr></table></figure>

<p>其中 TTL 是资源记录的生存时间，它定义了资源记录能够被其他的 DNS 服务器缓存多长时间。</p>
<p>常用的一共有四种 Type 的值，分别是 A、NS、CNAME 和 MX ，不同 Type 的值，对应资源记录代表的意义不同：</p>
<ul>
<li>如果 Type &#x3D; A，则 Name 是主机名，Value 是主机名对应的 IP 地址。因此一条记录为 A 的资源记录，提供了标 准的主机名到 IP 地址的映射。</li>
<li>如果 Type &#x3D; NS，则 Name 是个域名，Value 是负责该域名的 DNS 服务器的主机名。这个记录主要用于 DNS 链式 查询时，返回下一级需要查询的 DNS 服务器的信息。</li>
<li>如果 Type &#x3D; CNAME，则 Name 为别名，Value 为该主机的规范主机名。该条记录用于向查询的主机返回一个主机名 对应的规范主机名，从而告诉查询主机去查询这个主机名的 IP 地址。主机别名主要是为了通过给一些复杂的主机名提供 一个便于记忆的简单的别名。</li>
<li>如果 Type &#x3D; MX，则 Name 为一个邮件服务器的别名，Value 为邮件服务器的规范主机名。它的作用和 CNAME 是一 样的，都是为了解决规范主机名不利于记忆的缺点。</li>
</ul>
<h2 id="五、网络模型"><a href="#五、网络模型" class="headerlink" title="五、网络模型"></a>五、网络模型</h2><h3 id="1-OSI七层模型"><a href="#1-OSI七层模型" class="headerlink" title="1. OSI七层模型"></a>1. OSI七层模型</h3><p><code>ISO</code>为了更好的使网络应用更为普及，推出了<code>OSI</code>参考模型。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604024701811-7ac177bc-d649-45b8-8646-53af8f18a0de.webp"  ><span class="image-caption">image</span></p>
<h4 id="（1）应用层"><a href="#（1）应用层" class="headerlink" title="（1）应用层"></a>（1）应用层</h4><p><code>OSI</code>参考模型中最靠近用户的一层，是为计算机用户提供应用接口，也为用户直接提供各种网络服务。我们常见应用层的网络服务协议有：<code>HTTP</code>，<code>HTTPS</code>，<code>FTP</code>，<code>POP3</code>、<code>SMTP</code>等。</p>
<ul>
<li>在客户端与服务器中经常会有数据的请求，这个时候就是会用到<code>http(hyper text transfer protocol)(超文本传输协议)</code>或者<code>https</code>.在后端设计数据接口时，我们常常使用到这个协议。</li>
<li><code>FTP</code>是文件传输协议，在开发过程中，个人并没有涉及到，但是我想，在一些资源网站，比如<code>百度网盘``迅雷</code>应该是基于此协议的。</li>
<li><code>SMTP</code>是<code>simple mail transfer protocol（简单邮件传输协议）</code>。在一个项目中，在用户邮箱验证码登录的功能时，使用到了这个协议。</li>
</ul>
<h4 id="（2）表示层"><a href="#（2）表示层" class="headerlink" title="（2）表示层"></a>（2）表示层</h4><p>表示层提供各种用于应用层数据的编码和转换功能,确保一个系统的应用层发送的数据能被另一个系统的应用层识别。如果必要，该层可提供一种标准表示形式，用于将计算机内部的多种数据格式转换成通信中采用的标准表示形式。数据压缩和加密也是表示层可提供的转换功能之一。</p>
<p>在项目开发中，为了方便数据传输，可以使用<code>base64</code>对数据进行编解码。如果按功能来划分，<code>base64</code>应该是工作在表示层。</p>
<h4 id="（3）会话层"><a href="#（3）会话层" class="headerlink" title="（3）会话层"></a>（3）会话层</h4><p>会话层就是负责建立、管理和终止表示层实体之间的通信会话。该层的通信由不同设备中的应用程序之间的服务请求和响应组成。</p>
<h4 id="（4）传输层"><a href="#（4）传输层" class="headerlink" title="（4）传输层"></a>（4）传输层</h4><p>传输层建立了主机端到端的链接，传输层的作用是为上层协议提供端到端的可靠和透明的数据传输服务，包括处理差错控制和流量控制等问题。该层向高层屏蔽了下层数据通信的细节，使高层用户看到的只是在两个传输实体间的一条主机到主机的、可由用户控制和设定的、可靠的数据通路。我们通常说的，<code>TCP</code> <code>UDP</code>就是在这一层。端口号既是这里的“端”。</p>
<h4 id="（5）网络层"><a href="#（5）网络层" class="headerlink" title="（5）网络层"></a>（5）网络层</h4><p>本层通过<code>IP</code>寻址来建立两个节点之间的连接，为源端的运输层送来的分组，选择合适的路由和交换节点，正确无误地按照地址传送给目的端的运输层。就是通常说的<code>IP</code>层。这一层就是我们经常说的<code>IP</code>协议层。<code>IP</code>协议是<code>Internet</code>的基础。我们可以这样理解，网络层规定了数据包的传输路线，而传输层则规定了数据包的传输方式。</p>
<h4 id="（6）数据链路层"><a href="#（6）数据链路层" class="headerlink" title="（6）数据链路层"></a>（6）数据链路层</h4><p>将比特组合成字节,再将字节组合成帧,使用链路层地址 (以太网使用MAC地址)来访问介质,并进行差错检测。</p>
<p>网络层与数据链路层的对比，通过上面的描述，我们或许可以这样理解，网络层是规划了数据包的传输路线，而数据链路层就是传输路线。不过，在数据链路层上还增加了差错控制的功能。</p>
<h4 id="（7）物理层"><a href="#（7）物理层" class="headerlink" title="（7）物理层"></a>（7）物理层</h4><p>实际最终信号的传输是通过物理层实现的。通过物理介质传输比特流。规定了电平、速度和电缆针脚。常用设备有（各种物理设备）集线器、中继器、调制解调器、网线、双绞线、同轴电缆。这些都是物理层的传输介质。</p>
<p><strong>OSI七层模型通信特点：对等通信</strong></p>
<p>对等通信，为了使数据分组从源传送到目的地，源端OSI模型的每一层都必须与目的端的对等层进行通信，这种通信方式称为对等层通信。在每一层通信过程中，使用本层自己协议进行通信。</p>
<h3 id="2-TCP-x2F-IP五层协议"><a href="#2-TCP-x2F-IP五层协议" class="headerlink" title="2. TCP&#x2F;IP五层协议"></a>2. TCP&#x2F;IP五层协议</h3><p><code>TCP/IP</code>五层协议和<code>OSI</code>的七层协议对应关系如下：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png"  ><span class="image-caption">image</span></p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604025489154-966a96f5-1c8e-4d03-b9f9-f51250f63a22.png"  ><span class="image-caption">image</span></p>
<ul>
<li><p>**应用层 (application layer)**：直接为应用进程提供服务。应用层协议定义的是应用进程间通讯和交互的规则，不同的应用有着不同的应用层协议，如 HTTP协议（万维网服务）、FTP协议（文件传输）、SMTP协议（电子邮件）、DNS（域名查询）等。</p>
</li>
<li><p>**传输层 (transport layer)**：有时也译为运输层，它负责为两台主机中的进程提供通信服务。该层主要有以下两种协议：</p>
</li>
<li><ul>
<li>传输控制协议 (Transmission Control Protocol，TCP)：提供面向连接的、可靠的数据传输服务，数据传输的基本单位是报文段（segment）；</li>
<li>用户数据报协议 (User Datagram Protocol，UDP)：提供无连接的、尽最大努力的数据传输服务，但不保证数据传输的可靠性，数据传输的基本单位是用户数据报。</li>
</ul>
</li>
<li><p>**网络层 (internet layer)**：有时也译为网际层，它负责为两台主机提供通信服务，并通过选择合适的路由将数据传递到目标主机。</p>
</li>
<li><p>**数据链路层 (data link layer)**：负责将网络层交下来的 IP 数据报封装成帧，并在链路的两个相邻节点间传送帧，每一帧都包含数据和必要的控制信息（如同步信息、地址信息、差错控制等）。</p>
</li>
<li><p>**物理层 (physical Layer)**：确保数据可以在各种物理媒介上进行传输，为数据的传输提供可靠的环境。</p>
</li>
</ul>
<p>从上图中可以看出，<code>TCP/IP</code>模型比<code>OSI</code>模型更加简洁，它把<code>应用层/表示层/会话层</code>全部整合为了<code>应用层</code>。</p>
<p>在每一层都工作着不同的设备，比如我们常用的交换机就工作在数据链路层的，一般的路由器是工作在网络层的。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604025001463-47398363-0ab1-4bcf-b247-5d3d76ce117a.webp"  ><span class="image-caption">image</span></p>
<p>在每一层实现的协议也各不同，即每一层的服务也不同，下图列出了每层主要的传输协议：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/webp/1500604/1604025001203-7b104c36-1453-475e-a282-ff2e9cb19e2c.webp"  ><span class="image-caption">image</span></p>
<p>同样，<code>TCP/IP</code>五层协议的通信方式也是对等通信：</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604065635582-1a4e62ba-bdfa-45db-8a56-0302ff9a8020.png"  ><span class="image-caption">image.png</span></p>
<h2 id="六、TCP与UDP"><a href="#六、TCP与UDP" class="headerlink" title="六、TCP与UDP"></a>六、TCP与UDP</h2><h3 id="1-TCP-和-UDP的概念及特点"><a href="#1-TCP-和-UDP的概念及特点" class="headerlink" title="1. TCP 和 UDP的概念及特点"></a>1. TCP 和 UDP的概念及特点</h3><p>TCP 和 UDP都是传输层协议，他们都属于TCP&#x2F;IP协议族：</p>
<p><strong>（1）UDP</strong></p>
<p>UDP的全称是<strong>用户数据报协议</strong>，在网络中它与TCP协议一样用于处理数据包，是一种无连接的协议。在OSI模型中，在传输层，处于IP协议的上一层。UDP有不提供数据包分组、组装和不能对数据包进行排序的缺点，也就是说，当报文发送之后，是无法得知其是否安全完整到达的。</p>
<p>它的特点如下：</p>
<p><strong>1）面向无连接</strong></p>
<p>首先 UDP 是不需要和 TCP一样在发送数据前进行三次握手建立连接的，想发数据就可以开始发送了。并且也只是数据报文的搬运工，不会对数据报文进行任何拆分和拼接操作。</p>
<p>具体来说就是：</p>
<ul>
<li>在发送端，应用层将数据传递给传输层的 UDP 协议，UDP 只会给数据增加一个 UDP 头标识下是 UDP 协议，然后就传递给网络层了</li>
<li>在接收端，网络层将数据传递给传输层，UDP 只去除 IP 报文头就传递给应用层，不会任何拼接操作</li>
</ul>
<p><strong>2）有单播，多播，广播的功能</strong></p>
<p>UDP 不止支持一对一的传输方式，同样支持一对多，多对多，多对一的方式，也就是说 UDP 提供了单播，多播，广播的功能。</p>
<p><strong>3）面向报文</strong></p>
<p>发送方的UDP对应用程序交下来的报文，在添加首部后就向下交付IP层。UDP对应用层交下来的报文，既不合并，也不拆分，而是保留这些报文的边界。因此，应用程序必须选择合适大小的报文</p>
<p><strong>4）不可靠性</strong></p>
<p>首先不可靠性体现在无连接上，通信都不需要建立连接，想发就发，这样的情况肯定不可靠。</p>
<p>并且收到什么数据就传递什么数据，并且也不会备份数据，发送数据也不会关心对方是否已经正确接收到数据了。</p>
<p>再者网络环境时好时坏，但是 UDP 因为没有拥塞控制，一直会以恒定的速度发送数据。即使网络条件不好，也不会对发送速率进行调整。这样实现的弊端就是在网络条件不好的情况下可能会导致丢包，但是优点也很明显，在某些实时性要求高的场景（比如电话会议）就需要使用 UDP 而不是 TCP。</p>
<p><strong>5）头部开销小，传输数据报文时是很高效的。</strong></p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023358917-72134998-53bd-4d9c-b71f-7a762dff31a9.png"  ><span class="image-caption">image</span></p>
<p>UDP 头部包含了以下几个数据：</p>
<ul>
<li>两个十六位的端口号，分别为源端口（可选字段）和目标端口</li>
<li>整个数据报文的长度</li>
<li>整个数据报文的检验和（IPv4 可选字段），该字段用于发现头部信息和数据中的错误</li>
</ul>
<p>因此 UDP 的头部开销小，只有8字节，相比 TCP 的至少20字节要少得多，在传输数据报文时是很高效的。</p>
<p><strong>（2）TCP</strong></p>
<p>TCP的全称是传输控制协议是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP 是面向连接的、可靠的流协议（流就是指不间断的数据结构）。</p>
<p>它有以下几个特点：</p>
<p><strong>1）面向连接</strong></p>
<p>面向连接，是指发送数据之前必须在两端建立连接。建立连接的方法是“三次握手”，这样能建立可靠的连接。建立连接，是为数据的可靠传输打下了基础。</p>
<p><strong>2）仅支持单播传输</strong></p>
<p>每条TCP传输连接只能有两个端点，只能进行点对点的数据传输，不支持多播和广播传输方式。</p>
<p><strong>3）面向字节流</strong></p>
<p>TCP不像UDP一样那样一个个报文独立地传输，而是在不保留报文边界的情况下以字节流方式进行传输。</p>
<p><strong>4）可靠传输</strong></p>
<p>对于可靠传输，判断丢包、误码靠的是TCP的段编号以及确认号。TCP为了保证报文传输的可靠，就给每个包一个序号，同时序号也保证了传送到接收端实体的包的按序接收。然后接收端实体对已成功收到的字节发回一个相应的确认(ACK)；如果发送端实体在合理的往返时延(RTT)内未收到确认，那么对应的数据（假设丢失了）将会被重传。</p>
<p><strong>5）提供拥塞控制</strong></p>
<p>当网络出现拥塞的时候，TCP能够减小向网络注入数据的速率和数量，缓解拥塞。</p>
<p><strong>6）提供全双工通信</strong></p>
<p>TCP允许通信双方的应用程序在任何时候都能发送数据，因为TCP连接的两端都设有缓存，用来临时存放双向通信的数据。当然，TCP可以立即发送一个数据段，也可以缓存一段时间以便一次发送更多的数据段（最大的数据段大小取决于MSS）</p>
<h3 id="2-TCP和UDP的区别"><a href="#2-TCP和UDP的区别" class="headerlink" title="2. TCP和UDP的区别"></a>2. TCP和UDP的区别</h3><table>
<thead>
<tr>
<th></th>
<th>UDP</th>
<th>TCP</th>
</tr>
</thead>
<tbody><tr>
<td>是否连接</td>
<td>无连接</td>
<td>面向连接</td>
</tr>
<tr>
<td>是否可靠</td>
<td>不可靠传输，不使用流量控制和拥塞控制</td>
<td>可靠传输（数据顺序和正确性），使用流量控制和拥塞控制</td>
</tr>
<tr>
<td>连接对象个数</td>
<td>支持一对一，一对多，多对一和多对多交互通信</td>
<td>只能是一对一通信</td>
</tr>
<tr>
<td>传输方式</td>
<td>面向报文</td>
<td>面向字节流</td>
</tr>
<tr>
<td>首部开销</td>
<td>首部开销小，仅8字节</td>
<td>首部最小20字节，最大60字节</td>
</tr>
<tr>
<td>适用场景</td>
<td>适用于实时应用，例如视频会议、直播</td>
<td>适用于要求可靠传输的应用，例如文件传输</td>
</tr>
</tbody></table>
<h3 id="3-TCP和UDP的使用场景"><a href="#3-TCP和UDP的使用场景" class="headerlink" title="3. TCP和UDP的使用场景"></a>3. TCP和UDP的使用场景</h3><ul>
<li><strong>TCP应用场景：</strong> 效率要求相对低，但对准确性要求相对高的场景。因为传输中需要对数据确认、重发、排序等操作，相比之下效率没有UDP高。例如：文件传输（准确高要求高、但是速度可以相对慢）、接受邮件、远程登录。</li>
<li><strong>UDP应用场景：</strong> 效率要求相对高，对准确性要求相对低的场景。例如：QQ聊天、在线视频、网络语音电话（即时通讯，速度要求高，但是出现偶尔断续不是太大问题，并且此处完全不可以使用重发机制）、广播通信（广播、多播）。</li>
</ul>
<h3 id="4-UDP协议为什么不可靠？"><a href="#4-UDP协议为什么不可靠？" class="headerlink" title="4. UDP协议为什么不可靠？"></a>4. UDP协议为什么不可靠？</h3><p>UDP在传输数据之前不需要先建立连接，远地主机的运输层在接收到UDP报文后，不需要确认，提供不可靠交付。总结就以下四点：</p>
<ul>
<li>不保证消息交付：不确认，不重传，无超时</li>
<li>不保证交付顺序：不设置包序号，不重排，不会发生队首阻塞</li>
<li>不跟踪连接状态：不必建立连接或重启状态机</li>
<li>不进行拥塞控制：不内置客户端或网络反馈机制</li>
</ul>
<h3 id="5-TCP的重传机制"><a href="#5-TCP的重传机制" class="headerlink" title="5. TCP的重传机制"></a>5. TCP的重传机制</h3><p>由于TCP的下层网络（网络层）可能出现<strong>丢失、重复或失序</strong>的情况，TCP协议提供可靠数据传输服务。为保证数据传输的正确性，TCP会重传其认为已丢失（包括报文中的比特错误）的包。TCP使用两套独立的机制来完成重传，一是<strong>基于时间</strong>，二是<strong>基于确认信息</strong>。</p>
<p>TCP在发送一个数据之后，就开启一个定时器，若是在这个时间内没有收到发送数据的ACK确认报文，则对该报文进行重传，在达到一定次数还没有成功时放弃并发送一个复位信号。</p>
<h3 id="6-TCP的拥塞控制机制"><a href="#6-TCP的拥塞控制机制" class="headerlink" title="6. TCP的拥塞控制机制"></a>6. TCP的拥塞控制机制</h3><p>TCP的拥塞控制机制主要是以下四种机制：</p>
<ul>
<li>慢启动（慢开始）</li>
<li>拥塞避免</li>
<li>快速重传</li>
<li>快速恢复</li>
</ul>
<p><strong>（1）慢启动（慢开始）</strong></p>
<ul>
<li><p>在开始发送的时候设置cwnd &#x3D; 1（cwnd指的是拥塞窗口）</p>
</li>
<li><p>思路：开始的时候不要发送大量数据，而是先测试一下网络的拥塞程度，由小到大增加拥塞窗口的大小。</p>
</li>
<li><p>为了防止cwnd增长过大引起网络拥塞，设置一个慢开始门限(ssthresh 状态变量)</p>
</li>
<li><ul>
<li>当cnwd &lt; ssthresh，使用慢开始算法</li>
<li>当cnwd &#x3D; ssthresh，既可使用慢开始算法，也可以使用拥塞避免算法</li>
<li>当cnwd &gt; ssthresh，使用拥塞避免算法</li>
</ul>
</li>
</ul>
<p><strong>（2）拥塞避免</strong></p>
<ul>
<li><p>拥塞避免未必能够完全避免拥塞，是说在拥塞避免阶段将拥塞窗口控制为按线性增长，使网络不容易出现阻塞。</p>
</li>
<li><p>思路： 让拥塞窗口cwnd缓慢的增大，即每经过一个返回时间RTT就把发送方的拥塞控制窗口加一</p>
</li>
<li><p>无论是在慢开始阶段还是在拥塞避免阶段，只要发送方判断网络出现拥塞，就把慢开始门限设置为出现拥塞时的发送窗口大小的一半。然后把拥塞窗口设置为1，执行慢开始算法。如图所示:<br><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952123-62276cba-d882-46c9-8a1c-70655dc501af.png"  ><span class="image-caption">image</span></p>
</li>
<li><p>其中，判断网络出现拥塞的根据就是没有收到确认，虽然没有收到确认可能是其他原因的分组丢失，但是因为无法判定，所以都当做拥塞来处理。</p>
</li>
</ul>
<p><strong>（3）快速重传</strong></p>
<ul>
<li>快重传要求接收方在收到一个失序的报文段后就立即发出重复确认(为的是使发送方及早知道有报文段没有到达对方)。发送方只要连续收到三个重复确认就立即重传对方尚未收到的报文段，而不必继续等待设置的重传计时器时间到期。</li>
<li>由于不需要等待设置的重传计时器到期，能尽早重传未被确认的报文段，能提高整个网络的吞吐量</li>
</ul>
<p><strong>（4）快速恢复</strong></p>
<ul>
<li>当发送方连续收到三个重复确认时，就执行“乘法减小”算法，把ssthresh门限减半。但是接下去并不执行慢开始算法。</li>
<li>考虑到如果网络出现拥塞的话就不会收到好几个重复的确认，所以发送方现在认为网络可能没有出现拥塞。所以此时不执行慢开始算法，而是将cwnd设置为ssthresh的大小，然后执行拥塞避免算法。<br><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604022952153-a7106d22-225d-4081-9b0a-56b0d1876bc2.png"  ><span class="image-caption">image</span></li>
</ul>
<h3 id="7-TCP的流量控制机制"><a href="#7-TCP的流量控制机制" class="headerlink" title="7. TCP的流量控制机制"></a>7. TCP的流量控制机制</h3><p>一般来说，流量控制就是为了让发送方发送数据的速度不要太快，要让接收方来得及接收。TCP采用大小可变的<strong>滑动窗口</strong>进行流量控制，窗口大小的单位是字节。这里说的窗口大小其实就是每次传输的数据大小。</p>
<ul>
<li>当一个连接建立时，连接的每一端分配一个缓冲区来保存输入的数据，并将缓冲区的大小发送给另一端。</li>
<li>当数据到达时，接收方发送确认，其中包含了自己剩余的缓冲区大小。（剩余的缓冲区空间的大小被称为窗口，指出窗口大小的通知称为窗口通告 。接收方在发送的每一确认中都含有一个窗口通告。）</li>
<li>如果接收方应用程序读数据的速度能够与数据到达的速度一样快，接收方将在每一确认中发送一个正的窗口通告。</li>
<li>如果发送方操作的速度快于接收方，接收到的数据最终将充满接收方的缓冲区，导致接收方通告一个零窗口 。发送方收到一个零窗口通告时，必须停止发送，直到接收方重新通告一个正的窗口。</li>
</ul>
<h3 id="8-TCP的可靠传输机制"><a href="#8-TCP的可靠传输机制" class="headerlink" title="8. TCP的可靠传输机制"></a>8. TCP的可靠传输机制</h3><p>TCP 的可靠传输机制是基于连续 ARQ 协议和滑动窗口协议的。</p>
<p>TCP 协议在发送方维持了一个发送窗口，发送窗口以前的报文段是已经发送并确认了的报文段，发送窗口中包含了已经发送但 未确认的报文段和允许发送但还未发送的报文段，发送窗口以后的报文段是缓存中还不允许发送的报文段。当发送方向接收方发 送报文时，会依次发送窗口内的所有报文段，并且设置一个定时器，这个定时器可以理解为是最早发送但未收到确认的报文段。 如果在定时器的时间内收到某一个报文段的确认回答，则滑动窗口，将窗口的首部向后滑动到确认报文段的后一个位置，此时如 果还有已发送但没有确认的报文段，则重新设置定时器，如果没有了则关闭定时器。如果定时器超时，则重新发送所有已经发送 但还未收到确认的报文段，并将超时的间隔设置为以前的两倍。当发送方收到接收方的三个冗余的确认应答后，这是一种指示， 说明该报文段以后的报文段很有可能发生丢失了，那么发送方会启用快速重传的机制，就是当前定时器结束前，发送所有的已发 送但确认的报文段。</p>
<p>接收方使用的是累计确认的机制，对于所有按序到达的报文段，接收方返回一个报文段的肯定回答。如果收到了一个乱序的报文 段，那么接方会直接丢弃，并返回一个最近的按序到达的报文段的肯定回答。使用累计确认保证了返回的确认号之前的报文段都 已经按序到达了，所以发送窗口可以移动到已确认报文段的后面。</p>
<p>发送窗口的大小是变化的，它是由接收窗口剩余大小和网络中拥塞程度来决定的，TCP 就是通过控制发送窗口的长度来控制报文 段的发送速率。</p>
<p>但是 TCP 协议并不完全和滑动窗口协议相同，因为许多的 TCP 实现会将失序的报文段给缓存起来，并且发生重传时，只会重 传一个报文段，因此 TCP 协议的可靠传输机制更像是窗口滑动协议和选择重传协议的一个混合体。</p>
<h3 id="9-TCP的三次握手和四次挥手"><a href="#9-TCP的三次握手和四次挥手" class="headerlink" title="9. TCP的三次握手和四次挥手"></a>9. TCP的三次握手和四次挥手</h3><h4 id="（1）三次握手"><a href="#（1）三次握手" class="headerlink" title="（1）三次握手"></a>（1）三次握手</h4><p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663256-5eb6dcdf-fdb6-4b67-a3da-da15c1d396fb.png"  ><span class="image-caption">image</span></p>
<p>三次握手（Three-way Handshake）其实就是指建立一个TCP连接时，需要客户端和服务器总共发送3个包。进行三次握手的主要作用就是为了确认双方的接收能力和发送能力是否正常、指定自己的初始化序列号为后面的可靠性传送做准备。实质上其实就是连接服务器指定端口，建立TCP连接，并同步连接双方的序列号和确认号，交换TCP窗口大小信息。</p>
<p>刚开始客户端处于 Closed 的状态，服务端处于 Listen 状态。</p>
<ul>
<li>第一次握手：客户端给服务端发一个 SYN 报文，并指明客户端的初始化序列号 ISN，此时客户端处于 SYN_SEND 状态。</li>
</ul>
<blockquote>
<p>首部的同步位SYN&#x3D;1，初始序号seq&#x3D;x，SYN&#x3D;1的报文段不能携带数据，但要消耗掉一个序号。</p>
</blockquote>
<ul>
<li>第二次握手：服务器收到客户端的 SYN 报文之后，会以自己的 SYN 报文作为应答，并且也是指定了自己的初始化序列号 ISN。同时会把客户端的 ISN + 1 作为ACK 的值，表示自己已经收到了客户端的 SYN，此时服务器处于 SYN_REVD 的状态。</li>
</ul>
<blockquote>
<p>在确认报文段中SYN&#x3D;1，ACK&#x3D;1，确认号ack&#x3D;x+1，初始序号seq&#x3D;y</p>
</blockquote>
<ul>
<li>第三次握手：客户端收到 SYN 报文之后，会发送一个 ACK 报文，当然，也是一样把服务器的 ISN + 1 作为 ACK 的值，表示已经收到了服务端的 SYN 报文，此时客户端处于 ESTABLISHED 状态。服务器收到 ACK 报文之后，也处于 ESTABLISHED 状态，此时，双方已建立起了连接。</li>
</ul>
<blockquote>
<p>确认报文段ACK&#x3D;1，确认号ack&#x3D;y+1，序号seq&#x3D;x+1（初始为seq&#x3D;x，第二个报文段所以要+1），ACK报文段可以携带数据，不携带数据则不消耗序号。</p>
</blockquote>
<p><strong>那为什么要三次握手呢？两次不行吗？</strong></p>
<ul>
<li>为了确认双方的接收能力和发送能力都正常</li>
<li>如果是用两次握手，则会出现下面这种情况：</li>
</ul>
<blockquote>
<p>如客户端发出连接请求，但因连接请求报文丢失而未收到确认，于是客户端再重传一次连接请求。后来收到了确认，建立了连接。数据传输完毕后，就释放了连接，客户端共发出了两个连接请求报文段，其中第一个丢失，第二个到达了服务端，但是第一个丢失的报文段只是在某些网络结点长时间滞留了，延误到连接释放以后的某个时间才到达服务端，此时服务端误认为客户端又发出一次新的连接请求，于是就向客户端发出确认报文段，同意建立连接，不采用三次握手，只要服务端发出确认，就建立新的连接了，此时客户端忽略服务端发来的确认，也不发送数据，则服务端一致等待客户端发送数据，浪费资源。</p>
</blockquote>
<p><strong>简单来说就是以下三步：</strong></p>
<ul>
<li><strong>第一次握手：</strong>客户端向服务端发送连接请求报文段。该报文段中包含自身的数据通讯初始序号。请求发送后，客户端便进入 SYN-SENT 状态。</li>
<li><strong>第二次握手：</strong>服务端收到连接请求报文段后，如果同意连接，则会发送一个应答，该应答中也会包含自身的数据通讯初始序号，发送完成后便进入 SYN-RECEIVED 状态。</li>
<li><strong>第三次握手：</strong>当客户端收到连接同意的应答后，还要向服务端发送一个确认报文。客户端发完这个报文段后便进入 ESTABLISHED 状态，服务端收到这个应答后也进入 ESTABLISHED 状态，此时连接建立成功。</li>
</ul>
<p>TCP 三次握手的建立连接的过程就是相互确认初始序号的过程，告诉对方，什么样序号的报文段能够被正确接收。 第三次握手的作用是客户端对服务器端的初始序号的确认。如果只使用两次握手，那么服务器就没有办法知道自己的序号是否 已被确认。同时这样也是为了防止失效的请求报文段被服务器接收，而出现错误的情况。</p>
<h4 id="（2）四次挥手"><a href="#（2）四次挥手" class="headerlink" title="（2）四次挥手"></a>（2）四次挥手</h4><p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1604023663279-0ea063ba-a06b-4f57-9aa9-0e2d1c8d373c.png"  ><span class="image-caption">image</span></p>
<p>刚开始双方都处于 ESTABLISHED 状态，假如是客户端先发起关闭请求。四次挥手的过程如下：</p>
<ul>
<li>第一次挥手： 客户端会发送一个 FIN 报文，报文中会指定一个序列号。此时客户端处于 FIN_WAIT1 状态。</li>
</ul>
<blockquote>
<p>即发出连接释放报文段（FIN&#x3D;1，序号seq&#x3D;u），并停止再发送数据，主动关闭TCP连接，进入FIN_WAIT1（终止等待1）状态，等待服务端的确认。</p>
</blockquote>
<ul>
<li>第二次挥手：服务端收到 FIN 之后，会发送 ACK 报文，且把客户端的序列号值 +1 作为 ACK 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 CLOSE_WAIT 状态。</li>
</ul>
<blockquote>
<p>即服务端收到连接释放报文段后即发出确认报文段（ACK&#x3D;1，确认号ack&#x3D;u+1，序号seq&#x3D;v），服务端进入CLOSE_WAIT（关闭等待）状态，此时的TCP处于半关闭状态，客户端到服务端的连接释放。客户端收到服务端的确认后，进入FIN_WAIT2（终止等待2）状态，等待服务端发出的连接释放报文段。</p>
</blockquote>
<ul>
<li>第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 FIN 报文，且指定一个序列号。此时服务端处于 LAST_ACK 的状态。</li>
</ul>
<blockquote>
<p>即服务端没有要向客户端发出的数据，服务端发出连接释放报文段（FIN&#x3D;1，ACK&#x3D;1，序号seq&#x3D;w，确认号ack&#x3D;u+1），服务端进入LAST_ACK（最后确认）状态，等待客户端的确认。</p>
</blockquote>
<ul>
<li>第四次挥手：客户端收到 FIN 之后，一样发送一个 ACK 报文作为应答，且把服务端的序列号值 +1 作为自己 ACK 报文的序列号值，此时客户端处于 TIME_WAIT 状态。需要过一阵子以确保服务端收到自己的 ACK 报文之后才会进入 CLOSED 状态，服务端收到 ACK 报文之后，就处于关闭连接了，处于 CLOSED 状态。</li>
</ul>
<blockquote>
<p>即客户端收到服务端的连接释放报文段后，对此发出确认报文段（ACK&#x3D;1，seq&#x3D;u+1，ack&#x3D;w+1），客户端进入TIME_WAIT（时间等待）状态。此时TCP未释放掉，需要经过时间等待计时器设置的时间2MSL后，客户端才进入CLOSED状态。</p>
</blockquote>
<p><strong>那为什么需要四次挥手呢？</strong></p>
<blockquote>
<p>因为当服务端收到客户端的SYN连接请求报文后，可以直接发送SYN+ACK报文。其中ACK报文是用来应答的，SYN报文是用来同步的。但是关闭连接时，当服务端收到FIN报文时，很可能并不会立即关闭SOCKET，所以只能先回复一个ACK报文，告诉客户端，“你发的FIN报文我收到了”。只有等到我服务端所有的报文都发送完了，我才能发送FIN报文，因此不能一起发送，故需要四次挥手。</p>
</blockquote>
<p><strong>简单来说就是以下四步：</strong></p>
<ul>
<li><strong>第一次<strong><strong>挥手</strong></strong>：</strong>若客户端认为数据发送完成，则它需要向服务端发送连接释放请求。</li>
<li><strong>第二次****挥手</strong>：服务端收到连接释放请求后，会告诉应用层要释放 TCP 链接。然后会发送 ACK 包，并进入 CLOSE_WAIT 状态，此时表明客户端到服务端的连接已经释放，不再接收客户端发的数据了。但是因为 TCP 连接是双向的，所以服务端仍旧可以发送数据给客户端。</li>
<li><strong>第三次挥手</strong>：服务端如果此时还有没发完的数据会继续发送，完毕后会向客户端发送连接释放请求，然后服务端便进入 LAST-ACK 状态。</li>
<li><strong>第四次<strong><strong>挥手</strong></strong>：</strong>客户端收到释放请求后，向服务端发送确认应答，此时客户端进入 TIME-WAIT 状态。该状态会持续 2MSL（最大段生存期，指报文段在网络中生存的时间，超时会被抛弃） 时间，若该时间段内没有服务端的重发请求的话，就进入 CLOSED 状态。当服务端收到确认应答后，也便进入 CLOSED 状态。</li>
</ul>
<p>TCP 使用四次挥手的原因是因为 TCP 的连接是全双工的，所以需要双方分别释放到对方的连接，单独一方的连接释放，只代 表不能再向对方发送数据，连接处于的是半释放的状态。</p>
<p>最后一次挥手中，客户端会等待一段时间再关闭的原因，是为了防止发送给服务器的确认报文段丢失或者出错，从而导致服务器 端不能正常关闭。</p>
<h3 id="10-TCP粘包是怎么回事，如何处理"><a href="#10-TCP粘包是怎么回事，如何处理" class="headerlink" title="10. TCP粘包是怎么回事，如何处理**?**"></a>10. <strong>TCP</strong>粘包是怎么回事，如何处理**?**</h3><p>默认情况下, TCP 连接会启⽤延迟传送算法 (Nagle 算法), 在数据发送之前缓存他们. 如果短时间有多个数据发送, 会缓冲到⼀起作⼀次发送 (缓冲⼤⼩⻅ socket.bufferSize ), 这样可以减少 IO 消耗提⾼性能. </p>
<p>如果是传输⽂件的话, 那么根本不⽤处理粘包的问题, 来⼀个包拼⼀个包就好了。但是如果是多条消息, 或者是别的⽤途的数据那么就需要处理粘包. </p>
<p>下面看⼀个例⼦, 连续调⽤两次 send 分别发送两段数据 data1 和 data2, 在接收端有以下⼏种常⻅的情况: </p>
<p>A. 先接收到 data1, 然后接收到 data2 . </p>
<p>B. 先接收到 data1 的部分数据, 然后接收到 data1 余下的部分以及 data2 的全部. </p>
<p>C. 先接收到了 data1 的全部数据和 data2 的部分数据, 然后接收到了 data2 的余下的数据. </p>
<p>D. ⼀次性接收到了 data1 和 data2 的全部数据. </p>
<p>其中的 BCD 就是我们常⻅的粘包的情况. ⽽对于处理粘包的问题, 常⻅的解决⽅案有: </p>
<ul>
<li><strong>多次发送之前间隔⼀个等待时间</strong>：只需要等上⼀段时间再进⾏下⼀次 send 就好, 适⽤于交互频率特别低的场景. 缺点也很明显, 对于⽐较频繁的场景⽽⾔传输效率实在太低，不过⼏乎不⽤做什么处理. </li>
<li><strong>关闭</strong> <strong>Nagle</strong> <strong>算法</strong>：关闭 Nagle 算法, 在 Node.js 中你可以通过 socket.setNoDelay() ⽅法来关闭 Nagle 算法, 让每⼀次 send 都不缓冲直接发送。该⽅法⽐较适⽤于每次发送的数据都⽐较⼤ (但不是⽂件那么⼤), 并且频率不是特别⾼的场景。如果是每次发送的数据量⽐较⼩, 并且频率特别⾼的, 关闭 Nagle 纯属⾃废武功。另外, 该⽅法不适⽤于⽹络较差的情况, 因为 Nagle 算法是在服务端进⾏的包合并情况, 但是如果短时间内客户端的⽹络情况不好, 或者应⽤层由于某些原因不能及时将 TCP 的数据 recv, 就会造成多个包在客户端缓冲从⽽粘包的情况。 (如果是在稳定的机房内部通信那么这个概率是⽐较⼩可以选择忽略的)  </li>
<li><strong>进⾏封包</strong><strong>&#x2F;拆包：</strong>封包&#x2F;拆包是⽬前业内常⻅的解决⽅案了。即给每个数据包在发送之前, 于其前&#x2F;后放⼀些有特征的数据, 然后收到数据的时 候根据特征数据分割出来各个数据包。</li>
</ul>
<h3 id="11-为什么udp不会粘包？"><a href="#11-为什么udp不会粘包？" class="headerlink" title="11. 为什么udp不会粘包？"></a>11. 为什么<strong>udp</strong>不会粘包？</h3><ul>
<li>TCP协议是⾯向流的协议，UDP是⾯向消息的协议。UDP段都是⼀条消息，应⽤程序必须以消息为单位提取数据，不能⼀次提取任意字节的数据 </li>
<li>UDP具有保护消息边界，在每个UDP包中就有了消息头（消息来源地址，端⼝等信息），这样对于接收端来说就容易进⾏区分处理了。传输协议把数据当作⼀条独⽴的消息在⽹上传输，接收端只能接收独⽴的消息。接收端⼀次只能接收发送端发出的⼀个数据包,如果⼀次接受数据的⼤⼩⼩于发送端⼀次发送的数据⼤⼩，就会丢失⼀部分数据，即使丢失，接受端也不会分两次去接收。</li>
</ul>
<h2 id="七、WebSocket"><a href="#七、WebSocket" class="headerlink" title="七、WebSocket"></a>七、WebSocket</h2><h3 id="1-对-WebSocket-的理解"><a href="#1-对-WebSocket-的理解" class="headerlink" title="1. 对 WebSocket 的理解"></a>1. 对 WebSocket 的理解</h3><p>WebSocket是HTML5提供的一种浏览器与服务器进行<strong>全双工通讯</strong>的网络技术，属于应用层协议。它基于TCP传输协议，并复用HTTP的握手通道。浏览器和服务器只需要完成一次握手，两者之间就直接可以创建持久性的连接， 并进行双向数据传输。</p>
<p>WebSocket 的出现就解决了半双工通信的弊端。它最大的特点是：<strong>服务器可以向客户端主动推动消息，客户端也可以主动向服务器推送消息。</strong></p>
<p><strong>WebSocket原理</strong>：客户端向 WebSocket 服务器通知（notify）一个带有所有接收者ID（recipients IDs）的事件（event），服务器接收后立即通知所有活跃的（active）客户端，只有ID在接收者ID序列中的客户端才会处理这个事件。</p>
<p><strong>WebSocket 特点的如下：</strong></p>
<ul>
<li>支持双向通信，实时性更强</li>
<li>可以发送文本，也可以发送二进制数据‘’</li>
<li>建立在TCP协议之上，服务端的实现比较容易</li>
<li>数据格式比较轻量，性能开销小，通信高效</li>
<li>没有同源限制，客户端可以与任意服务器通信</li>
<li>协议标识符是ws（如果加密，则为wss），服务器网址就是 URL</li>
<li>与 HTTP 协议有着良好的兼容性。默认端口也是80和443，并且握手阶段采用 HTTP 协议，因此握手时不容易屏蔽，能通过各种 HTTP 代理服务器。</li>
</ul>
<p><strong>Websocket的使用方法如下：</strong></p>
<p>在客户端中：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// 在index.html中直接写WebSocket，设置服务端的端口号为 9999</span><br>let ws = <span class="hljs-keyword">new</span> WebSocket(<span class="hljs-string">&#x27;ws://localhost:9999&#x27;</span>);<br><span class="hljs-comment">// 在客户端与服务端建立连接后触发</span><br>ws.onopen = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Connection open.&quot;</span>); <br>    ws.send(<span class="hljs-string">&#x27;hello&#x27;</span>);<br>&#125;;<br><span class="hljs-comment">// 在服务端给客户端发来消息的时候触发</span><br>ws.onmessage = <span class="hljs-keyword">function</span>(<span class="hljs-params">res</span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);       <span class="hljs-comment">// 打印的是MessageEvent对象</span><br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res.data);  <span class="hljs-comment">// 打印的是收到的消息</span><br>&#125;;<br><span class="hljs-comment">// 在客户端与服务端建立关闭后触发</span><br>ws.onclose = <span class="hljs-keyword">function</span>(<span class="hljs-params">evt</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;Connection closed.&quot;</span>);<br>&#125;; <br></code></pre></td></tr></table></figure>

<h3 id="2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？"><a href="#2-即时通讯的实现：短轮询、长轮询、SSE-和-WebSocket-间的区别？" class="headerlink" title="2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？"></a>2. 即时通讯的实现：短轮询、长轮询、SSE 和 WebSocket 间的区别？</h3><p>短轮询和长轮询的目的都是用于实现客户端和服务器端的一个即时通讯。</p>
<p><strong>短轮询的基本思路：</strong>浏览器每隔一段时间向浏览器发送 http 请求，服务器端在收到请求后，不论是否有数据更新，都直接进行响应。这种方式实现的即时通信，本质上还是浏览器发送请求，服务器接受请求的一个过程，通过让客户端不断的进行请求，使得客户端能够模拟实时地收到服务器端的数据的变化。这种方式的优点是比较简单，易于理解。缺点是这种方式由于需要不断的建立 http 连接，严重浪费了服务器端和客户端的资源。当用户增加时，服务器端的压力就会变大，这是很不合理的。</p>
<p><strong>长轮询的基本思路：</strong>首先由客户端向服务器发起请求，当服务器收到客户端发来的请求后，服务器端不会直接进行响应，而是先将这个请求挂起，然后判断服务器端数据是否有更新。如果有更新，则进行响应，如果一直没有数据，则到达一定的时间限制才返回。客户端 JavaScript 响应处理函数会在处理完服务器返回的信息后，再次发出请求，重新建立连接。长轮询和短轮询比起来，它的优点是明显减少了很多不必要的 http 请求次数，相比之下节约了资源。长轮询的缺点在于，连接挂起也会导致资源的浪费。</p>
<p><strong>SSE 的基本思想：</strong>服务器使用流信息向服务器推送信息。严格地说，http 协议无法做到服务器主动推送信息。但是，有一种变通方法，就是服务器向客户端声明，接下来要发送的是流信息。也就是说，发送的不是一次性的数据包，而是一个数据流，会连续不断地发送过来。这时，客户端不会关闭连接，会一直等着服务器发过来的新的数据流，视频播放就是这样的例子。SSE 就是利用这种机制，使用流信息向浏览器推送信息。它基于 http 协议，目前除了 IE&#x2F;Edge，其他浏览器都支持。它相对于前面两种方式来说，不需要建立过多的 http 请求，相比之下节约了资源。</p>
<p><strong>WebSocket</strong> 是 HTML5 定义的一个新协议议，与传统的 http 协议不同，该协议允许由服务器主动的向客户端推送信息。使用 WebSocket 协议的缺点是在服务器端的配置比较复杂。WebSocket 是一个全双工的协议，也就是通信双方是平等的，可以相互发送消息，而 SSE 的方式是单向通信的，只能由服务器端向客户端推送信息，如果客户端需要发送信息就是属于下一个 http 请求了。</p>
<p><strong>上面的四个通信协议，前三个都是基于HTTP协议的。</strong></p>
<p>对于这四种即使通信协议，从性能的角度来看：</p>
<p><strong>WebSocket &gt; 长连接（SEE） &gt; 长轮询 &gt; 短轮询</strong></p>
<p>但是，我们如果考虑浏览器的兼容性问题，顺序就恰恰相反了：</p>
<p><strong>短轮询 &gt; 长轮询 &gt; 长连接（SEE） &gt; WebSocket</strong></p>
<p>所以，还是要根据具体的使用场景来判断使用哪种方式。</p>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>手写代码</title>
    <url>/2022/08/22/handwritten%20code/</url>
    <content><![CDATA[<h2 id="手写代码"><a href="#手写代码" class="headerlink" title="手写代码"></a>手写代码</h2><span id="more"></span>

<p><img  src="/images/image/code.png"  ><span class="image-caption">手写代码面试题.png</span></p>
<h2 id="一、JavaScript-基础"><a href="#一、JavaScript-基础" class="headerlink" title="一、JavaScript 基础"></a>一、JavaScript 基础</h2><h3 id="1-手写-Object-create"><a href="#1-手写-Object-create" class="headerlink" title="1. 手写 Object.create"></a>1. 手写 Object.create</h3><p>思路：将传入的对象作为原型</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">create</span>(obj) &#123;<br>  <span class="hljs-keyword">function</span> <span class="hljs-title">F</span>() &#123;&#125;<br>  F.prototype = obj<br>  <span class="hljs-keyword">return</span> <span class="hljs-type">new</span> F()<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-手写-instanceof-方法"><a href="#2-手写-instanceof-方法" class="headerlink" title="2. 手写 instanceof 方法"></a>2. 手写 instanceof 方法</h3><p>instanceof 运算符用于判断构造函数的 prototype 属性是否出现在对象的原型链中的任何位置。</p>
<p>实现步骤：</p>
<ol>
<li>首先获取类型的原型</li>
<li>然后获得对象的原型</li>
<li>然后一直循环判断对象的原型是否等于类型的原型，直到对象原型为 <code>null</code>，因为原型链最终为 <code>null</code></li>
</ol>
<p>具体实现：</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">Instanceof(<span class="hljs-params">left</span>, <span class="hljs-params">right</span>)</span> &#123;<br>  <span class="hljs-keyword">let</span> proto = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">left</span>)</span>, <span class="hljs-comment">// 获取对象的原型</span><br>      prototype = right.prototype; <span class="hljs-comment">// 获取构造函数的 prototype 对象</span><br><br>  <span class="hljs-comment">// 判断构造函数的 prototype 对象是否在对象的原型链上</span><br>  <span class="hljs-keyword">while</span> (<span class="hljs-literal">true</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!proto) return <span class="hljs-literal">false</span>;<br>    <span class="hljs-keyword">if</span> (proto<span class="hljs-operator"> === </span>prototype) return <span class="hljs-literal">true</span>;<br><br>    proto = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Object</span>.</span></span>get<span class="hljs-constructor">PrototypeOf(<span class="hljs-params">proto</span>)</span>;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-手写-new-操作符"><a href="#3-手写-new-操作符" class="headerlink" title="3. 手写 new 操作符"></a>3. 手写 new 操作符</h3><p>在调用 <code>new</code> 的过程中会发生以上四件事情：</p>
<p>（1）首先创建了一个新的空对象</p>
<p>（2）设置原型，将对象的原型设置为函数的 prototype 对象。</p>
<p>（3）让函数的 this 指向这个对象，执行构造函数的代码（为这个新对象添加属性）</p>
<p>（4）判断函数的返回值类型，如果是值类型，返回创建的对象。如果是引用类型，就返回这个引用类型的对象。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">objectFactory</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-literal">null</span>;<br>  <span class="hljs-keyword">let</span> constructor = <span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">shift</span>.<span class="hljs-title function_">call</span>(<span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断参数是否是一个函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> constructor !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>    <span class="hljs-keyword">return</span>;<br>  &#125;<br>  <span class="hljs-comment">// 新建一个空对象，对象的原型为构造函数的 prototype 对象</span><br>  newObject = <span class="hljs-title class_">Object</span>.<span class="hljs-title function_">create</span>(constructor.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>);<br>  <span class="hljs-comment">// 将 this 指向新建对象，并执行函数</span><br>  result = constructor.<span class="hljs-title function_">apply</span>(newObject, <span class="hljs-variable language_">arguments</span>);<br>  <span class="hljs-comment">// 判断返回对象</span><br>  <span class="hljs-keyword">let</span> flag = result &amp;&amp; (<span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;object&quot;</span> || <span class="hljs-keyword">typeof</span> result === <span class="hljs-string">&quot;function&quot;</span>);<br>  <span class="hljs-comment">// 判断返回结果</span><br>  <span class="hljs-keyword">return</span> flag ? result : newObject;<br>&#125;<br><span class="hljs-comment">// 使用方法</span><br><span class="hljs-title function_">objectFactory</span>(构造函数, 初始化参数);<br></code></pre></td></tr></table></figure>

<h3 id="4-手写-Promise"><a href="#4-手写-Promise" class="headerlink" title="4. 手写 Promise"></a>4. 手写 Promise</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">PENDING</span> = <span class="hljs-string">&quot;pending&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">RESOLVED</span> = <span class="hljs-string">&quot;resolved&quot;</span>;<br><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">REJECTED</span> = <span class="hljs-string">&quot;rejected&quot;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">MyPromise</span>(<span class="hljs-params">fn</span>) &#123;<br>  <span class="hljs-comment">// 保存初始化状态</span><br>  <span class="hljs-keyword">var</span> self = <span class="hljs-variable language_">this</span>;<br><br>  <span class="hljs-comment">// 初始化状态</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">PENDING</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 或者 rejected 传入的值</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span> = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-comment">// 用于保存 resolve 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 用于保存 reject 的回调函数</span><br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span> = [];<br><br>  <span class="hljs-comment">// 状态转变为 resolved 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">resolve</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 判断传入元素是否为 Promise 值，如果是，则状态改变必须等待前一个状态改变后再进行改变</span><br>    <span class="hljs-keyword">if</span> (value <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">MyPromise</span>) &#123;<br>      <span class="hljs-keyword">return</span> value.<span class="hljs-title function_">then</span>(resolve, reject);<br>    &#125;<br><br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变，</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">RESOLVED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 状态转变为 rejected 方法</span><br>  <span class="hljs-keyword">function</span> <span class="hljs-title function_">reject</span>(<span class="hljs-params">value</span>) &#123;<br>    <span class="hljs-comment">// 保证代码的执行顺序为本轮事件循环的末尾</span><br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      <span class="hljs-comment">// 只有状态为 pending 时才能转变</span><br>      <span class="hljs-keyword">if</span> (self.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>        <span class="hljs-comment">// 修改状态</span><br>        self.<span class="hljs-property">state</span> = <span class="hljs-variable constant_">REJECTED</span>;<br><br>        <span class="hljs-comment">// 设置传入的值</span><br>        self.<span class="hljs-property">value</span> = value;<br><br>        <span class="hljs-comment">// 执行回调函数</span><br>        self.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">callback</span> =&gt;</span> &#123;<br>          <span class="hljs-title function_">callback</span>(value);<br>        &#125;);<br>      &#125;<br>    &#125;, <span class="hljs-number">0</span>);<br>  &#125;<br><br>  <span class="hljs-comment">// 将两个方法传入函数执行</span><br>  <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-title function_">fn</span>(resolve, reject);<br>  &#125; <span class="hljs-keyword">catch</span> (e) &#123;<br>    <span class="hljs-comment">// 遇到错误时，捕获错误，执行 reject 函数</span><br>    <span class="hljs-title function_">reject</span>(e);<br>  &#125;<br>&#125;<br><br><span class="hljs-title class_">MyPromise</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">then</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">onResolved, onRejected</span>) &#123;<br>  <span class="hljs-comment">// 首先判断两个参数是否为函数类型，因为这两个参数是可选参数</span><br>  onResolved =<br>    <span class="hljs-keyword">typeof</span> onResolved === <span class="hljs-string">&quot;function&quot;</span><br>      ? onResolved<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) &#123;<br>          <span class="hljs-keyword">return</span> value;<br>        &#125;;<br><br>  onRejected =<br>    <span class="hljs-keyword">typeof</span> onRejected === <span class="hljs-string">&quot;function&quot;</span><br>      ? onRejected<br>      : <span class="hljs-keyword">function</span>(<span class="hljs-params">error</span>) &#123;<br>          <span class="hljs-keyword">throw</span> error;<br>        &#125;;<br><br>  <span class="hljs-comment">// 如果是等待状态，则将函数加入对应列表中</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">PENDING</span>) &#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">resolvedCallbacks</span>.<span class="hljs-title function_">push</span>(onResolved);<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">rejectedCallbacks</span>.<span class="hljs-title function_">push</span>(onRejected);<br>  &#125;<br><br>  <span class="hljs-comment">// 如果状态已经凝固，则直接执行对应状态的函数</span><br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">RESOLVED</span>) &#123;<br>    <span class="hljs-title function_">onResolved</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">state</span> === <span class="hljs-variable constant_">REJECTED</span>) &#123;<br>    <span class="hljs-title function_">onRejected</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">value</span>);<br>  &#125;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="5-手写-Promise-then"><a href="#5-手写-Promise-then" class="headerlink" title="5. 手写 Promise.then"></a>5. 手写 Promise.then</h3><p><code>then</code> 方法返回一个新的 <code>promise</code> 实例，为了在 <code>promise</code> 状态发生变化时（<code>resolve</code> &#x2F; <code>reject</code> 被调用时）再执行 <code>then</code> 里的函数，我们使用一个 <code>callbacks</code> 数组先把传给then的函数暂存起来，等状态改变时再调用。</p>
<p><strong>那么，怎么保证后一个</strong> <code>**then**</code> <strong>里的方法在前一个</strong> <code>**then**</code><strong>（可能是异步）结束之后再执行呢？</strong></p>
<p>我们可以将传给 <code>then</code> 的函数和新 <code>promise</code> 的 <code>resolve</code> 一起 <code>push</code> 到前一个 <code>promise</code> 的 <code>callbacks</code> 数组中，达到承前启后的效果：</p>
<ul>
<li>承前：当前一个 <code>promise</code> 完成后，调用其 <code>resolve</code> 变更状态，在这个 <code>resolve</code> 里会依次调用 <code>callbacks</code> 里的回调，这样就执行了 <code>then</code> 里的方法了</li>
<li>启后：上一步中，当 <code>then</code> 里的方法执行完成后，返回一个结果，如果这个结果是个简单的值，就直接调用新 <code>promise</code> 的 <code>resolve</code>，让其状态变更，这又会依次调用新 <code>promise</code> 的 <code>callbacks</code> 数组里的方法，循环往复。。如果返回的结果是个 <code>promise</code>，则需要等它完成之后再触发新 <code>promise</code> 的 <code>resolve</code>，所以可以在其结果的 <code>then</code> 里调用新 <code>promise</code> 的 <code>resolve</code></li>
</ul>
<figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir">then(onFulfilled, onReject)&#123;<br>    <span class="hljs-comment">// 保存前一个promise的this</span><br>    <span class="hljs-keyword">const</span> <span class="hljs-keyword">self</span> = this; <br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> MyPromise((resolve, reject) =&gt; &#123;<br>      <span class="hljs-comment">// 封装前一个promise成功时执行的函数</span><br>      <span class="hljs-keyword">let</span> fulfilled = () =&gt; &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-keyword">const</span> result = onFulfilled(<span class="hljs-keyword">self</span>.value); <span class="hljs-comment">// 承前</span><br>          <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> MyPromise? result.then(resolve, reject) : resolve(result); <span class="hljs-comment">//启后</span><br>        &#125;<span class="hljs-keyword">catch</span>(err)&#123;<br>          reject(err)<br>        &#125;<br>      &#125;<br>      <span class="hljs-comment">// 封装前一个promise失败时执行的函数</span><br>      <span class="hljs-keyword">let</span> rejected = () =&gt; &#123;<br>        <span class="hljs-keyword">try</span>&#123;<br>          <span class="hljs-keyword">const</span> result = onReject(<span class="hljs-keyword">self</span>.reason);<br>          <span class="hljs-keyword">return</span> result <span class="hljs-keyword">instanceof</span> MyPromise? result.then(resolve, reject) : reject(result);<br>        &#125;<span class="hljs-keyword">catch</span>(err)&#123;<br>          reject(err)<br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">switch</span>(<span class="hljs-keyword">self</span>.status)&#123;<br>        <span class="hljs-keyword">case</span> PENDING: <br>          <span class="hljs-keyword">self</span>.onFulfilledCallbacks.push(fulfilled);<br>          <span class="hljs-keyword">self</span>.onRejectedCallbacks.push(rejected);<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> FULFILLED:<br>          fulfilled();<br>          <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> REJECT:<br>          rejected();<br>          <span class="hljs-keyword">break</span>;<br>      &#125;<br>    &#125;)<br>   &#125;<br></code></pre></td></tr></table></figure>

<p><strong>注意：</strong></p>
<ul>
<li>连续多个 <code>then</code> 里的回调方法是同步注册的，但注册到了不同的 <code>callbacks</code> 数组中，因为每次 <code>then</code> 都返回新的 <code>promise</code> 实例（参考上面的例子和图）</li>
<li>注册完成后开始执行构造函数中的异步事件，异步完成之后依次调用 <code>callbacks</code> 数组中提前注册的回调</li>
</ul>
<h3 id="6-手写-Promise-all"><a href="#6-手写-Promise-all" class="headerlink" title="6. 手写 Promise.all"></a>6. 手写 Promise.all</h3><p><strong>1) 核心思路</strong></p>
<ol>
<li>接收一个 Promise 实例的数组或具有 Iterator 接口的对象作为参数</li>
<li>这个方法返回一个新的 promise 对象，</li>
<li>遍历传入的参数，用Promise.resolve()将参数”包一层”，使其变成一个promise对象</li>
<li>参数所有回调成功才是成功，返回值数组与参数顺序一致</li>
<li>参数数组其中一个失败，则触发失败状态，第一个触发失败的 Promise 错误信息作为 Promise.all 的错误信息。</li>
</ol>
<p><strong>2）实现代码</strong></p>
<p>一般来说，Promise.all 用来处理多个并发请求，也是为了页面数据构造的方便，将一个页面所用到的在不同接口的数据一起请求过来，不过，如果其中一个接口失败了，多个请求也就失败了，页面可能啥也出不来，这就看当前页面的耦合程度了</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> promise<span class="hljs-constructor">All(<span class="hljs-params">promises</span>)</span> &#123;<br>  return <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span>(<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">promises</span>)</span>)&#123;<br>        throw <span class="hljs-keyword">new</span> <span class="hljs-constructor">TypeError(`<span class="hljs-params">argument</span> <span class="hljs-params">must</span> <span class="hljs-params">be</span> <span class="hljs-params">a</span> <span class="hljs-params">array</span>`)</span><br>    &#125;<br>    var resolvedCounter = <span class="hljs-number">0</span>;<br>    var promiseNum = promises.length;<br>    var resolvedResult = <span class="hljs-literal">[]</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; promiseNum; i++) &#123;<br>      <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Promise</span>.</span></span>resolve(promises<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span>).<span class="hljs-keyword">then</span>(value=&gt;&#123;<br>        resolvedCounter++;<br>        resolvedResult<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = value;<br>        <span class="hljs-keyword">if</span> (resolvedCounter<span class="hljs-operator"> == </span>promiseNum) &#123;<br>            return resolve(resolvedResult)<br>          &#125;<br>      &#125;,error=&gt;&#123;<br>        return reject(error)<br>      &#125;)<br>    &#125;<br>  &#125;)<br>&#125;<br><span class="hljs-comment">// test</span><br><span class="hljs-keyword">let</span> p1 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> (<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">function</span> ()</span> &#123;<br>        resolve(<span class="hljs-number">1</span>)<br>    &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p2 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> (<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">function</span> ()</span> &#123;<br>        resolve(<span class="hljs-number">2</span>)<br>    &#125;, <span class="hljs-number">2000</span>)<br>&#125;)<br><span class="hljs-keyword">let</span> p3 = <span class="hljs-keyword">new</span> <span class="hljs-constructor">Promise(<span class="hljs-params">function</span> (<span class="hljs-params">resolve</span>, <span class="hljs-params">reject</span>)</span> &#123;<br>    set<span class="hljs-constructor">Timeout(<span class="hljs-params">function</span> ()</span> &#123;<br>        resolve(<span class="hljs-number">3</span>)<br>    &#125;, <span class="hljs-number">3000</span>)<br>&#125;)<br>promise<span class="hljs-constructor">All([<span class="hljs-params">p3</span>, <span class="hljs-params">p1</span>, <span class="hljs-params">p2</span>])</span>.<span class="hljs-keyword">then</span>(res =&gt; &#123;<br>    console.log(res) <span class="hljs-comment">// [3, 1, 2]</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="7-手写-Promise-race"><a href="#7-手写-Promise-race" class="headerlink" title="7. 手写 Promise.race"></a>7. 手写 Promise.race</h3><p>该方法的参数是 Promise 实例数组, 然后其 then 注册的回调方法是数组中的某一个 Promise 的状态变为 fulfilled 的时候就执行. 因为 Promise 的状态<strong>只能改变一次</strong>, 那么我们只需要把 Promise.race 中产生的 Promise 对象的 resolve 方法, 注入到数组中的每一个 Promise 实例中的回调函数中即可.</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Promise</span>.<span class="hljs-property">race</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params">args</span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = args.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>      args[i].<span class="hljs-title function_">then</span>(resolve, reject)<br>    &#125;<br>  &#125;)<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-手写防抖函数"><a href="#8-手写防抖函数" class="headerlink" title="8. 手写防抖函数"></a>8. 手写防抖函数</h3><p>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数防抖的实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">let</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>,<br>        args = <span class="hljs-variable language_">arguments</span>;<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9-手写节流函数"><a href="#9-手写节流函数" class="headerlink" title="9. 手写节流函数"></a>9. 手写节流函数</h3><p>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 函数节流的实现;</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">let</span> curTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span>,<br>        args = <span class="hljs-variable language_">arguments</span>,<br>        nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - curTime &gt;= delay) &#123;<br>      curTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="10-手写类型判断函数"><a href="#10-手写类型判断函数" class="headerlink" title="10. 手写类型判断函数"></a>10. 手写类型判断函数</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">getType</span>(<span class="hljs-params">value</span>) &#123;<br>  <span class="hljs-comment">// 判断数据是 null 的情况</span><br>  <span class="hljs-keyword">if</span> (value === <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-keyword">return</span> value + <span class="hljs-string">&quot;&quot;</span>;<br>  &#125;<br>  <span class="hljs-comment">// 判断数据是引用类型的情况</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> value === <span class="hljs-string">&quot;object&quot;</span>) &#123;<br>    <span class="hljs-keyword">let</span> valueClass = <span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">toString</span>.<span class="hljs-title function_">call</span>(value),<br>      <span class="hljs-keyword">type</span> = valueClass.<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot; &quot;</span>)[<span class="hljs-number">1</span>].<span class="hljs-title function_">split</span>(<span class="hljs-string">&quot;&quot;</span>);<br>    <span class="hljs-keyword">type</span>.<span class="hljs-title function_">pop</span>();<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">type</span>.<span class="hljs-title function_">join</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-title function_">toLowerCase</span>();<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 判断数据是基本数据类型的情况和函数的情况</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">typeof</span> value;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="11-手写-call-函数"><a href="#11-手写-call-函数" class="headerlink" title="11. 手写 call 函数"></a>11. 手写 call 函数</h3><p>call 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>处理传入的参数，截取第一个参数后的所有参数。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性。</li>
<li>返回结果。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// call函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myCall</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-string">&quot;type error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>      result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否传入，如果未传入则设置为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将调用函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用函数</span><br>  result = context.<span class="hljs-title function_">fn</span>(...args);<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="12-手写-apply-函数"><a href="#12-手写-apply-函数" class="headerlink" title="12. 手写 apply 函数"></a>12. 手写 apply 函数</h3><p>apply 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>判断传入上下文对象是否存在，如果不存在，则设置为 window 。</li>
<li>将函数作为上下文对象的一个属性。</li>
<li>判断参数值是否传入</li>
<li>使用上下文对象来调用这个方法，并保存返回结果。</li>
<li>删除刚才新增的属性</li>
<li>返回结果</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// apply 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myApply</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-keyword">let</span> result = <span class="hljs-literal">null</span>;<br>  <span class="hljs-comment">// 判断 context 是否存在，如果未传入则为 window</span><br>  context = context || <span class="hljs-variable language_">window</span>;<br>  <span class="hljs-comment">// 将函数设为对象的方法</span><br>  context.<span class="hljs-property">fn</span> = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-comment">// 调用方法</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]) &#123;<br>    result = context.<span class="hljs-title function_">fn</span>(...<span class="hljs-variable language_">arguments</span>[<span class="hljs-number">1</span>]);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    result = context.<span class="hljs-title function_">fn</span>();<br>  &#125;<br>  <span class="hljs-comment">// 将属性删除</span><br>  <span class="hljs-keyword">delete</span> context.<span class="hljs-property">fn</span>;<br>  <span class="hljs-keyword">return</span> result;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="13-手写-bind-函数"><a href="#13-手写-bind-函数" class="headerlink" title="13. 手写 bind 函数"></a>13. 手写 bind 函数</h3><p>bind 函数的实现步骤：</p>
<ol>
<li>判断调用对象是否为函数，即使我们是定义在函数的原型上的，但是可能出现使用 call 等方式调用的情况。</li>
<li>保存当前函数的引用，获取其余传入参数值。</li>
<li>创建一个函数返回</li>
<li>函数内部使用 apply 来绑定函数调用，需要判断函数作为构造函数的情况，这个时候需要传入当前函数的 this 给 apply 调用，其余情况都传入指定的上下文对象。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// bind 函数实现</span><br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">myBind</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">context</span>) &#123;<br>  <span class="hljs-comment">// 判断调用对象是否为函数</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-variable language_">this</span> !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">TypeError</span>(<span class="hljs-string">&quot;Error&quot;</span>);<br>  &#125;<br>  <span class="hljs-comment">// 获取参数</span><br>  <span class="hljs-keyword">var</span> args = [...<span class="hljs-variable language_">arguments</span>].<span class="hljs-title function_">slice</span>(<span class="hljs-number">1</span>),<br>      fn = <span class="hljs-variable language_">this</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">Fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-comment">// 根据调用方式，传入不同绑定值</span><br>    <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(<br>      <span class="hljs-variable language_">this</span> <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Fn</span> ? <span class="hljs-variable language_">this</span> : context,<br>      args.<span class="hljs-title function_">concat</span>(...<span class="hljs-variable language_">arguments</span>)<br>    );<br>  &#125;;<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="14-函数柯里化的实现"><a href="#14-函数柯里化的实现" class="headerlink" title="14. 函数柯里化的实现"></a>14. 函数柯里化的实现</h3><p> 函数柯里化指的是一种将使用多个参数的一个函数转换成一系列使用一个参数的函数的技术。</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span><span class="hljs-params">(fn, args)</span> &#123;<br>  <span class="hljs-comment">// 获取函数需要的参数长度</span><br>  let length = fn.length;<br><br>  args = args || [];<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span><span class="hljs-params">()</span> &#123;<br>    let subArgs = args.slice(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">// 拼接得到现有的所有参数</span><br>    <span class="hljs-keyword">for</span> (let i = <span class="hljs-number">0</span>; i &lt; arguments.length; i++) &#123;<br>      subArgs.push(arguments[i]);<br>    &#125;<br><br>    <span class="hljs-comment">// 判断参数的长度是否已经满足函数所需参数的长度</span><br>    <span class="hljs-keyword">if</span> (subArgs.length &gt;= length) &#123;<br>      <span class="hljs-comment">// 如果满足，执行函数</span><br>      <span class="hljs-keyword">return</span> fn.apply(<span class="hljs-keyword">this</span>, subArgs);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-comment">// 如果不满足，递归返回科里化的函数，等待参数的传入</span><br>      <span class="hljs-keyword">return</span> curry.call(<span class="hljs-keyword">this</span>, fn, subArgs);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// es6 实现</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">curry</span><span class="hljs-params">(fn, <span class="hljs-rest_arg">...args</span>)</span> &#123;<br>  <span class="hljs-keyword">return</span> fn.length &lt;= args.length ? fn(...args) : curry.bind(<span class="hljs-literal">null</span>, fn, ...args);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="15-实现AJAX请求"><a href="#15-实现AJAX请求" class="headerlink" title="15. 实现AJAX请求"></a>15. 实现AJAX请求</h3><p>AJAX是 Asynchronous JavaScript and XML 的缩写，指的是通过 JavaScript 的 异步通信，从服务器获取 XML 文档从中提取数据，再更新当前网页的对应部分，而不用刷新整个网页。</p>
<p>创建AJAX请求的步骤：</p>
<ul>
<li><strong>创建一个 XMLHttpRequest 对象。</strong></li>
<li>在这个对象上<strong>使用 open 方法创建一个 HTTP 请求</strong>，open 方法所需要的参数是请求的方法、请求的地址、是否异步和用户的认证信息。</li>
<li>在发起请求前，可以为这个对象<strong>添加一些信息和监听函数</strong>。比如说可以通过 setRequestHeader 方法来为请求添加头信息。还可以为这个对象添加一个状态监听函数。一个 XMLHttpRequest 对象一共有 5 个状态，当它的状态变化时会触发onreadystatechange 事件，可以通过设置监听函数，来处理请求成功后的结果。当对象的 readyState 变为 4 的时候，代表服务器返回的数据接收完成，这个时候可以通过判断请求的状态，如果状态是 2xx 或者 304 的话则代表返回正常。这个时候就可以通过 response 中的数据来对页面进行更新了。</li>
<li>当对象的属性和监听函数设置完成后，最后调<strong>用 sent 方法来向服务器发起请求</strong>，可以传入参数作为发送的数据体。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-variable constant_">SERVER_URL</span> = <span class="hljs-string">&quot;/server&quot;</span>;<br><span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br><span class="hljs-comment">// 创建 Http 请求</span><br>xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-variable constant_">SERVER_URL</span>, <span class="hljs-literal">true</span>);<br><span class="hljs-comment">// 设置状态监听函数</span><br>xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>  <span class="hljs-comment">// 当请求成功时</span><br>  <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>    <span class="hljs-title function_">handle</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>  &#125;<br>&#125;;<br><span class="hljs-comment">// 设置请求失败时的监听函数</span><br>xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>);<br>&#125;;<br><span class="hljs-comment">// 设置请求头信息</span><br>xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br><span class="hljs-comment">// 发送 Http 请求</span><br>xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<h3 id="16-使用Promise封装AJAX请求"><a href="#16-使用Promise封装AJAX请求" class="headerlink" title="16. 使用Promise封装AJAX请求"></a>16. 使用Promise封装AJAX请求</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// promise 封装实现：</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getJSON</span>(<span class="hljs-params">url</span>) &#123;<br>  <span class="hljs-comment">// 创建一个 promise 对象</span><br>  <span class="hljs-keyword">let</span> promise = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve, reject</span>) &#123;<br>    <span class="hljs-keyword">let</span> xhr = <span class="hljs-keyword">new</span> <span class="hljs-title class_">XMLHttpRequest</span>();<br>    <span class="hljs-comment">// 新建一个 http 请求</span><br>    xhr.<span class="hljs-title function_">open</span>(<span class="hljs-string">&quot;GET&quot;</span>, url, <span class="hljs-literal">true</span>);<br>    <span class="hljs-comment">// 设置状态的监听函数</span><br>    xhr.<span class="hljs-property">onreadystatechange</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">readyState</span> !== <span class="hljs-number">4</span>) <span class="hljs-keyword">return</span>;<br>      <span class="hljs-comment">// 当请求成功或失败时，改变 promise 的状态</span><br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">status</span> === <span class="hljs-number">200</span>) &#123;<br>        <span class="hljs-title function_">resolve</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">response</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>      &#125;<br>    &#125;;<br>    <span class="hljs-comment">// 设置错误监听函数</span><br>    xhr.<span class="hljs-property">onerror</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-title function_">reject</span>(<span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-variable language_">this</span>.<span class="hljs-property">statusText</span>));<br>    &#125;;<br>    <span class="hljs-comment">// 设置响应的数据类型</span><br>    xhr.<span class="hljs-property">responseType</span> = <span class="hljs-string">&quot;json&quot;</span>;<br>    <span class="hljs-comment">// 设置请求头信息</span><br>    xhr.<span class="hljs-title function_">setRequestHeader</span>(<span class="hljs-string">&quot;Accept&quot;</span>, <span class="hljs-string">&quot;application/json&quot;</span>);<br>    <span class="hljs-comment">// 发送 http 请求</span><br>    xhr.<span class="hljs-title function_">send</span>(<span class="hljs-literal">null</span>);<br>  &#125;);<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="17-实现浅拷贝"><a href="#17-实现浅拷贝" class="headerlink" title="17. 实现浅拷贝"></a>17. 实现浅拷贝</h3><p>浅拷贝是指，一个新的对象对原始对象的属性值进行精确地拷贝，如果拷贝的是基本数据类型，拷贝的就是基本数据类型的值，如果是引用数据类型，拷贝的就是内存地址。如果其中一个对象的引用内存地址发生改变，另一个对象也会发生变化。</p>
<h4 id="（1）Object-assign"><a href="#（1）Object-assign" class="headerlink" title="（1）Object.assign()"></a>（1）Object.assign()</h4><p><code>Object.assign()</code>是ES6中对象的拷贝方法，接受的第一个参数是目标对象，其余参数是源对象，用法：<code>Object.assign(target, source_1, ···)</code>，该方法可以实现浅拷贝，也可以实现一维对象的深拷贝。</p>
<p><strong>注意：</strong></p>
<ul>
<li>如果目标对象和源对象有同名属性，或者多个源对象有同名属性，则后面的属性会覆盖前面的属性。</li>
<li>如果该函数只有一个参数，当参数为对象时，直接返回该对象；当参数不是对象时，会先将参数转为对象然后返回。</li>
<li>因为<code>null</code> 和 <code>undefined</code> 不能转化为对象，所以第一个参数不能为<code>null</code>或 <code>undefined</code>，会报错。</li>
</ul>
<figure class="highlight ceylon"><table><tr><td class="code"><pre><code class="hljs ceylon"><span class="hljs-keyword">let</span> target = &#123;a: <span class="hljs-number">1</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">object</span><span class="hljs-number">2</span> = &#123;b: <span class="hljs-number">2</span>&#125;;<br><span class="hljs-keyword">let</span> <span class="hljs-keyword">object</span><span class="hljs-number">3</span> = &#123;c: <span class="hljs-number">3</span>&#125;;<br>Object.<span class="hljs-keyword">assign</span>(target,<span class="hljs-keyword">object</span><span class="hljs-number">2</span>,<span class="hljs-keyword">object</span><span class="hljs-number">3</span>);  <br>console.log(target);  <span class="hljs-comment">// &#123;a: 1, b: 2, c: 3&#125;</span><br></code></pre></td></tr></table></figure>

<h4 id="（2）扩展运算符"><a href="#（2）扩展运算符" class="headerlink" title="（2）扩展运算符"></a>（2）扩展运算符</h4><p>使用扩展运算符可以在构造字面量对象的时候，进行属性的拷贝。语法：<code>let cloneObj = &#123; ...obj &#125;;</code></p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> obj1 = &#123;a:<span class="hljs-number">1</span>,b:&#123;c:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-attribute">let</span> obj2 = &#123;...obj1&#125;;<br><span class="hljs-attribute">obj1</span>.a = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">console</span>.log(obj1); //&#123;a:<span class="hljs-number">2</span>,b:&#123;c:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-attribute">console</span>.log(obj2); //&#123;a:<span class="hljs-number">1</span>,b:&#123;c:<span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-attribute">obj1</span>.b.c = <span class="hljs-number">2</span>;<br><span class="hljs-attribute">console</span>.log(obj1); //&#123;a:<span class="hljs-number">2</span>,b:&#123;c:<span class="hljs-number">2</span>&#125;&#125;<br><span class="hljs-attribute">console</span>.log(obj2); //&#123;a:<span class="hljs-number">1</span>,b:&#123;c:<span class="hljs-number">2</span>&#125;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（3）数组方法实现数组浅拷贝"><a href="#（3）数组方法实现数组浅拷贝" class="headerlink" title="（3）数组方法实现数组浅拷贝"></a>（3）数组方法实现数组浅拷贝</h4><h6 id="1）Array-prototype-slice"><a href="#1）Array-prototype-slice" class="headerlink" title="1）Array.prototype.slice"></a><strong>1）Array.prototype.slice</strong></h6><ul>
<li><code>slice()</code>方法是JavaScript数组的一个方法，这个方法可以从已有数组中返回选定的元素：用法：<code>array.slice(start, end)</code>，该方法不会改变原始数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">slice</span>()); <span class="hljs-comment">// [1,2,3,4]</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">slice</span>() === arr); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<h6 id="2）Array-prototype-concat"><a href="#2）Array-prototype-concat" class="headerlink" title="2）Array.prototype.concat"></a><strong>2）Array.prototype.concat</strong></h6><ul>
<li><code>concat()</code> 方法用于合并两个或多个数组。此方法不会更改现有数组，而是返回一个新数组。</li>
<li>该方法有两个参数，两个参数都可选，如果两个参数都不写，就可以实现一个数组的浅拷贝。</li>
</ul>
<figure class="highlight openscad"><table><tr><td class="code"><pre><code class="hljs openscad"><span class="hljs-built_in">let</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>];<br>console.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">concat</span>()); <span class="hljs-comment">// [1,2,3,4]</span><br>console.<span class="hljs-built_in">log</span>(arr.<span class="hljs-built_in">concat</span>() === arr); <span class="hljs-comment">//false</span><br></code></pre></td></tr></table></figure>

<h4 id="（4）手写实现浅拷贝"><a href="#（4）手写实现浅拷贝" class="headerlink" title="（4）手写实现浅拷贝"></a>（4）手写实现浅拷贝</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> shallow<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>    &#125;<br>  &#125;<br><br>  return newObject;<br>&#125;<span class="hljs-comment">// 浅拷贝的实现;</span><br><br><span class="hljs-keyword">function</span> shallow<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return;<br><br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>    &#125;<br>  &#125;<br><br>  return newObject;<br>&#125;<span class="hljs-comment">// 浅拷贝的实现;</span><br><span class="hljs-keyword">function</span> shallow<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br>  <span class="hljs-comment">// 只拷贝对象</span><br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return;<br>  <span class="hljs-comment">// 根据 object 的类型判断是新建一个数组还是对象</span><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br>  <span class="hljs-comment">// 遍历 object，并且判断是 object 的属性才拷贝</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> = <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>    &#125;<br>  &#125;<br>  return newObject;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="18-实现深拷贝"><a href="#18-实现深拷贝" class="headerlink" title="18. 实现深拷贝"></a>18. 实现深拷贝</h3><ul>
<li><strong>浅拷贝：</strong>浅拷贝指的是将一个对象的属性值复制到另一个对象，如果有的属性的值为引用类型的话，那么会将这个引用的地址复制给对象，因此两个对象会有同一个引用类型的引用。浅拷贝可以使用  Object.assign 和展开运算符来实现。</li>
<li><strong>深拷贝：</strong>深拷贝相对浅拷贝而言，如果遇到属性值为引用类型的时候，它新建一个引用类型并将对应的值复制给它，因此对象获得的一个新的引用类型而不是一个原有类型的引用。深拷贝对于一些对象可以使用 JSON 的两个函数来实现，但是由于 JSON 的对象格式比 js 的对象格式更加严格，所以如果属性值里边出现函数或者 Symbol 类型的值时，会转换失败</li>
</ul>
<h4 id="（1）JSON-stringify"><a href="#（1）JSON-stringify" class="headerlink" title="（1）JSON.stringify()"></a>（1）JSON.stringify()</h4><ul>
<li><code>JSON.parse(JSON.stringify(obj))</code>是目前比较常用的深拷贝方法之一，它的原理就是利用<code>JSON.stringify</code> 将<code>js</code>对象序列化（JSON字符串），再使用<code>JSON.parse</code>来反序列化(还原)<code>js</code>对象。</li>
<li>这个方法可以简单粗暴的实现深拷贝，但是还存在问题，拷贝的对象中如果有函数，undefined，symbol，当使用过<code>JSON.stringify()</code>进行处理之后，都会消失。</li>
</ul>
<figure class="highlight yaml"><table><tr><td class="code"><pre><code class="hljs yaml"><span class="hljs-string">let</span> <span class="hljs-string">obj1</span> <span class="hljs-string">=</span> &#123;  <span class="hljs-attr">a:</span> <span class="hljs-number">0</span>,<br>              <span class="hljs-attr">b:</span> &#123;<br>                 <span class="hljs-attr">c:</span> <span class="hljs-number">0</span><br>                 &#125;<br>            &#125;<span class="hljs-string">;</span><br><span class="hljs-string">let</span> <span class="hljs-string">obj2</span> <span class="hljs-string">=</span> <span class="hljs-string">JSON.parse(JSON.stringify(obj1));</span><br><span class="hljs-string">obj1.a</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br><span class="hljs-string">obj1.b.c</span> <span class="hljs-string">=</span> <span class="hljs-number">1</span><span class="hljs-string">;</span><br><span class="hljs-string">console.log(obj1);</span> <span class="hljs-string">//</span> &#123;<span class="hljs-attr">a:</span> <span class="hljs-number">1</span>, <span class="hljs-attr">b:</span> &#123;<span class="hljs-attr">c:</span> <span class="hljs-number">1</span>&#125;&#125;<br><span class="hljs-string">console.log(obj2);</span> <span class="hljs-string">//</span> &#123;<span class="hljs-attr">a:</span> <span class="hljs-number">0</span>, <span class="hljs-attr">b:</span> &#123;<span class="hljs-attr">c:</span> <span class="hljs-number">0</span>&#125;&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（2）函数库lodash的-cloneDeep方法"><a href="#（2）函数库lodash的-cloneDeep方法" class="headerlink" title="（2）函数库lodash的_.cloneDeep方法"></a>（2）函数库lodash的_.cloneDeep方法</h4><p>该函数库也有提供_.cloneDeep用来做 Deep Copy</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> _ = require(<span class="hljs-string">&#x27;lodash&#x27;</span>);<br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">b</span>: &#123; <span class="hljs-attr">f</span>: &#123; <span class="hljs-attr">g</span>: <span class="hljs-number">1</span> &#125; &#125;,<br>    <span class="hljs-attr">c</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>&#125;;<br><span class="hljs-keyword">var</span> obj2 = _.cloneDeep(obj1);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.b.f === obj2.b.f);<span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h4 id="（3）手写实现深拷贝函数"><a href="#（3）手写实现深拷贝函数" class="headerlink" title="（3）手写实现深拷贝函数"></a>（3）手写实现深拷贝函数</h4><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 深拷贝的实现</span><br><span class="hljs-keyword">function</span> deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">object</span><span class="hljs-operator"> || </span>typeof <span class="hljs-keyword">object</span> !== <span class="hljs-string">&quot;object&quot;</span>) return;<br><br>  <span class="hljs-keyword">let</span> newObject = <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">object</span>)</span> ? <span class="hljs-literal">[]</span> : &#123;&#125;;<br><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">object</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">object</span>.has<span class="hljs-constructor">OwnProperty(<span class="hljs-params">key</span>)</span>) &#123;<br>      newObject<span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span> =<br>        typeof <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span><span class="hljs-operator"> === </span><span class="hljs-string">&quot;object&quot;</span> ? deep<span class="hljs-constructor">Copy(<span class="hljs-params">object</span>[<span class="hljs-params">key</span>])</span> : <span class="hljs-keyword">object</span><span class="hljs-literal">[<span class="hljs-identifier">key</span>]</span>;<br>    &#125;<br>  &#125;<br><br>  return newObject;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="二、数据处理"><a href="#二、数据处理" class="headerlink" title="二、数据处理"></a>二、数据处理</h2><h3 id="1-实现日期格式化函数"><a href="#1-实现日期格式化函数" class="headerlink" title="1. 实现日期格式化函数"></a>1. 实现日期格式化函数</h3><p>输入：</p>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">dateFormat</span>(new Date(&#x27;<span class="hljs-number">2020</span>-<span class="hljs-number">12</span>-<span class="hljs-number">01</span>&#x27;), &#x27;yyyy/MM/dd&#x27;) // <span class="hljs-number">2020</span>/<span class="hljs-number">12</span>/<span class="hljs-number">01</span><br><span class="hljs-attribute">dateFormat</span>(new Date(&#x27;<span class="hljs-number">2020</span>-<span class="hljs-number">04</span>-<span class="hljs-number">01</span>&#x27;), &#x27;yyyy/MM/dd&#x27;) // <span class="hljs-number">2020</span>/<span class="hljs-number">04</span>/<span class="hljs-number">01</span><br><span class="hljs-attribute">dateFormat</span>(new Date(&#x27;<span class="hljs-number">2020</span>-<span class="hljs-number">04</span>-<span class="hljs-number">01</span>&#x27;), &#x27;yyyy年MM月dd日&#x27;) // <span class="hljs-number">2020</span>年<span class="hljs-number">04</span>月<span class="hljs-number">01</span>日<br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const dateFormat = <span class="hljs-function">(<span class="hljs-params">dateInput, format</span>)=&gt;</span>&#123;<br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">day</span> = dateInput.getDate() <br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">month</span> = dateInput.getMonth() + <span class="hljs-number">1</span>  <br>    <span class="hljs-keyword">var</span> <span class="hljs-built_in">year</span> = dateInput.getFullYear()   <br>    format = format.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/yyyy/</span>, <span class="hljs-built_in">year</span>)<br>    format = format.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/MM/</span>,<span class="hljs-built_in">month</span>)<br>    format = format.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/dd/</span>,<span class="hljs-built_in">day</span>)<br>    <span class="hljs-keyword">return</span> format<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="2-交换a-b的值，不能用临时变量"><a href="#2-交换a-b的值，不能用临时变量" class="headerlink" title="2. 交换a,b的值，不能用临时变量"></a>2. 交换a,b的值，不能用临时变量</h3><p>巧妙的利用两个数的和、差：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">a</span> + <span class="hljs-selector-tag">b</span><br><span class="hljs-selector-tag">b</span> = <span class="hljs-selector-tag">a</span> - <span class="hljs-selector-tag">b</span><br><span class="hljs-selector-tag">a</span> = <span class="hljs-selector-tag">a</span> - b<br></code></pre></td></tr></table></figure>

<h3 id="3-实现数组的乱序输出"><a href="#3-实现数组的乱序输出" class="headerlink" title="3. 实现数组的乱序输出"></a>3. 实现数组的乱序输出</h3><p>主要的实现思路就是：</p>
<ul>
<li>取出数组的第一个元素，随机产生一个索引值，将该第一个元素和这个索引对应的元素进行交换。</li>
<li>第二次取出数据数组第二个元素，随机产生一个除了索引为1的之外的索引值，并将第二个元素与该索引值对应的元素进行交换</li>
<li>按照上面的规律执行，直到遍历完成</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>  const randomIndex = Math.<span class="hljs-built_in">round</span>(Math.<span class="hljs-built_in">random</span>() * (arr.<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span> - i)) + i;<br>  [arr[i], arr[randomIndex]] = [arr[randomIndex], arr[i]];<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr)<br></code></pre></td></tr></table></figure>

<p>还有一方法就是倒序遍历：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>];<br>let <span class="hljs-built_in">length</span> = arr.<span class="hljs-built_in">length</span>,<br>    randomIndex,<br>    temp;<br>  <span class="hljs-keyword">while</span> (<span class="hljs-built_in">length</span>) &#123;<br>    randomIndex = Math.<span class="hljs-built_in">floor</span>(Math.<span class="hljs-built_in">random</span>() * <span class="hljs-built_in">length</span>--);<br>    temp = arr[<span class="hljs-built_in">length</span>];<br>    arr[<span class="hljs-built_in">length</span>] = arr[randomIndex];<br>    arr[randomIndex] = temp;<br>  &#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arr)<br></code></pre></td></tr></table></figure>

<h3 id="4-实现数组元素求和"><a href="#4-实现数组元素求和" class="headerlink" title="4. 实现数组元素求和"></a>4. 实现数组元素求和</h3><ul>
<li>arr&#x3D;[1,2,3,4,5,6,7,8,9,10]，求和</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">let</span> arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br><span class="hljs-attribute">let</span> sum = arr.reduce( (total,i) =&gt; total += i,<span class="hljs-number">0</span>);<br><span class="hljs-attribute">console</span>.log(sum);<br></code></pre></td></tr></table></figure>

<ul>
<li>arr&#x3D;[1,2,3,[[4,5],6],7,8,9]，求和</li>
</ul>
<figure class="highlight apache"><table><tr><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">var</span> = arr=[<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,[[<span class="hljs-number">4</span>,<span class="hljs-number">5</span>],<span class="hljs-number">6</span>],<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br><span class="hljs-attribute">let</span> arr= arr.toString().split(&#x27;,&#x27;).reduce( (total,i) =&gt; total += Number(i),<span class="hljs-number">0</span>);<br><span class="hljs-attribute">console</span>.log(arr);<br></code></pre></td></tr></table></figure>

<p>递归实现：</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">let arr = <span class="hljs-selector-attr">[1, 2, 3, 4, 5, 6]</span> <br><br>function <span class="hljs-built_in">add</span>(arr) &#123;<br>    <span class="hljs-keyword">if</span> (arr<span class="hljs-selector-class">.length</span> == <span class="hljs-number">1</span>) return arr<span class="hljs-selector-attr">[0]</span> <br>    return arr<span class="hljs-selector-attr">[0]</span> + <span class="hljs-built_in">add</span>(arr<span class="hljs-selector-class">.slice</span>(<span class="hljs-number">1</span>)) <br>&#125;<br>console<span class="hljs-selector-class">.log</span>(<span class="hljs-built_in">add</span>(arr)) <span class="hljs-comment">// 21</span><br></code></pre></td></tr></table></figure>

<h3 id="5-实现数组的扁平化"><a href="#5-实现数组的扁平化" class="headerlink" title="5. 实现数组的扁平化"></a>5. 实现数组的扁平化</h3><p><strong>（1）递归实现</strong></p>
<p>普通的递归思路很容易理解，就是通过循环递归的方式，一项一项地去遍历，如果每一项还是一个数组，那么就继续往下遍历，利用递归程序的方法，来实现数组的每一项的连接：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]];<br>function <span class="hljs-built_in">flatten</span>(arr) &#123;<br>  <span class="hljs-built_in">let</span> result = [];<br><br>  <span class="hljs-keyword">for</span>(<span class="hljs-built_in">let</span> i = <span class="hljs-number">0</span>; i &lt; arr.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(Array.isArray(arr[i])) &#123;<br>      result = result.<span class="hljs-built_in">concat</span>(<span class="hljs-built_in">flatten</span>(arr[i]));<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.<span class="hljs-built_in">push</span>(arr[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-built_in">return</span> result;<br>&#125;<br><span class="hljs-built_in">flatten</span>(arr);  //  [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>，<span class="hljs-number">5</span>]<br></code></pre></td></tr></table></figure>

<p><strong>（2）reduce 函数迭代</strong></p>
<p>从上面普通的递归函数中可以看出，其实就是对数组的每一项进行处理，那么其实也可以用reduce 来实现数组的拼接，从而简化第一种方法的代码，改造后的代码如下所示：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.<span class="hljs-built_in">reduce</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">prev, next</span>)&#123;<br>        <span class="hljs-keyword">return</span> prev.concat(<span class="hljs-built_in">Array</span>.isArray(next) ? flatten(next) : next)<br>    &#125;, [])<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(flatten(arr));<span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure>

<p><strong>（3）扩展运算符实现</strong></p>
<p>这个方法的实现，采用了扩展运算符和 some 的方法，两者共同使用，达到数组扁平化的目的：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">while</span> (arr.some(<span class="hljs-function"><span class="hljs-params">item</span> =&gt;</span> <span class="hljs-built_in">Array</span>.isArray(item))) &#123;<br>        arr = [].concat(...arr);<br>    &#125;<br>    <span class="hljs-keyword">return</span> arr;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(flatten(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure>

<p><strong>（4）split 和 toString</strong> </p>
<p>可以通过 split 和 toString 两个方法来共同实现数组扁平化，由于数组会默认带一个 toString 的方法，所以可以把数组直接转换成逗号分隔的字符串，然后再用 split 方法把字符串重新转换为数组，如下面的代码所示：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>    <span class="hljs-keyword">return</span> arr.toString().<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;,&#x27;</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(flatten(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure>

<p>通过这两个方法可以将多维数组直接转换成逗号连接的字符串，然后再重新分隔成数组。</p>
<p><strong>（5）****ES6 中的 flat</strong></p>
<p>我们还可以直接调用 ES6 中的 flat 方法来实现数组扁平化。flat 方法的语法：<code>arr.flat([depth])</code></p>
<p>其中 depth 是 flat 的参数，depth 是可以传递数组的展开深度（默认不填、数值是 1），即展开一层数组。如果层数不确定，参数可以传进 Infinity，代表不论多少层都要展开：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, <span class="hljs-number">4</span>]]];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">return</span> arr.flat(<span class="hljs-literal">Infinity</span>);<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(flatten(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure>

<p>可以看出，一个嵌套了两层的数组，通过将 flat 方法的参数设置为 Infinity，达到了我们预期的效果。其实同样也可以设置成 2，也能实现这样的效果。在编程过程中，如果数组的嵌套层数不确定，最好直接使用 Infinity，可以达到扁平化。</p>
<p><strong>（6）正则和 JSON 方法</strong></p>
<p>在第4种方法中已经使用 toString 方法，其中仍然采用了将 JSON.stringify 的方法先转换为字符串，然后通过正则表达式过滤掉字符串中的数组的方括号，最后再利用 JSON.parse 把它转换成数组：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [<span class="hljs-number">1</span>, [<span class="hljs-number">2</span>, [<span class="hljs-number">3</span>, [<span class="hljs-number">4</span>, <span class="hljs-number">5</span>]]], <span class="hljs-number">6</span>];<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">flatten</span>(<span class="hljs-params">arr</span>) &#123;<br>  <span class="hljs-keyword">let</span> str = <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(arr);<br>  str = str.<span class="hljs-title function_">replace</span>(<span class="hljs-regexp">/(\[|\])/g</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>  str = <span class="hljs-string">&#x27;[&#x27;</span> + str + <span class="hljs-string">&#x27;]&#x27;</span>;<br>  <span class="hljs-keyword">return</span> <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">parse</span>(str); <br>&#125;<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">flatten</span>(arr)); <span class="hljs-comment">//  [1, 2, 3, 4，5]</span><br></code></pre></td></tr></table></figure>

<h3 id="6-实现数组去重"><a href="#6-实现数组去重" class="headerlink" title="6. 实现数组去重"></a>6. 实现数组去重</h3><p>给定某无序数组，要求去除数组中的重复数字并且返回新的无重复数组。</p>
<p>ES6方法（使用数据结构集合）：</p>
<figure class="highlight smali"><table><tr><td class="code"><pre><code class="hljs smali">const<span class="hljs-built_in"> array </span>= [1, 2, 3, 5, 1, 5, 9, 1, 2, 8];<br><br>Array.from(new Set(array)); // [1, 2, 3, 5, 9, 8]<br></code></pre></td></tr></table></figure>

<p>ES5方法：使用map存储不重复的数字</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">array</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-number">1</span>, <span class="hljs-number">5</span>, <span class="hljs-number">9</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">8</span>];<br><br>uniqueArray(<span class="hljs-built_in">array</span>); <span class="hljs-comment">// [1, 2, 3, 5, 9, 8]</span><br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">uniqueArray</span>(<span class="hljs-params">array</span>) &#123;<br>  let <span class="hljs-built_in">map</span> = &#123;&#125;;<br>  let res = [];<br>  <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">array</span>.<span class="hljs-built_in">length</span>; i++) &#123;<br>    <span class="hljs-keyword">if</span>(!<span class="hljs-built_in">map</span>.hasOwnProperty([<span class="hljs-built_in">array</span>[i]])) &#123;<br>      <span class="hljs-built_in">map</span>[<span class="hljs-built_in">array</span>[i]] = <span class="hljs-number">1</span>;<br>      res.<span class="hljs-built_in">push</span>(<span class="hljs-built_in">array</span>[i]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-实现数组的flat方法"><a href="#7-实现数组的flat方法" class="headerlink" title="7. 实现数组的flat方法"></a>7. 实现数组的flat方法</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> <span class="hljs-constructor">_flat(<span class="hljs-params">arr</span>, <span class="hljs-params">depth</span>)</span> &#123;<br>  <span class="hljs-keyword">if</span>(!<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">arr</span>)</span><span class="hljs-operator"> || </span>depth &lt;= <span class="hljs-number">0</span>) &#123;<br>    return arr;<br>  &#125;<br>  return arr.reduce((prev, cur) =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">Array</span>.</span></span>is<span class="hljs-constructor">Array(<span class="hljs-params">cur</span>)</span>) &#123;<br>      return prev.concat(<span class="hljs-constructor">_flat(<span class="hljs-params">cur</span>, <span class="hljs-params">depth</span> - 1)</span>)<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      return prev.concat(cur);<br>    &#125;<br>  &#125;, <span class="hljs-literal">[]</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-实现数组的push方法"><a href="#8-实现数组的push方法" class="headerlink" title="8. 实现数组的push方法"></a>8. 实现数组的push方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">let</span> arr = [];<br><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">push</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">for</span>( <span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span> ; i &lt; <span class="hljs-variable language_">arguments</span>.<span class="hljs-property">length</span> ; i++)&#123;<br>        <span class="hljs-variable language_">this</span>[<span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>] = <span class="hljs-variable language_">arguments</span>[i] ;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="9-实现数组的filter方法"><a href="#9-实现数组的filter方法" class="headerlink" title="9. 实现数组的filter方法"></a>9. 实现数组的filter方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_filter</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        <span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]) &amp;&amp; res.<span class="hljs-title function_">push</span>(<span class="hljs-variable language_">this</span>[i]);<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="10-实现数组的map方法"><a href="#10-实现数组的map方法" class="headerlink" title="10. 实现数组的map方法"></a>10. 实现数组的map方法</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-title class_">Array</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">_map</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> fn !== <span class="hljs-string">&quot;function&quot;</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;参数必须是一个函数&#x27;</span>);<br>    &#125;<br>    <span class="hljs-keyword">const</span> res = [];<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, len = <span class="hljs-variable language_">this</span>.<span class="hljs-property">length</span>; i &lt; len; i++) &#123;<br>        res.<span class="hljs-title function_">push</span>(<span class="hljs-title function_">fn</span>(<span class="hljs-variable language_">this</span>[i]));<br>    &#125;<br>    <span class="hljs-keyword">return</span> res;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="11-实现字符串的repeat方法"><a href="#11-实现字符串的repeat方法" class="headerlink" title="11. 实现字符串的repeat方法"></a>11. 实现字符串的repeat方法</h3><p>输入字符串s，以及其重复的次数，输出重复的结果，例如输入abc，2，输出abcabc。</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span>(s, n) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">(new</span> <span class="hljs-keyword">Array</span>(n + <span class="hljs-number">1</span>)).join(s);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>递归：</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada"><span class="hljs-keyword">function</span> <span class="hljs-title">repeat</span>(s, n) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-type">(n</span> &gt; <span class="hljs-number">0</span>) ? s.concat(repeat(s, <span class="hljs-comment">--n)) : &quot;&quot;;</span><br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="12-实现字符串翻转"><a href="#12-实现字符串翻转" class="headerlink" title="12. 实现字符串翻转"></a>12. 实现字符串翻转</h3><p>在字符串的原型链上添加一个方法，实现字符串翻转：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">String.prototype._reverse = <span class="hljs-keyword">function</span>(<span class="hljs-params">a</span>)&#123;<br>    <span class="hljs-keyword">return</span> a.<span class="hljs-built_in">split</span>(<span class="hljs-string">&quot;&quot;</span>).<span class="hljs-built_in">reverse</span>().join(<span class="hljs-string">&quot;&quot;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> obj = <span class="hljs-keyword">new</span> String();<br><span class="hljs-keyword">var</span> res = obj._reverse (<span class="hljs-string">&#x27;hello&#x27;</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);    <span class="hljs-comment">// olleh</span><br></code></pre></td></tr></table></figure>

<p>需要注意的是，必须通过实例化对象之后再去调用定义的方法，不然找不到该方法。</p>
<h3 id="13-将数字每千分位用逗号隔开"><a href="#13-将数字每千分位用逗号隔开" class="headerlink" title="13. 将数字每千分位用逗号隔开"></a>13. 将数字每千分位用逗号隔开</h3><p><strong>数字有小数版本：</strong></p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let format = <span class="hljs-function"><span class="hljs-params">n</span> =&gt;</span> &#123;<br>    let num = n.toString() <span class="hljs-comment">// 转成字符串</span><br>    let decimals = <span class="hljs-string">&#x27;&#x27;</span><br>        <span class="hljs-comment">// 判断是否有小数</span><br>    num.<span class="hljs-built_in">indexOf</span>(<span class="hljs-string">&#x27;.&#x27;</span>) &gt; <span class="hljs-number">-1</span> ? decimals = num.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">1</span>] : decimals<br>    let len = num.<span class="hljs-built_in">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-keyword">return</span> num<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        let temp = <span class="hljs-string">&#x27;&#x27;</span><br>        let remainder = len % <span class="hljs-number">3</span><br>        decimals ? temp = <span class="hljs-string">&#x27;.&#x27;</span> + decimals : temp<br>        <span class="hljs-keyword">if</span> (remainder &gt; <span class="hljs-number">0</span>) &#123; <span class="hljs-comment">// 不是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, remainder) + <span class="hljs-string">&#x27;,&#x27;</span> + num.<span class="hljs-built_in">slice</span>(remainder, len).match(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).join(<span class="hljs-string">&#x27;,&#x27;</span>) + temp<br>        &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// 是3的整数倍</span><br>            <span class="hljs-keyword">return</span> num.<span class="hljs-built_in">slice</span>(<span class="hljs-number">0</span>, len).match(<span class="hljs-regexp">/\d&#123;3&#125;/g</span>).join(<span class="hljs-string">&#x27;,&#x27;</span>) + temp <br>        &#125;<br>    &#125;<br>&#125;<br>format(<span class="hljs-number">12323.33</span>)  <span class="hljs-comment">// &#x27;12,323.33&#x27;</span><br></code></pre></td></tr></table></figure>

<p><strong>数字无小数版本：</strong></p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">let</span> format = n =&gt; &#123;<br>    <span class="hljs-built_in">let</span> <span class="hljs-built_in">num</span> = n.toString() <br>    <span class="hljs-built_in">let</span> len = <span class="hljs-built_in">num</span>.<span class="hljs-built_in">length</span><br>    <span class="hljs-keyword">if</span> (len &lt;= <span class="hljs-number">3</span>) &#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-built_in">num</span><br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">let</span> <span class="hljs-built_in">remainder</span> = len <span class="hljs-symbol">%</span> <span class="hljs-number">3</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">remainder</span> &gt; <span class="hljs-number">0</span>) &#123; // 不是<span class="hljs-number">3</span>的整数倍<br>            <span class="hljs-built_in">return</span> <span class="hljs-built_in">num</span>.slice(<span class="hljs-number">0</span>, <span class="hljs-built_in">remainder</span>) + &#x27;,&#x27; + <span class="hljs-built_in">num</span>.slice(<span class="hljs-built_in">remainder</span>, len).match(/\d&#123;<span class="hljs-number">3</span>&#125;/g).<span class="hljs-built_in">join</span>(&#x27;,&#x27;) <br>        &#125; <span class="hljs-keyword">else</span> &#123; // 是<span class="hljs-number">3</span>的整数倍<br>            <span class="hljs-built_in">return</span> <span class="hljs-built_in">num</span>.slice(<span class="hljs-number">0</span>, len).match(/\d&#123;<span class="hljs-number">3</span>&#125;/g).<span class="hljs-built_in">join</span>(&#x27;,&#x27;) <br>        &#125;<br>    &#125;<br>&#125;<br>format(<span class="hljs-number">1232323</span>)  // &#x27;<span class="hljs-number">1</span>,<span class="hljs-number">232</span>,<span class="hljs-number">323</span>&#x27;<br></code></pre></td></tr></table></figure>

<h3 id="14-实现非负大整数相加"><a href="#14-实现非负大整数相加" class="headerlink" title="14. 实现非负大整数相加"></a>14. 实现非负大整数相加</h3><p>JavaScript对数值有范围的限制，限制如下：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">Number</span>.MAX_VALUE <span class="hljs-comment">// 1.7976931348623157e+308</span><br><span class="hljs-built_in">Number</span>.MAX_SAFE_INTEGER <span class="hljs-comment">// 9007199254740991</span><br><span class="hljs-built_in">Number</span>.MIN_VALUE <span class="hljs-comment">// 5e-324</span><br><span class="hljs-built_in">Number</span>.MIN_SAFE_INTEGER <span class="hljs-comment">// -9007199254740991</span><br></code></pre></td></tr></table></figure>

<p>如果想要对一个超大的整数(<code>&gt; Number.MAX_SAFE_INTEGER</code>)进行加法运算，但是又想输出一般形式，那么使用 + 是无法达到的，一旦数字超过 <code>Number.MAX_SAFE_INTEGER</code> 数字会被立即转换为科学计数法，并且数字精度相比以前将会有误差。</p>
<p>实现一个算法进行大数的相加：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sumBigNumber</span>(<span class="hljs-params">a, b</span>) &#123;<br>  let res = <span class="hljs-string">&#x27;&#x27;</span>;<br>  let temp = <span class="hljs-number">0</span>;<br>  <br>  a = a.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  b = b.<span class="hljs-built_in">split</span>(<span class="hljs-string">&#x27;&#x27;</span>);<br>  <br>  <span class="hljs-keyword">while</span> (a.<span class="hljs-built_in">length</span> || b.<span class="hljs-built_in">length</span> || temp) &#123;<br>    temp += ~~a.<span class="hljs-built_in">pop</span>() + ~~b.<span class="hljs-built_in">pop</span>();<br>    res = (temp % <span class="hljs-number">10</span>) + res;<br>    temp  = temp &gt; <span class="hljs-number">9</span><br>  &#125;<br>  <span class="hljs-keyword">return</span> res.<span class="hljs-built_in">replace</span>(<span class="hljs-regexp">/^0+/</span>, <span class="hljs-string">&#x27;&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>其主要的思路如下：</p>
<ul>
<li>首先用字符串的方式来保存大数，这样数字在数学表示上就不会发生变化</li>
<li>初始化res，temp来保存中间的计算结果，并将两个字符串转化为数组，以便进行每一位的加法运算</li>
<li>将两个数组的对应的位进行相加，两个数相加的结果可能大于10，所以可能要仅为，对10进行取余操作，将结果保存在当前位</li>
<li>判断当前位是否大于9，也就是是否会进位，若是则将temp赋值为true，因为在加法运算中，true会自动隐式转化为1，以便于下一次相加</li>
<li>重复上述操作，直至计算结束</li>
</ul>
<h3 id="13-实现-add-1-2-3"><a href="#13-实现-add-1-2-3" class="headerlink" title="13. 实现 add(1)(2)(3)"></a>13. 实现 add(1)(2)(3)</h3><p>函数柯里化概念： 柯里化（Currying）是把接受多个参数的函数转变为接受一个单一参数的函数，并且返回接受余下的参数且返回结果的新函数的技术。</p>
<p>1）粗暴版</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> (<span class="hljs-params">a</span>) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">b</span>) &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> (<span class="hljs-params">c</span>) &#123;<br>      <span class="hljs-keyword">return</span> a + b + c;<br>    &#125;<br>&#125;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(add(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)); <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p>2）柯里化解决方案</p>
<ul>
<li>参数长度固定</li>
</ul>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> add = <span class="hljs-keyword">function</span> (<span class="hljs-params">m</span>) &#123;<br>  <span class="hljs-keyword">var</span> temp = <span class="hljs-keyword">function</span> (<span class="hljs-params">n</span>) &#123;<br>    <span class="hljs-keyword">return</span> add(m + n);<br>  &#125;<br>  temp.toString = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">return</span> m;<br>  &#125;<br>  <span class="hljs-keyword">return</span> temp;<br>&#125;;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(add(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>)(<span class="hljs-number">5</span>)); <span class="hljs-comment">// 12</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(add(<span class="hljs-number">3</span>)(<span class="hljs-number">6</span>)(<span class="hljs-number">9</span>)(<span class="hljs-number">25</span>)); <span class="hljs-comment">// 43</span><br></code></pre></td></tr></table></figure>

<p>对于add(3)(4)(5)，其执行过程如下：</p>
<ol>
<li>先执行add(3)，此时m&#x3D;3，并且返回temp函数；</li>
<li>执行temp(4)，这个函数内执行add(m+n)，n是此次传进来的数值4，m值还是上一步中的3，所以add(m+n)&#x3D;add(3+4)&#x3D;add(7)，此时m&#x3D;7，并且返回temp函数</li>
<li>执行temp(5)，这个函数内执行add(m+n)，n是此次传进来的数值5，m值还是上一步中的7，所以add(m+n)&#x3D;add(7+5)&#x3D;add(12)，此时m&#x3D;12，并且返回temp函数</li>
<li>由于后面没有传入参数，等于返回的temp函数不被执行而是打印，了解JS的朋友都知道对象的toString是修改对象转换字符串的方法，因此代码中temp函数的toString函数return m值，而m值是最后一步执行函数时的值m&#x3D;12，所以返回值是12。</li>
</ol>
<ul>
<li>参数长度不固定</li>
</ul>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">add</span> <span class="hljs-params">(<span class="hljs-rest_arg">...args</span>)</span> &#123;<br>    <span class="hljs-comment">//求和</span><br>    <span class="hljs-keyword">return</span> args.reduce((a, b) =&gt; a + b)<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">currying</span> <span class="hljs-params">(fn)</span> &#123;<br>    let args = []<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span> <span class="hljs-title function_">temp</span> <span class="hljs-params">(<span class="hljs-rest_arg">...newArgs</span>)</span> &#123;<br>        <span class="hljs-keyword">if</span> (newArgs.length) &#123;<br>            args = [<br>                ...args,<br>                ...newArgs<br>            ]<br>            <span class="hljs-keyword">return</span> temp<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            let val = fn.apply(<span class="hljs-keyword">this</span>, args)<br>            args = [] <span class="hljs-comment">//保证再次调用时清空</span><br>            <span class="hljs-keyword">return</span> val<br>        &#125;<br>    &#125;<br>&#125;<br>let addCurry = currying(add)<br>console.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>)(<span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span><br>console.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>)(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span><br>console.log(addCurry(<span class="hljs-number">1</span>)(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)())  <span class="hljs-comment">//15</span><br></code></pre></td></tr></table></figure>

<h3 id="14-实现类数组转化为数组"><a href="#14-实现类数组转化为数组" class="headerlink" title="14. 实现类数组转化为数组"></a>14. 实现类数组转化为数组</h3><p>类数组转换为数组的方法有这样几种：</p>
<ul>
<li>通过 call 调用数组的 slice 方法来实现转换</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.slice.call(arrayLike);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 call 调用数组的 splice 方法来实现转换</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.splice.call(arrayLike, 0);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 apply 调用数组的 concat 方法来实现转换</li>
</ul>
<figure class="highlight elm"><table><tr><td class="code"><pre><code class="hljs elm"><span class="hljs-type">Array</span>.proto<span class="hljs-keyword">type</span>.concat.apply([], arrayLike);<br></code></pre></td></tr></table></figure>

<ul>
<li>通过 Array.from 方法来实现转换</li>
</ul>
<figure class="highlight angelscript"><table><tr><td class="code"><pre><code class="hljs angelscript">Array.<span class="hljs-keyword">from</span>(<span class="hljs-built_in">array</span>Like);<br></code></pre></td></tr></table></figure>

<h3 id="15-使用-reduce-求和"><a href="#15-使用-reduce-求和" class="headerlink" title="15. 使用 reduce 求和"></a>15. 使用 reduce 求和</h3><p>arr &#x3D; [1,2,3,4,5,6,7,8,9,10]，求和</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>arr.<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> prev + cur &#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p>arr &#x3D; [1,2,3,[[4,5],6],7,8,9]，求和</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>,<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>,<span class="hljs-number">10</span>]<br>arr.flat(<span class="hljs-literal">Infinity</span>).<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123; <span class="hljs-keyword">return</span> prev + cur &#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p>arr &#x3D; [{a:1, b:3}, {a:2, b:3, c:4}, {a:3}]，求和</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let arr = [&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">9</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">3</span>, <span class="hljs-attr">c</span>:<span class="hljs-number">4</span>&#125;, &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">1</span>, <span class="hljs-attr">b</span>:<span class="hljs-number">3</span>&#125;, &#123;<span class="hljs-attr">a</span>:<span class="hljs-number">3</span>&#125;] <br><br>arr.<span class="hljs-built_in">reduce</span>(<span class="hljs-function">(<span class="hljs-params">prev, cur</span>) =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> prev + cur[<span class="hljs-string">&quot;a&quot;</span>];<br>&#125;, <span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<h3 id="16-将js对象转化为树形结构"><a href="#16-将js对象转化为树形结构" class="headerlink" title="16. 将js对象转化为树形结构"></a>16. 将js对象转化为树形结构</h3><figure class="highlight nestedtext"><table><tr><td class="code"><pre><code class="hljs nestedtext"><span class="hljs-attribute">// 转换前：</span><br><span class="hljs-attribute">source = [&#123;</span><br><span class="hljs-attribute">            id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>            <span class="hljs-attribute">pid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0,</span><br>            <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;body&#x27;</span><br>          <span class="hljs-attribute">&#125;, &#123;</span><br><span class="hljs-attribute">            id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2,</span><br>            <span class="hljs-attribute">pid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>            <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;title&#x27;</span><br>          <span class="hljs-attribute">&#125;, &#123;</span><br><span class="hljs-attribute">            id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3,</span><br>            <span class="hljs-attribute">pid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2,</span><br>            <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;div&#x27;</span><br>          <span class="hljs-attribute">&#125;]</span><br><span class="hljs-attribute">// 转换为</span><span class="hljs-punctuation">: </span><br><span class="hljs-attribute">tree = [&#123;</span><br><span class="hljs-attribute">          id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>          <span class="hljs-attribute">pid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">0,</span><br>          <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;body&#x27;,</span><br>          <span class="hljs-attribute">children</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#123;</span><br>            <span class="hljs-attribute">id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">2,</span><br>            <span class="hljs-attribute">pid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>            <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;title&#x27;,</span><br>            <span class="hljs-attribute">children</span><span class="hljs-punctuation">:</span> <span class="hljs-string">[&#123;</span><br>              <span class="hljs-attribute">id</span><span class="hljs-punctuation">:</span> <span class="hljs-string">3,</span><br>              <span class="hljs-attribute">pid</span><span class="hljs-punctuation">:</span> <span class="hljs-string">1,</span><br>              <span class="hljs-attribute">name</span><span class="hljs-punctuation">:</span> <span class="hljs-string">&#x27;div&#x27;</span><br>            &#125;]<br>          &#125;<br>        &#125;]<br></code></pre></td></tr></table></figure>

<p>代码实现：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span> jsonToTree(data) &#123;<br>  // 初始化结果数组，并判断输入数据的格式<br>  <span class="hljs-keyword">let</span> result = []<br>  <span class="hljs-keyword">if</span>(!Array.isArray(data)) &#123;<br>    <span class="hljs-keyword">return</span> result<br>  &#125;<br>  // 使用<span class="hljs-keyword">map</span>，将当前对象<span class="hljs-built_in">的id</span>与当前对象对应存储起来<br>  <span class="hljs-keyword">let</span> <span class="hljs-keyword">map</span> = &#123;&#125;;<br>  data.forEach(<span class="hljs-type">item</span> =&gt; &#123;<br>    <span class="hljs-keyword">map</span>[<span class="hljs-type">item</span><span class="hljs-built_in">.id</span>] = <span class="hljs-type">item</span>;<br>  &#125;);<br>  // <br>  data.forEach(<span class="hljs-type">item</span> =&gt; &#123;<br>    <span class="hljs-keyword">let</span> parent = <span class="hljs-keyword">map</span>[<span class="hljs-type">item</span>.pid];<br>    <span class="hljs-keyword">if</span>(parent) &#123;<br>      (parent.children || (parent.children = [])).push(<span class="hljs-type">item</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      result.push(<span class="hljs-type">item</span>);<br>    &#125;<br>  &#125;);<br>  <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="17-使用ES5和ES6求函数参数的和"><a href="#17-使用ES5和ES6求函数参数的和" class="headerlink" title="17. 使用ES5和ES6求函数参数的和"></a>17. 使用ES5和ES6求函数参数的和</h3><p>ES5：</p>
<figure class="highlight xquery"><table><tr><td class="code"><pre><code class="hljs xquery"><span class="hljs-keyword">function</span><span class="hljs-built_in"> sum</span>() &#123;<br>    <span class="hljs-keyword">let</span><span class="hljs-built_in"> sum</span> = <span class="hljs-number">0</span><br>    Array.prototype.forEach.call(arguments, <span class="hljs-keyword">function</span>(<span class="hljs-type">item</span>) &#123;<br>       <span class="hljs-built_in"> sum</span> += <span class="hljs-type">item</span> * <span class="hljs-number">1</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span><span class="hljs-built_in"> sum</span><br>&#125;<br></code></pre></td></tr></table></figure>

<p>ES6：</p>
<figure class="highlight actionscript"><table><tr><td class="code"><pre><code class="hljs actionscript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">sum</span><span class="hljs-params">(<span class="hljs-rest_arg">...nums</span>)</span> &#123;<br>    let sum = <span class="hljs-number">0</span><br>    nums.forEach(<span class="hljs-keyword">function</span><span class="hljs-params">(item)</span> &#123;<br>        sum += item * <span class="hljs-number">1</span><br>    &#125;)<br>    <span class="hljs-keyword">return</span> sum<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="18-解析-URL-Params-为对象"><a href="#18-解析-URL-Params-为对象" class="headerlink" title="18. 解析 URL Params 为对象"></a>18. 解析 URL Params 为对象</h3><figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">let url = <span class="hljs-string">&#x27;http://www.domain.com/?user=anonymous&amp;id=123&amp;id=456&amp;city=%E5%8C%97%E4%BA%AC&amp;enabled&#x27;</span>;<br>parseParam(url)<br>/* 结果<br>&#123; user: <span class="hljs-string">&#x27;anonymous&#x27;</span>,<br>  id: [ <span class="hljs-number">123</span>, <span class="hljs-number">456</span> ], <span class="hljs-regexp">//</span> 重复出现的 key 要组装成数组，能被转成数字的就转成数字类型<br>  city: <span class="hljs-string">&#x27;北京&#x27;</span>, <span class="hljs-regexp">//</span> 中文需解码<br>  enabled: true, <span class="hljs-regexp">//</span> 未指定值得 key 约定为 true<br>&#125;<br>*/<br></code></pre></td></tr></table></figure>

<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-keyword">function</span> parseParam(url) &#123;<br>  const paramsStr = <span class="hljs-regexp">/.+\?(.+)$/</span>.exec(url)[<span class="hljs-number">1</span>]; <span class="hljs-regexp">//</span> 将 ? 后面的字符串取出来<br>  const paramsArr = paramsStr.split(<span class="hljs-string">&#x27;&amp;&#x27;</span>); <span class="hljs-regexp">//</span> 将字符串以 &amp; 分割后存到数组中<br>  let paramsObj = &#123;&#125;;<br>  <span class="hljs-regexp">//</span> 将 params 存到对象中<br>  paramsArr.forEach(param =&gt; &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-regexp">/=/</span>.test(param)) &#123; <span class="hljs-regexp">//</span> 处理有 value 的参数<br>      let [key, val] = param.split(<span class="hljs-string">&#x27;=&#x27;</span>); <span class="hljs-regexp">//</span> 分割 key 和 value<br>      val = decodeURIComponent(val); <span class="hljs-regexp">//</span> 解码<br>      val = <span class="hljs-regexp">/^\d+$/</span>.test(val) ? parseFloat(val) : val; <span class="hljs-regexp">//</span> 判断是否转为数字<br>      <span class="hljs-keyword">if</span> (paramsObj.hasOwnProperty(key)) &#123; <span class="hljs-regexp">//</span> 如果对象有 key，则添加一个值<br>        paramsObj[key] = [].concat(paramsObj[key], val);<br>      &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span> 如果对象没有这个 key，创建 key 并设置值<br>        paramsObj[key] = val;<br>      &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-regexp">//</span> 处理没有 value 的参数<br>      paramsObj[param] = true;<br>    &#125;<br>  &#125;)<br>  return paramsObj;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="三、场景应用"><a href="#三、场景应用" class="headerlink" title="三、场景应用"></a>三、场景应用</h2><h3 id="1-循环打印红黄绿"><a href="#1-循环打印红黄绿" class="headerlink" title="1. 循环打印红黄绿"></a>1. 循环打印红黄绿</h3><p>下面来看一道比较典型的问题，通过这个问题来对比几种异步编程方法：<strong>红灯 3s 亮一次，绿灯 1s 亮一次，黄灯 2s 亮一次；如何让三个灯不断交替重复亮灯？</strong></p>
<p>三个亮灯函数：</p>
<figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">red</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;red&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">green</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;green&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">yellow</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;yellow&#x27;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<p>这道题复杂的地方在于<strong>需要“交替重复”亮灯</strong>，而不是“亮完一次”就结束了。</p>
<h4 id="（1）用-callback-实现"><a href="#（1）用-callback-实现" class="headerlink" title="（1）用 callback 实现"></a>（1）用 callback 实现</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const task = <span class="hljs-function"><span class="hljs-params">(timer, light, callback)</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>            red()<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;<br>            green()<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;<br>            yellow()<br>        &#125;<br>        callback()<br>    &#125;, timer)<br>&#125;<br>task(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    task(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        task(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, <span class="hljs-built_in">Function</span>.prototype)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>这里存在一个 bug：代码只是完成了一次流程，执行后红黄绿灯分别只亮一次。该如何让它交替重复进行呢？</p>
<p>上面提到过递归，可以递归亮灯的一个周期：</p>
<figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const step = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    task(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>        task(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>, <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            task(<span class="hljs-number">1000</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>, step)<br>        &#125;)<br>    &#125;)<br>&#125;<br>step()<br></code></pre></td></tr></table></figure>

<p><strong>注意看黄灯亮的回调里又再次调用了 step 方法</strong> 以完成循环亮灯。</p>
<h4 id="（2）用-promise-实现"><a href="#（2）用-promise-实现" class="headerlink" title="（2）用 promise 实现"></a>（2）用 promise 实现</h4><figure class="highlight coffeescript"><table><tr><td class="code"><pre><code class="hljs coffeescript">const task = <span class="hljs-function"><span class="hljs-params">(timer, light)</span> =&gt;</span> <br>    <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>        <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;red&#x27;</span>) &#123;<br>                red()<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;green&#x27;</span>) &#123;<br>                green()<br>            &#125;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (light === <span class="hljs-string">&#x27;yellow&#x27;</span>) &#123;<br>                yellow()<br>            &#125;<br>            resolve()<br>        &#125;, timer)<br>    &#125;)<br>const step = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    task(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br>        .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> task(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>))<br>        .<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> task(<span class="hljs-number">2100</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>))<br>        .<span class="hljs-keyword">then</span>(step)<br>&#125;<br>step()<br></code></pre></td></tr></table></figure>

<p>这里将回调移除，在一次亮灯结束后，resolve 当前 promise，并依然使用递归进行。</p>
<h4 id="（3）用-async-x2F-await-实现"><a href="#（3）用-async-x2F-await-实现" class="headerlink" title="（3）用 async&#x2F;await 实现"></a>（3）用 async&#x2F;await 实现</h4><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">const taskRunner =  async () =&gt; &#123;<br>    await <span class="hljs-built_in">task</span>(<span class="hljs-number">3000</span>, <span class="hljs-string">&#x27;red&#x27;</span>)<br>    await <span class="hljs-built_in">task</span>(<span class="hljs-number">2000</span>, <span class="hljs-string">&#x27;green&#x27;</span>)<br>    await <span class="hljs-built_in">task</span>(<span class="hljs-number">2100</span>, <span class="hljs-string">&#x27;yellow&#x27;</span>)<br>    <span class="hljs-built_in">taskRunner</span>()<br>&#125;<br><span class="hljs-function"><span class="hljs-title">taskRunner</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<h3 id="2-实现每隔一秒打印-1-2-3-4"><a href="#2-实现每隔一秒打印-1-2-3-4" class="headerlink" title="2. 实现每隔一秒打印 1,2,3,4"></a>2. 实现每隔一秒打印 1,2,3,4</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 使用闭包实现</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  (<span class="hljs-keyword">function</span>(<span class="hljs-params">i</span>) &#123;<br>    <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>      <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>    &#125;, i * <span class="hljs-number">1000</span>);<br>  &#125;)(i);<br>&#125;<br><span class="hljs-comment">// 使用 let 块级作用域</span><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(i);<br>  &#125;, i * <span class="hljs-number">1000</span>);<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="3-小孩报数问题"><a href="#3-小孩报数问题" class="headerlink" title="3. 小孩报数问题"></a>3. 小孩报数问题</h3><p>有30个小孩儿，编号从1-30，围成一圈依此报数，1、2、3 数到 3 的小孩儿退出这个圈， 然后下一个小孩 重新报数 1、2、3，问最后剩下的那个小孩儿的编号是多少?</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> child<span class="hljs-constructor">Num(<span class="hljs-params">num</span>, <span class="hljs-params">count</span>)</span>&#123;<br>    <span class="hljs-keyword">let</span> allplayer = <span class="hljs-literal">[]</span>;    <br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>        allplayer<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> = i + <span class="hljs-number">1</span>;<br>    &#125;<br>    <br>    <span class="hljs-keyword">let</span> exitCount = <span class="hljs-number">0</span>;    <span class="hljs-comment">// 离开人数</span><br>    <span class="hljs-keyword">let</span> counter = <span class="hljs-number">0</span>;      <span class="hljs-comment">// 记录报数</span><br>    <span class="hljs-keyword">let</span> curIndex = <span class="hljs-number">0</span>;     <span class="hljs-comment">// 当前下标</span><br>    <br>    <span class="hljs-keyword">while</span>(exitCount &lt; num - <span class="hljs-number">1</span>)&#123;<br>        <span class="hljs-keyword">if</span>(allplayer<span class="hljs-literal">[<span class="hljs-identifier">curIndex</span>]</span> !== <span class="hljs-number">0</span>) counter++;    <br>        <br>        <span class="hljs-keyword">if</span>(counter<span class="hljs-operator"> == </span>count)&#123;<br>            allplayer<span class="hljs-literal">[<span class="hljs-identifier">curIndex</span>]</span> = <span class="hljs-number">0</span>;                 <br>            counter = <span class="hljs-number">0</span>;<br>            exitCount++;  <br>        &#125;<br>        curIndex++;<br>        <span class="hljs-keyword">if</span>(curIndex<span class="hljs-operator"> == </span>num)&#123;<br>            curIndex = <span class="hljs-number">0</span>               <br>        &#125;;           <br>    &#125;    <br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; num; i++)&#123;<br>        <span class="hljs-keyword">if</span>(allplayer<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span> !== <span class="hljs-number">0</span>)&#123;<br>            return allplayer<span class="hljs-literal">[<span class="hljs-identifier">i</span>]</span><br>        &#125;      <br>    &#125;<br>&#125;<br>child<span class="hljs-constructor">Num(30, 3)</span><br></code></pre></td></tr></table></figure>

<h3 id="4-用Promise实现图片的异步加载"><a href="#4-用Promise实现图片的异步加载" class="headerlink" title="4. 用Promise实现图片的异步加载"></a>4. 用Promise实现图片的异步加载</h3><figure class="highlight arcade"><table><tr><td class="code"><pre><code class="hljs arcade">let imageAsync=<span class="hljs-function">(<span class="hljs-params">url</span>)=&gt;</span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve,reject</span>)=&gt;</span>&#123;<br>                let img = <span class="hljs-keyword">new</span> Image();<br>                img.src = url;<br>                img.οnlοad=<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>                    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`图片请求成功，此处进行通用操作`</span>);<br>                    resolve(image);<br>                &#125;<br>                img.οnerrοr=<span class="hljs-function">(<span class="hljs-params">err</span>)=&gt;</span>&#123;<br>                    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">`失败，此处进行失败的通用操作`</span>);<br>                    reject(err);<br>                &#125;<br>            &#125;)<br>        &#125;<br>        <br>imageAsync(<span class="hljs-string">&quot;url&quot;</span>).then(<span class="hljs-function"><span class="hljs-params">()</span>=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;加载成功&quot;</span>);<br>&#125;).catch(<span class="hljs-function">(<span class="hljs-params">error</span>)=&gt;</span>&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;加载失败&quot;</span>);<br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="5-实现发布-订阅模式"><a href="#5-实现发布-订阅模式" class="headerlink" title="5. 实现发布-订阅模式"></a>5. 实现发布-订阅模式</h3><figure class="highlight typescript"><table><tr><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EventCenter</span>&#123;<br>  <span class="hljs-comment">// 1. 定义事件容器，用来装事件数组</span><br>    <span class="hljs-keyword">let</span> handlers = &#123;&#125;<br><br>  <span class="hljs-comment">// 2. 添加事件方法，参数：事件名 事件方法</span><br>  <span class="hljs-title function_">addEventListener</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, handler</span>) &#123;<br>    <span class="hljs-comment">// 创建新数组容器</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>] = []<br>    &#125;<br>    <span class="hljs-comment">// 存入事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">push</span>(handler)<br>  &#125;<br><br>  <span class="hljs-comment">// 3. 触发事件，参数：事件名 事件参数</span><br>  <span class="hljs-title function_">dispatchEvent</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, params</span>) &#123;<br>    <span class="hljs-comment">// 若没有注册该事件则抛出错误</span><br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;该事件未注册&#x27;</span>)<br>    &#125;<br>    <span class="hljs-comment">// 触发事件</span><br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">forEach</span>(<span class="hljs-function"><span class="hljs-params">handler</span> =&gt;</span> &#123;<br>      <span class="hljs-title function_">handler</span>(...params)<br>    &#125;)<br>  &#125;<br><br>  <span class="hljs-comment">// 4. 事件移除，参数：事件名 要删除事件，若无第二个参数则删除该事件的订阅和发布</span><br>  <span class="hljs-title function_">removeEventListener</span>(<span class="hljs-params"><span class="hljs-keyword">type</span>, handler</span>) &#123;<br>    <span class="hljs-keyword">if</span> (!<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>]) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;事件无效&#x27;</span>)<br>    &#125;<br>    <span class="hljs-keyword">if</span> (!handler) &#123;<br>      <span class="hljs-comment">// 移除事件</span><br>      <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>]<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>      <span class="hljs-keyword">const</span> index = <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">findIndex</span>(<span class="hljs-function"><span class="hljs-params">el</span> =&gt;</span> el === handler)<br>      <span class="hljs-keyword">if</span> (index === -<span class="hljs-number">1</span>) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Error</span>(<span class="hljs-string">&#x27;无该绑定事件&#x27;</span>)<br>      &#125;<br>      <span class="hljs-comment">// 移除事件</span><br>      <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>].<span class="hljs-title function_">splice</span>(index, <span class="hljs-number">1</span>)<br>      <span class="hljs-keyword">if</span> (<span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>].<span class="hljs-property">length</span> === <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">delete</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">handlers</span>[<span class="hljs-keyword">type</span>]<br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="6-查找文章中出现频率最高的单词"><a href="#6-查找文章中出现频率最高的单词" class="headerlink" title="6. 查找文章中出现频率最高的单词"></a>6. 查找文章中出现频率最高的单词</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> find<span class="hljs-constructor">MostWord(<span class="hljs-params">article</span>)</span> &#123;<br>  <span class="hljs-comment">// 合法性判断</span><br>  <span class="hljs-keyword">if</span> (!article) return;<br>  <span class="hljs-comment">// 参数处理</span><br>  article = article.trim<span class="hljs-literal">()</span>.<span class="hljs-keyword">to</span><span class="hljs-constructor">LowerCase()</span>;<br>  <span class="hljs-keyword">let</span> wordList = article.<span class="hljs-keyword">match</span>(/<span class="hljs-literal">[<span class="hljs-identifier">a</span>-<span class="hljs-identifier">z</span>]</span>+/g),<br>    visited = <span class="hljs-literal">[]</span>,<br>    maxNum = <span class="hljs-number">0</span>,<br>    maxWord = <span class="hljs-string">&quot;&quot;</span>;<br>  article = <span class="hljs-string">&quot; &quot;</span> + wordList.join(<span class="hljs-string">&quot;  &quot;</span>) + <span class="hljs-string">&quot; &quot;</span>;<br>  <span class="hljs-comment">// 遍历判断单词出现次数</span><br>  wordList.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each(<span class="hljs-params">function</span>(<span class="hljs-params">item</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> (visited.index<span class="hljs-constructor">Of(<span class="hljs-params">item</span>)</span> &lt; <span class="hljs-number">0</span>) &#123;<br>      <span class="hljs-comment">// 加入 visited </span><br>      visited.push(item);<br>      <span class="hljs-keyword">let</span> word = <span class="hljs-keyword">new</span> <span class="hljs-constructor">RegExp(<span class="hljs-string">&quot; &quot;</span> + <span class="hljs-params">item</span> + <span class="hljs-string">&quot; &quot;</span>, <span class="hljs-string">&quot;g&quot;</span>)</span>,<br>        num = article.<span class="hljs-keyword">match</span>(word).length;<br>      <span class="hljs-keyword">if</span> (num &gt; maxNum) &#123;<br>        maxNum = num;<br>        maxWord = item;<br>      &#125;<br>    &#125;<br>  &#125;);<br>  return maxWord + <span class="hljs-string">&quot;  &quot;</span> + maxNum;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="7-封装异步的fetch，使用async-await方式来使用"><a href="#7-封装异步的fetch，使用async-await方式来使用" class="headerlink" title="7. 封装异步的fetch，使用async await方式来使用"></a>7. 封装异步的fetch，使用async await方式来使用</h3><figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">(<span class="hljs-keyword">async</span> () =&gt; &#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">HttpRequestUtil</span> &#123;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">get</span>(<span class="hljs-params">url</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url);<br>            <span class="hljs-keyword">const</span> data = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> data;<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">post</span>(<span class="hljs-params">url, data</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;POST&#x27;</span>,<br>                <span class="hljs-attr">headers</span>: &#123;<br>                    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                &#125;,<br>                <span class="hljs-attr">body</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>            &#125;);<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">put</span>(<span class="hljs-params">url, data</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;PUT&#x27;</span>,<br>                <span class="hljs-attr">headers</span>: &#123;<br>                    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                &#125;,<br>                <span class="hljs-attr">data</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>            &#125;);<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>        <span class="hljs-keyword">async</span> <span class="hljs-title function_">delete</span>(<span class="hljs-params">url, data</span>) &#123;<br>            <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> <span class="hljs-title function_">fetch</span>(url, &#123;<br>                <span class="hljs-attr">method</span>: <span class="hljs-string">&#x27;DELETE&#x27;</span>,<br>                <span class="hljs-attr">headers</span>: &#123;<br>                    <span class="hljs-string">&#x27;Content-Type&#x27;</span>: <span class="hljs-string">&#x27;application/json&#x27;</span><br>                &#125;,<br>                <span class="hljs-attr">data</span>: <span class="hljs-title class_">JSON</span>.<span class="hljs-title function_">stringify</span>(data)<br>            &#125;);<br>            <span class="hljs-keyword">const</span> result = <span class="hljs-keyword">await</span> res.<span class="hljs-title function_">json</span>();<br>            <span class="hljs-keyword">return</span> result;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">const</span> httpRequestUtil = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HttpRequestUtil</span>();<br>    <span class="hljs-keyword">const</span> res = <span class="hljs-keyword">await</span> httpRequestUtil.<span class="hljs-title function_">get</span>(<span class="hljs-string">&#x27;http://golderbrother.cn/&#x27;</span>);<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(res);<br>&#125;)();<br></code></pre></td></tr></table></figure>

<h3 id="8-实现prototype继承"><a href="#8-实现prototype继承" class="headerlink" title="8. 实现prototype继承"></a>8. 实现prototype继承</h3><p>所谓的原型链继承就是让新实例的原型等于父类的实例：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">//父方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SupperFunction</span>(<span class="hljs-params">flag1</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flag1</span> = flag1;<br>&#125;<br><br><span class="hljs-comment">//子方法</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubFunction</span>(<span class="hljs-params">flag2</span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">flag2</span> = flag2;<br>&#125;<br><br><span class="hljs-comment">//父实例</span><br><span class="hljs-keyword">var</span> superInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SupperFunction</span>(<span class="hljs-literal">true</span>);<br><br><span class="hljs-comment">//子继承父</span><br><span class="hljs-title class_">SubFunction</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = superInstance;<br><br><span class="hljs-comment">//子实例</span><br><span class="hljs-keyword">var</span> subInstance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubFunction</span>(<span class="hljs-literal">false</span>);<br><span class="hljs-comment">//子调用自己和父的属性</span><br>subInstance.<span class="hljs-property">flag1</span>;   <span class="hljs-comment">// true</span><br>subInstance.<span class="hljs-property">flag2</span>;   <span class="hljs-comment">// false</span><br></code></pre></td></tr></table></figure>

<h3 id="9-实现双向数据绑定"><a href="#9-实现双向数据绑定" class="headerlink" title="9. 实现双向数据绑定"></a>9. 实现双向数据绑定</h3><figure class="highlight stylus"><table><tr><td class="code"><pre><code class="hljs stylus">let obj = &#123;&#125;<br>let <span class="hljs-selector-tag">input</span> = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;input&#x27;</span>)<br>let <span class="hljs-selector-tag">span</span> = document<span class="hljs-selector-class">.getElementById</span>(<span class="hljs-string">&#x27;span&#x27;</span>)<br><span class="hljs-comment">// 数据劫持</span><br>Object<span class="hljs-selector-class">.defineProperty</span>(obj, <span class="hljs-string">&#x27;text&#x27;</span>, &#123;<br>  configurable: true,<br>  enumerable: true,<br>  <span class="hljs-built_in">get</span>() &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;获取数据了&#x27;</span>)<br>  &#125;,<br>  <span class="hljs-built_in">set</span>(newVal) &#123;<br>    console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;数据更新了&#x27;</span>)<br>    <span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.value</span> = newVal<br>    <span class="hljs-selector-tag">span</span><span class="hljs-selector-class">.innerHTML</span> = newVal<br>  &#125;<br>&#125;)<br><span class="hljs-comment">// 输入监听</span><br><span class="hljs-selector-tag">input</span><span class="hljs-selector-class">.addEventListener</span>(<span class="hljs-string">&#x27;keyup&#x27;</span>, <span class="hljs-built_in">function</span>(e) &#123;<br>  obj<span class="hljs-selector-class">.text</span> = e<span class="hljs-selector-class">.target</span><span class="hljs-selector-class">.value</span><br>&#125;)<br></code></pre></td></tr></table></figure>

<h3 id="10-实现简单路由"><a href="#10-实现简单路由" class="headerlink" title="10. 实现简单路由"></a>10. 实现简单路由</h3><figure class="highlight kotlin"><table><tr><td class="code"><pre><code class="hljs kotlin"><span class="hljs-comment">// hash路由</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Route</span>&#123;<br>  <span class="hljs-keyword">constructor</span>()&#123;<br>    <span class="hljs-comment">// 路由存储对象</span><br>    <span class="hljs-keyword">this</span>.routes = &#123;&#125;<br>    <span class="hljs-comment">// 当前hash</span><br>    <span class="hljs-keyword">this</span>.currentHash = <span class="hljs-string">&#x27;&#x27;</span><br>    <span class="hljs-comment">// 绑定this，避免监听时this指向改变</span><br>    <span class="hljs-keyword">this</span>.freshRoute = <span class="hljs-keyword">this</span>.freshRoute.bind(<span class="hljs-keyword">this</span>)<br>    <span class="hljs-comment">// 监听</span><br>    window.addEventListener(<span class="hljs-string">&#x27;load&#x27;</span>, <span class="hljs-keyword">this</span>.freshRoute, <span class="hljs-literal">false</span>)<br>    window.addEventListener(<span class="hljs-string">&#x27;hashchange&#x27;</span>, <span class="hljs-keyword">this</span>.freshRoute, <span class="hljs-literal">false</span>)<br>  &#125;<br>  <span class="hljs-comment">// 存储</span><br>  storeRoute (path, cb) &#123;<br>    <span class="hljs-keyword">this</span>.routes[path] = cb || function () &#123;&#125;<br>  &#125;<br>  <span class="hljs-comment">// 更新</span><br>  freshRoute () &#123;<br>    <span class="hljs-keyword">this</span>.currentHash = location.hash.slice(<span class="hljs-number">1</span>) || <span class="hljs-string">&#x27;/&#x27;</span><br>    <span class="hljs-keyword">this</span>.routes[<span class="hljs-keyword">this</span>.currentHash]()<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="11-实现斐波那契数列"><a href="#11-实现斐波那契数列" class="headerlink" title="11. 实现斐波那契数列"></a>11. 实现斐波那契数列</h3><figure class="highlight zephir"><table><tr><td class="code"><pre><code class="hljs zephir"><span class="hljs-comment">// 递归</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span> <span class="hljs-params">(n)</span></span>&#123;<br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>    <span class="hljs-keyword">if</span>(n==<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">1</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">fn</span><span class="hljs-params">(n<span class="hljs-number">-2</span>)</span>+<span class="hljs-title">fn</span><span class="hljs-params">(n<span class="hljs-number">-1</span>)</span></span><br><span class="hljs-function">&#125;</span><br><span class="hljs-function">// 优化</span><br><span class="hljs-function"><span class="hljs-title">function</span> <span class="hljs-title">fibonacci2</span><span class="hljs-params">(n)</span> </span>&#123;<br>    <span class="hljs-keyword">const</span> arr = [<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>];<br>    <span class="hljs-keyword">const</span> arrLen = arr.length;<br><br>    <span class="hljs-keyword">if</span> (n &lt;= arrLen) &#123;<br>        <span class="hljs-keyword">return</span> arr[n];<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = arrLen; i &lt; n; i++) &#123;<br>        arr.push(arr[i - <span class="hljs-number">1</span>] + arr[ i - <span class="hljs-number">2</span>]);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> arr[arr.length - <span class="hljs-number">1</span>];<br>&#125;<br><span class="hljs-comment">// 非递归</span><br><span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fn</span><span class="hljs-params">(n)</span> </span>&#123;<br>    <span class="hljs-keyword">let</span> pre1 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> pre2 = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">let</span> current = <span class="hljs-number">2</span>;<br><br>    <span class="hljs-keyword">if</span> (n &lt;= <span class="hljs-number">2</span>) &#123;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">2</span>; i &lt; n; i++) &#123;<br>        pre1 = pre2;<br>        pre2 = current;<br>        current = pre1 + pre2;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> current;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="12-字符串出现的不重复最长长度"><a href="#12-字符串出现的不重复最长长度" class="headerlink" title="12. 字符串出现的不重复最长长度"></a>12. 字符串出现的不重复最长长度</h3><p>用一个滑动窗口装没有重复的字符，枚举字符记录最大值即可。用 map 维护字符的索引，遇到相同的字符，把左边界移动过去即可。挪动的过程中记录最大长度：</p>
<figure class="highlight livescript"><table><tr><td class="code"><pre><code class="hljs livescript"><span class="hljs-keyword">var</span> lengthOfLongestSubstring = <span class="hljs-keyword">function</span> (s) &#123;<br>    <span class="hljs-keyword">let</span> <span class="hljs-keyword">map</span> = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Map</span>();<br>    <span class="hljs-keyword">let</span> i = -<span class="hljs-number">1</span><br>    <span class="hljs-keyword">let</span> res = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">let</span> n = s.length<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> j = <span class="hljs-number">0</span>; j &lt; n; j++) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">map</span>.has(s[j])) &#123;<br>            i = <span class="hljs-built_in">Math</span>.max(i, <span class="hljs-keyword">map</span>.get(s[j]))<br>        &#125;<br>        res = <span class="hljs-built_in">Math</span>.max(res, j - i)<br>        <span class="hljs-keyword">map</span>.set(s[j], j)<br>    &#125;<br>    <span class="hljs-keyword">return</span> res<br>&#125;;<br></code></pre></td></tr></table></figure>

<h3 id="13-使用-setTimeout-实现-setInterval"><a href="#13-使用-setTimeout-实现-setInterval" class="headerlink" title="13. 使用 setTimeout 实现 setInterval"></a>13. 使用 setTimeout 实现 setInterval</h3><p>setInterval 的作用是每隔一段指定时间执行一个函数，但是这个执行不是真的到了时间立即执行，它真正的作用是每隔一段时间将事件加入事件队列中去，只有当当前的执行栈为空的时候，才能去从事件队列中取出事件执行。所以可能会出现这样的情况，就是当前执行栈执行的时间很长，导致事件队列里边积累多个定时器加入的事件，当执行栈结束的时候，这些事件会依次执行，因此就不能到间隔一段时间执行的效果。</p>
<p>针对 setInterval 的这个缺点，我们可以使用 setTimeout 递归调用来模拟 setInterval，这样我们就确保了只有一个事件结束了，我们才会触发下一个定时器事件，这样解决了 setInterval 的问题。</p>
<p>实现思路是使用递归函数，不断地去执行 setTimeout 从而达到 setInterval 的效果</p>
<figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">function</span> my<span class="hljs-constructor">SetInterval(<span class="hljs-params">fn</span>, <span class="hljs-params">timeout</span>)</span> &#123;<br>  <span class="hljs-comment">// 控制器，控制定时器是否继续执行</span><br>  var timer = &#123;<br>    flag: <span class="hljs-literal">true</span><br>  &#125;;<br>  <span class="hljs-comment">// 设置递归函数，模拟定时器执行。</span><br>  <span class="hljs-keyword">function</span> interval<span class="hljs-literal">()</span> &#123;<br>    <span class="hljs-keyword">if</span> (timer.flag) &#123;<br>      fn<span class="hljs-literal">()</span>;<br>      set<span class="hljs-constructor">Timeout(<span class="hljs-params">interval</span>, <span class="hljs-params">timeout</span>)</span>;<br>    &#125;<br>  &#125;<br>  <span class="hljs-comment">// 启动定时器</span><br>  set<span class="hljs-constructor">Timeout(<span class="hljs-params">interval</span>, <span class="hljs-params">timeout</span>)</span>;<br>  <span class="hljs-comment">// 返回控制器</span><br>  return timer;<br>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="14-实现-jsonp"><a href="#14-实现-jsonp" class="headerlink" title="14. 实现 jsonp"></a>14. 实现 jsonp</h3><figure class="highlight reasonml"><table><tr><td class="code"><pre><code class="hljs reasonml"><span class="hljs-comment">// 动态的加载js文件</span><br><span class="hljs-keyword">function</span> add<span class="hljs-constructor">Script(<span class="hljs-params">src</span>)</span> &#123;<br>  const script = document.create<span class="hljs-constructor">Element(&#x27;<span class="hljs-params">script</span>&#x27;)</span>;<br>  script.src = src;<br>  script.<span class="hljs-keyword">type</span> = <span class="hljs-string">&quot;text/javascript&quot;</span>;<br>  document.body.append<span class="hljs-constructor">Child(<span class="hljs-params">script</span>)</span>;<br>&#125;<br>add<span class="hljs-constructor">Script(<span class="hljs-string">&quot;http://xxx.xxx.com/xxx.js?callback=handleRes&quot;</span>)</span>;<br><span class="hljs-comment">// 设置一个全局的callback函数来接收回调结果</span><br><span class="hljs-keyword">function</span> handle<span class="hljs-constructor">Res(<span class="hljs-params">res</span>)</span> &#123;<br>  console.log(res);<br>&#125;<br><span class="hljs-comment">// 接口返回的数据格式</span><br>handle<span class="hljs-constructor">Res(&#123;<span class="hljs-params">a</span>: 1, <span class="hljs-params">b</span>: 2&#125;)</span>;<br></code></pre></td></tr></table></figure>

<h3 id="15-判断对象是否存在循环引用"><a href="#15-判断对象是否存在循环引用" class="headerlink" title="15. 判断对象是否存在循环引用"></a>15. 判断对象是否存在循环引用</h3><p>循环引用对象本来没有什么问题，但是序列化的时候就会发生问题，比如调用<code>JSON.stringify()</code>对该类对象进行序列化，就会报错: <code>Converting circular structure to JSON.</code></p>
<p>下面方法可以用来判断一个对象中是否已存在循环引用：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">const</span> <span class="hljs-title function_">isCycleObject</span> = (<span class="hljs-params">obj,parent</span>) =&gt; &#123;<br>    <span class="hljs-keyword">const</span> parentArr = parent || [obj];<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">let</span> i <span class="hljs-keyword">in</span> obj) &#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-keyword">typeof</span> obj[i] === <span class="hljs-string">&#x27;object&#x27;</span>) &#123;<br>            <span class="hljs-keyword">let</span> flag = <span class="hljs-literal">false</span>;<br>            parentArr.<span class="hljs-title function_">forEach</span>(<span class="hljs-function">(<span class="hljs-params">pObj</span>) =&gt;</span> &#123;<br>                <span class="hljs-keyword">if</span>(pObj === obj[i])&#123;<br>                    flag = <span class="hljs-literal">true</span>;<br>                &#125;<br>            &#125;)<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>            flag = <span class="hljs-title function_">isCycleObject</span>(obj[i],[...parentArr,obj[i]]);<br>            <span class="hljs-keyword">if</span>(flag) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>&#125;<br><br><br><span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">const</span> b = &#123;a&#125;;<br><span class="hljs-keyword">const</span> c = &#123;b&#125;;<br><span class="hljs-keyword">const</span> o = &#123;<span class="hljs-attr">d</span>:&#123;<span class="hljs-attr">a</span>:<span class="hljs-number">3</span>&#125;,c&#125;<br>o.<span class="hljs-property">c</span>.<span class="hljs-property">b</span>.<span class="hljs-property">aa</span> = a;<br><br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title function_">isCycleObject</span>(o)<br></code></pre></td></tr></table></figure>

<p>查找有序二维数组的目标值：</p>
<figure class="highlight maxima"><table><tr><td class="code"><pre><code class="hljs maxima"><span class="hljs-built_in">var</span> findNumberIn2DArray = function(<span class="hljs-built_in">matrix</span>, target) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">matrix</span> == null || <span class="hljs-built_in">matrix</span>.<span class="hljs-built_in">length</span> == <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>    &#125;<br>    <span class="hljs-built_in">let</span> <span class="hljs-built_in">row</span> = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">let</span> column = <span class="hljs-built_in">matrix</span>[<span class="hljs-number">0</span>].<span class="hljs-built_in">length</span> - <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">while</span> (<span class="hljs-built_in">row</span> &lt; <span class="hljs-built_in">matrix</span>.<span class="hljs-built_in">length</span> &amp;&amp; column &gt;= <span class="hljs-number">0</span>) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">matrix</span>[<span class="hljs-built_in">row</span>][column] == target) &#123;<br>            <span class="hljs-built_in">return</span> <span class="hljs-literal">true</span>;<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-built_in">matrix</span>[<span class="hljs-built_in">row</span>][column] &gt; target) &#123;<br>            column--;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-built_in">row</span>++;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">return</span> <span class="hljs-literal">false</span>;<br>&#125;;<br></code></pre></td></tr></table></figure>

<p>二维数组斜向打印：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">printMatrix</span>(<span class="hljs-params">arr</span>)&#123;<br>  <span class="hljs-keyword">let</span> m = arr.<span class="hljs-property">length</span>, n = arr[<span class="hljs-number">0</span>].<span class="hljs-property">length</span><br>    <span class="hljs-keyword">let</span> res = []<br>  <br>  <span class="hljs-comment">// 左上角，从0 到 n - 1 列进行打印</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">0</span>; k &lt; n; k++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = <span class="hljs-number">0</span>, j = k; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i++, j--) &#123;<br>      res.<span class="hljs-title function_">push</span>(arr[i][j]);<br>    &#125;<br>  &#125;<br><br>  <span class="hljs-comment">// 右下角，从1 到 n - 1 行进行打印</span><br>  <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> k = <span class="hljs-number">1</span>; k &lt; m; k++) &#123;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">let</span> i = k, j = n - <span class="hljs-number">1</span>; i &lt; m &amp;&amp; j &gt;= <span class="hljs-number">0</span>; i++, j--) &#123;<br>      res.<span class="hljs-title function_">push</span>(arr[i][j]);<br>    &#125;<br>  &#125;<br>  <span class="hljs-keyword">return</span> res<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>性能优化</title>
    <url>/2022/08/22/optimization/</url>
    <content><![CDATA[<h2 id="性能优化"><a href="#性能优化" class="headerlink" title="性能优化"></a>性能优化</h2><span id="more"></span>

<p><img  src="/images/image/performance-optimization.png"  ><span class="image-caption">性能优化面试题.png</span></p>
<h2 id="一、CDN"><a href="#一、CDN" class="headerlink" title="一、CDN"></a>一、CDN</h2><h3 id="1-CDN的概念"><a href="#1-CDN的概念" class="headerlink" title="1. CDN的概念"></a>1. CDN的概念</h3><p>CDN（Content Delivery Network，<strong>内容分发网络</strong>）是指一种通过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。</p>
<p>典型的CDN系统由下面三个部分组成：</p>
<ul>
<li><strong>分发服务系统：</strong>最基本的工作单元就是Cache设备，cache（边缘cache）负责直接响应最终用户的访问请求，把缓存在本地的内容快速地提供给用户。同时cache还负责与源站点进行内容同步，把更新的内容以及本地没有的内容从源站点获取并保存在本地。Cache设备的数量、规模、总服务能力是衡量一个CDN系统服务能力的最基本的指标。</li>
<li><strong>负载均衡系统：</strong>主要功能是负责对所有发起服务请求的用户进行访问调度，确定提供给用户的最终实际访问地址。两级调度体系分为全局负载均衡（GSLB）和本地负载均衡（SLB）。<strong>全局负载均衡</strong>主要根据用户就近性原则，通过对每个服务节点进行“最优”判断，确定向用户提供服务的cache的物理位置。<strong>本地负载均衡</strong>主要负责节点内部的设备负载均衡</li>
<li><strong>运营管理系统：</strong>运营管理系统分为运营管理和网络管理子系统，负责处理业务层面的与外界系统交互所必须的收集、整理、交付工作，包含客户管理、产品管理、计费管理、统计分析等功能。</li>
</ul>
<h3 id="2-CDN的作用"><a href="#2-CDN的作用" class="headerlink" title="2. CDN的作用"></a>2. CDN的作用</h3><p>CDN一般会用来托管Web资源（包括文本、图片和脚本等），可供下载的资源（媒体文件、软件、文档等），应用程序（门户网站等）。使用CDN来加速这些资源的访问。</p>
<p>（1）在性能方面，引入CDN的作用在于：</p>
<ul>
<li>用户收到的内容来自最近的数据中心，延迟更低，内容加载更快</li>
<li>部分资源请求分配给了CDN，减少了服务器的负载</li>
</ul>
<p>（2）在安全方面，CDN有助于防御DDoS、MITM等网络攻击：</p>
<ul>
<li>针对DDoS：通过监控分析异常流量，限制其请求频率</li>
<li>针对MITM：从源服务器到 CDN 节点到 ISP（Internet Service Provider），全链路 HTTPS 通信</li>
</ul>
<p>除此之外，CDN作为一种基础的云服务，同样具有资源托管、按需扩展（能够应对流量高峰）等方面的优势。</p>
<h3 id="3-CDN的原理"><a href="#3-CDN的原理" class="headerlink" title="3. CDN的原理"></a>3. CDN的原理</h3><p>CDN和DNS有着密不可分的联系，先来看一下DNS的解析域名过程，在浏览器输入 <a href="http://www.test.com/">www.test.com</a> 的解析过程如下：</p>
<p>（1） 检查浏览器缓存</p>
<p>（2）检查操作系统缓存，常见的如hosts文件</p>
<p>（3）检查路由器缓存</p>
<p>（4）如果前几步都没没找到，会向ISP(网络服务提供商)的LDNS服务器查询</p>
<p>（5）如果LDNS服务器没找到，会向根域名服务器(Root Server)请求解析，分为以下几步：</p>
<ul>
<li>根服务器返回顶级域名(TLD)服务器如<code>.com</code>，<code>.cn</code>，<code>.org</code>等的地址，该例子中会返回<code>.com</code>的地址</li>
<li>接着向顶级域名服务器发送请求，然后会返回次级域名(SLD)服务器的地址，本例子会返回<code>.test</code>的地址</li>
<li>接着向次级域名服务器发送请求，然后会返回通过域名查询到的目标IP，本例子会返回<code>www.test.com</code>的地址</li>
<li>Local DNS Server会缓存结果，并返回给用户，缓存在系统中</li>
</ul>
<p><strong>CDN的工作原理：</strong></p>
<p>（1）用户未使用CDN缓存资源的过程：</p>
<ol>
<li>浏览器通过DNS对域名进行解析（就是上面的DNS解析过程），依次得到此域名对应的IP地址</li>
<li>浏览器根据得到的IP地址，向域名的服务主机发送数据请求</li>
<li>服务器向浏览器返回响应数据</li>
</ol>
<p>（2）用户使用CDN缓存资源的过程：</p>
<ol>
<li>对于点击的数据的URL，经过本地DNS系统的解析，发现该URL对应的是一个CDN专用的DNS服务器，DNS系统就会将域名解析权交给CNAME指向的CDN专用的DNS服务器。</li>
<li>CND专用DNS服务器将CND的全局负载均衡设备IP地址返回给用户</li>
<li>用户向CDN的全局负载均衡设备发起数据请求</li>
<li>CDN的全局负载均衡设备根据用户的IP地址，以及用户请求的内容URL，选择一台用户所属区域的区域负载均衡设备，告诉用户向这台设备发起请求</li>
<li>区域负载均衡设备选择一台合适的缓存服务器来提供服务，将该缓存服务器的IP地址返回给全局负载均衡设备</li>
<li>全局负载均衡设备把服务器的IP地址返回给用户</li>
<li>用户向该缓存服务器发起请求，缓存服务器响应用户的请求，将用户所需内容发送至用户终端。</li>
</ol>
<p>如果缓存服务器没有用户想要的内容，那么缓存服务器就会向它的上一级缓存服务器请求内容，以此类推，直到获取到需要的资源。最后如果还是没有，就会回到自己的服务器去获取资源。</p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966294889-153271b5-4b9f-4470-b05f-c7a9f030d043.png?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image</span></p>
<p>CNAME（意为：别名）：在域名解析中，实际上解析出来的指定域名对应的IP地址，或者该域名的一个CNAME，然后再根据这个CNAME来查找对应的IP地址。</p>
<h3 id="4-CDN的使用场景"><a href="#4-CDN的使用场景" class="headerlink" title="4. CDN的使用场景"></a>4. CDN的使用场景</h3><ul>
<li><strong>使用第三方的CDN服务：</strong>如果想要开源一些项目，可以使用第三方的CDN服务</li>
<li><strong>使用CDN进行静态资源的缓存：</strong>将自己网站的静态资源放在CDN上，比如js、css、图片等。可以将整个项目放在CDN上，完成一键部署。</li>
<li><strong>直播传送：</strong>直播本质上是使用流媒体进行传送，CDN也是支持流媒体传送的，所以直播完全可以使用CDN来提高访问速度。CDN在处理流媒体的时候与处理普通静态文件有所不同，普通文件如果在边缘节点没有找到的话，就会去上一层接着寻找，但是流媒体本身数据量就非常大，如果使用回源的方式，必然会带来性能问题，所以流媒体一般采用的都是主动推送的方式来进行。</li>
</ul>
<h2 id="二、懒加载"><a href="#二、懒加载" class="headerlink" title="二、懒加载"></a>二、懒加载</h2><h3 id="1-懒加载的概念"><a href="#1-懒加载的概念" class="headerlink" title="1. 懒加载的概念"></a>1. 懒加载的概念</h3><p>懒加载也叫做延迟加载、按需加载，指的是在长网页中延迟加载图片数据，是一种较好的网页性能优化的方式。在比较长的网页或应用中，如果图片很多，所有的图片都被加载出来，而用户只能看到可视窗口的那一部分图片数据，这样就浪费了性能。</p>
<p>如果使用图片的懒加载就可以解决以上问题。在滚动屏幕之前，可视化区域之外的图片不会进行加载，在滚动屏幕时才加载。这样使得网页的加载速度更快，减少了服务器的负载。懒加载适用于图片较多，页面列表较长（长列表）的场景中。</p>
<h3 id="2-懒加载的特点"><a href="#2-懒加载的特点" class="headerlink" title="2. 懒加载的特点"></a>2. 懒加载的特点</h3><ul>
<li><strong>减少无用资源的加载</strong>：使用懒加载明显减少了服务器的压力和流量，同时也减小了浏览器的负担。</li>
<li><strong>提升用户体验</strong>: 如果同时加载较多图片，可能需要等待的时间较长，这样影响了用户体验，而使用懒加载就能大大的提高用户体验。</li>
<li><strong>防止加载过多图片而影响其他资源文件的加载</strong> ：会影响网站应用的正常使用。</li>
</ul>
<h3 id="3-懒加载的实现原理"><a href="#3-懒加载的实现原理" class="headerlink" title="3. 懒加载的实现原理"></a>3. 懒加载的实现原理</h3><p>图片的加载是由<code>src</code>引起的，当对<code>src</code>赋值时，浏览器就会请求图片资源。根据这个原理，我们使用HTML5 的<code>data-xxx</code>属性来储存图片的路径，在需要加载图片的时候，将<code>data-xxx</code>中图片的路径赋值给<code>src</code>，这样就实现了图片的按需加载，即懒加载。</p>
<p>注意：<code>data-xxx</code> 中的<code>xxx</code>可以自定义，这里我们使用<code>data-src</code>来定义。</p>
<p>懒加载的实现重点在于确定用户需要加载哪张图片，在浏览器中，可视区域内的资源就是用户需要的资源。所以当图片出现在可视区域时，获取图片的真实地址并赋值给图片即可。</p>
<p>使用原生JavaScript实现懒加载：</p>
<p><strong>知识点：</strong></p>
<p>（1）<code>window.innerHeight</code> 是浏览器可视区的高度</p>
<p>（2）<code>document.body.scrollTop || document.documentElement.scrollTop</code> 是浏览器滚动的过的距离</p>
<p>（3）<code>imgs.offsetTop</code> 是元素顶部距离文档顶部的高度（包括滚动条的距离）</p>
<p>（4）图片加载条件：<code>img.offsetTop &lt; window.innerHeight + document.body.scrollTop;</code></p>
<p><strong>图示：</strong></p>
<p><img  src="https://cdn.nlark.com/yuque/0/2020/png/1500604/1603966605254-fe880ec0-ebd1-4f94-b662-cdd5e5396c34.png?x-oss-process=image/resize,w_1500"  ><span class="image-caption">image</span></p>
<p><strong>代码实现：</strong></p>
<figure class="highlight xml"><table><tr><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">div</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;container&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">img</span> <span class="hljs-attr">src</span>=<span class="hljs-string">&quot;loading.gif&quot;</span>  <span class="hljs-attr">data-src</span>=<span class="hljs-string">&quot;pic.png&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">div</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">script</span>&gt;</span><span class="language-javascript"></span><br><span class="language-javascript"><span class="hljs-keyword">var</span> imgs = <span class="hljs-variable language_">document</span>.<span class="hljs-title function_">querySelectorAll</span>(<span class="hljs-string">&#x27;img&#x27;</span>);</span><br><span class="language-javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">lozyLoad</span>(<span class="hljs-params"></span>)&#123;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> scrollTop = <span class="hljs-variable language_">document</span>.<span class="hljs-property">body</span>.<span class="hljs-property">scrollTop</span> || <span class="hljs-variable language_">document</span>.<span class="hljs-property">documentElement</span>.<span class="hljs-property">scrollTop</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">var</span> winHeight= <span class="hljs-variable language_">window</span>.<span class="hljs-property">innerHeight</span>;</span><br><span class="language-javascript">        <span class="hljs-keyword">for</span>(<span class="hljs-keyword">var</span> i=<span class="hljs-number">0</span>;i &lt; imgs.<span class="hljs-property">length</span>;i++)&#123;</span><br><span class="language-javascript">            <span class="hljs-keyword">if</span>(imgs[i].<span class="hljs-property">offsetTop</span> &lt; scrollTop + winHeight )&#123;</span><br><span class="language-javascript">                imgs[i].<span class="hljs-property">src</span> = imgs[i].<span class="hljs-title function_">getAttribute</span>(<span class="hljs-string">&#x27;data-src&#x27;</span>);</span><br><span class="language-javascript">            &#125;</span><br><span class="language-javascript">        &#125;</span><br><span class="language-javascript">    &#125;</span><br><span class="language-javascript">  <span class="hljs-variable language_">window</span>.<span class="hljs-property">onscroll</span> = <span class="hljs-title function_">lozyLoad</span>();</span><br><span class="language-javascript"></span><span class="hljs-tag">&lt;/<span class="hljs-name">script</span>&gt;</span><br></code></pre></td></tr></table></figure>

<h3 id="4-懒加载与预加载的区别"><a href="#4-懒加载与预加载的区别" class="headerlink" title="4. 懒加载与预加载的区别"></a>4. 懒加载与预加载的区别</h3><p>这两种方式都是提高网页性能的方式，两者主要区别是一个是提前加载，一个是迟缓甚至不加载。懒加载对服务器前端有一定的缓解压力作用，预加载则会增加服务器前端压力。</p>
<ul>
<li><strong>懒加载也叫延迟加载，指的是在长网页中延迟加载图片的时机，当用户需要访问时，再去加载</strong>，这样可以提高网站的首屏加载速度，提升用户的体验，并且可以减少服务器的压力。它适用于图片很多，页面很长的电商网站的场景。懒加载的实现原理是，将页面上的图片的 src 属性设置为空字符串，将图片的真实路径保存在一个自定义属性中，当页面滚动的时候，进行判断，如果图片进入页面可视区域内，则从自定义属性中取出真实路径赋值给图片的 src 属性，以此来实现图片的延迟加载。</li>
<li><strong>预加载指的是将所需的资源提前请求加载到本地，这样后面在需要用到时就直接从缓存取资源。</strong>通过预加载能够减少用户的等待时间，提高用户的体验。我了解的预加载的最常用的方式是使用 js 中的 image 对象，通过为 image 对象来设置 scr 属性，来实现图片的预加载。</li>
</ul>
<h2 id="三、回流与重绘"><a href="#三、回流与重绘" class="headerlink" title="三、回流与重绘"></a>三、回流与重绘</h2><h3 id="1-回流与重绘的概念及触发条件"><a href="#1-回流与重绘的概念及触发条件" class="headerlink" title="1. 回流与重绘的概念及触发条件"></a>1. 回流与重绘的概念及触发条件</h3><h4 id="（1）回流"><a href="#（1）回流" class="headerlink" title="（1）回流"></a>（1）回流</h4><p>当渲染树中部分或者全部元素的尺寸、结构或者属性发生变化时，浏览器会重新渲染部分或者全部文档的过程就称为<strong>回流</strong>。</p>
<p>下面这些操作会导致回流：</p>
<ul>
<li>页面的首次渲染</li>
<li>浏览器的窗口大小发生变化</li>
<li>元素的内容发生变化</li>
<li>元素的尺寸或者位置发生变化</li>
<li>元素的字体大小发生变化</li>
<li>激活CSS伪类</li>
<li>查询某些属性或者调用某些方法</li>
<li>添加或者删除可见的DOM元素</li>
</ul>
<p>在触发回流（重排）的时候，由于浏览器渲染页面是基于流式布局的，所以当触发回流时，会导致周围的DOM元素重新排列，它的影响范围有两种：</p>
<ul>
<li>全局范围：从根节点开始，对整个渲染树进行重新布局</li>
<li>局部范围：对渲染树的某部分或者一个渲染对象进行重新布局</li>
</ul>
<h4 id="（2）重绘"><a href="#（2）重绘" class="headerlink" title="（2）重绘"></a>（2）重绘</h4><p>当页面中某些元素的样式发生变化，但是不会影响其在文档流中的位置时，浏览器就会对元素进行重新绘制，这个过程就是<strong>重绘</strong>。</p>
<p>下面这些操作会导致重绘：</p>
<ul>
<li>color、background 相关属性：background-color、background-image 等</li>
<li>outline 相关属性：outline-color、outline-width 、text-decoration</li>
<li>border-radius、visibility、box-shadow</li>
</ul>
<p>注意： <strong>当触发回流时，一定会触发重绘，但是重绘不一定会引发回流。</strong></p>
<h3 id="2-如何避免回流与重绘？"><a href="#2-如何避免回流与重绘？" class="headerlink" title="2. 如何避免回流与重绘？"></a>2. 如何避免回流与重绘？</h3><p><strong>减少回流与重绘的措施：</strong></p>
<ul>
<li>操作DOM时，尽量在低层级的DOM节点进行操作</li>
<li>不要使用<code>table</code>布局， 一个小的改动可能会使整个<code>table</code>进行重新布局</li>
<li>使用CSS的表达式</li>
<li>不要频繁操作元素的样式，对于静态页面，可以修改类名，而不是样式。</li>
<li>使用absolute或者fixed，使元素脱离文档流，这样他们发生变化就不会影响其他元素</li>
<li>避免频繁操作DOM，可以创建一个文档片段<code>documentFragment</code>，在它上面应用所有DOM操作，最后再把它添加到文档中</li>
<li>将元素先设置<code>display: none</code>，操作结束后再把它显示出来。因为在display属性为none的元素上进行的DOM操作不会引发回流和重绘。</li>
<li>将DOM的多个读操作（或者写操作）放在一起，而不是读写操作穿插着写。这得益于<strong>浏览器的渲染队列机制</strong>。</li>
</ul>
<p>浏览器针对页面的回流与重绘，进行了自身的优化——<strong>渲染队列</strong></p>
<p><strong>浏览器会将所有的回流、重绘的操作放在一个队列中，当队列中的操作到了一定的数量或者到了一定的时间间隔，浏览器就会对队列进行批处理。这样就会让多次的回流、重绘变成一次回流重绘。</strong></p>
<p>上面，将多个读操作（或者写操作）放在一起，就会等所有的读操作进入队列之后执行，这样，原本应该是触发多次回流，变成了只触发一次回流。</p>
<h3 id="3-如何优化动画？"><a href="#3-如何优化动画？" class="headerlink" title="3. 如何优化动画？"></a>3. 如何优化动画？</h3><p>对于如何优化动画，我们知道，一般情况下，动画需要频繁的操作DOM，就就会导致页面的性能问题，我们可以将动画的<code>position</code>属性设置为<code>absolute</code>或者<code>fixed</code>，将动画脱离文档流，这样他的回流就不会影响到页面了。</p>
<h3 id="4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？"><a href="#4-documentFragment-是什么？用它跟直接操作-DOM-的区别是什么？" class="headerlink" title="4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？"></a>4. documentFragment 是什么？用它跟直接操作 DOM 的区别是什么？</h3><p>MDN中对<code>documentFragment</code>的解释：</p>
<blockquote>
<p>DocumentFragment，文档片段接口，一个没有父对象的最小文档对象。它被作为一个轻量版的 Document使用，就像标准的document一样，存储由节点（nodes）组成的文档结构。与document相比，最大的区别是DocumentFragment不是真实 DOM 树的一部分，它的变化不会触发 DOM 树的重新渲染，且不会导致性能等问题。</p>
</blockquote>
<p>当我们把一个 DocumentFragment 节点插入文档树时，插入的不是 DocumentFragment 自身，而是它的所有子孙节点。在频繁的DOM操作时，我们就可以将DOM元素插入DocumentFragment，之后一次性的将所有的子孙节点插入文档中。和直接操作DOM相比，将DocumentFragment 节点插入DOM树时，不会触发页面的重绘，这样就大大提高了页面的性能。</p>
<h2 id="四、节流与防抖"><a href="#四、节流与防抖" class="headerlink" title="四、节流与防抖"></a>四、节流与防抖</h2><h3 id="1-对节流与防抖的理解"><a href="#1-对节流与防抖的理解" class="headerlink" title="1. 对节流与防抖的理解"></a>1. 对节流与防抖的理解</h3><ul>
<li>函数防抖是指在事件被触发 n 秒后再执行回调，如果在这 n 秒内事件又被触发，则重新计时。这可以使用在一些点击请求的事件上，避免因为用户的多次点击向后端发送多次请求。</li>
<li>函数节流是指规定一个单位时间，在这个单位时间内，只能有一次触发事件的回调函数执行，如果在同一个单位时间内某事件被触发多次，只有一次能生效。节流可以使用在 scroll 函数的事件监听上，通过事件节流来降低事件调用的频率。</li>
</ul>
<p><strong>防抖函数的应用场景：</strong></p>
<ul>
<li>按钮提交场景：防⽌多次提交按钮，只执⾏最后提交的⼀次 </li>
<li>服务端验证场景：表单验证需要服务端配合，只执⾏⼀段连续的输⼊事件的最后⼀次，还有搜索联想词功能类似⽣存环境请⽤lodash.debounce</li>
</ul>
<p><strong>节流函数的****适⽤场景：</strong> </p>
<ul>
<li>拖拽场景：固定时间内只执⾏⼀次，防⽌超⾼频次触发位置变动 </li>
<li>缩放场景：监控浏览器resize </li>
<li>动画场景：避免短时间内多次触发动画引起性能问题</li>
</ul>
<h3 id="2-实现节流函数和防抖函数"><a href="#2-实现节流函数和防抖函数" class="headerlink" title="2. 实现节流函数和防抖函数"></a>2. 实现节流函数和防抖函数</h3><p><strong>函数防抖的实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">debounce</span>(<span class="hljs-params">fn, wait</span>) &#123;<br>  <span class="hljs-keyword">var</span> timer = <span class="hljs-literal">null</span>;<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>];<br><br>    <span class="hljs-comment">// 如果此时存在定时器的话，则取消之前的定时器重新记时</span><br>    <span class="hljs-keyword">if</span> (timer) &#123;<br>      <span class="hljs-built_in">clearTimeout</span>(timer);<br>      timer = <span class="hljs-literal">null</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 设置定时器，使事件间隔指定事件后执行</span><br>    timer = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>      fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;, wait);<br>  &#125;;<br>&#125;<br></code></pre></td></tr></table></figure>

<p><strong>函数节流的实现：</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 时间戳版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span>(<span class="hljs-params">fn, delay</span>) &#123;<br>  <span class="hljs-keyword">var</span> preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> context = <span class="hljs-variable language_">this</span>,<br>      args = [...<span class="hljs-variable language_">arguments</span>],<br>      nowTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br><br>    <span class="hljs-comment">// 如果两次时间间隔超过了指定时间，则执行函数。</span><br>    <span class="hljs-keyword">if</span> (nowTime - preTime &gt;= delay) &#123;<br>      preTime = <span class="hljs-title class_">Date</span>.<span class="hljs-title function_">now</span>();<br>      <span class="hljs-keyword">return</span> fn.<span class="hljs-title function_">apply</span>(context, args);<br>    &#125;<br>  &#125;;<br>&#125;<br><br><span class="hljs-comment">// 定时器版</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">throttle</span> (fun, wait)&#123;<br>  <span class="hljs-keyword">let</span> timeout = <span class="hljs-literal">null</span><br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">let</span> context = <span class="hljs-variable language_">this</span><br>    <span class="hljs-keyword">let</span> args = [...<span class="hljs-variable language_">arguments</span>]<br>    <span class="hljs-keyword">if</span>(!timeout)&#123;<br>      timeout = <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function">() =&gt;</span> &#123;<br>        fun.<span class="hljs-title function_">apply</span>(context, args)<br>        timeout = <span class="hljs-literal">null</span> <br>      &#125;, wait)<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h2 id="五、图片优化"><a href="#五、图片优化" class="headerlink" title="五、图片优化"></a>五、图片优化</h2><h3 id="1-如何对项目中的图片进行优化？"><a href="#1-如何对项目中的图片进行优化？" class="headerlink" title="1. 如何对项目中的图片进行优化？"></a>1. 如何对项目中的图片进行优化？</h3><ol>
<li>不用图片。很多时候会使用到很多修饰类图片，其实这类修饰图片完全可以用 CSS 去代替。</li>
<li>对于移动端来说，屏幕宽度就那么点，完全没有必要去加载原图浪费带宽。一般图片都用 CDN 加载，可以计算出适配屏幕的宽度，然后去请求相应裁剪好的图片。</li>
<li>小图使用 base64 格式</li>
<li>将多个图标文件整合到一张图片中（雪碧图）</li>
<li>选择正确的图片格式：</li>
</ol>
<ul>
<li><ul>
<li>对于能够显示 WebP 格式的浏览器尽量使用 WebP 格式。因为 WebP 格式具有更好的图像数据压缩算法，能带来更小的图片体积，而且拥有肉眼识别无差异的图像质量，缺点就是兼容性并不好</li>
<li>小图使用 PNG，其实对于大部分图标这类图片，完全可以使用 SVG 代替</li>
<li>照片使用 JPEG</li>
</ul>
</li>
</ul>
<h3 id="2-常见的图片格式及使用场景"><a href="#2-常见的图片格式及使用场景" class="headerlink" title="2. 常见的图片格式及使用场景"></a>2. 常见的图片格式及使用场景</h3><p>（1）<strong>BMP</strong>，是无损的、既支持索引色也支持直接色的点阵图。这种图片格式几乎没有对数据进行压缩，所以BMP格式的图片通常是较大的文件。</p>
<p>（2）<strong>GIF</strong>是无损的、采用索引色的点阵图。采用LZW压缩算法进行编码。文件小，是GIF格式的优点，同时，GIF格式还具有支持动画以及透明的优点。但是GIF格式仅支持8bit的索引色，所以GIF格式适用于对色彩要求不高同时需要文件体积较小的场景。</p>
<p>（3）<strong>JPEG</strong>是有损的、采用直接色的点阵图。JPEG的图片的优点是采用了直接色，得益于更丰富的色彩，JPEG非常适合用来存储照片，与GIF相比，JPEG不适合用来存储企业Logo、线框类的图。因为有损压缩会导致图片模糊，而直接色的选用，又会导致图片文件较GIF更大。</p>
<p>（4）<strong>PNG-8</strong>是无损的、使用索引色的点阵图。PNG是一种比较新的图片格式，PNG-8是非常好的GIF格式替代者，在可能的情况下，应该尽可能的使用PNG-8而不是GIF，因为在相同的图片效果下，PNG-8具有更小的文件体积。除此之外，PNG-8还支持透明度的调节，而GIF并不支持。除非需要动画的支持，否则没有理由使用GIF而不是PNG-8。</p>
<p>（5）<strong>PNG-24</strong>是无损的、使用直接色的点阵图。PNG-24的优点在于它压缩了图片的数据，使得同样效果的图片，PNG-24格式的文件大小要比BMP小得多。当然，PNG24的图片还是要比JPEG、GIF、PNG-8大得多。</p>
<p>（6）<strong>SVG</strong>是无损的矢量图。SVG是矢量图意味着SVG图片由直线和曲线以及绘制它们的方法组成。当放大SVG图片时，看到的还是线和曲线，而不会出现像素点。这意味着SVG图片在放大时，不会失真，所以它非常适合用来绘制Logo、Icon等。</p>
<p>（7）<strong>WebP</strong>是谷歌开发的一种新图片格式，WebP是同时支持有损和无损压缩的、使用直接色的点阵图。从名字就可以看出来它是为Web而生的，什么叫为Web而生呢？就是说相同质量的图片，WebP具有更小的文件体积。现在网站上充满了大量的图片，如果能够降低每一个图片的文件大小，那么将大大减少浏览器和服务器之间的数据传输量，进而降低访问延迟，提升访问体验。目前只有Chrome浏览器和Opera浏览器支持WebP格式，兼容性不太好。</p>
<ul>
<li>在无损压缩的情况下，相同质量的WebP图片，文件大小要比PNG小26%；</li>
<li>在有损压缩的情况下，具有相同图片精度的WebP图片，文件大小要比JPEG小25%~34%；</li>
<li>WebP图片格式支持图片透明度，一个无损压缩的WebP图片，如果要支持透明度只需要22%的格外文件大小。</li>
</ul>
<h2 id="六、Webpack优化"><a href="#六、Webpack优化" class="headerlink" title="六、Webpack优化"></a>六、Webpack优化</h2><h3 id="1-如何提⾼webpack的打包速度"><a href="#1-如何提⾼webpack的打包速度" class="headerlink" title="1. 如何提⾼webpack的打包速度**?**"></a>1. 如何提⾼<strong>webpack</strong>的打包速度**?**</h3><h4 id="（1）优化-Loader"><a href="#（1）优化-Loader" class="headerlink" title="（1）优化 Loader"></a>（1）优化 Loader</h4><p>对于 Loader 来说，影响打包效率首当其冲必属 Babel 了。因为 Babel 会将代码转为字符串生成 AST，然后对 AST 继续进行转变最后再生成新的代码，项目越大，<strong>转换代码越多，效率就越低</strong>。当然了，这是可以优化的。</p>
<p>首先我们<strong>优化 Loader 的文件搜索范围</strong></p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk">module.exports = &#123;<br>  module: &#123;<br>    rules: [<br>      &#123;<br>        <span class="hljs-regexp">//</span> js 文件才使用 babel<br>        test: <span class="hljs-regexp">/\.js$/</span>,<br>        loader: <span class="hljs-string">&#x27;babel-loader&#x27;</span>,<br>        <span class="hljs-regexp">//</span> 只在 src 文件夹下查找<br>        include: [resolve(<span class="hljs-string">&#x27;src&#x27;</span>)],<br>        <span class="hljs-regexp">//</span> 不会去查找的路径<br>        exclude: <span class="hljs-regexp">/node_modules/</span><br>      &#125;<br>    ]<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>对于 Babel 来说，希望只作用在 JS 代码上的，然后 <code>node_modules</code> 中使用的代码都是编译过的，所以完全没有必要再去处理一遍。</p>
<p>当然这样做还不够，还可以将 Babel 编译过的文件<strong>缓存</strong>起来，下次只需要编译更改过的代码文件即可，这样可以大幅度加快打包时间</p>
<figure class="highlight ada"><table><tr><td class="code"><pre><code class="hljs ada">loader: <span class="hljs-symbol">&#x27;babel</span>-loader?cacheDirectory=<span class="hljs-literal">true</span>&#x27;<br></code></pre></td></tr></table></figure>

<h4 id="（2）HappyPack"><a href="#（2）HappyPack" class="headerlink" title="（2）HappyPack"></a>（2）HappyPack</h4><p>受限于 Node 是单线程运行的，所以 Webpack 在打包的过程中也是单线程的，特别是在执行 Loader 的时候，长时间编译的任务很多，这样就会导致等待的情况。</p>
<p><strong>HappyPack 可以将 Loader 的同步执行转换为并行的</strong>，这样就能充分利用系统资源来加快打包效率了</p>
<figure class="highlight gradle"><table><tr><td class="code"><pre><code class="hljs gradle">module: &#123;<br>  loaders: [<br>    &#123;<br>      test: <span class="hljs-regexp">/\.js$/</span>,<br>      <span class="hljs-keyword">include</span>: [resolve(<span class="hljs-string">&#x27;src&#x27;</span>)],<br>      <span class="hljs-keyword">exclude</span>: <span class="hljs-regexp">/node_modules/</span>,<br>      <span class="hljs-comment">// id 后面的内容对应下面</span><br>      loader: <span class="hljs-string">&#x27;happypack/loader?id=happybabel&#x27;</span><br>    &#125;<br>  ]<br>&#125;,<br>plugins: [<br>  <span class="hljs-keyword">new</span> HappyPack(&#123;<br>    id: <span class="hljs-string">&#x27;happybabel&#x27;</span>,<br>    loaders: [<span class="hljs-string">&#x27;babel-loader?cacheDirectory&#x27;</span>],<br>    <span class="hljs-comment">// 开启 4 个线程</span><br>    threads: <span class="hljs-number">4</span><br>  &#125;)<br>]<br></code></pre></td></tr></table></figure>

<h4 id="（3）DllPlugin"><a href="#（3）DllPlugin" class="headerlink" title="（3）DllPlugin"></a>（3）DllPlugin</h4><p><strong>DllPlugin 可以将特定的类库提前打包然后引入</strong>。这种方式可以极大的减少打包类库的次数，只有当类库更新版本才有需要重新打包，并且也实现了将公共代码抽离成单独文件的优化方案。DllPlugin的使用方法如下：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// 单独配置在一个文件中</span><br><span class="hljs-comment">// webpack.dll.conf.js</span><br><span class="hljs-keyword">const</span> path = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;path&#x27;</span>)<br><span class="hljs-keyword">const</span> webpack = <span class="hljs-built_in">require</span>(<span class="hljs-string">&#x27;webpack&#x27;</span>)<br><span class="hljs-variable language_">module</span>.<span class="hljs-property">exports</span> = &#123;<br>  <span class="hljs-attr">entry</span>: &#123;<br>    <span class="hljs-comment">// 想统一打包的类库</span><br>    <span class="hljs-attr">vendor</span>: [<span class="hljs-string">&#x27;react&#x27;</span>]<br>  &#125;,<br>  <span class="hljs-attr">output</span>: &#123;<br>    <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>),<br>    <span class="hljs-attr">filename</span>: <span class="hljs-string">&#x27;[name].dll.js&#x27;</span>,<br>    <span class="hljs-attr">library</span>: <span class="hljs-string">&#x27;[name]-[hash]&#x27;</span><br>  &#125;,<br>  <span class="hljs-attr">plugins</span>: [<br>    <span class="hljs-keyword">new</span> webpack.<span class="hljs-title class_">DllPlugin</span>(&#123;<br>      <span class="hljs-comment">// name 必须和 output.library 一致</span><br>      <span class="hljs-attr">name</span>: <span class="hljs-string">&#x27;[name]-[hash]&#x27;</span>,<br>      <span class="hljs-comment">// 该属性需要与 DllReferencePlugin 中一致</span><br>      <span class="hljs-attr">context</span>: __dirname,<br>      <span class="hljs-attr">path</span>: path.<span class="hljs-title function_">join</span>(__dirname, <span class="hljs-string">&#x27;dist&#x27;</span>, <span class="hljs-string">&#x27;[name]-manifest.json&#x27;</span>)<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<p>然后需要执行这个配置文件生成依赖文件，接下来需要使用 <code>DllReferencePlugin</code> 将依赖文件引入项目中</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><code class="hljs awk"><span class="hljs-regexp">//</span> webpack.conf.js<br>module.exports = &#123;<br>  <span class="hljs-regexp">//</span> ...省略其他配置<br>  plugins: [<br>    new webpack.DllReferencePlugin(&#123;<br>      context: __dirname,<br>      <span class="hljs-regexp">//</span> manifest 就是之前打包出来的 json 文件<br>      manifest: require(<span class="hljs-string">&#x27;./dist/vendor-manifest.json&#x27;</span>),<br>    &#125;)<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（4）代码压缩"><a href="#（4）代码压缩" class="headerlink" title="（4）代码压缩"></a>（4）代码压缩</h4><p>在 Webpack3 中，一般使用 <code>UglifyJS</code> 来压缩代码，但是这个是单线程运行的，为了加快效率，可以使用 <code>webpack-parallel-uglify-plugin</code> 来并行运行 <code>UglifyJS</code>，从而提高效率。</p>
<p>在 Webpack4 中，不需要以上这些操作了，只需要将 <code>mode</code> 设置为 <code>production</code> 就可以默认开启以上功能。代码压缩也是我们必做的性能优化方案，当然我们不止可以压缩 JS 代码，还可以压缩 HTML、CSS 代码，并且在压缩 JS 代码的过程中，我们还可以通过配置实现比如删除 <code>console.log</code> 这类代码的功能。</p>
<h4 id="（5）其他"><a href="#（5）其他" class="headerlink" title="（5）其他"></a>（5）其他</h4><p>可以通过一些小的优化点来加快打包速度</p>
<ul>
<li><code>resolve.extensions</code>：用来表明文件后缀列表，默认查找顺序是 <code>[&#39;.js&#39;, &#39;.json&#39;]</code>，如果你的导入文件没有添加后缀就会按照这个顺序查找文件。我们应该尽可能减少后缀列表长度，然后将出现频率高的后缀排在前面</li>
<li><code>resolve.alias</code>：可以通过别名的方式来映射一个路径，能让 Webpack 更快找到路径</li>
<li><code>module.noParse</code>：如果你确定一个文件下没有其他依赖，就可以使用该属性让 Webpack 不扫描该文件，这种方式对于大型的类库很有帮助</li>
</ul>
<h3 id="2-如何减少-Webpack-打包体积"><a href="#2-如何减少-Webpack-打包体积" class="headerlink" title="2. 如何减少 Webpack 打包体积"></a>2. 如何减少 Webpack 打包体积</h3><h4 id="（1）按需加载"><a href="#（1）按需加载" class="headerlink" title="（1）按需加载"></a>（1）按需加载</h4><p>在开发 SPA 项目的时候，项目中都会存在很多路由页面。如果将这些页面全部打包进一个 JS 文件的话，虽然将多个请求合并了，但是同样也加载了很多并不需要的代码，耗费了更长的时间。那么为了首页能更快地呈现给用户，希望首页能加载的文件体积越小越好，<strong>这时候就可以使用按需加载，将每个路由页面单独打包为一个文件</strong>。当然不仅仅路由可以按需加载，对于 <code>loadash</code> 这种大型类库同样可以使用这个功能。</p>
<p>按需加载的代码实现这里就不详细展开了，因为鉴于用的框架不同，实现起来都是不一样的。当然了，虽然他们的用法可能不同，但是底层的机制都是一样的。都是当使用的时候再去下载对应文件，返回一个 <code>Promise</code>，当 <code>Promise</code> 成功以后去执行回调。</p>
<h4 id="（2）Scope-Hoisting"><a href="#（2）Scope-Hoisting" class="headerlink" title="（2）Scope Hoisting"></a>（2）Scope Hoisting</h4><p><strong>Scope Hoisting 会分析出模块之间的依赖关系，尽可能的把打包出来的模块合并到一个函数中去。</strong></p>
<p>比如希望打包两个文件：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br></code></pre></td></tr></table></figure>

<p>对于这种情况，打包出来的代码会类似这样：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">[<br>  <span class="hljs-comment">/* 0 */</span><br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;,<br>  <span class="hljs-comment">/* 1 */</span><br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<p>但是如果使用 Scope Hoisting ，代码就会尽可能的合并到一个函数中去，也就变成了这样的类似代码：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript">[<br>  <span class="hljs-comment">/* 0 */</span><br>  <span class="hljs-keyword">function</span> (<span class="hljs-params"><span class="hljs-variable language_">module</span>, <span class="hljs-built_in">exports</span>, <span class="hljs-built_in">require</span></span>) &#123;<br>    <span class="hljs-comment">//...</span><br>  &#125;<br>]<br></code></pre></td></tr></table></figure>

<p>这样的打包方式生成的代码明显比之前的少多了。如果在 Webpack4 中你希望开启这个功能，只需要启用 <code>optimization.concatenateModules</code> 就可以了：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span>.<span class="hljs-keyword">exports</span> = &#123;<br>  optimization: &#123;<br>    concatenateModules: <span class="hljs-literal">true</span><br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<h4 id="（3）Tree-Shaking"><a href="#（3）Tree-Shaking" class="headerlink" title="（3）Tree Shaking"></a>（3）Tree Shaking</h4><p><strong>Tree Shaking 可以实现删除项目中未被引用的代码</strong>，比如：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><code class="hljs javascript"><span class="hljs-comment">// test.js</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> a = <span class="hljs-number">1</span><br><span class="hljs-keyword">export</span> <span class="hljs-keyword">const</span> b = <span class="hljs-number">2</span><br><span class="hljs-comment">// index.js</span><br><span class="hljs-keyword">import</span> &#123; a &#125; <span class="hljs-keyword">from</span> <span class="hljs-string">&#x27;./test.js&#x27;</span><br></code></pre></td></tr></table></figure>

<p>对于以上情况，<code>test</code> 文件中的变量 <code>b</code> 如果没有在项目中使用到的话，就不会被打包到文件中。</p>
<p>如果使用 Webpack 4 的话，开启生产环境就会自动启动这个优化功能。</p>
<h3 id="3-如何⽤webpack来优化前端性能？"><a href="#3-如何⽤webpack来优化前端性能？" class="headerlink" title="3. 如何⽤webpack来优化前端性能？"></a>3. 如何⽤<strong>webpack</strong>来优化前端性能？</h3><p>⽤webpack优化前端性能是指优化webpack的输出结果，让打包的最终结果在浏览器运⾏快速⾼效。 </p>
<ul>
<li><strong>压缩代码</strong>：删除多余的代码、注释、简化代码的写法等等⽅式。可以利⽤webpack的 UglifyJsPlugin 和 ParallelUglifyPlugin 来压缩JS⽂件， 利⽤ cssnano （css-loader?minimize）来压缩css </li>
<li><strong>利⽤<strong><strong>CDN</strong></strong>加速</strong>: 在构建过程中，将引⽤的静态资源路径修改为CDN上对应的路径。可以利⽤webpack对于 output 参数和各loader的 publicPath 参数来修改资源路径 </li>
<li><strong>Tree Shaking</strong>: 将代码中永远不会⾛到的⽚段删除掉。可以通过在启动webpack时追加参数 –optimize-minimize 来实现</li>
<li><strong>Code Splitting:</strong> 将代码按路由维度或者组件分块(chunk),这样做到按需加载,同时可以充分利⽤浏览器缓存 </li>
<li><strong>提取公共第三⽅库</strong>: SplitChunksPlugin插件来进⾏公共模块抽取,利⽤浏览器缓存可以⻓期缓存这些⽆需频繁变动的公共代码</li>
</ul>
<h3 id="4-如何提⾼webpack的构建速度？"><a href="#4-如何提⾼webpack的构建速度？" class="headerlink" title="4. 如何提⾼webpack的构建速度？"></a>4. 如何提⾼<strong>webpack</strong>的构建速度？</h3><ol>
<li>多⼊⼝情况下，使⽤ CommonsChunkPlugin 来提取公共代码 </li>
<li>通过 externals 配置来提取常⽤库 </li>
<li>利⽤ DllPlugin 和 DllReferencePlugin 预编译资源模块 通过 DllPlugin 来对那些我们引⽤但是绝对不会修改的npm包来进⾏预编译，再通过 DllReferencePlugin 将预编译的模块加载进来。 </li>
<li>使⽤ Happypack 实现多线程加速编译 </li>
<li>使⽤ webpack-uglify-parallel 来提升 uglifyPlugin 的压缩速度。 原理上 webpack-uglify-parallel 采⽤了多核并⾏压缩来提升压缩速度 </li>
<li>使⽤ Tree-shaking 和 Scope Hoisting 来剔除多余代码</li>
</ol>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>为什么现在的年轻人活得那么累？</title>
    <url>/2022/10/05/young%20people/</url>
    <content><![CDATA[<h2 id="为什么现在的年轻人活得那么累？"><a href="#为什么现在的年轻人活得那么累？" class="headerlink" title="为什么现在的年轻人活得那么累？"></a>为什么现在的年轻人活得那么累？</h2><span id="more"></span>
<p>21岁的“阿袋”在读者问答征集中提出问题：为什么现在二十岁的年轻人活得那么累？</p>
<hr>
<p>看到这个题目时我想起自己二十岁以后常常感叹累的瞬间。</p>
<p>普通本科学历，笨鸟先飞，我比其他人更早参加实习，两个月后独立负责标杆房企的营销策划方案。领导是名校毕业的白富美，同事是到点就走的本地人，甲方是吹毛求疵、流程繁冗的国企，节点卡在眼前，日日加班，步步为营。那是第一份实习，对于二十二岁的我，要保证毕业不失业，只能追着别人跑。</p>
<p>辗转几份工作后，已经有了一些可以反向选择的资本，但依然没敢停下来。从房地产的营销策划条线到了设计条线，由于不是相关专业出身，做事情永远慢半拍，平级同事的工作又常交给我处理，我从没拒绝过。那时的累是选择。我大可以完成工作就走，可以拒绝同事的委托，但生活不是孤立的点，今天的一切都不会白费。</p>
<p>二十五岁时我基本完成了自恰——活着就是很辛苦的。<strong>因为不想跑，所以努力跑</strong>。</p>
<p><strong>年轻人的累，来自爆炸的信息</strong>。互联网通过一块块屏幕，把金字塔顶端的生活碎片推来我们面前，年轻人眼中的世界充满贫富分化、容貌焦虑。</p>
<p><strong>年轻人的累，来自教育的局限</strong>。一方面，发达地区和欠发达地区的贫富差距带来了教育资源的巨大落差；另一方面，多数人前二十年埋头苦读，迈出象牙塔时，又发现真正的丛林法则未在书中习得。</p>
<p><strong>年轻人的累，来自沉重的感恩</strong>。二十岁自然活力无限，但父母老去的脚步从不减慢。如果自由的代价是让父母停在原地，那太多人会选择忍受年轻的累，太少人能把压力轻易卸下，独善其身。</p>
<p>我们负重前行，有人岁月静好。</p>
<p>而在我们看得到却触不可及的地方，外交官的儿子轻松成为高考状元，顶级奢侈品牌给疫情封控在家的VIP客户送去物资，女主播靠美貌登上福布斯富豪榜——王侯将相有“种”，天生丽质是“命”。</p>
<p>作为观众的年轻人常常自嘲：<strong>我来人间凑数的日子</strong>。看似戏谑，实际上裹挟在“躺平”姿态下的真心话却是自卑和害怕——一切似乎已注定，奔跑的脚步将被历史的车轮轧平。</p>
<p>但我今天写这些的目的并不是渲染年轻人的苦和累，也不是支持躺平和放弃，当然，更不是号召大家“卷”起来。</p>
<p><strong>痛苦不是生活的唯一真相，一味乐观也不是</strong>。</p>
<p>中国式教育鼓励比较、竞争、赢，因为我们国家人太多了，坦白讲，所有的机会都是争取来的。上个世纪处于温饱时人民争夺一口粮食，那是活下来的机会；竞争铁饭碗，那是生存的保障；高考，被称为千军万马过独木桥；考公务员，理想的岗位招人时千里挑一……</p>
<p>物竞天择适者生存的逻辑根植于中国人脑子，因为我们脱贫还没有太久，退休制度和医保制度尚未覆盖全民。说累，其实不过是一边拿二十岁的汗水换六十岁的保障，一边不甘于成为时代沉默的炮灰。</p>
<p>我在地产行业的第一年，领导告诉我一个极有效的工作技巧，列时间表。事情太多了，新增的太多，变化的也太多，只能靠把所有事项写下来，每天更新，每天完结。二十二岁的青春光鲜亮丽，背地里也在一遍遍时间倒推的紧迫中自我雕刻。</p>
<p>我在地产行业的第三年，微信签名是很简单的五个字：和时间赛跑。所有的节点、目标都在推着人们走，只好无限增加工作时长。白天出差，晚上回自己的城市到公司做文件。夜与白昼同时被拉长。</p>
<p>薪水似乎没有因工作年限的增加而产生突破，而中年危机、房价上涨从来没有等过人。</p>
<p><strong>国人就是这样的，和资源、和同类竞争了以后，还要和时间比、和自己比</strong>。</p>
<p>到工作第四年，有一天我突然意识到，人在工作中什么时候开始不那么累呢，是不比了。</p>
<p>做错了事情——错了就错了，改就好了。</p>
<p>今年业绩没有比去年更好，拿的钱少了——少就少了，继续干就完了。</p>
<p><strong>生活没有别的办法，只能继续生活</strong>。</p>
<p>有一天你发现你不是跟自己和解了也不是跟世界和解了，因为<strong>人活着不是一场比赛，每个人的状态、思想观念都不必跟其他人战斗</strong>。</p>
<p>同为人类，我们承认年轻人的累，根本上是希望能够抚平焦虑：<strong>你的一切都在被“看见”</strong>。</p>
<p>我们不歌颂苦难教育，也从不认为自己体会过的苦和累比别人更沉重、更深刻，<strong>因为苦难不应该被计算和比较，谁都不能傲慢地轻看他人的遭遇</strong>。</p>
<p>而你之所以看穿人生艰难却不再愁眉不展，只因为这是你琢磨出来最有效的解法——沉在旋涡里没用，你还得继续冲向浪潮。<strong>我们呼吁勇敢和坚持，因为这是破釜沉舟的觉悟，是不得不做的抉择。倒不是酷不酷的问题，是自你进入生命的这片海，往前漂就成了唯一的使命</strong>。</p>
]]></content>
      <categories>
        <category>问答</category>
      </categories>
      <tags>
        <tag>问答</tag>
        <tag>阅读</tag>
        <tag>转载</tag>
      </tags>
  </entry>
  <entry>
    <title>程序员软技能</title>
    <url>/2022/08/22/soft%20skill/</url>
    <content><![CDATA[<h2 id="程序员软技能"><a href="#程序员软技能" class="headerlink" title="程序员软技能"></a>程序员软技能</h2><span id="more"></span>

<h2 id="一、如何通过HR⾯"><a href="#一、如何通过HR⾯" class="headerlink" title="一、如何通过HR⾯"></a>一、如何通过HR⾯</h2><p>HR通常是程序员⾯试的最后⼀⾯,讲道理刷⼈的⼏率不⼤,但是依然有⼈倒在了这最后⼀关上，我们会从HR的⻆度出发来分析如何应对HR⾯. </p>
<h3 id="1-HR⾯的⽬的"><a href="#1-HR⾯的⽬的" class="headerlink" title="1. HR⾯的⽬的"></a>1. HR⾯的⽬的</h3><p>HR⾯往往是把控⼈才质量的最后⼀关,与前⾯的技术⾯不同,HR⾯往往侧重员⼯⻛险的评估与基本的员⼯素质。</p>
<ul>
<li><strong>录⽤⻛险评估****，</strong>这部分是评估候选⼈是否具备稳定性,是否会带来额外的管理⻛险，是否能⻢上胜任⼯作，⽐如频繁的跳槽会带了稳定性的⻛险，HR会慎重考虑这⼀点，⽐如在⾯试中候选⼈体现出了「杠精」潜质，HR会担⼼候选⼈在⼯作中会难以与他⼈协作或者不服从管理，带来管理⻛险，再⽐如，虽然国家明确规定在招聘中不得有性别、年龄等歧视，但是⼀个⼤龄已婚妇⼥会有近期产⼦的可能性，可能会有⻓期的产假，HR也会做出评估。 </li>
<li><strong>员⼯素质评估****，</strong>这部分评估候选⼈是否具备职场的基本素质，是否有基本的沟通能⼒，是否有团队精神和合作意识等等，⽐如⼀个表现极为内向的候选⼈,HR可能会对其沟通能⼒产⽣怀疑.</li>
</ul>
<p>所以在与HR交流中要尽量保持踏实稳重、积极乐观的态度，切忌暴露出夸夸其谈、负能量、浮躁等性格缺陷。 </p>
<h3 id="2-HR⾯的常⻅问题"><a href="#2-HR⾯的常⻅问题" class="headerlink" title="2. HR⾯的常⻅问题"></a>2. HR⾯的常⻅问题</h3><h4 id="（1）你对未来3-5年的职业规划"><a href="#（1）你对未来3-5年的职业规划" class="headerlink" title="（1）你对未来3-5年的职业规划"></a>（1）你对未来3-5年的职业规划</h4><p><strong>⽬的</strong>: 这个问题就是考察候选⼈对未来的规划能⼒,主要想通过候选⼈的规划来嗅出候选⼈对⼯作的态度、稳定性和对技术的追求. </p>
<p><strong>分析</strong>: ⼀定要在你的回到中体现对技术的追求、对团队的贡献、对⼯作的态度，不要谈⼀些假⼤空的东⻄，或者薪资、职位这些太过于功利的东⻄,⽽且最好体现出你的稳定性,如果是校招⽣或者⼯作没⼏年的新⼈最好不要涉及创业这种话题,⼀⽅⾯职场新⼈计划没⼏年就创业,这种很不切实际,说明候选⼈没法按实际出发,另⼀⽅⾯说明候选⼈的稳定性不够. </p>
<p>建议分三部分谈: </p>
<ol>
<li>⾸先表示考虑过这个问题(有规划),如何谈⼀谈⾃⼰的现状(结合实际). </li>
<li>接着从⼯作本身出发,谈谈⾃⼰会如何出⾊完成本职⼯作,如何对团队贡献、如何帮助带领团队其他成员创造更多的价值、如何帮助团队扩⼤影响⼒. </li>
<li>最后从学习出发,谈谈⾃⼰会如何精进领域知识、如何通过提升⾃⼰专业能⼒,如何反哺团队.</li>
</ol>
<p>⾄于想成为技术leader还是技术专家,就看⾃⼰的喜好了. </p>
<h4 id="（2）如何看待加班-996"><a href="#（2）如何看待加班-996" class="headerlink" title="（2）如何看待加班(996)?"></a>（2）如何看待加班(996)?</h4><p><strong>⽬的</strong>: 考察候选⼈的抗压能⼒和责任⼼ </p>
<p><strong>分析</strong>: 这个问题⼏乎是必问的,虽然996ICU事件闹得沸沸扬扬,但是官⽅的态度很暧昧,只⼝头批评从没有实际⾏动,基本上是默许企业违反劳动法的,除了个别外企在国内基本没可能找到不加班的公司,所以在这个⾯试题中尽量体现出⾃⼰愿意牺牲⾃我时间来帮助团队和企业的意愿就⾏了,⽽且要强调⾃⼰的责任⼼,如果真的是碰到⽆意义加班,好好学习怎么⽤vscode刷LeetCode划⽔是正道. </p>
<p><strong>建议</strong>: </p>
<ol>
<li>把加班分为紧急加班和⻓期加班 </li>
<li>对于紧急加班,表示这是每个公司都会遇到的情况,⾃⼰愿意牺牲时间帮助公司和团队 </li>
<li>对于⻓期加班,如果是⾃⼰⻓期加班那么会磨练⾃⼰的技能,提⾼⾃⼰的效率,如果是团队⻓期加班,⾃⼰会帮助团队找到问题,利⽤⾃动化⼯具或者更⾼效的协作流程来提⾼整个团队的效率,帮助⼤家摆脱加班</li>
</ol>
<p>当然了,就算你提⾼了团队效率，还是会被安排更多的任务，加班很多时候仅仅是⽬的,，但是你不能说出来啊，尤其是⼀些候选⼈很强硬得表示⻓期加班不接受,其实可以回答的更委婉，除⾮你是真的对这个公司没兴趣，如果以进⼊这个公司为第⼀⽬的,还是做个⾼姿态⽐较好。 </p>
<h4 id="（3）⾯对⼤量超过⾃⼰承受能⼒且时间有限的⼯作时你会怎么办"><a href="#（3）⾯对⼤量超过⾃⼰承受能⼒且时间有限的⼯作时你会怎么办" class="headerlink" title="（3）⾯对⼤量超过⾃⼰承受能⼒且时间有限的⼯作时你会怎么办?"></a>（3）⾯对⼤量超过⾃⼰承受能⼒且时间有限的⼯作时你会怎么办?</h4><p><strong>⽬的</strong>: 考察候选⼈时间管理和处理⼤量任务的能⼒,当然也会涉及⼀定的沟通能⼒ </p>
<p><strong>分析</strong>: 程序员的⼯作内容可能⼤部分时间并不在写代码上,⽽是要处理各种会议、需求和沟通,通常都属于⼯作超负荷的状态,⾯对上⾯这种问题不建议以加班的⽅式来解决,因为主要考察的是你的时间管理能⼒和沟通能⼒,这些要素要在回答中体现出来 </p>
<p>建议:</p>
<ol>
<li>将⼤量任务分解为紧急且重要、重要但不紧急、紧急但不重要、不重要且不紧急,依次完成上述任务,在这⾥体现出时间管理的能⼒ </li>
<li>与⾃⼰的领导沟通将不重要的任务放缓执⾏或者砍掉,或者派给组内的新⼈处理,在这⾥体现出沟通能⼒</li>
</ol>
<h4 id="（4）你之前在上海为什么现在来北京发展"><a href="#（4）你之前在上海为什么现在来北京发展" class="headerlink" title="（4）你之前在上海为什么现在来北京发展?"></a>（4）你之前在上海为什么现在来北京发展?</h4><p><strong>⽬的</strong>: 考察候选⼈的稳定性和职业选择 </p>
<p>分析: 这个问题⼀般是上份⼯作在异地的情况下⼤概率出现,HR主要担⼼候选⼈异地换⼯作可能会不稳定,有短期内离职⻛险,这个时候不建议说”北京互联⽹公司多,机会多”这种话(合着觉得北京好跳槽?),回答最好要体现出⾃⼰的稳定性,⽐如”⼥朋友在北京,⻓期异地,准备来北京⼀起发展” “家在北京,回北京发展” 等等,潜台词就是以后会在北京发展,不会在多地之间来回摇摆. </p>
<h4 id="（5）为什么从上⼀家公司离职"><a href="#（5）为什么从上⼀家公司离职" class="headerlink" title="（5）为什么从上⼀家公司离职?"></a>（5）为什么从上⼀家公司离职?</h4><p>⽬的: 考察离职原因,候选⼈离职⻛险评估 </p>
<p><strong>分析</strong>: 这个问题经常会在跳槽的时候问到,这个时候切忌吐槽上⼀家公司或者⾃⼰的上⼀任⽼板,尽量从职业发展的⻆度来回答，凸显⾃⼰的稳定性和渴望学习上升的决⼼,⾄于⼀些敏感话题,⽐如加班太多、薪资太低这种问题也是可以谈的，毕竟你跳槽的诉求就是解决上家公司碰到的问题，但是不能触碰刚才提到的底线问题，切忌吐槽向. </p>
<p><strong>建议</strong>:</p>
<ol>
<li>因为⼯资低、离家远、加班多、技术含量低等等原因离职 </li>
<li>因为离家远花费在路途上的时间过多,不如⽤来充电,因为加班多导致没有时间充电,⽆法提⾼等等</li>
</ol>
<p>除了不要有负能量和吐槽向,这个部分可以坦诚得说出来 </p>
<h4 id="（6）你还有其他公司的Offer吗"><a href="#（6）你还有其他公司的Offer吗" class="headerlink" title="（6）你还有其他公司的Offer吗?"></a>（6）你还有其他公司的Offer吗?</h4><p>⽬的: 评估候选⼈是否有短时间内⼊职其他公司的可能性 </p>
<p>分析: 很多时候并不是候选⼈完美符合⼀个岗位的要求，HR当然想要⼀个技术更好、要钱更少、技术更匹配的候选⼈，但是候选⼈⼀般都会有这样或者那样的⼩问题。 </p>
<p>⽐如，你的表现是可以胜任⽬前的岗位的，但是这个岗位不是很紧急，HR可能把你当做备胎，来找⼀个性价⽐更⾼的候选⼈。⽐如,你的表现很好,履历优秀，HR不知道能不能100%拿下你。所以如果你很希望加⼊这个公司，最好要做到「欲擒故纵」,既要体现⾃身的市场竞争⼒,⼜要给到HR⼀定的压⼒。所以,即使你已经拿了全北京城互联⽹公司的offer了，也不要说⾃⼰offer多如⽜⽑，⼀副满不在乎的样⼦，这样会给HR造成他⼊职可能性不⼤的错觉，因为他的选择太多了。当然,也不要跪在地上舔:”加⼊公司是我的梦想,我只等这⼀个offer”，放⼼吧，⼀定被hr放到备胎⼈才库中. </p>
<p>建议: </p>
<ol>
<li>表明⾃⼰有三四个已经确认过的offer了(没有offer也要吹,但是不要透露具体公司) </li>
<li>但是第⼀意向还是本公司,如果薪资差距不⼤,会优先考虑本公司 </li>
<li>再透露出,有⼀两个offer催得⽐较急,希望这边快点出结果</li>
</ol>
<h4 id="（7）如何与HR谈薪资"><a href="#（7）如何与HR谈薪资" class="headerlink" title="（7）如何与HR谈薪资?"></a>（7）如何与HR谈薪资?</h4><p>HR与你谈论薪资经常有如下套路： </p>
<ul>
<li>HR: 您期望的薪资是多少？ </li>
<li>你: 25K。</li>
</ul>
<p>OK，你已经被HR成功套路。这个时候你的最⾼价就是25K了，然后HR会顺着这个价往下砍，所以你最终的薪资⼀般都会低于25K。等你接到offer，你的⼼⾥肯定充满了各种“悔恨”：其实当时报价26、27甚⾄28、29也是可以的。</p>
<p>正确的回答可以这样，并且还能够反套路⼀下HR： </p>
<ul>
<li>HR: 您期望的薪资是多少？ </li>
<li>你: 就我的⾯试表现，贵公司最⾼可以给多少薪⽔？</li>
</ul>
<p>如果经验不够⽼道的HR可能就真会说出⼀个报价（如25K）来，然后，你就可以很开⼼地顺着这个价慢慢地往上谈了。所以这种情况下，你最终的薪资肯定是⼤于25K的。当然，经验⽼道的HR会给你⼀句很官⽅的套话： </p>
<ul>
<li>HR: 您期望的薪资是多少？ </li>
<li>你: 就我的⾯试表现，贵公司最⾼可以给多少薪⽔？ </li>
<li>HR: 这个暂且没法确定，要结合您⼏轮⾯试结果和⽤⼈部⻔的意⻅来综合评定。</li>
</ul>
<p>虽然薪资很重要，但是我个⼈觉得这不是最重要的。我有以下建议： </p>
<ul>
<li>如果你觉得你技术⾯试效果很好，可以报⼀个⾼⼀点的薪资，这样如果HR想要你，会找你商量的。 </li>
<li>如果你觉得技术⾯试效果⼀般，但是你⽐较想进这家公司，可以报⼀个折中的薪资。 </li>
<li>如果你觉得⾯试效果很好，但是你不想进这家公司，你可以适当“漫天要价”⼀下。 </li>
<li>如果你觉得⾯试效果不好，但是你想进这家公司，你可以开⼀个稍微低⼀点的⼯资。</li>
</ul>
<p>需要注意的是，⾯试求职是⼀个双向选择的过程。⾯试应该做到不卑不亢，千万不要因为⾯试结果不好，就低声下⽓地乞求⼯作，每个⼈的⼯作经历和经验都是不⼀样的，技术⾯试不好，知道⾃⼰的短板针对性地补缺补差就⾏，⽽不是在⼈事关系上动歪脑筋。</p>
<h2 id="二、回答问题的技巧"><a href="#二、回答问题的技巧" class="headerlink" title="二、回答问题的技巧"></a>二、回答问题的技巧</h2><p>技术⾯试通常⾄少三轮: </p>
<ol>
<li>基础⾯试: 主要考察对岗位和简历中涉及到基础知识部分的提问,包括⼀部分算法和场景设计的⾯试题,这⼀⾯可能会涉及现场coding. </li>
<li>项⽬⾯试: 主要考察简历中涉及的项⽬,会涉及你项⽬的相关业务知识、扮演⻆⾊、技术取舍、技术攻坚等等. </li>
<li>HR⾯试: 这⼀⾯通常是HR把关,主要涉及⾏为⾯试,考察候选⼈是否价值观符合公司要求、⼯作稳定性如何、沟通协作能⼒如何等等.</li>
</ol>
<p>当然,对于初级岗或者校招⽣会涉及⼀轮笔试，相当多的公司会在现场⾯之前进⾏⼀轮电话⾯试，⽬的是最快速有效地把不符合要求的候选⼈筛除，对于个别需要跨部⻔协作的岗位会涉及交叉⾯试，⽐如前端候选⼈会被后端的⾯试官⾯试，⼀些有管理需求的岗位或者重要岗位可能会涉及总监⾯试或者vp⾯。</p>
<p>⽽⼀个正常的技术⾯试流程(以项⽬⾯为例)分为⼤致三个部分: </p>
<ol>
<li>⾃我介绍 </li>
<li>项⽬(技术)考察 </li>
<li>向⾯试官提问</li>
</ol>
<p>那么该如何准备技术⾯试,如何在⾯试中掌握主动权呢? </p>
<h3 id="1-⾃我介绍"><a href="#1-⾃我介绍" class="headerlink" title="1. ⾃我介绍"></a>1. ⾃我介绍</h3><p>⼏乎所有的⾯试都是从⾃我介绍这个环节开始的，所以我们得搞清楚为什么⾃我介绍通常作为⼀个⾯试的开头。 </p>
<h4 id="（1）为什么需要⾃我介绍"><a href="#（1）为什么需要⾃我介绍" class="headerlink" title="（1）为什么需要⾃我介绍"></a>（1）为什么需要⾃我介绍</h4><p>⾸先,有⼀个很普遍的问题就是⾯试官很可能才刚拿到你的简历，他需要在你⾃我介绍的时候快速浏览你的简历,因为技术⾯试的⾯试官很多是⼀线的员⼯,⾯试候选⼈只是其⼯作中的⼀⼩部分，很多情况下是没有提前看过你的简历的。</p>
<p>其次,⾃我介绍其实是⼀个热身,⾯试官和候选⼈其实是陌⽣⼈,⾃我介绍不管是⾯试还是其他情况下,都是两个陌⽣⼈彼此交流的起点,也是缓解候选⼈与⾯试官之间尴尬的⼀种热身⽅式. </p>
<p>最后,⾃我介绍是展示⾃我、引出接下来技术⾯试的引⼦，是你⾃⼰指定技术⾯试⽅向的⼀次机会。 </p>
<p>知道了以上原因，我们才能进⾏准备更好的⾃我介绍。 </p>
<h4 id="（2）⾃我介绍的⼏个必备要素"><a href="#（2）⾃我介绍的⼏个必备要素" class="headerlink" title="（2）⾃我介绍的⼏个必备要素"></a>（2）⾃我介绍的⼏个必备要素</h4><p>⾃我介绍归根到底是⼀个热身运动,因此切忌占⽤⼤量的篇幅,上来就把⾃⼰从出⽣的经历到⼤学像流⽔账⼀样吐出来的，往往会被没耐⼼的⾯试官打断,⽽这也暴露了候选⼈讲话缺乏重点、沟通能⼒⼀般的缺点。 </p>
<p>但是，⼀些关键信息是必须体现的，就我个⼈⽽⾔，以下信息是必备的: </p>
<ul>
<li>个⼈信息: ⾄少要体现出⾃⼰的姓名、岗位和⼯作年限，应届⽣则必须要介绍⾃⼰的教育背景，如果⾃⼰的前东家是个⼤⼚（⽐如BAT）最好提及，⾃⼰的学历是亮点（985或者硕博或者类似于北邮这种CS强校）最好提及，其他的什么有没有⼥朋友、是不是独⽣⼦没⼈在意，不要占⽤篇幅。这个部分重点在于「你是谁？」。 </li>
<li>技术能⼒: 简要地介绍⾃⼰的技术栈,切忌把⾃⼰只是简单使⽤过，写过⼏个Demo或者看了看⽂档的所谓「技术栈」也说出来，⼀旦后⾯问到算是⾃找尴尬。这个部分的重点在于「你会什么？」。 </li>
<li>技能擅⻓: 重点介绍⾃⼰擅⻓的技术,⽐如性能优化、⾼并发、系统架构设计或者是沟通协调能⼒等等，切忌夸⼤其词，要实事求是，这是之后考察的重点。这个部分重点⾃在于「你擅⻓什么?」。</li>
</ul>
<h4 id="（3）⾃我介绍要重点匹配当前岗位的技术栈"><a href="#（3）⾃我介绍要重点匹配当前岗位的技术栈" class="headerlink" title="（3）⾃我介绍要重点匹配当前岗位的技术栈"></a>（3）⾃我介绍要重点匹配当前岗位的技术栈</h4><p>你的⾯试简历可能包含了各种各样的技术栈,但是在⾃我介绍过程中需要匹配当前岗位的技术要求。就⽐如你⽬前⾯试的是移动端H5前端的开发岗位,就重点在⾃我介绍中突出⾃⼰在移动前端的经验,⽽此时⼤篇幅得讲述 ⾃⼰如何⽤Node⽀撑公司的web项⽬就显得很不明智. </p>
<h4 id="（4）要在⾃我介绍中做刻意引导"><a href="#（4）要在⾃我介绍中做刻意引导" class="headerlink" title="（4）要在⾃我介绍中做刻意引导"></a>（4）要在⾃我介绍中做刻意引导</h4><p>如果你的⾃我介绍跟流⽔账⼀样,没有任何重点,其实⾯试官也很难办，因为他都没法往下接话… </p>
<p>⽽只要你稍作引导,绝⼤部分⾯试官就会接你的话茬,⽐如「你在⾃我介绍中重点提及了⼀个项⽬，碰到了⼀些难点，然后被你攻克了，效果如何如何好等等」，如果我是⾯试官⼀定会问「你的xx项⽬的xx难点后来是怎么解决的？」。 </p>
<p>⾯试官的⽬的是考察候选⼈的能⼒，对候选⼈做出评估，因此需要知道候选⼈擅⻓什么，是否匹配岗位，⾯试官绝⼤多数情况下很乐意你这种有意⽆意的引导，这样双⽅的沟通和评估会很顺利，⽽不是故意刁难候选⼈。 </p>
<h4 id="（5）如何准备⾃我介绍"><a href="#（5）如何准备⾃我介绍" class="headerlink" title="（5）如何准备⾃我介绍"></a>（5）如何准备⾃我介绍</h4><p>其实最好的⽅法也是最笨的⽅法就是把⾃我介绍写下来，这个⾃我介绍⼀定要体现上⾯提到的⼏⼤必备要素，在⾯试前简单过⼏遍，能把⾃我介绍的内容顺利得表达出来即可，切忌跟背课⽂⼀样。 </p>
<p>⾃我介绍的时间最好控制在1-3分钟之间，这些时间⾜够⾯试官把你的简历过⼀遍了，⾯试官看完简历后正好接着你的⾃我介绍进⾏提问是最舒服的节奏，别上来开始10分钟的演讲，⾯试官等待的时候会很尴尬，这么⻓的篇幅说明你的⾃我介绍⼀定是流⽔账式的。 </p>
<h3 id="2-技术考察"><a href="#2-技术考察" class="headerlink" title="2. 技术考察"></a>2. 技术考察</h3><p>⼀个好的技术考察的开始,必须得有⾃我介绍部分好的铺垫和引导,有⼀种情况我们经常遇⻅: </p>
<blockquote>
<p>候选⼈说了⼀⼤堆⾮重点的⾃我介绍,⾯试官⼀时语塞,完全get不到候选⼈的重点,也不知道候选⼈擅⻓什么、有什么亮点项⽬，然后就在他简历的技术栈中选了本公司也在⽤的技术，候选⼈这个时候也开始冒汗，因为这个技术栈并不是他的擅⻓，回答的也磕磕绊绊，⾯试官的引导和深⼊追问也没有达到很好的效果，⾯试就在这种尴尬的⽓氛中展开了，⾯试结束后⾯试官对候选⼈的评价是技术不熟练、没有深⼊理解原理，候选⼈的感受是，⾯试官专挑⾃⼰不会的问。 </p>
</blockquote>
<p>所以在前⾯的部分,⼀定要做好引导,把⾯试官的问题引到我们擅⻓的领域,但是这样还不够,正所谓不打⽆准备之仗,我们依然需要针对可能出现的问题进⾏准备. </p>
<p>那么如何准备可能的⾯试题？ </p>
<p>⽐如你擅⻓前端的性能优化,在⾃我介绍的部分已经做好了引导,接下来⾯试官⼀定会重点考察你性能优化的能⼒,很可能会涉及很有深度的问题,即使你擅⻓这⽅⾯的技术,但是如果没有准备也可能临场乱了阵脚. </p>
<h4 id="（1）多重提问"><a href="#（1）多重提问" class="headerlink" title="（1）多重提问"></a>（1）多重提问</h4><p>⾃我多重提问的意思是,当⼀个技术问题抛出的时候,你可能⾯对更深层次的追问。</p>
<p>依旧以前端性能优化为例,⾯试官可能的提问: </p>
<ol>
<li>你把这个⼿机端的⽩屏时间减少了150%以上,是从哪些⽅⾯⼊⼿优化的?这个问题即使你没做过前端性能优化也能回答个七七⼋⼋,⽆⾮是组件分割、缓存、tree shaking等等，这是第⼀重⽐较浅的问题。 </li>
<li>我看你⽤webpack中SplitChunksPlugin这个插件进⾏分chunk的,你分chunk的取舍是什么?哪些库分在同⼀个chunk,哪些应该分开你是如何考虑的?如果你提到了SplitChunksPlugin插件可能会有类似的追问,如果没有实际操作过的候选⼈这个时候就难以招架了,这个过程⼀定是需要⼀定的试错和取舍的. </li>
<li>在分chunk的过程中有没有遇到什么坑?怎么解决的?其实SplitChunksPlugin这个插件有⼀个暗坑,那就是chunid⾃增性导致id不固定唯⼀,很可能⼀个新依赖就导致id全部打乱,使得http缓存失效.</li>
</ol>
<p>以上只是针对SplitChunksPlugin插件相关的优化提问,当然也可能从你的性能测试⻆度、代码层⾯进⾏考察，但是思路是类似的。因此不能把⾃⼰准备的问题答案停留在⼀个很浅显的层⾯，⼀⽅⾯⽆法展示⾃⼰的技术深度，另⼀⽅⾯在⾯试官的深度体情况下容易丢分，因此在⾃⼰的答案后⾯多进⾏⾃我的追问，看⼀看能不能把问题做的更深⼊。 </p>
<h4 id="（2）答题法则"><a href="#（2）答题法则" class="headerlink" title="（2）答题法则"></a>（2）答题法则</h4><p>很多⾯试相关的宝典都推荐使⽤STAR法则进⾏问题的应答,我们不想引⼊这个额外的概念,基础技术⾯试的部分⽼⽼实实回答⾯试官的问题即可,通常需要问题运⽤到这个法则的是项⽬⾯,⽐如让你介绍⼀下你最得意的项⽬,回答问题的法则有这⼏个要点: </p>
<ul>
<li>项⽬背景: 简要说⼀下项⽬的背景,让⾯试官知道这个项⽬是做什么的 </li>
<li>个⼈⻆⾊: 让⾯试官知道你在这个项⽬中扮演的⻆⾊ </li>
<li>难点: 让⾯试官知道你在项⽬开发过程中碰到的难点 </li>
<li>解决⽅案: 针对上⾯的难点你有哪⼀些解决⽅案,是如何结合业务进⾏取舍的 </li>
<li>总结沉淀: 在攻克上述的难点后有没有沉淀出⼀套通⽤的解决⽅案,有没有将⾃⼰的⽅案在⼤部⻔进⾏推⼴等等</li>
</ul>
<p>重点就在于后⾯三条,也是最体现你个⼈综合素质的⼀部分,我是⾯试官的话会⾮常欣赏那种可以发现问题、找到多种⽅ 案、能对多种⽅案进⾏⽐对取舍还可以总结沉淀出通⽤解决⽅案回馈团队的⼈。从上述⼏点可以体现出⼀个⼈的技术热情、解决问题的能⼒和总结提⾼的能⼒。 </p>
<h4 id="（3）刻意引导"><a href="#（3）刻意引导" class="headerlink" title="（3）刻意引导"></a>（3）刻意引导</h4><p>是的，在回答⾯试官提问的时候也可以做到刻意引导。 </p>
<p>举⼏个简单的例⼦： </p>
<ul>
<li>除了Vue还⽤过Angular吗？ 这个时候很多候选⼈就很实诚回答「没有」，其实我们可以回答的更好，把你知道的说出来展示⾃⼰的能⼒才是最重要的，你可以说「我虽然没⽤过，但是在学习双向绑定原理的时候了解了⼀下 Angular脏检查的原理，在学习Nestjs的时候了解了依赖注⼊的原理，跟Angular也是类似的」，⾯试官⼀定会接着问你脏检查和依赖注⼊的问题，虽然你没有⽤过Angular，但是Angular的基本原理你都懂，这是很好的加分项，说明候选⼈有深⼊理解原理的意愿和触类旁通的能⼒ </li>
<li>Vue如何实现双向绑定的？ 很多候选⼈⽼⽼实实答了 object.defineproperty 如何如何操作,然后就没有了,其实你可以在回答完之后加上⼀嘴「Vue 3.0则选择了更好⽤的Proxy来替代object.defineproperty」或者「除了object.defineproperty这种数据劫持的⽅式，观察者模式和脏检查都可以实现双向绑定」，⾯试官⼤概率会问「Proxy好在哪？」或者「聊聊脏检查」等等，这样下⼀个问题就会依然在你的可控范围内</li>
</ul>
<p>我们第⼀个例⼦把本来回答不上来的问题，转化为了成功展示⾃⼰能⼒的加分项，第⼆个例⼦让⾃⼰更多的展示了⾃⼰的能⼒，⽽且始终使⾯试官的问题在⾃⼰的可控范围内。</p>
<h3 id="3-向⾯试官提问"><a href="#3-向⾯试官提问" class="headerlink" title="3. 向⾯试官提问"></a>3. 向⾯试官提问</h3><p>这个部分基本到了⾯试尾声了,属于做好了不影响⼤局,但是可能加分,如果做不好很容易踩雷的区域. </p>
<p>⾸先我们声明⼏个雷区: </p>
<ul>
<li>切忌问结果: 问了也⽩问,绝⼤部分公司规定不会透露结果的,你这样让⼤家很尴尬 </li>
<li>切忌问⼯资: 除了HR跟你谈⼯资的时候,千万别跟技术⾯试官谈⼯资,⼯资是所有公司的⾼压线,没法谈论 </li>
<li>切忌问技术问题: 别拿⾃⼰不会的技术难题反问⾯试官,完全没意义,⾯试官答也不是不答也不是</li>
</ul>
<p>有⼏个⽐较好的提问可供参考: </p>
<ul>
<li>如果我⼊职这个岗位的话,前三个⽉你希望我能做到些什么? </li>
<li>我的这个岗位的前任是为什么离职的,我什么地⽅能做的更好? </li>
<li>你对这个职位理想⼈选的要求是什么?</li>
</ul>
<p>尽量围绕你的岗位进⾏提问,这可以使得你更快得熟悉你的⼯作内容,也让⾯试官看到你对此岗位的兴趣和热情,重要的是 这些问题对于⾯试官⽽⾔既可以简略回答,也可以详细的给你讲解,如果他很热情得跟你介绍此岗位相关的情况,说明你可能表现得不错,否则的话,你可能不在他的备选名单⾥,这个时候就需要你早做打算了。</p>
<h2 id="三、⾯试官到底想看什么样的简历？"><a href="#三、⾯试官到底想看什么样的简历？" class="headerlink" title="三、⾯试官到底想看什么样的简历？"></a>三、⾯试官到底想看什么样的简历？</h2><p>⾯试⼀直是程序员跳槽时期⾮常热⻔的话题，虽然现在已经过了跳槽的旺季，下⼀轮跳槽季需要到年底才会出现，但是当跳槽季的时候你再看这篇⽂章可能已经晚了，过冬的粮⻝永远不是冬天准备的，⽽是秋收的时候。 </p>
<p>简历是你进⼊⾯试的敲⻔砖，也是留给意向公司的第⼀印象，所以这个很重要，必须在这上⾯做⾜了⽂章，⼀份优秀的⾯试简历是整个⾯试成败的重中之重，我们会详细分析如何准备简历才能保证简历不被刷掉。 </p>
<p>简历通常有这⼏部分构成: </p>
<ol>
<li>基本资料 </li>
<li>专业技能 </li>
<li>⼯作经历 </li>
<li>项⽬经历 </li>
<li>教育背景</li>
</ol>
<p>我们会逐⼀进⾏分析。 </p>
<h3 id="1-准备简历模板"><a href="#1-准备简历模板" class="headerlink" title="1. 准备简历模板"></a>1. 准备简历模板</h3><p>万事开头难，简历的编写如果从头开始需要浪费很多时间，其实最快速也最聪明的办法就是先找⼀份还不错的简历模板，之后我们只需要填写信息即可。 </p>
<p>简历模板的选择很讲究，有些简历基本不看内容就会被刷掉，这些简历⼀般会对⾯试官进⾏视觉攻击，让简历给⾯试官的第⼀印象就是反感。 </p>
<p>有两种坑爹的简历模板: </p>
<ul>
<li>⼀种是经典简历模板，真是堪称『经典』，这种简历模板在我上⼩学的时候就有了，以现在的眼光看有点不够看了，配 ⾊也⽐较『魔幻』，加上表格类的简历属于low到底端的简历类型，基本上扫⼀眼就扔了，这种简历只需要3秒钟就能被⾯试官扔到垃圾堆</li>
<li>另⼀种是设计感⼗⾜的简历模板，这种简历设计感⼗⾜，这五颜六⾊的配⾊⼀定能亮瞎⾯试官的双眼，这种花⾥胡哨的简历同样也是3秒钟沉到垃圾堆底部的简历。</li>
</ul>
<p>以上两类简历模板堪称⾯试官杀⼿，我相信只要你⽤了上述两类模板，绝对连让⾯试官看第⼆眼的兴趣都没有。⾯试官筛简历要的是⾼效、清晰、内容突出，不管是HR还是技术⾯试官都想在最快速的情况下看到有效信息，你眼中所谓的『视觉效果』在别⼈眼⾥就是『视觉噪⾳』或者『视觉垃圾』，严重影响看简历的⼼情和寻找有效信息的速度。</p>
<h3 id="2-准备个⼈信息"><a href="#2-准备个⼈信息" class="headerlink" title="2. 准备个⼈信息"></a>2. 准备个⼈信息</h3><p>个⼈信息部分主要包括姓名、电话、点⼦邮箱、求职意向，当然这四个是必填的，其它的都是选填，填好了是加分项，否则很可能减分。 </p>
<p>接下来才是重点： </p>
<ol>
<li>github：如果准备⼀个基本没有更新的博客或者没有任何贡献的github，那么给⾯试官⼀种为了放上去⽽放上去的感觉，这基本上就是在跟⾯试官说『这个候选⼈平时根本没有总结提炼的习惯』，所以如果有⻓期维护的github或者博客⼀定要放上去，质量好的话会⾮常有⽤，如果没有千万别放。 </li>
<li>学历：如果你的学历是专科、⾼中毕业之类的，还写在简历头部强调⼀遍，这就造成了你是『学渣』的印象，没有公司喜欢学渣的，这⼜增加了简历被刷的⼏率，如果是研究⽣以上学历可以写，突出⼀下学历优势，本科学历在技术⾯试领域基本上敲⻔砖级别的，没必要写。 </li>
<li>年龄：如果你是⼤龄程序员，尤其是你还在求⼀份低端岗位的时候千万别写，⼀个⼤龄程序员在求职⼀个中低端岗位，说明这些年基本原地踏步，还不能加班，到这⾥基本上此简历就凉了⼀半了。 </li>
<li>照⽚：形象优秀的可以贴，尤其是形象优秀的⼥程序媛，其它的最好不要贴，如果要贴的话，最好是贴那种PS过的⾮常职业的证件照，那种平时搞怪的、光着膀⼦的⽣活照，基本就是⾃杀⾏为。</li>
</ol>
<h3 id="3-准备专业技能"><a href="#3-准备专业技能" class="headerlink" title="3. 准备专业技能"></a>3. 准备专业技能</h3><p>对于程序员的专业技能其实就是技术栈，对于⾃⼰的技术栈如何描述是个很难的问题，⽐如什么算是精通？什么算是了解？什么是熟悉？ </p>
<p>关于对技术技能的描述有很多种，有五种的也有三种的，⽽且每个⼈对词汇的理解都不⼀样，我结合相关专家的理解和⾃⼰的理解来简单阐述下描述词汇的区别，我们这⾥只讲三种的了解、熟悉、精通。 </p>
<ul>
<li>了解：使⽤过某⼀项技术，能在别⼈指导下完成⼯作，但不能胜任复杂⼯作，也不能独⽴解决问题。 </li>
<li>熟悉：⼤量运⽤过的某⼀项技术，能独⽴完成⼯作，且能独⽴完成有⼀定复杂度的⼯作，在技术的应⽤层⾯不会有太⼤问题，甚⾄理解⼀点原理。 </li>
<li>精通：不仅可以运⽤某⼀⻔技术完成复杂项⽬，⽽且理解这项技术背后的原理，可以对此技术进⾏⼆次开发，甚⾄本身就是技术源码的贡献者。</li>
</ul>
<p>我们就以Vue这个框架为例，如果你可以⽤vue写⼀些简单的⻚⾯，单独完成某⼏个⻚⾯的开发，但是⽆法脱离公司脚⼿架⼯作，也⽆法独⽴从0完成⼀个有⼀定复杂度的项⽬，只能称之为了解。 </p>
<p>如果你有⼤量运⽤vue的经验，有从0独⽴完成⼀定复杂度项⽬的能⼒，可以完全脱离脚⼿架进⾏开发，且对vue的原理有⼀定的了解，可以称之为熟悉。 </p>
<p>如果你⽤vue完成过复杂度很⾼的项⽬，⽽且⾮常熟悉vue的原理，是vue源码的主要贡献者，亦或者根据vue源码进⾏过魔改（⽐如mpvue），你可以称得上精通。</p>
<p>那么有两个坑是候选⼈经常犯的，『杂』和『精』，这种两个坑⼤量集中在应届⽣和刚毕业每两年的新⼿身上，其主要特点是『急于表现⾃我』、『对技术深度与⼴度出现⽆知⽽导致的过度⾃信』。 </p>
<p>⾸先说说杂，⽐如你要应聘⼀个Java后端，⽼⽼实实把⾃⼰的java技术栈写好就⾏了，强调⼀下⾃⼰擅⻓什么即可，最好专精某领域⽐如『⾼并发』、『⾼可⽤』等等，这个时候⼀些简历⾮要给⾃⼰加戏，⾃⼰会的不会的⼀股脑往上堆，什么逆向、密码学、图形、驱动、AI都要体现出来，越杂越好，这种简历给⼈的印象就是个什么都不懂的半吊⼦。 </p>
<p>再说说精，⼀个刚毕业的应届⽣，出来简历就各种精通，精通Java、精通Java虚拟机、精通spring全家桶、精通kafka等等，请放⼼，这种简历是不会没头没脑投过来了，这种在⼤学⾥就精通各种的天才早被他的各种学⻓介绍进了⼤⼚或者外企做某某Star重点培养了，往往看到的这种也是半吊⼦。 </p>
<h3 id="4-准备⼯作经历"><a href="#4-准备⼯作经历" class="headerlink" title="4. 准备⼯作经历"></a>4. 准备⼯作经历</h3><p>⼯作经历本身不⽤花太多笔墨去写，⾯试官主要想看的就是每段⼯作经历的持续时间、在不同公司担任的职责如何、是否有⼤⼚的⼯作经验等等。 </p>
<p>那么什么简历在这⾥给⾯试官减分呢？ </p>
<ul>
<li>频繁跳槽：⽐如三年换了四家公司，每个公司呆的时⻓不要超过⼀年 </li>
<li>常年初级岗：⽐如⼯作五六年之后依然在完成⼀些简单的项⽬开发 </li>
<li>末流公司经历：在技术招聘届，⼤⼚的优先级最⾼⽐如BAT、TMD甚⾄微软、⾕歌等外企，知名度独⻆兽其次，⽐如商汤、旷视等等，⼀般的互联⽹公司排在第三，就是⼯作中⼩型的互联⽹公司⼀般⼤家叫不上名字，排在最后的就是外包和传统企业的经历</li>
</ul>
<p>所以，如果你有频繁跳槽的经历怎么办？在本公司⽼⽼实实等到满⼀年再跳槽。 </p>
<p>如果常年初级岗怎么办？想办法晋升或者参与⼀些业界知名项⽬，再或者写⼀个有⼀定复杂度的私⼈项⽬。 </p>
<p>如果有末流公司经历怎么办？如果是很久以前的末流公司经验可以直接不写，也没⼈在乎你很早之前的⼯作经历，如果你现在就在末流公司，赶紧想办法跳槽，去不了⼤⼚，去⾮知名的互联⽹公司也算是胜利⼤逃亡了。 </p>
<h3 id="5-准备项⽬经历"><a href="#5-准备项⽬经历" class="headerlink" title="5. 准备项⽬经历"></a>5. 准备项⽬经历</h3><p>项⽬经历不管对于社招还是校招都是重中之重，很多时候成败就在于项⽬经历这块，⼀个普通本科可以通过优秀的项⽬经历逆袭985，⼀个⼩⼚的员⼯也可以获得⼤⼚的⾯试机会。 </p>
<p>但是必须要说⼀下项⽬经历的编写很讲究，这是为后⾯⾯试部分铺路的绝佳机会，也是直接让你的简历扑街的重点沦陷区域。 </p>
<p>先说容易让简历扑街的⼏个坑位。 </p>
<h4 id="（1）切忌流⽔账写法"><a href="#（1）切忌流⽔账写法" class="headerlink" title="（1）切忌流⽔账写法"></a>（1）切忌流⽔账写法</h4><p>项⽬经历流⽔账写法是绝⼤多数简历的通病，通篇下来就讲了⼀件事『我⼲了啥』。 </p>
<p>⼤部分简历却是这样的： </p>
<blockquote>
<p>⽤Vue、Vuex、Vue-router、axios等技术开发电商⽹站的前端部分，主要负责⾸⻚、店铺详情、商品详情、商品列表、订单详情、订单中⼼等相关⻚⾯的开发⼯作，与设计师与后端配合，可要⾼度还原设计稿。 </p>
</blockquote>
<p>这个描述有什么问题？ 其实看似也没啥问题，但是这种流⽔账写法太多了，完全⽆法突出⾃⼰的优势展现⾃⼰的能⼒。项⽬经历是考察重点，⾯试官想知道候选⼈在⼀次项⽬经历中扮演的⻆⾊、负责的模块、碰到的问题、解决的思路、达成的效果以及最后的总结与沉淀。 </p>
<p>⽽上⾯的描述只显示了『我⼲了啥』，所以这种项⽬描述⼏乎是没意义的，因为对于⾯试官⽽⾔他看不到有效信息，没有有效信息的项⽬描述基本就没价值了，如果这个时候你还没有⼤⼚经历或者名校背书，基本上也就凉了。 </p>
<h4 id="（2）切忌堆积项⽬"><a href="#（2）切忌堆积项⽬" class="headerlink" title="（2）切忌堆积项⽬"></a>（2）切忌堆积项⽬</h4><p>堆积项⽬这种现象往往出现在没有什么优秀项⽬经历的简历身上，候选⼈企图以数量优势掩盖质量的劣势，其实往往适得其反，项⽬经历的⼀栏最好放2-3个项⽬，⾮常优秀的项⽬可能放⼀个就⾜够了，举个极端例⼦如果有⼀天尤⾬溪写简历，其实只需要在项⽬经历那些⼀⾏『Vue.js作者』就⾏了,当然,他并不需要投简历。 </p>
<p>有⼀些项⽬切忌放上去: </p>
<ul>
<li>demo级项⽬：很多简历居然还在放⼀些仿xx官⽹的demo，这是⼗⾜的减分项，有⼀些则是东拼⻄凑抄了⼀些框架 的源码搞了个玩具项⽬，也没有任何价值。 </li>
<li>烂⼤街的项⽬：这种以vue技术栈的为最，由于视频⽹站的某⻔课程流⾏，导致⼤量的仿饿了么、仿qq⾳乐、仿美 团、仿去哪⼉，同样Java的同学也是仿电商⽹站、仿⼤众点评等等，⼗份简历5份⼀模⼀样的项⽬，你是⾯试官会怎么想。 </li>
<li>低质量的开源项⽬：⼀个⼤原则就是低star的尽量别放（除⾮是⾼质量代码的冷⻔项⽬），⻓期弃坑的也不要放，不要为了凑数量把低质量的项⽬暴露出来，好好藏着。</li>
</ul>
<p>如果只放两个项⽬，最好的搭配是⼀个公司内部挑⼤梁的项⽬和⼀个社区内的开源项⽬，后者之所以可以占据⼀席之地，是因为通过你的开源项⽬，⾯试官可以通过commit完整看到你的创造过程，⽐如⼯程化建设、commit规范、代码规范、协作⽅式、代码能⼒、沟通能⼒等等，这甚⾄⽐⾯试都有⽤，没有⽐开源项⽬更能展示你综合素质的东⻄了。</p>
<h4 id="（3）切忌放虚假项⽬"><a href="#（3）切忌放虚假项⽬" class="headerlink" title="（3）切忌放虚假项⽬"></a>（3）切忌放虚假项⽬</h4><p>⼀个项⽬做没做过只要是有经验的⾯试官⼀问便知，如果你真的靠假项⽬忽悠过了⾯试，那这个公司⼋成也有问题，⼈才把关不过硬，你可以想象你的队友都是什么⽔平，在这种公司⼤成⻓价值也不⼤。好，如果你说实在没项⽬可写了，我只能造假了，那么你应该想⼀下这多层追问。 </p>
<p>⽐如你说你优化了⼀个前端项⽬的⾸屏性能，降低了⽩屏时间，那么⾯试官对这个性能优化问题会进⾏深挖，来考察候选⼈的实际⽔平： </p>
<ol>
<li>你的性能优化指标是怎么确定的？平均下来时间减短了多少？ </li>
<li>你的性能是如何测试的？有两种主流的性能测试⽅法你是怎么选的？ </li>
<li>你是根据哪些指标进⾏针对性优化的？ </li>
<li>除了你说的这些优化⽅法还有没有想过通过xx来解决？ </li>
<li>你的这个优化⽅法在实际操作中碰到过什么问题吗？有没有进⼀步做过测试？ </li>
<li>我们假设这么⼀种情况，⽐如xxxx，你会这么进⾏优化？</li>
</ol>
<p>⾯试官多层追问的逻辑是这样的：<strong>了解背景</strong> <strong>-&gt;</strong> <strong>了解⽅案</strong> <strong>-&gt;</strong> <strong>深挖⽅案</strong> <strong>-&gt;</strong> <strong>模拟场景</strong> </p>
<p>⾸先得了解你性能优化的指标如何，接着需要了解你是这么测试的指标、再怎么进⾏针对性优化的，再接着提出⼀些其它解决⽅案考察你对优化场景的知识储备和⽅案决策能⼒，最后再模拟⼀个其它的业务场景，来考察你的技能迁移能⼒，看看是否是对某块领域有⼀定的了解，⽽不是只针对某个项⽬。 </p>
<p>如果要真的在⾯试现场对答如流，那么⼀定是在某⼀块领域有⼀定知识储备的⼈，不是随随便便搞个项⽬就能蒙混过关的。</p>
<h4 id="（4）合格的项⽬经历如何写"><a href="#（4）合格的项⽬经历如何写" class="headerlink" title="（4）合格的项⽬经历如何写"></a>（4）合格的项⽬经历如何写</h4><p>合格的项⽬经历必须要有以下⼏点： </p>
<ul>
<li>项⽬概述 </li>
<li>个⼈职责 </li>
<li>项⽬难点</li>
<li>⼯作成果</li>
</ul>
<p>如果你不怕字太多，还可以选择性加⼊解决⽅案、选型思路等等，但是由于篇幅限制和为⾯试铺垫就不太建议写得太多。</p>
<p><strong>项⽬概述</strong>的⽬的是让⾯试官理解项⽬，不是每个⼈⾯试官都做过你的那种项⽬，所以需⼀个简述⽅便⾯试官理解。 </p>
<p><strong>个⼈职责</strong>就是告诉⾯试官你在本项⽬中扮演的⻆⾊，是领导者？主导者？还是跟随者，你负责了哪些模块，承担了多⼤的⼯作量，以此来评估你在团队中的作⽤。 </p>
<p><strong>项⽬难点</strong>的⽬的在于让⾯试官看到你碰到的技术难题，⽅便后续⾯试对项⽬进⾏⼀系列讨论。 </p>
<p>⼯作成果就很明显了，⾯试官需要看到你在做了上述⼯作到底达成了什么成绩，这个时候最好以数据说话，⽐如访问量、⽩屏时间等等。 </p>
<p>这个时候也切忌展开⻓篇⼤论，把技术细节⼀个个写上去，甚⾄还写了⼼路历程的都是⼤忌，⼀⽅⾯篇幅太⼤会造成视觉混乱，另⼀⽅⾯⾯试官想看到的是『简』历，不是技术总结，⾯试官要⾯对上百份简历没那么时间来看你⻓篇⼤论，⻓篇⼤论⼤可以在⾯试中展开。 </p>
<p>最好的⽅法就是⼀⾏⽂字简单得说清楚即可，反正项⽬⾯的时候⼀定会问到，到时候好好把你准备的内容讲给⾯试官，掌握⾯试的主动权就是从项⽬经历这⼀栏中开始</p>
<h3 id="6-其他"><a href="#6-其他" class="headerlink" title="6. 其他"></a>6. 其他</h3><h4 id="（1）教育背景"><a href="#（1）教育背景" class="headerlink" title="（1）教育背景"></a>（1）教育背景</h4><p>应届⽣可以写得更详细⼀点，⽐如绩点排名怎么样，有没有突出的科⽬，社招就不要写太多了，简单的⼊学时间、学校、专业即可，⽽且写你的最⾼学历即可，没必要从初中就开始写学历流⽔账，没有⼈看的。 </p>
<h4 id="（2）注意事项"><a href="#（2）注意事项" class="headerlink" title="（2）注意事项"></a>（2）注意事项</h4><ul>
<li><strong>⾃我评价不建议写</strong>：技术⾯试⼏乎没⼈看你的⾃我评价，连⾯试技术问题都嫌『talk is cheap show me the code』，你的⾃我评价除了占篇幅没啥⽤处，充其量算是⾯试官的⼲扰信息。 </li>
<li><strong>简历封⾯千万别搞</strong>：这都是⼀些简历制作⽹站骗⽤户付费的伎俩，不仅是互联⽹⾏业，其它⾏业我也没⻅过要简历封⾯这种⽆⽤操作的。</li>
<li><strong>证书不建议写</strong>：应届⽣可以酌情考虑弄个六级证书什么的，对于社招⽽⾔，列⼀堆证书甚⾄是减分项，国内的各种证你也懂的，是有多不⾃信才沦落到靠⼀堆证书来证明⾃⼰的价值。 </li>
<li><strong>千万别⽤技能图表</strong>：⾸先⽤90分、80分来评价⾃⼰的技术本身就没有什么说服⼒，也不可能这么精准，⽽且什么是90分、什么是80根本就没有⼀个公论，所以⽤⼀般的⽐较通⽤的熟悉、精通描述即可，千万别加戏，⾯试官或者HR没那么多闲⼯夫去理解你的图表，⽼⽼实实按最通⽤⾼效的⽅式描述⾃⼰的技术栈。 </li>
<li><strong>简历最好⼀⻚</strong>：程序员⼜不是设计师有时候需要作品呈现，如果你的简历超过⼀⻚那么⼀定是出问题了，要么项⽬、技术栈描述太多太杂占据⼤量篇幅，要么加了⼀堆图表或者图画来加戏，当然往往是犯前⼀个错误的更多。</li>
</ul>
]]></content>
      <categories>
        <category>面试</category>
      </categories>
      <tags>
        <tag>八股文</tag>
        <tag>面试</tag>
      </tags>
  </entry>
  <entry>
    <title>网站推荐</title>
    <url>/2022/10/24/resource/</url>
    <content><![CDATA[<h2 id="网站推荐"><a href="#网站推荐" class="headerlink" title="网站推荐"></a>网站推荐</h2><span id="more"></span>

<h2 id="QC的网站-夹带私货"><a href="#QC的网站-夹带私货" class="headerlink" title="QC的网站(夹带私货) "></a><center>QC的网站(夹带私货) </center></h2><table>
<thead>
<tr>
<th align="center"><strong>网站名</strong></th>
<th align="center"><strong>网址</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://qcvip.github.io/">无言</a></td>
<td align="center"><a href="https://qcvip.github.io/">https://qcvip.github.io/</a></td>
<td align="center">博客</td>
</tr>
<tr>
<td align="center"><a href="https://qcvip.github.io/topbook/">Topbook</a></td>
<td align="center"><a href="https://qcvip.github.io/topbook/">https://qcvip.github.io/topbook/</a></td>
<td align="center">HTML网页课设</td>
</tr>
<tr>
<td align="center"><a href="https://qcvip.github.io/sspai/">少数派</a></td>
<td align="center"><a href="https://qcvip.github.io/sspai/">https://qcvip.github.io/sspai/</a></td>
<td align="center">jQuery课设</td>
</tr>
<tr>
<td align="center"><a href="https://qcvip.github.io/wallhaven/">wallhavenk</a></td>
<td align="center"><a href="https://qcvip.github.io/wallhaven/">https://qcvip.github.io/wallhaven/</a></td>
<td align="center">视频网页壁纸</td>
</tr>
</tbody></table>
<h2 id="阅读网站推荐"><a href="#阅读网站推荐" class="headerlink" title="阅读网站推荐 "></a><center>阅读网站推荐 </center></h2><table>
<thead>
<tr>
<th align="center"><strong>网站名</strong></th>
<th align="center"><strong>网址</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://topbook.cc/overview">Topbook</a></td>
<td align="center"><a href="https://topbook.cc/overview">https://topbook.cc/overview</a></td>
<td align="center">阅读</td>
</tr>
<tr>
<td align="center"><a href="http://wufazhuce.com/">ONE一个</a></td>
<td align="center"><a href="http://wufazhuce.com/">http://wufazhuce.com/</a></td>
<td align="center">阅读</td>
</tr>
<tr>
<td align="center"><a href="https://sspai.com/">少数派</a></td>
<td align="center"><a href="https://sspai.com/">https://sspai.com/</a></td>
<td align="center">阅读</td>
</tr>
<tr>
<td align="center"><a href="https://www.dgtle.com/">数字尾巴</a></td>
<td align="center"><a href="https://www.dgtle.com/">https://www.dgtle.com/</a></td>
<td align="center">阅读</td>
</tr>
</tbody></table>
<br>


<h2 id="学习网站推荐"><a href="#学习网站推荐" class="headerlink" title="学习网站推荐 "></a><center>学习网站推荐 </center></h2><table>
<thead>
<tr>
<th align="center"><strong>网站名</strong></th>
<th align="center"><strong>网址</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://leetcode.cn/">力扣</a></td>
<td align="center"><a href="https://leetcode.cn/">https://leetcode.cn/</a></td>
<td align="center">学习</td>
</tr>
<tr>
<td align="center"><a href="https://r2coding.com/#/">Coding</a></td>
<td align="center"><a href="https://r2coding.com/#/">https://r2coding.com/#/</a></td>
<td align="center">学习</td>
</tr>
<tr>
<td align="center"><a href="https://github.com/">github</a></td>
<td align="center"><a href="https://github.com/">https://github.com/</a></td>
<td align="center">学习</td>
</tr>
<tr>
<td align="center"><a href="https://www.duolingo.cn/">多邻国</a></td>
<td align="center"><a href="https://www.duolingo.cn/">https://www.duolingo.cn/</a></td>
<td align="center">学习</td>
</tr>
</tbody></table>
<br>


<h2 id="工具类网站推荐"><a href="#工具类网站推荐" class="headerlink" title="工具类网站推荐 "></a><center>工具类网站推荐 </center></h2><table>
<thead>
<tr>
<th align="center"><strong>网站名</strong></th>
<th align="center"><strong>网址</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://greasyfork.org/zh-CN">Greasy Fork</a></td>
<td align="center"><a href="https://greasyfork.org/zh-CN">https://greasyfork.org/zh-CN</a></td>
<td align="center">油猴脚本</td>
</tr>
<tr>
<td align="center"><a href="https://bbs.tampermonkey.net.cn/">油猴中文网</a></td>
<td align="center"><a href="https://bbs.tampermonkey.net.cn/">https://bbs.tampermonkey.net.cn/</a></td>
<td align="center">油猴脚本</td>
</tr>
<tr>
<td align="center"><a href="https://www.zhaojiaoben.cn/">找脚本</a></td>
<td align="center"><a href="https://www.zhaojiaoben.cn/">https://www.zhaojiaoben.cn/</a></td>
<td align="center">油猴脚本</td>
</tr>
<tr>
<td align="center"><a href="https://musclewiki.cn/">MuscleWiki</a></td>
<td align="center"><a href="https://musclewiki.cn/">https://musclewiki.cn/</a></td>
<td align="center">健身</td>
</tr>
<tr>
<td align="center"><a href="http://live.yj1211.work/index/home/recommend">Live</a></td>
<td align="center"><a href="http://live.yj1211.work/index/home/recommend">http://live.yj1211.work/index/home/recommend</a></td>
<td align="center">聚合直播</td>
</tr>
<tr>
<td align="center"><a href="https://wallhaven.cc/">wallhaven</a></td>
<td align="center"><a href="https://wallhaven.cc/">https://wallhaven.cc/</a></td>
<td align="center">壁纸</td>
</tr>
<tr>
<td align="center"><a href="https://www.speedtest.net/">SPEEDTEST</a></td>
<td align="center"><a href="https://www.speedtest.net/">https://www.speedtest.net/</a></td>
<td align="center">测网速</td>
</tr>
<tr>
<td align="center"><a href="http://gbtgame.ysepan.com/">游戏空间</a></td>
<td align="center"><a href="http://gbtgame.ysepan.com/">http://gbtgame.ysepan.com/</a></td>
<td align="center">游戏资源</td>
</tr>
<tr>
<td align="center"><a href="http://flysheep.ysepan.com/">资源避难所</a></td>
<td align="center"><a href="http://flysheep.ysepan.com/">http://flysheep.ysepan.com/</a></td>
<td align="center">游戏资源</td>
</tr>
</tbody></table>
<br>
 
<h2 id="影视网站推荐"><a href="#影视网站推荐" class="headerlink" title="影视网站推荐 "></a><center>影视网站推荐 </center></h2><table>
<thead>
<tr>
<th align="center"><strong>网站名</strong></th>
<th align="center"><strong>网址</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://www.duboku.tv/">独播库</a></td>
<td align="center"><a href="https://www.duboku.tv/">https://www.duboku.tv/</a></td>
<td align="center">影视</td>
</tr>
<tr>
<td align="center"><a href="https://zxzj.vip/">在线之家</a></td>
<td align="center"><a href="https://zxzj.vip/">https://zxzj.vip/</a></td>
<td align="center">影视</td>
</tr>
<tr>
<td align="center"><a href="https://www.ak1080.me/">喜鹊视频</a></td>
<td align="center"><a href="https://www.ak1080.me/">https://www.ak1080.me/</a></td>
<td align="center">影视</td>
</tr>
<tr>
<td align="center"><a href="https://yanetflix.com/">鸭奈飞</a></td>
<td align="center"><a href="https://yanetflix.com/">https://yanetflix.com/</a></td>
<td align="center">影视</td>
</tr>
</tbody></table>
<h2 id="外部-特殊"><a href="#外部-特殊" class="headerlink" title="外部 特殊"></a><center>外部 特殊</center></h2><table>
<thead>
<tr>
<th align="center"><strong>网站名</strong></th>
<th align="center"><strong>网址</strong></th>
<th align="center"><strong>备注</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="center"><a href="https://mail.google.com/">Gmail</a></td>
<td align="center"><a href="https://mail.google.com/">https://mail.google.com/</a></td>
<td align="center">Gmail</td>
</tr>
<tr>
<td align="center"><a href="https://youtube.com/">YouTube</a></td>
<td align="center"><a href="https://youtube.com/">https://youtube.com/</a></td>
<td align="center">YouTube</td>
</tr>
<tr>
<td align="center"><a href="https://twitter.com/">Twitter</a></td>
<td align="center"><a href="https://twitter.com/">https://twitter.com/</a></td>
<td align="center">Twitter</td>
</tr>
<tr>
<td align="center"><a href="https://www.instagram.com/">Instagram</a></td>
<td align="center"><a href="https://www.instagram.com/">https://www.instagram.com/</a></td>
<td align="center">Instagram</td>
</tr>
<tr>
<td align="center"><a href="https://maps.google.com/">Google地图</a></td>
<td align="center"><a href="https://maps.google.com/">https://maps.google.com/</a></td>
<td align="center">Google地图</td>
</tr>
<tr>
<td align="center"><a href="https://zh.wikipedia.org/">维基百科</a></td>
<td align="center"><a href="https://zh.wikipedia.org/">https://zh.wikipedia.org/</a></td>
<td align="center">维基百科</td>
</tr>
<tr>
<td align="center"><a href="https://www.nasa.gov//">NASA</a></td>
<td align="center"><a href="https://www.nasa.gov/">https://www.nasa.gov/</a></td>
<td align="center">美国国家航天局</td>
</tr>
</tbody></table>
]]></content>
      <categories>
        <category>资源推荐</category>
      </categories>
      <tags>
        <tag>文章</tag>
        <tag>资源</tag>
      </tags>
  </entry>
</search>
