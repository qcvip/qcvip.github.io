

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>代码输出 - 无言</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="代码输出


前言：代码输出结果也是面试中常考的题目，...">
  <meta name="author" content="刘十三">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="https://at.alicdn.com/t/font_1445822_p6ry5n7lrr.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/vs2015.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      loading: {
        gif: '/images/theme/loading.gif',
        lottie: ''
      },
      lazyload: {
        enable: true,
        only_post: 'false',
        loading: {
          gif: '/images/theme/loading.gif',
          lottie: ''
        }
      },
      donate: {
        enable: true,
        alipay: '/images/theme/zfb.jpg',
        wechat: '/images/theme/wx.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: true
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '我在开了灯的床头下，想问问自己的心啊。',
          typing: true,
          api: 'https://v1.hitokoto.cn/?encode=text&c=d&c=e&c=h&c=i&c=k&c=j&c=i',
          data_contents: ''
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: true,
        path: 'search.xml'
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 6.3.0"></head>

<body class="lock-screen">
  <script type="text/javascript"
color="0,0,255" opacity='0.8' zIndex="-2" count="100"   src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
  <div class="loading" id="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
        <i class="iconfont iconsearch j-navbar-search"></i>
      
    </div>
    <div class="center">代码输出</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 相册</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/guestbook" class="underline "> 留言板</a>
      </li><li class="menu-item">
        <a href="/graphic" class="underline "> 图文</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme and Qc - <a target="_blank" href="https://github.com/qcvip/qcvip.github.io">无言</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img   class="lazyload" data-original="/images/essay/8.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="  draggable="false">
  <div class="head-mask">
    <h1 class="head-title">代码输出</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>10 月 22, 2022</span>
      
        <span class="post-info-item">
          <i class="iconfont iconeye"></i><span id="/2022/10/22/code%20output/" class="leancloud-counter" data-flag-title="代码输出"></span>
        </span>
        <span class="post-info-item">
          <i class="iconfont iconheart"></i><span id="/2022/10/22/code%20output/" class="leancloud-like" data-flag-title="代码输出"></span>
        </span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>40071</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        
          <p><h2 id="代码输出"><a href="#代码输出" class="headerlink" title="代码输出"></a>代码输出</h2></p>
        
        <h3 id="前言："><a href="#前言：" class="headerlink" title="前言："></a>前言：</h3><p><strong>代码输出结果</strong>也是面试中常考的题目，一段代码中可能涉及到很多的知识点，这就考察到了应聘者的基础能力。在前端面试中，常考的代码输出问题主要涉及到以下知识点：<strong>异步编程、事件循环、this指向、作用域、变量提升、闭包、原型、继承</strong>等，这些知识点往往不是单独出现的，而是在同一段代码中包含多个知识点。所以，笔者将这些问题大致分为四类进行讨论。这里不会系统的阐述基础知识，而是通过面试例题的形式，来讲述每个题目的知识点以及代码的执行过程。如果会了这些例题，在前端面试中多数代码输出问题就可以轻而易举的解决了。</p>
<p><strong>注：</strong>本文中所有例题收集自牛客网面经、网络博文等，如果侵权，请联系删除！</p>
<h2 id="一、异步-amp-事件循环"><a href="#一、异步-amp-事件循环" class="headerlink" title="一、异步&amp;事件循环"></a>一、异步&amp;事件循环</h2><h3 id="1-代码输出结果"><a href="#1-代码输出结果" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const promise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">2 </span><br><span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>

<p>promise.then 是微任务，它会在所有的宏任务执行完之后才会执行，同时需要promise内部的状态发生变化，因为这里内部没有发生变化，一直处于pending状态，所以不输出3。</p>
<h3 id="2-代码输出结果"><a href="#2-代码输出结果" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const promise1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  resolve(<span class="hljs-string">&#x27;resolve1&#x27;</span>)<br>&#125;)<br>const promise2 = promise1.then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>&#125;)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>, promise1);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>, promise2);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml">promise1<br>1 Promise&#123;<span class="hljs-tag">&lt;<span class="hljs-name">resolved</span>&gt;</span>: resolve1&#125;<br>2 Promise&#123;<span class="hljs-tag">&lt;<span class="hljs-name">pending</span>&gt;</span>&#125;<br>resolve1<br></code></pre></td></tr></table></figure>

<p>需要注意的是，直接打印promise1，会打印出它的状态值和参数。</p>
<p>代码执行过程如下：</p>
<ol>
<li>script是一个宏任务，按照顺序执行这些代码；</li>
<li>首先进入Promise，执行该构造函数中的代码，打印<code>promise1</code>；</li>
<li>碰到<code>resolve</code>函数, 将<code>promise1</code>的状态改变为<code>resolved</code>, 并将结果保存下来；</li>
<li>碰到<code>promise1.then</code>这个微任务，将它放入微任务队列；</li>
<li><code>promise2</code>是一个新的状态为<code>pending</code>的<code>Promise</code>；</li>
<li>执行同步代码1， 同时打印出<code>promise1</code>的状态是<code>resolved</code>；</li>
<li>执行同步代码2，同时打印出<code>promise2</code>的状态是<code>pending</code>；</li>
<li>宏任务执行完毕，查找微任务队列，发现<code>promise1.then</code>这个微任务且状态为<code>resolved</code>，执行它。</li>
</ol>
<h3 id="3-代码输出结果"><a href="#3-代码输出结果" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const promise = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;timerStart&quot;</span>);<br>    resolve(<span class="hljs-string">&quot;success&quot;</span>);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;timerEnd&quot;</span>);<br>  &#125;, <span class="hljs-number">0</span>);<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;);<br>promise.then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>2<br>4<br>timerStart<br>timerEnd<br>success<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ul>
<li>首先遇到Promise构造函数，会先执行里面的内容，打印<code>1</code>；</li>
<li>遇到定时器<code>steTimeout</code>，它是一个宏任务，放入宏任务队列；</li>
<li>继续向下执行，打印出2；</li>
<li>由于<code>Promise</code>的状态此时还是<code>pending</code>，所以<code>promise.then</code>先不执行；</li>
<li>继续执行下面的同步任务，打印出4；</li>
<li>此时微任务队列没有任务，继续执行下一轮宏任务，执行<code>steTimeout</code>；</li>
<li>首先执行<code>timerStart</code>，然后遇到了<code>resolve</code>，将<code>promise</code>的状态改为<code>resolved</code>且保存结果并将之前的<code>promise.then</code>推入微任务队列，再执行<code>timerEnd</code>；</li>
<li>执行完这个宏任务，就去执行微任务<code>promise.then</code>，打印出<code>resolve</code>的结果。</li>
</ul>
<h3 id="4-代码输出结果"><a href="#4-代码输出结果" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>);<br>  const timer2 = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;);<br>const timer1 = setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise2&#x27;</span>)<br>  &#125;)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"><span class="hljs-literal">start</span><br>promise1<br>timer1<br>promise2<br>timer2<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先，<code>Promise.resolve().then</code>是一个微任务，加入微任务队列</li>
<li>执行timer1，它是一个宏任务，加入宏任务队列</li>
<li>继续执行下面的同步代码，打印出<code>start</code></li>
<li>这样第一轮宏任务就执行完了，开始执行微任务<code>Promise.resolve().then</code>，打印出<code>promise1</code></li>
<li>遇到<code>timer2</code>，它是一个宏任务，将其加入宏任务队列，此时宏任务队列有两个任务，分别是<code>timer1</code>、<code>timer2</code>；</li>
<li>这样第一轮微任务就执行完了，开始执行第二轮宏任务，首先执行定时器<code>timer1</code>，打印<code>timer1</code>；</li>
<li>遇到<code>Promise.resolve().then</code>，它是一个微任务，加入微任务队列</li>
<li>开始执行微任务队列中的任务，打印<code>promise2</code>；</li>
<li>最后执行宏任务<code>timer2</code>定时器，打印出<code>timer2</code>；</li>
</ol>
<h3 id="5-代码输出结果"><a href="#5-代码输出结果" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success1&#x27;</span>);<br>    reject(<span class="hljs-string">&#x27;error&#x27;</span>);<br>    resolve(<span class="hljs-string">&#x27;success2&#x27;</span>);<br>&#125;);<br>promise.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">(res)</span> =&gt;</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;then:&#x27;</span>, res);<br>&#125;).<span class="hljs-keyword">catch</span>(<span class="hljs-function"><span class="hljs-params">(err)</span> =&gt;</span> &#123;<br>    console.log(<span class="hljs-string">&#x27;catch:&#x27;</span>, err);<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">then：success1<br></code></pre></td></tr></table></figure>

<p>这个题目考察的就是<strong>Promise的状态在发生变化之后，就不会再发生变化</strong>。开始状态由<code>pending</code>变为<code>resolve</code>，说明已经变为已完成状态，下面的两个状态的就不会再执行，同时下面的catch也不会捕获到错误。</p>
<h3 id="6-代码输出结果"><a href="#6-代码输出结果" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>(1)<br>  .the<span class="hljs-meta">n</span>(2)<br>  .the<span class="hljs-meta">n</span>(Promise.<span class="hljs-meta">resolve</span>(3))<br>  .the<span class="hljs-meta">n</span>(console.log)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript"><span class="hljs-number">1</span><br><span class="hljs-built_in">Promise</span> &#123;&lt;fulfilled&gt;: <span class="hljs-literal">undefined</span>&#125;<br></code></pre></td></tr></table></figure>

<p>Promise.resolve方法的参数如果是一个原始值，或者是一个不具有then方法的对象，则Promise.resolve方法返回一个新的Promise对象，状态为resolved，Promise.resolve方法的参数，会同时传给回调函数。</p>
<p>then方法接受的参数是函数，而如果传递的并非是一个函数，它实际上会将其解释为then(null)，这就会导致前一个Promise的结果会传递下面。</p>
<h3 id="7-代码输出结果"><a href="#7-代码输出结果" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise1 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">Promise</span>(<span class="hljs-function"><span class="hljs-params">(resolve, reject)</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;success&#x27;</span>)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;)<br>const promise2 = promise1.<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>&#125;)<br>console.log(<span class="hljs-string">&#x27;promise1&#x27;</span>, promise1)<br>console.log(<span class="hljs-string">&#x27;promise2&#x27;</span>, promise2)<br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  console.log(<span class="hljs-string">&#x27;promise1&#x27;</span>, promise1)<br>  console.log(<span class="hljs-string">&#x27;promise2&#x27;</span>, promise2)<br>&#125;, <span class="hljs-number">2000</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs javascript">promise1 <span class="hljs-title class_">Promise</span> &#123;&lt;pending&gt;&#125;<br>promise2 <span class="hljs-title class_">Promise</span> &#123;&lt;pending&gt;&#125;<br><br><span class="hljs-title class_">Uncaught</span> (<span class="hljs-keyword">in</span> promise) <span class="hljs-title class_">Error</span>: error!!!<br>promise1 <span class="hljs-title class_">Promise</span> &#123;&lt;fulfilled&gt;: <span class="hljs-string">&quot;success&quot;</span>&#125;<br>promise2 <span class="hljs-title class_">Promise</span> &#123;&lt;rejected&gt;: <span class="hljs-title class_">Error</span>: error!!&#125;<br></code></pre></td></tr></table></figure>

<h3 id="8-代码输出结果"><a href="#8-代码输出结果" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.resolve(<span class="hljs-number">1</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res);<br>  &#125;);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span>  <br><span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p>Promise是可以链式调用的，由于每次调用 <code>.then</code> 或者 <code>.catch</code> 都会返回一个新的 promise，从而实现了链式调用, 它并不像一般任务的链式调用一样return this。</p>
<p>上面的输出结果之所以依次打印出1和2，是因为<code>resolve(1)</code>之后走的是第一个then方法，并没有进catch里，所以第二个then中的res得到的实际上是第一个then的返回值。并且return 2会被包装成<code>resolve(2)</code>，被最后的then打印输出2。</p>
<h3 id="9-代码输出结果"><a href="#9-代码输出结果" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;then: &quot;</span>, res)<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;catch: &quot;</span>, err)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs 1c"><span class="hljs-string">&quot;then: &quot;</span> <span class="hljs-string">&quot;Error: error!!!&quot;</span><br></code></pre></td></tr></table></figure>

<p>返回任意一个非 promise 的值都会被包裹成 promise 对象，因此这里的<code>return new Error(&#39;error!!!&#39;)</code>也被包裹成了<code>return Promise.resolve(new Error(&#39;error!!!&#39;))</code>，因此它会被then捕获而不是catch。</p>
<h3 id="10-代码输出结果"><a href="#10-代码输出结果" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">const promise = <span class="hljs-built_in">Promise</span>.resolve().<span class="hljs-keyword">then</span>(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-keyword">return</span> promise;<br>&#125;)<br>promise.<span class="hljs-keyword">catch</span>(console.err)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-built_in">Uncaught</span> (in promise) TypeError: Chaining cycle detected <span class="hljs-keyword">for</span> promise #&lt;Promise&gt;<br></code></pre></td></tr></table></figure>

<p>这里其实是一个坑，<code>.then</code> 或 <code>.catch</code> 返回的值不能是 promise 本身，否则会造成死循环。</p>
<h3 id="11-代码输出结果"><a href="#11-代码输出结果" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sas">Promise.<span class="hljs-meta">resolve</span>(1)<br>  .the<span class="hljs-meta">n</span>(2)<br>  .the<span class="hljs-meta">n</span>(Promise.<span class="hljs-meta">resolve</span>(3))<br>  .the<span class="hljs-meta">n</span>(console.log)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">1<br></code></pre></td></tr></table></figure>

<p>看到这个题目，好多的then，实际上只需要记住一个原则：<code>.then</code> 或<code>.catch</code> 的参数期望是函数，传入非函数则会发生<strong>值透传</strong>。</p>
<p>第一个then和第二个then中传入的都不是函数，一个是数字，一个是对象，因此发生了透传，将<code>resolve(1)</code> 的值直接传到最后一个then里，直接打印出1。</p>
<h3 id="12-代码输出结果"><a href="#12-代码输出结果" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.reject(<span class="hljs-string">&#x27;err!!!&#x27;</span>)<br>  .then(<span class="hljs-function">(<span class="hljs-params">res</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;success&#x27;</span>, res)<br>  &#125;, (err) =&gt; &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;error&#x27;</span>, err)<br>  &#125;).catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;catch&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs subunit"><span class="hljs-keyword">error </span>err!!!<br></code></pre></td></tr></table></figure>

<p>我们知道，<code>.then</code>函数中的两个参数：</p>
<ul>
<li>第一个参数是用来处理Promise成功的函数</li>
<li>第二个则是处理失败的函数</li>
</ul>
<p>也就是说<code>Promise.resolve(&#39;1&#39;)</code>的值会进入成功的函数，<code>Promise.reject(&#39;2&#39;)</code>的值会进入失败的函数。</p>
<p>在这道题中，错误直接被<code>then</code>的第二个参数捕获了，所以就不会被<code>catch</code>捕获了，输出结果为：<code>error err!!!&#39;</code></p>
<p>但是，如果是像下面这样：</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs qml"><span class="hljs-built_in">Promise</span>.resolve()<br>  .then(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">success</span> (<span class="hljs-params">res</span>) </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">&#x27;error!!!&#x27;</span>)<br>  &#125;, <span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fail1</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fail1&#x27;</span>, err)<br>  &#125;).catch(<span class="hljs-function"><span class="hljs-keyword">function</span> <span class="hljs-title">fail2</span> (<span class="hljs-params">err</span>) </span>&#123;<br>    <span class="hljs-built_in">console</span>.log(<span class="hljs-string">&#x27;fail2&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>在<code>then</code>的第一参数中抛出了错误，那么他就不会被第二个参数不活了，而是被后面的<code>catch</code>捕获到。</p>
<h3 id="13-代码输出结果"><a href="#13-代码输出结果" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.resolve(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)<br>  &#125;)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>)<br>  &#125;)<br>Promise.resolve(<span class="hljs-string">&#x27;2&#x27;</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally2&#x27;</span>)<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;我是finally2返回的值&#x27;</span><br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally2后面的then函数&#x27;</span>, res)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ceylon"><span class="hljs-number">1</span><br><span class="hljs-keyword">finally</span><span class="hljs-number">2</span><br><span class="hljs-keyword">finally</span><br><span class="hljs-keyword">finally</span><span class="hljs-number">2</span>后面的<span class="hljs-keyword">then</span>函数 <span class="hljs-number">2</span><br></code></pre></td></tr></table></figure>

<p><code>.finally()</code>一般用的很少，只要记住以下几点就可以了：</p>
<ul>
<li><code>.finally()</code>方法不管Promise对象最后的状态如何都会执行</li>
<li><code>.finally()</code>方法的回调函数不接受任何的参数，也就是说你在<code>.finally()</code>函数中是无法知道Promise最终的状态是<code>resolved</code>还是<code>rejected</code>的</li>
<li>它最终返回的默认会是一个上一次的Promise对象值，不过如果抛出的是一个异常则返回异常的Promise对象。</li>
<li>finally本质上是then方法的特例</li>
</ul>
<p><code>.finally()</code>的错误捕获：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.resolve(<span class="hljs-string">&#x27;1&#x27;</span>)<br>  .finally(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally1&#x27;</span>)<br>    throw <span class="hljs-keyword">new</span> Error(<span class="hljs-string">&#x27;我是finally中抛出的异常&#x27;</span>)<br>  &#125;)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally后面的then函数&#x27;</span>, res)<br>  &#125;)<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;捕获错误&#x27;</span>, err)<br>  &#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-string">&#x27;finally1&#x27;</span><br><span class="hljs-string">&#x27;捕获错误&#x27;</span> <span class="hljs-title class_">Error</span>: 我是<span class="hljs-keyword">finally</span>中抛出的异常<br></code></pre></td></tr></table></figure>

<h3 id="14-代码输出结果"><a href="#14-代码输出结果" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (<span class="hljs-params">x</span>) &#123;<br>    const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>))<br>    <span class="hljs-keyword">return</span> p<br>&#125;<br><br>Promise.<span class="hljs-built_in">all</span>([runAsync(<span class="hljs-number">1</span>), runAsync(<span class="hljs-number">2</span>), runAsync(<span class="hljs-number">3</span>)]).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs angelscript"><span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br><span class="hljs-string">[1, 2, 3]</span><br></code></pre></td></tr></table></figure>

<p>首先，定义了一个Promise，来异步执行函数runAsync，该函数传入一个值x，然后间隔一秒后打印出这个x。</p>
<p>之后再使用<code>Promise.all</code>来执行这个函数，执行的时候，看到一秒之后输出了1，2，3，同时输出了数组[1, 2, 3]，三个函数是同步执行的，并且在一个回调函数中返回了所有的结果。并且结果和函数的执行顺序是一致的。</p>
<h3 id="15-代码输出结果"><a href="#15-代码输出结果" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">runReject</span> (<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> rej(<span class="hljs-string">`Error: <span class="hljs-subst">$&#123;x&#125;</span>`</span>, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span> * x))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br>Promise.<span class="hljs-built_in">all</span>([runAsync(<span class="hljs-number">1</span>), runReject(<span class="hljs-number">4</span>), runAsync(<span class="hljs-number">3</span>), runReject(<span class="hljs-number">2</span>)])<br>       .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br>       .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs subunit">// 1s后输出<br>1<br>3<br>// 2s后输出<br>2<br><span class="hljs-keyword">Error: </span>2<br>// 4s后输出<br>4<br></code></pre></td></tr></table></figure>

<p>可以看到。catch捕获到了第一个错误，在这道题目中最先的错误就是<code>runReject(2)</code>的结果。如果一组异步操作中有一个异常都不会进入<code>.then()</code>的第一个回调函数参数中。会被<code>.then()</code>的第二个回调函数捕获。</p>
<h3 id="16-代码输出结果"><a href="#16-代码输出结果" class="headerlink" title="16. 代码输出结果"></a>16. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span> (<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span> setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>))<br>  <span class="hljs-keyword">return</span> p<br>&#125;<br>Promise.race([runAsync(<span class="hljs-number">1</span>), runAsync(<span class="hljs-number">2</span>), runAsync(<span class="hljs-number">3</span>)])<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;result: &#x27;</span>, res))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight scheme"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs scheme"><span class="hljs-number">1</span><br><span class="hljs-symbol">&#x27;result:</span> &#x27; <span class="hljs-number">1</span><br><span class="hljs-number">2</span><br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>then只会捕获第一个成功的方法，其他的函数虽然还会继续执行，但是不是被then捕获了。</p>
<h3 id="17-代码输出结果"><a href="#17-代码输出结果" class="headerlink" title="17. 代码输出结果"></a>17. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">runAsync</span>(<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">r</span> =&gt;</span><br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> r(x, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span>)<br>  );<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">runReject</span>(<span class="hljs-params">x</span>) &#123;<br>  const p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">res, rej</span>) =&gt;</span><br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> rej(<span class="hljs-string">`Error: <span class="hljs-subst">$&#123;x&#125;</span>`</span>, <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x)), <span class="hljs-number">1000</span> * x)<br>  );<br>  <span class="hljs-keyword">return</span> p;<br>&#125;<br>Promise.race([runReject(<span class="hljs-number">0</span>), runAsync(<span class="hljs-number">1</span>), runAsync(<span class="hljs-number">2</span>), runAsync(<span class="hljs-number">3</span>)])<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;result: &quot;</span>, res))<br>  .catch(<span class="hljs-function"><span class="hljs-params">err</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(err));<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">0<br><span class="hljs-keyword">Error: </span>0<br>1<br>2<br>3<br></code></pre></td></tr></table></figure>

<p>可以看到在catch捕获到第一个错误之后，后面的代码还不执行，不过不会再被捕获了。</p>
<p>注意：<code>all</code>和<code>race</code>传入的数组中如果有会抛出异常的异步任务，那么只有最先抛出的错误会被捕获，并且是被then的第二个参数或者后面的catch捕获；但并不会影响数组中其它的异步任务的执行。</p>
<h3 id="18-代码输出结果"><a href="#18-代码输出结果" class="headerlink" title="18. 代码输出结果"></a>18. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br>async1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;start&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs gcode">asy<span class="hljs-symbol">nc1</span> start<br>asy<span class="hljs-symbol">nc2</span><br>start<br>asy<span class="hljs-symbol">nc1</span> e<span class="hljs-symbol">nd</span><br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行函数中的同步代码<code>async1 start</code>，之后遇到了<code>await</code>，它会阻塞<code>async1</code>后面代码的执行，因此会先去执行<code>async2</code>中的同步代码<code>async2</code>，然后跳出<code>async1</code>；</li>
<li>跳出<code>async1</code>函数后，执行同步代码<code>start</code>；</li>
<li>在一轮宏任务全部执行完之后，再来执行<code>await</code>后面的内容<code>async1 end</code>。</li>
</ol>
<p>这里可以理解为await后面的语句相当于放到了new Promise中，下一行及之后的语句相当于放在Promise.then中。</p>
<h3 id="19-代码输出结果"><a href="#19-代码输出结果" class="headerlink" title="19. 代码输出结果"></a>19. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br>async1();<br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer3&#x27;</span>)<br>&#125;, <span class="hljs-number">0</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;start&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">async1 <span class="hljs-built_in">start</span><br>async2<br><span class="hljs-built_in">start</span><br>async1 <span class="hljs-function"><span class="hljs-keyword">end</span></span><br><span class="hljs-function"><span class="hljs-title">timer2</span></span><br>timer3<br>timer1<br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先进入<code>async1</code>，打印出<code>async1 start</code>；</li>
<li>之后遇到<code>async2</code>，进入<code>async2</code>，遇到定时器<code>timer2</code>，加入宏任务队列，之后打印<code>async2</code>；</li>
<li>由于<code>async2</code>阻塞了后面代码的执行，所以执行后面的定时器<code>timer3</code>，将其加入宏任务队列，之后打印<code>start</code>；</li>
<li>然后执行async2后面的代码，打印出<code>async1 end</code>，遇到定时器timer1，将其加入宏任务队列；</li>
<li>最后，宏任务队列有三个任务，先后顺序为<code>timer2</code>，<code>timer3</code>，<code>timer1</code>，没有微任务，所以直接所有的宏任务按照先进先出的原则执行。</li>
</ol>
<h3 id="20-代码输出结果"><a href="#20-代码输出结果" class="headerlink" title="20. 代码输出结果"></a>20. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  await <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 success&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 end&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt start&#x27;</span>)<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1 start<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<p>这里需要注意的是在<code>async1</code>中<code>await</code>后面的Promise是没有返回值的，也就是它的状态始终是<code>pending</code>状态，所以在<code>await</code>之后的内容是不会执行的，包括<code>async1</code>后面的 <code>.then</code>。</p>
<h3 id="21-代码输出结果"><a href="#21-代码输出结果" class="headerlink" title="21. 代码输出结果"></a>21. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 start&#x27;</span>);<br>  await <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>    resolve(<span class="hljs-string">&#x27;promise1 resolve&#x27;</span>)<br>  &#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 success&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 end&#x27;</span><br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt start&#x27;</span>)<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;srcipt end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这里是对上面一题进行了改造，加上了resolve。</p>
<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1 start<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br>promise1 resolve<br>async1 success<br>async1 <span class="hljs-keyword">end</span><br></code></pre></td></tr></table></figure>

<h3 id="22-代码输出结果"><a href="#22-代码输出结果" class="headerlink" title="22. 代码输出结果"></a>22. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 start&quot;</span>);<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async1 end&quot;</span>);<br>&#125;<br><br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;async2&quot;</span>);<br>&#125;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;script start&quot;</span>);<br><br>setTimeout(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;setTimeout&quot;</span>);<br>&#125;, <span class="hljs-number">0</span>);<br><br>async1();<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise1&quot;</span>);<br>  resolve();<br>&#125;).then(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;promise2&quot;</span>);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1 start<br>async2<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br>async1 <span class="hljs-keyword">end</span><br>promise2<br>setTimeout<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下： </p>
<ol>
<li>开头定义了async1和async2两个函数，但是并未执行，执行script中的代码，所以打印出script start；</li>
<li>遇到定时器Settimeout，它是一个宏任务，将其加入到宏任务队列；</li>
<li>之后执行函数async1，首先打印出async1 start；</li>
<li>遇到await，执行async2，打印出async2，并阻断后面代码的执行，将后面的代码加入到微任务队列；</li>
<li>然后跳出async1和async2，遇到Promise，打印出promise1；</li>
<li>遇到resolve，将其加入到微任务队列，然后执行后面的script代码，打印出script end；</li>
<li>之后就该执行微任务队列了，首先打印出async1 end，然后打印出promise2；</li>
<li>执行完微任务队列，就开始执行宏任务队列中的定时器，打印出setTimeout。</li>
</ol>
<h3 id="23-代码输出结果"><a href="#23-代码输出结果" class="headerlink" title="23. 代码输出结果"></a>23. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  await async2();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 success&#x27;</span><br>&#125;<br>async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async2</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async2&#x27;</span>)<br>    reject(<span class="hljs-string">&#x27;error&#x27;</span>)<br>  &#125;)<br>&#125;<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-attribute">async2</span><br>Uncaught (in promise) <span class="hljs-literal">error</span><br></code></pre></td></tr></table></figure>

<p>可以看到，如果async函数中抛出了错误，就会终止错误结果，不会继续向下执行。</p>
<p>如果想要让错误不足之处后面的代码执行，可以使用catch来捕获：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs arcade">async <span class="hljs-keyword">function</span> <span class="hljs-title function_">async1</span> (<span class="hljs-params"></span>) &#123;<br>  await Promise.reject(<span class="hljs-string">&#x27;error!!!&#x27;</span>).catch(<span class="hljs-function"><span class="hljs-params">e</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(e))<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  <span class="hljs-keyword">return</span> Promise.resolve(<span class="hljs-string">&#x27;async1 success&#x27;</span>)<br>&#125;<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>)<br></code></pre></td></tr></table></figure>

<p>这样的输出结果就是：</p>
<figure class="highlight erlang-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs erlang-repl">script start<br>error!!!<br>async1<br>async1 success<br></code></pre></td></tr></table></figure>

<h3 id="24-代码输出结果"><a href="#24-代码输出结果" class="headerlink" title="24. 代码输出结果"></a>24. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const <span class="hljs-built_in">first</span> = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> (<span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>    let p = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>);<br>        setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>            resolve(<span class="hljs-number">6</span>);<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(p)<br>        &#125;, <span class="hljs-number">0</span>)<br>        resolve(<span class="hljs-number">1</span>);<br>    &#125;);<br>    resolve(<span class="hljs-number">2</span>);<br>    p.then(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arg);<br>    &#125;);<br>&#125;));<br><span class="hljs-built_in">first</span>().then(<span class="hljs-function">(<span class="hljs-params">arg</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(arg);<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">3</span><br><span class="hljs-attribute">7</span><br><span class="hljs-attribute">4</span><br><span class="hljs-attribute">1</span><br><span class="hljs-attribute">2</span><br><span class="hljs-attribute">5</span><br><span class="hljs-attribute">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-number">1</span>&#125;<br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先会进入Promise，打印出3，之后进入下面的Promise，打印出7；</li>
<li>遇到了定时器，将其加入宏任务队列；</li>
<li>执行Promise  p中的resolve，状态变为resolved，返回值为1；</li>
<li>执行Promise first中的resolve，状态变为resolved，返回值为2；</li>
<li>遇到p.then，将其加入微任务队列，遇到first().then，将其加入任务队列；</li>
<li>执行外面的代码，打印出4；</li>
<li>这样第一轮宏任务就执行完了，开始执行微任务队列中的任务，先后打印出1和2；</li>
<li>这样微任务就执行完了，开始执行下一轮宏任务，宏任务队列中有一个定时器，执行它，打印出5，由于执行已经变为resolved状态，所以<code>resolve(6)</code>不会再执行；</li>
<li>最后<code>console.log(p)</code>打印出<code>Promise&#123;&lt;resolved&gt;: 1&#125;</code>；</li>
</ol>
<h3 id="25-代码输出结果"><a href="#25-代码输出结果" class="headerlink" title="25. 代码输出结果"></a>25. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const async1 = async () =&gt; &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1&#x27;</span>);<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">2000</span>)<br>  await <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;promise1&#x27;</span>)<br>  &#125;)<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;async1 end&#x27;</span>)<br>  <span class="hljs-keyword">return</span> <span class="hljs-string">&#x27;async1 success&#x27;</span><br>&#125; <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script start&#x27;</span>);<br>async1().then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res));<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;script end&#x27;</span>);<br>Promise.resolve(<span class="hljs-number">1</span>)<br>  .then(<span class="hljs-number">2</span>)<br>  .then(Promise.resolve(<span class="hljs-number">3</span>))<br>  .catch(<span class="hljs-number">4</span>)<br>  .then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res))<br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer2&#x27;</span>)<br>&#125;, <span class="hljs-number">1000</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs applescript"><span class="hljs-keyword">script</span> start<br>async1<br>promise1<br><span class="hljs-keyword">script</span> <span class="hljs-keyword">end</span><br><span class="hljs-number">1</span><br>timer2<br>timer1<br></code></pre></td></tr></table></figure>

<p>代码的执行过程如下：</p>
<ol>
<li>首先执行同步带吗，打印出script start；</li>
<li>遇到定时器timer1将其加入宏任务队列；</li>
<li>之后是执行Promise，打印出promise1，由于Promise没有返回值，所以后面的代码不会执行；</li>
<li>然后执行同步代码，打印出script end；</li>
<li>继续执行下面的Promise，.then和.catch期望参数是一个函数，这里传入的是一个数字，因此就会发生值渗透，将resolve(1)的值传到最后一个then，直接打印出1；</li>
<li>遇到第二个定时器，将其加入到微任务队列，执行微任务队列，按顺序依次执行两个定时器，但是由于定时器时间的原因，会在两秒后先打印出timer2，在四秒后打印出timer1。</li>
</ol>
<h3 id="26-代码输出结果"><a href="#26-代码输出结果" class="headerlink" title="26. 代码输出结果"></a>26. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">const p1 = <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve</span>) =&gt;</span> &#123;<br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    resolve(<span class="hljs-string">&#x27;resolve3&#x27;</span>);<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;timer1&#x27;</span>)<br>  &#125;, <span class="hljs-number">0</span>)<br>  resolve(<span class="hljs-string">&#x27;resovle1&#x27;</span>);<br>  resolve(<span class="hljs-string">&#x27;resolve2&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(res)  <span class="hljs-comment">// resolve1</span><br>  setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(p1)<br>  &#125;, <span class="hljs-number">1000</span>)<br>&#125;).finally(<span class="hljs-function"><span class="hljs-params">res</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;finally&#x27;</span>, res)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>执行结果为如下：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">resolve1<br><span class="hljs-keyword">finally</span>  <span class="hljs-literal">undefined</span><br>timer1<br><span class="hljs-built_in">Promise</span>&#123;&lt;resolved&gt;: <span class="hljs-literal">undefined</span>&#125;<br></code></pre></td></tr></table></figure>

<h3 id="27-代码输出结果"><a href="#27-代码输出结果" class="headerlink" title="27. 代码输出结果"></a>27. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>)<br>    &#125;)<br>&#125;)<br>process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;)<br><span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;7&#x27;</span>);<br>    <span class="hljs-title function_">resolve</span>();<br>&#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;8&#x27;</span>)<br>&#125;)<br><br><span class="hljs-built_in">setTimeout</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;9&#x27;</span>);<br>    process.<span class="hljs-title function_">nextTick</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;10&#x27;</span>);<br>    &#125;)<br>    <span class="hljs-keyword">new</span> <span class="hljs-title class_">Promise</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params">resolve</span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;11&#x27;</span>);<br>        <span class="hljs-title function_">resolve</span>();<br>    &#125;).<span class="hljs-title function_">then</span>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;12&#x27;</span>)<br>    &#125;)<br>&#125;)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>7<br>6<br>8<br>2<br>4<br>3<br>5<br>9<br>11<br>10<br>12<br></code></pre></td></tr></table></figure>

<p><strong>（1）第一轮事件循环流程分析如下：</strong></p>
<ul>
<li>整体script作为第一个宏任务进入主线程，遇到<code>console.log</code>，输出1。</li>
<li>遇到<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中。暂且记为<code>setTimeout1</code>。</li>
<li>遇到<code>process.nextTick()</code>，其回调函数被分发到微任务Event Queue中。记为<code>process1</code>。</li>
<li>遇到<code>Promise</code>，<code>new Promise</code>直接执行，输出7。<code>then</code>被分发到微任务Event Queue中。记为<code>then1</code>。</li>
<li>又遇到了<code>setTimeout</code>，其回调函数被分发到宏任务Event Queue中，记为<code>setTimeout2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout1</td>
<td>process1</td>
</tr>
<tr>
<td>setTimeout2</td>
<td>then1</td>
</tr>
</tbody></table>
<p>上表是第一轮事件循环宏任务结束时各Event Queue的情况，此时已经输出了1和7。发现了<code>process1</code>和<code>then1</code>两个微任务：</p>
<ul>
<li>执行<code>process1</code>，输出6。</li>
<li>执行<code>then1</code>，输出8。</li>
</ul>
<p>第一轮事件循环正式结束，这一轮的结果是输出1，7，6，8。</p>
<p><strong>（2）第二轮时间循环从</strong><code>**setTimeout1**</code><strong>宏任务开始：</strong></p>
<ul>
<li>首先输出2。接下来遇到了<code>process.nextTick()</code>，同样将其分发到微任务Event Queue中，记为<code>process2</code>。</li>
<li><code>new Promise</code>立即执行输出4，<code>then</code>也分发到微任务Event Queue中，记为<code>then2</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td>setTimeout2</td>
<td>process2</td>
</tr>
<tr>
<td></td>
<td>then2</td>
</tr>
</tbody></table>
<p>第二轮事件循环宏任务结束，发现有<code>process2</code>和<code>then2</code>两个微任务可以执行：</p>
<ul>
<li>输出3。</li>
<li>输出5。</li>
</ul>
<p>第二轮事件循环结束，第二轮输出2，4，3，5。</p>
<p><strong>（3）第三轮事件循环开始，此时只剩setTimeout2了，执行。</strong></p>
<ul>
<li>直接输出9。</li>
<li>将<code>process.nextTick()</code>分发到微任务Event Queue中。记为<code>process3</code>。</li>
<li>直接执行<code>new Promise</code>，输出11。</li>
<li>将<code>then</code>分发到微任务Event Queue中，记为<code>then3</code>。</li>
</ul>
<table>
<thead>
<tr>
<th>宏任务Event Queue</th>
<th>微任务Event Queue</th>
</tr>
</thead>
<tbody><tr>
<td></td>
<td>process3</td>
</tr>
<tr>
<td></td>
<td>then3</td>
</tr>
</tbody></table>
<p>第三轮事件循环宏任务执行结束，执行两个微任务<code>process3</code>和<code>then3</code>：</p>
<ul>
<li>输出10。</li>
<li>输出12。</li>
</ul>
<p>第三轮事件循环结束，第三轮输出9，11，10，12。</p>
<p>整段代码，共进行了三次事件循环，完整的输出为1，7，6，8，2，4，3，5，9，11，10，12。</p>
<h3 id="28-代码输出结果"><a href="#28-代码输出结果" class="headerlink" title="28. 代码输出结果"></a>28. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>&#125;)<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>  &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>  resolve(<span class="hljs-number">4</span>)<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(d))<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>)<br>  <span class="hljs-keyword">new</span> Promise(<span class="hljs-function"><span class="hljs-params">resolve</span> =&gt;</span>  &#123;<br>    resolve(<span class="hljs-number">6</span>)<br>  &#125;).then(<span class="hljs-function"><span class="hljs-params">d</span> =&gt;</span> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(d))<br>&#125;)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>)<br>&#125;)<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">8</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>3<br>8<br>4<br>2<br>5<br>6<br>7<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行script代码，打印出1；</li>
<li>遇到第一个定时器，加入到宏任务队列；</li>
<li>遇到Promise，执行代码，打印出3，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器，加入到宏任务队列；</li>
<li>遇到第三个定时器，加入到宏任务队列；</li>
<li>继续执行script代码，打印出8，第一轮执行结束；</li>
<li>执行微任务队列，打印出第一个Promise的resolve结果：4；</li>
<li>开始执行宏任务队列，执行第一个定时器，打印出2；</li>
<li>此时没有微任务，继续执行宏任务中的第二个定时器，首先打印出5，遇到Promise，首选打印出6，遇到resolve，将其加入到微任务队列；</li>
<li>执行微任务队列，打印出6；</li>
<li>执行宏任务队列中的最后一个定时器，打印出7。</li>
</ol>
<h3 id="29-代码输出结果"><a href="#29-代码输出结果" class="headerlink" title="29. 代码输出结果"></a>29. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>    <br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>  Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>)<br>  &#125;);<br>&#125;);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resolve, reject</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>)<br>  resolve(<span class="hljs-number">5</span>)<br>&#125;).then(<span class="hljs-function">(<span class="hljs-params">data</span>) =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(data);<br>&#125;)<br><br>setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>&#125;)<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>);<br></code></pre></td></tr></table></figure>

<p>代码输出结果如下：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs">1<br>4<br>7<br>5<br>2<br>3<br>6<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先执行scrip代码，打印出1；</li>
<li>遇到第一个定时器setTimeout，将其加入到宏任务队列；</li>
<li>遇到Promise，执行里面的同步代码，打印出4，遇到resolve，将其加入到微任务队列；</li>
<li>遇到第二个定时器setTimeout，将其加入到红任务队列；</li>
<li>执行script代码，打印出7，至此第一轮执行完成；</li>
<li>指定微任务队列中的代码，打印出resolve的结果：5；</li>
<li>执行宏任务中的第一个定时器setTimeout，首先打印出2，然后遇到 Promise.resolve().then()，将其加入到微任务队列；</li>
<li>执行完这个宏任务，就开始执行微任务队列，打印出3；</li>
<li>继续执行宏任务队列中的第二个定时器，打印出6。</li>
</ol>
<h3 id="30-代码输出结果"><a href="#30-代码输出结果" class="headerlink" title="30. 代码输出结果"></a>30. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade">Promise.resolve().then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;1&#x27;</span>);<br>    throw <span class="hljs-string">&#x27;Error&#x27;</span>;<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;2&#x27;</span>);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;3&#x27;</span>);<br>    throw <span class="hljs-string">&#x27;Error&#x27;</span>;<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;4&#x27;</span>);<br>&#125;).catch(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;5&#x27;</span>);<br>&#125;).then(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;6&#x27;</span>);<br>&#125;);<br></code></pre></td></tr></table></figure>

<p>执行结果如下：</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs basic"><span class="hljs-symbol">1 </span><br><span class="hljs-symbol">3 </span><br><span class="hljs-symbol">5 </span><br><span class="hljs-number">6</span><br></code></pre></td></tr></table></figure>

<p>在这道题目中，我们需要知道，无论是thne还是catch中，只要throw 抛出了错误，就会被catch捕获，如果没有throw出错误，就被继续执行后面的then。</p>
<h3 id="31-代码输出结果"><a href="#31-代码输出结果" class="headerlink" title="31. 代码输出结果"></a>31. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade">setTimeout(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>&#125;, <span class="hljs-number">100</span>);<br><br><span class="hljs-keyword">new</span> Promise(<span class="hljs-keyword">function</span> (<span class="hljs-params">resolve</span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>  resolve();<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;).then(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br>  <span class="hljs-keyword">new</span> Promise(<span class="hljs-function">(<span class="hljs-params">resove, reject</span>) =&gt;</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>    setTimeout(<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>      <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">6</span>);<br>    &#125;, <span class="hljs-number">10</span>);<br>  &#125;)<br>&#125;);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">7</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">8</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果为：</p>
<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs">2<br>3<br>7<br>8<br>4<br>5<br>6<br>1<br></code></pre></td></tr></table></figure>

<p>代码执行过程如下：</p>
<ol>
<li>首先遇到定时器，将其加入到宏任务队列；</li>
<li>遇到Promise，首先执行里面的同步代码，打印出2，遇到resolve，将其加入到微任务队列，执行后面同步代码，打印出3；</li>
<li>继续执行script中的代码，打印出7和8，至此第一轮代码执行完成；</li>
<li>执行微任务队列中的代码，首先打印出4，如遇到Promise，执行其中的同步代码，打印出5，遇到定时器，将其加入到宏任务队列中，此时宏任务队列中有两个定时器；</li>
<li>执行宏任务队列中的代码，这里我们需要注意是的第一个定时器的时间为100ms，第二个定时器的时间为10ms，所以先执行第二个定时器，打印出6；</li>
<li>此时微任务队列为空，继续执行宏任务队列，打印出1。</li>
</ol>
<p>做完这道题目，我们就需要格外注意，每个定时器的时间，并不是所有定时器的时间都为0哦。</p>
<h2 id="二、this"><a href="#二、this" class="headerlink" title="二、this"></a>二、this</h2><h3 id="1-代码输出结果-1"><a href="#1-代码输出结果-1" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>( this.a );<br>&#125;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">doFoo</span>(<span class="hljs-params"></span>) &#123;<br>  foo();<br>&#125;<br><br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">a</span>: <span class="hljs-number">1</span>,<br>  <span class="hljs-attr">doFoo</span>: doFoo<br>&#125;;<br><br><span class="hljs-keyword">var</span> a = <span class="hljs-number">2</span>; <br>obj.doFoo()<br></code></pre></td></tr></table></figure>

<p>输出结果：2 </p>
<p>在Javascript中，this指向函数执行时的当前对象。在执行foo的时候，执行环境就是doFoo函数，执行环境为全局。所以，foo中的this是指向window的，所以会打印出2。</p>
<h3 id="2-代码输出结果-1"><a href="#2-代码输出结果-1" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span><br><span class="hljs-selector-tag">var</span> obj = &#123;<br>  <span class="hljs-selector-tag">a</span>: <span class="hljs-number">20</span>,<br>  say: () =&gt; &#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)<br>  &#125;<br>&#125;<br>obj<span class="hljs-selector-class">.say</span>() <br><br><span class="hljs-selector-tag">var</span> anotherObj = &#123; <span class="hljs-selector-tag">a</span>: <span class="hljs-number">30</span> &#125; <br>obj<span class="hljs-selector-class">.say</span><span class="hljs-selector-class">.apply</span>(anotherObj) <br></code></pre></td></tr></table></figure>

<p>输出结果：10  10</p>
<p>我么知道，箭头函数时不绑定this的，它的this来自原其父级所处的上下文，所以首先会打印全局中的 a 的值10。后面虽然让say方法指向了另外一个对象，但是仍不能改变箭头函数的特性，它的this仍然是指向全局的，所以依旧会输出10。</p>
<p>但是，如果是普通函数，那么就会有完全不一样的结果：</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> = <span class="hljs-number">10</span>  <br><span class="hljs-selector-tag">var</span> obj = &#123;  <br>  <span class="hljs-selector-tag">a</span>: <span class="hljs-number">20</span>,  <br>  <span class="hljs-built_in">say</span>()&#123;<br>    console<span class="hljs-selector-class">.log</span>(this.a)  <br>  &#125;  <br>&#125;  <br>obj<span class="hljs-selector-class">.say</span>()   <br><span class="hljs-selector-tag">var</span> anotherObj=&#123;<span class="hljs-selector-tag">a</span>:<span class="hljs-number">30</span>&#125;   <br>obj<span class="hljs-selector-class">.say</span><span class="hljs-selector-class">.apply</span>(anotherObj)<br></code></pre></td></tr></table></figure>

<p>输出结果：20 30</p>
<p>这时，say方法中的this就会指向他所在的对象，输出其中的a的值。</p>
<h3 id="3-代码输出结果-1"><a href="#3-代码输出结果-1" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>&#125;<br>a.call(<span class="hljs-literal">null</span>);<br></code></pre></td></tr></table></figure>

<p>打印结果：window对象</p>
<p>根据ECMAScript262规范规定：如果第一个参数传入的对象调用者是null或者undefined，call方法将把全局对象（浏览器上是window对象）作为this的值。所以，不管传入null 还是 undefined，其this都是全局对象window。所以，在浏览器上答案是输出 window 对象。</p>
<p>要注意的是，在严格模式中，null 就是 null，undefined 就是 undefined：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-meta">&#x27;use strict&#x27;</span>;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-variable language_">this</span>);<br>&#125;<br>a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">null</span>); <span class="hljs-comment">// null</span><br>a.<span class="hljs-title function_">call</span>(<span class="hljs-literal">undefined</span>); <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h3 id="4-代码输出结果-1"><a href="#4-代码输出结果-1" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs kotlin"><span class="hljs-keyword">var</span> obj = &#123; <br>  name: <span class="hljs-string">&#x27;cuggz&#x27;</span>, <br>  <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-title">function</span><span class="hljs-params">()</span></span>&#123; <br>     console.log(<span class="hljs-keyword">this</span>.name); <br>  &#125; <br>&#125; <br>obj.<span class="hljs-keyword">fun</span>()     <span class="hljs-comment">// cuggz</span><br>new obj.<span class="hljs-keyword">fun</span>() <span class="hljs-comment">// undefined</span><br></code></pre></td></tr></table></figure>

<h3 id="6-代码输出结果-1"><a href="#6-代码输出结果-1" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = &#123;<br>   <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1111&quot;</span>, this);<br>     &#125;<br>     f1();<br>   &#125;,<br>   <span class="hljs-attr">pro</span>: &#123;<br>     <span class="hljs-attr">getPro</span>:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>     &#125;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o = obj.say;<br>o();<br>obj.say();<br>obj.pro.getPro();<br></code></pre></td></tr></table></figure>

<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> obj = &#123;<br>   <span class="hljs-attr">say</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>     <span class="hljs-keyword">var</span> f1 = <span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>       <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&quot;1111&quot;</span>, this);<br>     &#125;<br>     f1();<br>   &#125;,<br>   <span class="hljs-attr">pro</span>: &#123;<br>     <span class="hljs-attr">getPro</span>:<span class="hljs-function"><span class="hljs-params">()</span> =&gt;</span>  &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>     &#125;<br>   &#125;<br>&#125;<br><span class="hljs-keyword">var</span> o = obj.say;<br>o();<br>obj.say();<br>obj.pro.getPro();<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs dart"><span class="hljs-number">1111</span> <span class="hljs-built_in">window</span>对象<br><span class="hljs-number">1111</span> obj对象<br><span class="hljs-built_in">window</span>对象<br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>o()，o是在全局执行的，而f1是箭头函数，它是没有绑定this的，它的this指向其父级的this，其父级say方法的this指向的是全局作用域，所以会打印出window；</li>
<li>obj.say()，谁调用say，say 的this就指向谁，所以此时this指向的是obj对象；</li>
<li>obj.pro.getPro()，我们知道，箭头函数时不绑定this的，getPro处于pro中，而对象不构成单独的作用域，所以箭头的函数的this就指向了全局作用域window。</li>
</ol>
<h3 id="7-代码输出结果-1"><a href="#7-代码输出结果-1" class="headerlink" title="7. 代码输出结果"></a>7. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> myObject = &#123;<br>    <span class="hljs-attr">foo</span>: <span class="hljs-string">&quot;bar&quot;</span>,<br>    <span class="hljs-attr">func</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> self = this;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.foo);  <br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(self.foo);  <br>        (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.foo);  <br>            <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(self.foo);  <br>        &#125;());<br>    &#125;<br>&#125;;<br>myObject.func();<br></code></pre></td></tr></table></figure>

<p>输出结果：bar bar undefined bar</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先func是由myObject调用的，this指向myObject。又因为var self &#x3D; this;所以self指向myObject。</li>
<li>这个立即执行匿名函数表达式是由window调用的，this指向window 。立即执行匿名函数的作用域处于myObject.func的作用域中，在这个作用域找不到self变量，沿着作用域链向上查找self变量，找到了指向 myObject对象的self。</li>
</ol>
<h3 id="8-代码输出问题"><a href="#8-代码输出问题" class="headerlink" title="8. 代码输出问题"></a>8. 代码输出问题</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade">window.<span class="hljs-built_in">number</span> = <span class="hljs-number">2</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br> <span class="hljs-attr">number</span>: <span class="hljs-number">3</span>,<br> <span class="hljs-attr">db1</span>: (<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>   this.<span class="hljs-built_in">number</span> *= <span class="hljs-number">4</span>;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>     <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this);<br>     this.<span class="hljs-built_in">number</span> *= <span class="hljs-number">5</span>;<br>   &#125;<br> &#125;)()<br>&#125;<br><span class="hljs-keyword">var</span> db1 = obj.db1;<br>db1();<br>obj.db1();<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.<span class="hljs-built_in">number</span>);     <span class="hljs-comment">// 15</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(window.<span class="hljs-built_in">number</span>);  <span class="hljs-comment">// 40</span><br></code></pre></td></tr></table></figure>

<p>这道题目看清起来有点乱，但是实际上是考察this指向的:</p>
<ol>
<li>执行db1()时，this指向全局作用域，所以window.number * 4 &#x3D; 8，然后执行匿名函数， 所以window.number * 5 &#x3D; 40；</li>
<li>执行obj.db1();时，this指向obj对象，执行匿名函数，所以obj.numer * 5 &#x3D; 15。</li>
</ol>
<h3 id="9-代码输出结果-1"><a href="#9-代码输出结果-1" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> <span class="hljs-built_in">length</span> = <span class="hljs-number">10</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">fn</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.<span class="hljs-built_in">length</span>);<br>&#125;<br> <br><span class="hljs-keyword">var</span> obj = &#123;<br>  <span class="hljs-attr">length</span>: <span class="hljs-number">5</span>,<br>  <span class="hljs-attr">method</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params">fn</span>) &#123;<br>    fn();<br>    arguments[<span class="hljs-number">0</span>]();<br>  &#125;<br>&#125;;<br> <br>obj.method(fn, <span class="hljs-number">1</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果： 10 2 </p>
<p><strong>解析：</strong></p>
<ol>
<li>第一次执行fn()，this指向window对象，输出10。</li>
<li>第二次执行arguments<a href="">0</a>，相当于arguments调用方法，this指向arguments，而这里传了两个参数，故输出arguments长度为2。</li>
</ol>
<h3 id="10-代码输出结果-1"><a href="#10-代码输出结果-1" class="headerlink" title="10. 代码输出结果"></a>10. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">1</span>;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">printA</span>(<span class="hljs-params"></span>)&#123;<br>  <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a);<br>&#125;<br><span class="hljs-keyword">var</span> obj=&#123;<br>  <span class="hljs-attr">a</span>:<span class="hljs-number">2</span>,<br>  <span class="hljs-attr">foo</span>:printA,<br>  <span class="hljs-attr">bar</span>:<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    printA();<br>  &#125;<br>&#125;<br><br>obj.foo(); <span class="hljs-comment">// 2</span><br>obj.bar(); <span class="hljs-comment">// 1</span><br><span class="hljs-keyword">var</span> foo = obj.foo;<br>foo(); <span class="hljs-comment">// 1</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 2 1 1 </p>
<p><strong>解析：</strong></p>
<ol>
<li>obj.foo()，foo 的this指向obj对象，所以a会输出2；</li>
<li>obj.bar()，printA在bar方法中执行，所以此时printA的this指向的是window，所以会输出1；</li>
<li>foo()，foo是在全局对象中执行的，所以其this指向的是window，所以会输出1；</li>
</ol>
<h3 id="11-代码输出结果-1"><a href="#11-代码输出结果-1" class="headerlink" title="11. 代码输出结果"></a>11. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> x = <span class="hljs-number">3</span>;<br><span class="hljs-keyword">var</span> y = <span class="hljs-number">4</span>;<br><span class="hljs-keyword">var</span> obj = &#123;<br>    <span class="hljs-attr">x</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-attr">y</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-attr">getX</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> x = <span class="hljs-number">5</span>;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>            <span class="hljs-keyword">return</span> this.x;<br>        &#125;();<br>    &#125;,<br>    <span class="hljs-attr">getY</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-keyword">var</span> y = <span class="hljs-number">7</span>;<br>        <span class="hljs-keyword">return</span> this.y;<br>    &#125;<br>&#125;<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.getX()) <span class="hljs-comment">// 3</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj.getY()) <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p>输出结果：3  6</p>
<p><strong>解析：</strong></p>
<ol>
<li>我们知道，匿名函数的this是指向全局对象的，所以this指向window，会打印出3；</li>
<li>getY是由obj调用的，所以其this指向的是obj对象，会打印出6。</li>
</ol>
<h3 id="12-代码输出结果-1"><a href="#12-代码输出结果-1" class="headerlink" title="12. 代码输出结果"></a>12. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a = <span class="hljs-number">10</span>; <br><span class="hljs-keyword">var</span> obt = &#123; <br>  <span class="hljs-attr">a</span>: <span class="hljs-number">20</span>, <br>  <span class="hljs-attr">fn</span>: <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123; <br>    <span class="hljs-keyword">var</span> a = <span class="hljs-number">30</span>; <br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(this.a)<br>  &#125; <br>&#125;<br>obt.fn();  <span class="hljs-comment">// 20</span><br>obt.fn.call(); <span class="hljs-comment">// 10</span><br>(obt.fn)(); <span class="hljs-comment">// 20</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 20  10  20 </p>
<p><strong>解析：</strong></p>
<ol>
<li>obt.fn()，fn是由obt调用的，所以其this指向obt对象，会打印出20；</li>
<li>obt.fn.call()，这里call的参数啥都没写，就表示null，我们知道如果call的参数为undefined或null，那么this就会指向全局对象this，所以会打印出 10；</li>
<li>(obt.fn)()， 这里给表达式加了括号，而括号的作用是改变表达式的运算顺序，而在这里加与不加括号并无影响；相当于  obt.fn()，所以会打印出 20；</li>
</ol>
<h3 id="13-代码输出结果-1"><a href="#13-代码输出结果-1" class="headerlink" title="13. 代码输出结果"></a>13. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params">xx</span>)&#123;<br>  this.x = xx;<br>  <span class="hljs-keyword">return</span> this<br>&#125;;<br><span class="hljs-keyword">var</span> x = a(<span class="hljs-number">5</span>);<br><span class="hljs-keyword">var</span> y = a(<span class="hljs-number">6</span>);<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x.x)  <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(y.x)  <span class="hljs-comment">// 6</span><br></code></pre></td></tr></table></figure>

<p>输出结果： undefined  6</p>
<p><strong>解析：</strong></p>
<ol>
<li>最关键的就是var x &#x3D; a(5)，函数a是在全局作用域调用，所以函数内部的this指向window对象。<strong>所以 this.x &#x3D; 5 就相当于：window.x &#x3D; 5。</strong>之后 return this，也就是说 var x &#x3D; a(5) 中的x变量的值是window，这里的x将函数内部的x的值覆盖了。然后执行console.log(x.x)， 也就是console.log(window.x)，而window对象中没有x属性，所以会输出undefined。</li>
<li>当指向y.x时，会给全局变量中的x赋值为6，所以会打印出6。</li>
</ol>
<h3 id="14-代码输出结果-1"><a href="#14-代码输出结果-1" class="headerlink" title="14. 代码输出结果"></a>14. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>)&#123;<br>    this.a = something<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;<br>    <span class="hljs-attr">foo</span>: foo<br>&#125;<br><br><span class="hljs-keyword">var</span> obj2 = &#123;&#125;<br><br>obj1.foo(<span class="hljs-number">2</span>); <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><br>obj1.foo.call(obj2, <span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj2.a); <span class="hljs-comment">// 3</span><br><br><span class="hljs-keyword">var</span> bar = <span class="hljs-keyword">new</span> obj1.foo(<span class="hljs-number">4</span>)<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(bar.a); <span class="hljs-comment">// 4</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 2  3  2  4</p>
<p><strong>解析：</strong></p>
<ol>
<li>首先执行obj1.foo(2); 会在obj中添加a属性，其值为2。之后执行obj1.a，a是右obj1调用的，所以this指向obj，打印出2；</li>
<li>执行 obj1.foo.call(obj2, 3) 时，会将foo的this指向obj2，后面就和上面一样了，所以会打印出3；</li>
<li>obj1.a会打印出2；</li>
<li>最后就是考察this绑定的优先级了，new 绑定是比隐式绑定优先级高，所以会输出4。</li>
</ol>
<h3 id="15-代码输出结果-1"><a href="#15-代码输出结果-1" class="headerlink" title="15. 代码输出结果"></a>15. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">foo</span>(<span class="hljs-params">something</span>)&#123;<br>    this.a = something<br>&#125;<br><br><span class="hljs-keyword">var</span> obj1 = &#123;&#125;<br><br><span class="hljs-keyword">var</span> bar = foo.bind(obj1);<br>bar(<span class="hljs-number">2</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><br><span class="hljs-keyword">var</span> baz = <span class="hljs-keyword">new</span> bar(<span class="hljs-number">3</span>);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(obj1.a); <span class="hljs-comment">// 2</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(baz.a); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>输出结果： 2  2  3</p>
<p>这道题目和上面题目差不多，主要都是考察this绑定的优先级。记住以下结论即可：<strong>this绑定的优先级：****new绑定 &gt; 显式绑定 &gt; 隐式绑定 &gt; 默认绑定。</strong></p>
<h2 id="三、作用域-amp-变量提升-amp-闭包"><a href="#三、作用域-amp-变量提升-amp-闭包" class="headerlink" title="三、作用域&amp;变量提升&amp;闭包"></a>三、作用域&amp;变量提升&amp;闭包</h2><h3 id="1-代码输出结果-2"><a href="#1-代码输出结果-2" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs arcade">(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>   <span class="hljs-keyword">var</span> x = y = <span class="hljs-number">1</span>;<br>&#125;)();<br><span class="hljs-keyword">var</span> z;<br><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(y); <span class="hljs-comment">// 1</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(z); <span class="hljs-comment">// undefined</span><br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(x); <span class="hljs-comment">// Uncaught ReferenceError: x is not defined</span><br></code></pre></td></tr></table></figure>

<p>这段代码的关键在于：var x &#x3D; y &#x3D; 1; 实际上这里是从右往左执行的，首先执行y &#x3D; 1, 因为y没有使用var声明，所以它是一个全局变量，然后第二步是将y赋值给x，讲一个全局变量赋值给了一个局部变量，最终，x是一个局部变量，y是一个全局变量，所以打印x是报错。</p>
<h3 id="2-代码输出结果-2"><a href="#2-代码输出结果-2" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> a, b<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);<br>   <span class="hljs-keyword">var</span> a = (b = <span class="hljs-number">3</span>);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);   <br>&#125;)()<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(a);<br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(b);<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">undefined</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span> <br><span class="hljs-number">3</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs actionscript"><span class="hljs-literal">undefined</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span> <br><span class="hljs-number">3</span> <br><span class="hljs-literal">undefined</span> <br><span class="hljs-number">3</span><br></code></pre></td></tr></table></figure>

<p>这个题目和上面题目考察的知识点类似，b赋值为3，b此时是一个全局变量，而将3赋值给a，a是一个局部变量，所以最后打印的时候，a仍旧是undefined。</p>
<h3 id="3-代码输出结果-2"><a href="#3-代码输出结果-2" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> friendName = <span class="hljs-string">&#x27;World&#x27;</span>;<br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> friendName === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>    <span class="hljs-keyword">var</span> friendName = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Goodbye &#x27;</span> + friendName);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + friendName);<br>  &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p>输出结果：Goodbye Jack</p>
<p>我们知道，在 JavaScript中， Function 和 var 都会被提升（变量提升），所以上面的代码就相当于：</p>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">var</span> name = <span class="hljs-string">&#x27;World!&#x27;</span>;<br>(<span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> name;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">typeof</span> name === <span class="hljs-string">&#x27;undefined&#x27;</span>) &#123;<br>        name = <span class="hljs-string">&#x27;Jack&#x27;</span>;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Goodbye &#x27;</span> + name);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-string">&#x27;Hello &#x27;</span> + name);<br>    &#125;<br>&#125;)();<br></code></pre></td></tr></table></figure>

<p>这样，答案就一目了然了。</p>
<h3 id="4-代码输出结果-2"><a href="#4-代码输出结果-2" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stylus">function <span class="hljs-built_in">fn1</span>()&#123;<br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;fn1&#x27;</span>)<br>&#125;<br><span class="hljs-selector-tag">var</span> fn2<br> <br><span class="hljs-function"><span class="hljs-title">fn1</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br> <br>fn2 = <span class="hljs-built_in">function</span>() &#123;<br>  console<span class="hljs-selector-class">.log</span>(<span class="hljs-string">&#x27;fn2&#x27;</span>)<br>&#125;<br> <br><span class="hljs-function"><span class="hljs-title">fn2</span><span class="hljs-params">()</span></span><br></code></pre></td></tr></table></figure>

<p>输出结果： </p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs ada">fn1<br>Uncaught TypeError: fn2 <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> a <span class="hljs-keyword">function</span><br><span class="hljs-title">fn2</span><br></code></pre></td></tr></table></figure>

<p>这里也是在考察变量提升，关键在于第一个fn2()，这时fn2仍是一个undefined的变量，所以会报错fn2不是一个函数。</p>
<h3 id="5-代码输出结果-1"><a href="#5-代码输出结果-1" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-number">10</span>;<br>    <span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(temp); <span class="hljs-comment">// 10</span><br>    &#125;<br>    b();<br>&#125;<br>a();<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">a</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-keyword">var</span> temp = <span class="hljs-number">10</span>;<br>    b();<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">b</span>(<span class="hljs-params"></span>) &#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(temp); <span class="hljs-comment">// 报错 Uncaught ReferenceError: temp is not defined</span><br>&#125;<br>a();<br></code></pre></td></tr></table></figure>

<p>在上面的两段代码中，第一段是可以正常输出，这个应该没啥问题，关键在于第二段代码，它会报错Uncaught ReferenceError: temp is not defined。这时因为在b方法执行时，temp 的值为undefined。</p>
<h3 id="6-代码输出结果-2"><a href="#6-代码输出结果-2" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs abnf">var a<span class="hljs-operator">=</span><span class="hljs-number">3</span><span class="hljs-comment">;</span><br>function c()&#123;<br>   alert(a)<span class="hljs-comment">;</span><br>&#125;<br>(function()&#123;<br> var a<span class="hljs-operator">=</span><span class="hljs-number">4</span><span class="hljs-comment">;</span><br> c()<span class="hljs-comment">;</span><br>&#125;)()<span class="hljs-comment">;</span><br></code></pre></td></tr></table></figure>

<p>js中变量的作用域链与定义时的环境有关，与执行时无关。执行环境只会改变this、传递的参数、全局变量等</p>
<h3 id="7-代码输出问题"><a href="#7-代码输出问题" class="headerlink" title="7.  代码输出问题"></a>7.  代码输出问题</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(n, o)</span></span> &#123;<br>  console.log(o)<br>  <span class="hljs-keyword">return</span> &#123;<br>    <span class="hljs-function"><span class="hljs-keyword">fun</span>: <span class="hljs-title">function</span><span class="hljs-params">(m)</span></span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(m, n)</span></span>;<br>    &#125;<br>  &#125;;<br>&#125;<br><span class="hljs-keyword">var</span> a = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>;  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  a.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> b = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>).<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br><span class="hljs-keyword">var</span> c = <span class="hljs-function"><span class="hljs-title">fun</span><span class="hljs-params">(<span class="hljs-number">0</span>)</span></span>.<span class="hljs-keyword">fun</span>(<span class="hljs-number">1</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">2</span>);  c.<span class="hljs-keyword">fun</span>(<span class="hljs-number">3</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span>  <span class="hljs-number">0</span><br><span class="hljs-attribute">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">2</span><br><span class="hljs-attribute">undefined</span>  <span class="hljs-number">0</span>  <span class="hljs-number">1</span>  <span class="hljs-number">1</span><br></code></pre></td></tr></table></figure>

<p>这是一道关于闭包的题目，对于fun方法，调用之后返回的是一个对象。我们知道，当调用函数的时候传入的实参比函数声明时指定的形参个数要少，剩下的形参都将设置为undefined值。所以 <code>console.log(o);</code> 会输出undefined。而a就是是fun(0)返回的那个对象。也就是说，函数fun中参数 n 的值是0，而返回的那个对象中，需要一个参数n，而这个对象的作用域中没有n，它就继续沿着作用域向上一级的作用域中寻找n，最后在函数fun中找到了n，n的值是0。了解了这一点，其他运算就很简单了，以此类推。</p>
<h3 id="8-代码输出结果-1"><a href="#8-代码输出结果-1" class="headerlink" title="8. 代码输出结果"></a>8. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs arcade">f = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;;   <br>g = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>(<span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;   <br>   <span class="hljs-keyword">if</span> (g() &amp;&amp; [] == ![]) &#123;   <br>      f = <span class="hljs-keyword">function</span> <span class="hljs-title function_">f</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;&#125;;   <br>      <span class="hljs-keyword">function</span> <span class="hljs-title function_">g</span>(<span class="hljs-params"></span>) &#123;<span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;&#125;   <br>   &#125;   <br>&#125;)();   <br><span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(f());<br></code></pre></td></tr></table></figure>

<p>输出结果： false</p>
<p>这里首先定义了两个变量f和g，我们知道变量是可以重新赋值的。后面是一个匿名自执行函数，在 if 条件中调用了函数 g()，由于在匿名函数中，又重新定义了函数g，就覆盖了外部定义的变量g，所以，这里调用的是内部函数 g 方法，返回为 true。第一个条件通过，进入第二个条件。</p>
<p>第二个条件是[] &#x3D;&#x3D; ![]，先看 ![] ，在 JavaScript 中，当用于布尔运算时，比如在这里，对象的非空引用被视为 true，空引用 null 则被视为 false。由于这里不是一个 null, 而是一个没有元素的数组，所以 [] 被视为 true, 而 ![] 的结果就是 false 了。当一个布尔值参与到条件运算的时候，true 会被看作 1, 而 false 会被看作 0。现在条件变成了 [] &#x3D;&#x3D; 0 的问题了，当一个对象参与条件比较的时候，它会被求值，求值的结果是数组成为一个字符串，[] 的结果就是 ‘’ ，而 ‘’ 会被当作 0 ，所以，条件成立。</p>
<p>两个条件都成立，所以会执行条件中的代码， f 在定义是没有使用var，所以他是一个全局变量。因此，这里会通过闭包访问到外部的变量 f, 重新赋值，现在执行 f 函数返回值已经成为 false 了。而 g 则不会有这个问题，这里是一个函数内定义的 g，不会影响到外部的 g 函数。所以最后的结果就是 false。</p>
<h2 id="四、原型-amp-继承"><a href="#四、原型-amp-继承" class="headerlink" title="四、原型&amp;继承"></a>四、原型&amp;继承</h2><h3 id="1-代码输出结果-3"><a href="#1-代码输出结果-3" class="headerlink" title="1. 代码输出结果"></a>1. 代码输出结果</h3><figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs sqf">function Person(<span class="hljs-built_in">name</span>) &#123;<br>    this.<span class="hljs-built_in">name</span> = <span class="hljs-built_in">name</span><br>&#125;<br>var p2 = new Person(<span class="hljs-string">&#x27;king&#x27;</span>);<br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">//Person.prototype</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">//Object.prototype</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">// null</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//null后面没有了，报错</span><br>console.<span class="hljs-built_in">log</span>(p2.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//null后面没有了，报错</span><br>console.<span class="hljs-built_in">log</span>(p2.constructor)<span class="hljs-comment">//Person</span><br>console.<span class="hljs-built_in">log</span>(p2.prototype)<span class="hljs-comment">//undefined p2是实例，没有prototype属性</span><br>console.<span class="hljs-built_in">log</span>(Person.constructor)<span class="hljs-comment">//Function 一个空函数</span><br>console.<span class="hljs-built_in">log</span>(Person.prototype)<span class="hljs-comment">//打印出Person.prototype这个对象里所有的方法和属性</span><br>console.<span class="hljs-built_in">log</span>(Person.prototype.constructor)<span class="hljs-comment">//Person</span><br>console.<span class="hljs-built_in">log</span>(Person.prototype.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">// Object.prototype</span><br>console.<span class="hljs-built_in">log</span>(Person.<span class="hljs-variable">__proto__</span>) <span class="hljs-comment">//Function.prototype</span><br>console.<span class="hljs-built_in">log</span>(Function.prototype.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//Object.prototype</span><br>console.<span class="hljs-built_in">log</span>(Function.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//Function.prototype</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Object</span>.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//Function.prototype</span><br>console.<span class="hljs-built_in">log</span>(<span class="hljs-built_in">Object</span>.prototype.<span class="hljs-variable">__proto__</span>)<span class="hljs-comment">//null</span><br></code></pre></td></tr></table></figure>

<p>这道义题目考察原型、原型链的基础，记住就可以了。</p>
<h3 id="2-代码输出结果-3"><a href="#2-代码输出结果-3" class="headerlink" title="2. 代码输出结果"></a>2. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-comment">// a</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span> (<span class="hljs-params"></span>) &#123;<br> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br>   <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br> &#125;<br> <span class="hljs-keyword">return</span> this;<br>&#125;<br><span class="hljs-comment">// b</span><br>Foo.getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>);<br>&#125;<br><span class="hljs-comment">// c</span><br>Foo.prototype.getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><span class="hljs-comment">// d</span><br><span class="hljs-keyword">var</span> getName = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><span class="hljs-comment">// e</span><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">getName</span> (<span class="hljs-params"></span>) &#123;<br> <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">5</span>);<br>&#125;<br><br>Foo.getName();           <span class="hljs-comment">// 2</span><br>getName();               <span class="hljs-comment">// 4</span><br>Foo().getName();         <span class="hljs-comment">// 1</span><br>getName();               <span class="hljs-comment">// 1 </span><br><span class="hljs-keyword">new</span> Foo.getName();       <span class="hljs-comment">// 2</span><br><span class="hljs-keyword">new</span> Foo().getName();     <span class="hljs-comment">// 3</span><br><span class="hljs-keyword">new</span> <span class="hljs-keyword">new</span> Foo().getName(); <span class="hljs-comment">// 3</span><br></code></pre></td></tr></table></figure>

<p>输出结果：2  4  1  1  2  3  3</p>
<p><strong>解析：</strong></p>
<ol>
<li><strong>Foo.getName()，</strong>Foo为一个函数对象，对象都可以有属性，b 处定义Foo的getName属性为函数，输出2；</li>
<li><strong>getName()，</strong>这里看d、e处，d为函数表达式，e为函数声明，两者区别在于变量提升，函数声明的 5 会被后边函数表达式的 4 覆盖；</li>
<li><strong>Foo().getName()，</strong>这里要看a处，在Foo内部将全局的getName重新赋值为 console.log(1) 的函数，执行Foo()返回 this，这个this指向window，Foo().getName() 即为window.getName()，输出 1；</li>
<li><strong>getName()，</strong>上面3中，全局的getName已经被重新赋值，所以这里依然输出 1；</li>
<li><strong>new Foo.getName()，</strong>这里等价于 new (Foo.getName())，先执行 Foo.getName()，输出 2，然后new一个实例；</li>
<li><strong>new Foo().getName()，</strong>这里等价于 (new Foo()).getName(), 先new一个Foo的实例，再执行这个实例的getName方法，但是这个实例本身没有这个方法，所以去原型链__protot__上边找，实例.<strong>protot</strong> &#x3D;&#x3D;&#x3D; Foo.prototype，所以输出 3；</li>
<li><strong>new new Foo().getName()，</strong>这里等价于new (new Foo().getName())，如上述6，先输出 3，然后new 一个 new Foo().getName() 的实例。</li>
</ol>
<h3 id="3-代码输出结果-3"><a href="#3-代码输出结果-3" class="headerlink" title="3. 代码输出结果"></a>3. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> F = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;&#125;;<br><span class="hljs-title class_">Object</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;a&#x27;</span>);<br>&#125;;<br><span class="hljs-title class_">Function</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">b</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;b&#x27;</span>);<br>&#125;<br><span class="hljs-keyword">var</span> f = <span class="hljs-keyword">new</span> <span class="hljs-title function_">F</span>();<br>f.<span class="hljs-title function_">a</span>();<br>f.<span class="hljs-title function_">b</span>();<br>F.<span class="hljs-title function_">a</span>();<br>F.<span class="hljs-title function_">b</span>()<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs less"><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">Uncaught</span> <span class="hljs-selector-tag">TypeError</span>: <span class="hljs-selector-tag">f</span><span class="hljs-selector-class">.b</span> <span class="hljs-selector-tag">is</span> <span class="hljs-selector-tag">not</span> <span class="hljs-selector-tag">a</span> <span class="hljs-selector-tag">function</span><br><span class="hljs-selector-tag">a</span><br><span class="hljs-selector-tag">b</span><br></code></pre></td></tr></table></figure>

<p><strong>解析：</strong></p>
<ol>
<li>f 并不是 Function 的实例，因为它本来就不是构造函数，调用的是 Function 原型链上的相关属性和方法，只能访问到 Object 原型链。所以 f.a() 输出 a  ，而 f.b() 就报错了。</li>
<li>F 是个构造函数，而 F 是构造函数 Function 的一个实例。因为 F instanceof  Object &#x3D;&#x3D;&#x3D; true，F instanceof Function &#x3D;&#x3D;&#x3D; true，由此可以得出结论：F 是 Object 和 Function 两个的实例，即 F 能访问到 a， 也能访问到 b。所以 F.a() 输出 a ，F.b() 输出 b。</li>
</ol>
<h3 id="4-代码输出结果-3"><a href="#4-代码输出结果-3" class="headerlink" title="4. 代码输出结果"></a>4. 代码输出结果</h3><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Foo</span>(<span class="hljs-params"></span>)&#123;<br>    Foo.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">1</span>);<br>    &#125;<br>    this.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>        <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">2</span>)<br>    &#125;<br>&#125;<br><br>Foo.prototype.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">3</span>);<br>&#125;<br><br>Foo.a = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-built_in">console</span>.<span class="hljs-built_in">log</span>(<span class="hljs-number">4</span>);<br>&#125;<br><br>Foo.a();<br>let obj = <span class="hljs-keyword">new</span> Foo();<br>obj.a();<br>Foo.a();<br></code></pre></td></tr></table></figure>

<p>输出结果：4 2 1</p>
<p><strong>解析：</strong></p>
<ol>
<li>Foo.a() 这个是调用 Foo 函数的静态方法 a，虽然 Foo 中有优先级更高的属性方法 a，但 Foo 此时没有被调用，所以此时输出 Foo 的静态方法 a 的结果：4</li>
<li>let obj &#x3D; new Foo(); 使用了 new 方法调用了函数，返回了函数实例对象，此时 Foo 函数内部的属性方法初始化，原型链建立。</li>
<li>obj.a() ; 调用 obj 实例上的方法 a，该实例上目前有两个 a 方法：一个是内部属性方法，另一个是原型上的方法。当这两者都存在时，首先查找 ownProperty ，如果没有才去原型链上找，所以调用实例上的 a 输出：2</li>
<li>Foo.a() ; 根据第2步可知 Foo 函数内部的属性方法已初始化，覆盖了同名的静态方法，所以输出：1</li>
</ol>
<h3 id="5-代码输出结果-2"><a href="#5-代码输出结果-2" class="headerlink" title="5. 代码输出结果"></a>5. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">Dog</span>(<span class="hljs-params"></span>) &#123;<br>  <span class="hljs-variable language_">this</span>.<span class="hljs-property">name</span> = <span class="hljs-string">&#x27;puppy&#x27;</span><br>&#125;<br><span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">bark</span> = <span class="hljs-function">() =&gt;</span> &#123;<br>  <span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-string">&#x27;woof!woof!&#x27;</span>)<br>&#125;<br><span class="hljs-keyword">const</span> dog = <span class="hljs-keyword">new</span> <span class="hljs-title class_">Dog</span>()<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-title class_">Dog</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Dog</span> &amp;&amp; dog.<span class="hljs-property">constructor</span> === <span class="hljs-title class_">Dog</span> &amp;&amp; dog <span class="hljs-keyword">instanceof</span> <span class="hljs-title class_">Dog</span>)<br></code></pre></td></tr></table></figure>

<p>输出结果：true</p>
<p><strong>解析：</strong></p>
<p>因为constructor是prototype上的属性，所以dog.constructor实际上就是指向Dog.prototype.constructor；constructor属性指向构造函数。instanceof而实际检测的是类型是否在实例的原型链上。</p>
<p>constructor是prototype上的属性，这一点很容易被忽略掉。constructor和instanceof 的作用是不同的，感性地来说，constructor的限制比较严格，它只能严格对比对象的构造函数是不是指定的值；而instanceof比较松散，只要检测的类型在原型链上，就会返回true。</p>
<h3 id="6-代码输出结果-3"><a href="#6-代码输出结果-3" class="headerlink" title="6. 代码输出结果"></a>6. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">var</span> A = &#123;<span class="hljs-attr">n</span>: <span class="hljs-number">4399</span>&#125;;<br><span class="hljs-keyword">var</span> B =  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-variable language_">this</span>.<span class="hljs-property">n</span> = <span class="hljs-number">9999</span>&#125;;<br><span class="hljs-keyword">var</span> C =  <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<span class="hljs-keyword">var</span> n = <span class="hljs-number">8888</span>&#125;;<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = A;<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = A;<br><span class="hljs-keyword">var</span> b = <span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>();<br><span class="hljs-keyword">var</span> c = <span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>();<br>A.<span class="hljs-property">n</span>++<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(b.<span class="hljs-property">n</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(c.<span class="hljs-property">n</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果：9999  4400</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(b.n)，在查找b.n是首先查找 b 对象自身有没有 n 属性，如果没有会去原型（prototype）上查找，当执行var b &#x3D; new B()时，函数内部this.n&#x3D;9999(此时this指向 b) 返回b对象，b对象有自身的n属性，所以返回 9999。</li>
<li>console.log(c.n)，同理，当执行var c &#x3D; new C()时，c对象没有自身的n属性，向上查找，找到原型 （prototype）上的 n 属性，因为 A.n++(此时对象A中的n为4400)， 所以返回4400。</li>
</ol>
<h3 id="7-代码输出问题-1"><a href="#7-代码输出问题-1" class="headerlink" title="7. 代码输出问题"></a>7. 代码输出问题</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">A</span>(<span class="hljs-params"></span>)&#123;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">B</span>(<span class="hljs-params">a</span>)&#123;<br>　　<span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>&#125;<br><span class="hljs-keyword">function</span> <span class="hljs-title function_">C</span>(<span class="hljs-params">a</span>)&#123;<br>　　<span class="hljs-keyword">if</span>(a)&#123;<br><span class="hljs-variable language_">this</span>.<span class="hljs-property">a</span> = a;<br>　　&#125;<br>&#125;<br>A.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>B.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br>C.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">a</span> = <span class="hljs-number">1</span>;<br> <br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">A</span>().<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">B</span>().<span class="hljs-property">a</span>);<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(<span class="hljs-keyword">new</span> <span class="hljs-title function_">C</span>(<span class="hljs-number">2</span>).<span class="hljs-property">a</span>);<br></code></pre></td></tr></table></figure>

<p>输出结果：1  undefined  2</p>
<p><strong>解析：</strong></p>
<ol>
<li>console.log(new A().a)，new A()为构造函数创建的对象，本身没有a属性，所以向它的原型去找，发现原型的a属性的属性值为1，故该输出值为1；</li>
<li>console.log(new B().a)，ew B()为构造函数创建的对象，该构造函数有参数a，但该对象没有传参，故该输出值为undefined;</li>
<li>console.log(new C(2).a)，new C()为构造函数创建的对象，该构造函数有参数a，且传的实参为2，执行函数内部，发现if为真，执行this.a &#x3D; 2,故属性a的值为2。</li>
</ol>
<h3 id="8-代码输出问题-1"><a href="#8-代码输出问题-1" class="headerlink" title="8 代码输出问题"></a>8 代码输出问题</h3><figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs kotlin">function Parent() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">this</span>.b = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-keyword">this</span>.a];<br>    <span class="hljs-keyword">this</span>.c = &#123; demo: <span class="hljs-number">5</span> &#125;;<br>    <span class="hljs-keyword">this</span>.show = function () &#123;<br>        console.log(<span class="hljs-keyword">this</span>.a , <span class="hljs-keyword">this</span>.b , <span class="hljs-keyword">this</span>.c.demo );<br>    &#125;<br>&#125;<br><br>function Child() &#123;<br>    <span class="hljs-keyword">this</span>.a = <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">this</span>.change = function () &#123;<br>        <span class="hljs-keyword">this</span>.b.push(<span class="hljs-keyword">this</span>.a);<br>        <span class="hljs-keyword">this</span>.a = <span class="hljs-keyword">this</span>.b.length;<br>        <span class="hljs-keyword">this</span>.c.demo = <span class="hljs-keyword">this</span>.a++;<br>    &#125;<br>&#125;<br><br>Child.prototype = new Parent();<br><span class="hljs-keyword">var</span> parent = new Parent();<br><span class="hljs-keyword">var</span> child1 = new Child();<br><span class="hljs-keyword">var</span> child2 = new Child();<br>child1.a = <span class="hljs-number">11</span>;<br>child2.a = <span class="hljs-number">12</span>;<br>parent.show();<br>child1.show();<br>child2.show();<br>child1.change();<br>child2.change();<br>parent.show();<br>child1.show();<br>child2.show();<br></code></pre></td></tr></table></figure>

<p>输出结果：</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs awk">parent.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">1</span>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br><br>child1.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">11</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br>child2.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">12</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br><br>parent.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">1</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>] <span class="hljs-number">5</span><br><br>child1.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">5</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>] <span class="hljs-number">5</span><br><br>child2.show(); <span class="hljs-regexp">//</span> <span class="hljs-number">6</span> [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>,<span class="hljs-number">11</span>,<span class="hljs-number">12</span>] <span class="hljs-number">5</span><br></code></pre></td></tr></table></figure>

<p>这道题目值得神帝，他涉及到的知识点很多，例如<strong>this的指向、原型、原型链、类的继承、数据类型</strong>等。</p>
<p><strong>解析****：</strong></p>
<ol>
<li>parent.show()，可以直接获得所需的值，没啥好说的；</li>
<li>child1.show()，<code>Child</code>的构造函数原本是指向<code>Child</code>的，题目显式将<code>Child</code>类的原型对象指向了<code>Parent</code>类的一个实例，需要注意<code>Child.prototype</code>指向的是<code>Parent</code>的实例<code>parent</code>，而不是指向<code>Parent</code>这个类。</li>
<li>child2.show()，这个也没啥好说的；</li>
<li>parent.show()，<code>parent</code>是一个<code>Parent</code>类的实例，<code>Child.prorotype</code>指向的是<code>Parent</code>类的另一个实例，两者在堆内存中互不影响，所以上述操作不影响<code>parent</code>实例，所以输出结果不变；</li>
<li>child1.show()，<code>child1</code>执行了<code>change()</code>方法后，发生了怎样的变化呢?</li>
</ol>
<ul>
<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child1</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11]**;</li>
<li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child1.a</code>变为<strong>4</strong>;</li>
<li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child1</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，<code>this.a</code>值为<strong>4</strong>，为原始类型，故赋值操作时会直接赋值，<code>Child.prototype.c.demo</code>的结果为<strong>4</strong>，而<code>this.a</code>随后自增为<strong>5(4 + 1 &#x3D; 5)。</strong></li>
</ul>
<ol>
<li><code>child2</code>执行了<code>change()</code>方法, 而<code>child2</code>和<code>child1</code>均是<code>Child</code>类的实例，所以他们的原型链指向同一个原型对象<code>Child.prototype</code>,也就是同一个<code>parent</code>实例，所以<code>child2.change()</code>中所有影响到原型对象的语句都会影响<code>child1</code>的最终输出结果。</li>
</ol>
<ul>
<li><strong>this.b.push(this.a)，</strong>由于this的动态指向特性，this.b会指向<code>Child.prototype</code>上的<strong>b</strong>数组,this.a会指向<code>child2</code>的<strong>a</strong>属性,所以<code>Child.prototype.b</code>变成了**[1,2,1,11,12]**;</li>
<li><strong>this.a &#x3D; this.b.length，</strong>这条语句中<code>this.a</code>和<code>this.b</code>的指向与上一句一致，故结果为<code>child2.a</code>变为<strong>5</strong>;</li>
<li><strong>this.c.demo &#x3D; this.a++，</strong>由于<code>child2</code>自身属性并没有<strong>c</strong>这个属性，所以此处的<code>this.c</code>会指向<code>Child.prototype.c</code>，故执行结果为<code>Child.prototype.c.demo</code>的值变为<code>child2.a</code>的值<strong>5</strong>，而<code>child2.a</code>最终自增为<strong>6(5 + 1 &#x3D; 6)。</strong></li>
</ul>
<h3 id="9-代码输出结果-2"><a href="#9-代码输出结果-2" class="headerlink" title="9. 代码输出结果"></a>9. 代码输出结果</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs javascript"><span class="hljs-keyword">function</span> <span class="hljs-title function_">SuperType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span> = <span class="hljs-literal">true</span>;<br>&#125;<br><br><span class="hljs-title class_">SuperType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSuperValue</span> = <span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">property</span>;<br>&#125;;<br><br><span class="hljs-keyword">function</span> <span class="hljs-title function_">SubType</span>(<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span> = <span class="hljs-literal">false</span>;<br>&#125;<br><br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span> = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SuperType</span>();<br><span class="hljs-title class_">SubType</span>.<span class="hljs-property"><span class="hljs-keyword">prototype</span></span>.<span class="hljs-property">getSubValue</span> = <span class="hljs-keyword">function</span> (<span class="hljs-params"></span>)&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-variable language_">this</span>.<span class="hljs-property">subproperty</span>;<br>&#125;;<br><br><span class="hljs-keyword">var</span> instance = <span class="hljs-keyword">new</span> <span class="hljs-title class_">SubType</span>();<br><span class="hljs-variable language_">console</span>.<span class="hljs-title function_">log</span>(instance.<span class="hljs-title function_">getSuperValue</span>());<br></code></pre></td></tr></table></figure>

<p>输出结果：true</p>
<p>实际上，这段代码就是在实现原型链继承，SubType继承了SuperType，本质是重写了SubType的原型对象，代之以一个新类型的实例。SubType的原型被重写了，所以instance.constructor指向的是SuperType。具体如下：</p>
<p><img    class="lazyload" data-original="https://cdn.nlark.com/yuque/0/2021/png/1500604/1620043144097-44798602-b916-406d-bc50-e003f27dece2.png" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg=="   ><span class="image-caption">image.png</span></p>
      </section>
      <section class="extra">
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img   class="lazyload" data-original="/images/theme/zfb.jpg" src="data:image/gif;base64,iVBORw0KGgoAAAANSUhEUgAAAAEAAAABCAYAAAAfFcSJAAAADUlEQVQImWNgYGBgAAAABQABh6FO1AAAAABJRU5ErkJggg==" >
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E5%85%AB%E8%82%A1%E6%96%87/" rel="tag">八股文</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E9%9D%A2%E8%AF%95/" rel="tag">面试</a></li></ul> 

        
  <nav class="nav">
    <a href="/2022/10/22/handwritten%20code/"><i class="iconfont iconleft"></i>手写代码</a>
    <a href="/2022/10/22/LeetCode/">力扣题目<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
        <section class="comments">
  
  
<div id="valine"></div>
<script defer src="//unpkg.com/valine/dist/Valine.min.js"></script>
<script>
  window.onload = function () {
    var loadValine = function () {
      new Valine({
        el: '#valine',
        app_id: "zMoGZVsYMnyFph3ojvUBluW7-gzGzoHsz",
        app_key: "0lQCWCy3JboSPlyWJDTVzElx",
        placeholder: "请留下你此刻的想法",
        avatar: "monsterid",
        pageSize: "5",
        lang: "zh-CN",
      });
    }
    if ( false ) {
      $("#comments-btn").on("click", function () {
        $(this).hide();
        loadValine();
      });
    } else {
      loadValine();
    }
  };
</script>

</section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA"><span class="toc-text">代码输出</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%89%8D%E8%A8%80%EF%BC%9A"><span class="toc-text">前言：</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%80%E3%80%81%E5%BC%82%E6%AD%A5-amp-%E4%BA%8B%E4%BB%B6%E5%BE%AA%E7%8E%AF"><span class="toc-text">一、异步&amp;事件循环</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">5. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">7. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">8. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">9. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">10. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">11. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">12. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">13. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">14. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">15. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#16-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">16. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#17-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">17. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#18-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">18. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#19-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">19. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#20-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">20. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#21-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">21. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#22-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">22. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#23-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">23. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#24-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">24. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#25-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">25. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#26-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">26. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#27-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">27. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#28-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">28. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#29-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">29. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#30-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">30. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#31-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C"><span class="toc-text">31. 代码输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%BA%8C%E3%80%81this"><span class="toc-text">二、this</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">7. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-text">8. 代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">9. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#10-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">10. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#11-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">11. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#12-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">12. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#13-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">13. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#14-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">14. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#15-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">15. 代码输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E4%B8%89%E3%80%81%E4%BD%9C%E7%94%A8%E5%9F%9F-amp-%E5%8F%98%E9%87%8F%E6%8F%90%E5%8D%87-amp-%E9%97%AD%E5%8C%85"><span class="toc-text">三、作用域&amp;变量提升&amp;闭包</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">5. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98"><span class="toc-text">7.  代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-1"><span class="toc-text">8. 代码输出结果</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%9B%9B%E3%80%81%E5%8E%9F%E5%9E%8B-amp-%E7%BB%A7%E6%89%BF"><span class="toc-text">四、原型&amp;继承</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-text">1. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#2-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-text">2. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-text">3. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#4-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-text">4. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#5-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-text">5. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#6-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-3"><span class="toc-text">6. 代码输出结果</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#7-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98-1"><span class="toc-text">7. 代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#8-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E9%97%AE%E9%A2%98-1"><span class="toc-text">8 代码输出问题</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#9-%E4%BB%A3%E7%A0%81%E8%BE%93%E5%87%BA%E7%BB%93%E6%9E%9C-2"><span class="toc-text">9. 代码输出结果</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=1935280058 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://www.instagram.com/smokers072/ "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#DA2E76'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconinstagram "></i>
      </a><a 
        href="https://github.com/qcvip "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:qinchao2001@outlook.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme and Qc - <a target="_blank" href="https://github.com/qcvip/qcvip.github.io">无言</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
    <div class="fab fab-like">
      <i class="iconfont iconheart"></i>
    </div>
  
  
    <div class="fab fab-daovoice">
      <i class="iconfont iconcomment"></i>
    </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
    <div class="search">
  <div class="search-container">
    <div class="search-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <div class="search-input-wrapper">
      <i class="search-input-icon iconfont iconsearch"></i>
      <input class="search-input" type="search" id="search-input" placeholder="Search..." autofocus autocomplete="off"
        autocorrect="off" autocapitalize="off">
    </div>
    <div class="search-output" id="search-output"></div>
  </div>
</div>
  
</body>

<script src="https://code.jquery.com/jquery-3.6.0.min.js"></script>





  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>



  <script>
  $.getScript("//cdn.jsdelivr.net/npm/leancloud-storage@4.1.0/dist/av-min.js", () => {

    AV.init({
      appId: 'zMoGZVsYMnyFph3ojvUBluW7-gzGzoHsz',
      appKey: '0lQCWCy3JboSPlyWJDTVzElx',
      serverURLs: 'https://zmogzvsy.lc-cn-n1-shared.com',
    });

    const Counter = AV.Object.extend("Counter");
    const Like = AV.Object.extend("Like");

    const showCount = (Counter) => {
      const asyncLimit = new AsyncLimit(2);
      $(".leancloud-counter").each(async (e) => {
        const url = $(".leancloud-counter").eq(e).attr('id').trim();
        const query = new AV.Query("Counter");
        query.equalTo("words", url);
        let count = await asyncLimit.run(() => query.count());
        $(".leancloud-counter").eq(e).text(count ? count : 0);
      });
    }

    const addCount = (Counter) => {
      const url = $(".leancloud-counter").length === 1 ? $(".leancloud-counter").attr('id').trim() : 'http://example.com';
      var query = new Counter;
      query.save({
        words: url
      });
    }

    const showLike = (Like) => {
      const asyncLimit = new AsyncLimit(2);
      $(".leancloud-like").each(async (e) => {
        const url = $(".leancloud-like").eq(e).attr('id').trim();
        const query = new AV.Query("Like");
        query.equalTo("path", url);
        let count = await asyncLimit.run(() => query.count());
        $(".leancloud-like").eq(e).text(count ? count : 0);
      });
    }

    const addLike = (Like) => {
      const url = $(".leancloud-like").length === 1 ? $(".leancloud-like").attr('id').trim() : 'http://example.com';
      var query = new Like;
      query.save({
        path: url,
        nickName: 'Anonymous'
      });
      $(".leancloud-like").addClass('islike');
      $(".fab-like").children(".iconfont").removeClass("iconheart").addClass("iconheart-fill").css("color", "#eb3223");
      ZHAOO.zui.message({ text: '爱你哦~', type: 'success' });
      setTimeout(() => showLike(Like), 1000);
    }

    const handleLikeClick = () => {
      const isLike = $(".leancloud-like").length === 1 && $(".leancloud-like").hasClass('islike') ? true : false;
      if (isLike) {
        ZHAOO.zui.message({ text: '小心心不可以收回呢~', type: 'warning' });
      } else {
        addLike(Like);
      }
    }

    $(function () {
      addCount(Counter);
      showCount(Counter);
      showLike(Like);
      $(".fab-like").on("click", function () {
        handleLikeClick();
      });
    });

  });
</script>



  

<script>
  (function (i, s, o, g, r, a, m) {
    i["DaoVoiceObject"] = r;
    i[r] = i[r] || function () {
      (i[r].q = i[r].q || []).push(arguments)
    }, i[r].l = 1 * new Date();
    a = s.createElement(o), m = s.getElementsByTagName(o)[0];
    a.async = 1;
    a.src = g;
    a.charset = "utf-8";
    m.parentNode.insertBefore(a, m)
  })(window, document, "script", "https://widget.daovoice.io/widget/0f81ff2f.js", "daovoice")
  daovoice('init', {
    app_id: ""
  }, {
    launcher: {
      disableLauncherIcon: true,
    },
  });
  daovoice('update');
</script>



  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>